<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f515de19639a718bb052f51b0899229401139fe7">Adding Empty Project</a>  -  f515de1</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 48 insertions(+)

diff --git a/AWGL/Class1.cs b/AWGL/Class1.cs
new file mode 100644
index 0000000..25f7686
--- /dev/null
+++ b/AWGL/Class1.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class Class1
+    {
+    }
+}
new file mode 100644
index 0000000..9623e06
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("AWGL")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("AWGL")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/799d9fdf40ee0d1bc59747fdeb4d3f8be001475a">Renamed Main Class</a>  -  799d9fd</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 13 insertions(+)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
new file mode 100644
index 0000000..e91f871
--- /dev/null
+++ b/AWGL/AWGL.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public static class AWGL
+    {
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1e55fdda685c97b3891aec25a3dd152b017faac8">~</a>  -  1e55fdd</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 12 deletions(-)

diff --git a/AWGL/Class1.cs b/AWGL/Class1.cs
deleted file mode 100644
index 25f7686..0000000
--- a/AWGL/Class1.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class Class1
-    {
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b9922713a53840c6594ca530944a1dffaa4282ef">Adding Testing Application</a>  -  b992271</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 55 insertions(+)

diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
new file mode 100644
index 0000000..c75c740
--- /dev/null
+++ b/TestApplication/Program.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+using AWGL;
+
+namespace TestApplication
+{
+    class Program
+    {
+        [STAThread]
+        static void Main(string[] args)
+        {
+            AWGL.AWGL.Main(args);
+        }
+    }
+}
new file mode 100644
index 0000000..5e3ef72
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("TestApplication")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("TestApplication")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("3b8899cd-4523-439e-892a-a7ecfc8390ed")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/86d835b4c8fac46eb74e3639da25f3a2935faa5d">Adding Shaders</a>  -  86d835b</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 5 files changed, 76 insertions(+), 5 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index e91f871..ae051f1 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -1,6 +1,10 @@
-﻿using System;
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
@@ -8,5 +12,13 @@ namespace AWGL
 {
-    public static class AWGL
+    public static class AWGL 
     {
-
+        
+        public static void Main(string[] args)
+        {
+            using (Display display = new Display())
+            {
+                display.Run(30.0);
+            }
+        }
+        
     }
diff --git a/AWGL/Display.cs b/AWGL/Display.cs
new file mode 100644
index 0000000..94ccae3
--- /dev/null
+++ b/AWGL/Display.cs
@@ -0,0 +1,25 @@
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+namespace AWGL
+{
+    public class Display : GameWindow
+    {
+        private int vertexShaderID;
+        private int fragmentShaderID;
+
+        private int compiledShaderProgramID;
+
+        private void initProgram()
+        {
+            
+        }
+    }
+}
diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
new file mode 100644
index 0000000..607bcb0
--- /dev/null
+++ b/AWGL/Graphic.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    abstract class Graphic
+    {
+    }
+}
diff --git a/AWGL/Shaders/FS.glsl b/AWGL/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/AWGL/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/AWGL/Shaders/VS.glsl b/AWGL/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/AWGL/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/46ddc9333e4c12e610fc5e3a76152983032e12e0">Added method stubs</a>  -  46ddc93</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 34 insertions(+)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 94ccae3..437ab75 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -19,6 +19,40 @@ namespace AWGL
 
+        public Display() : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+
+        }   
+
         private void initProgram()
         {
+            compiledShaderProgramID = GL.CreateProgram();
+   
             
         }
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+        }
+
+        private void loadShader(String filename, ShaderType type, int program, out int address)
+        {
+            address = GL.CreateShader(type);
+            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            {
+                GL.ShaderSource(address, sr.ReadToEnd());
+            }
+            GL.CompileShader(address);
+            GL.AttachShader(program, address);
+            Console.WriteLine(GL.GetShaderInfoLog(address));
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/be4d7ae69e22a357f3db1ca9fb3e366abc59f0eb">Adding basic primitive shapes.</a>  -  be4d7ae</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 5 files changed, 310 insertions(+)

diff --git a/AWGL/Abstract/Volume.cs b/AWGL/Abstract/Volume.cs
new file mode 100644
index 0000000..8963d9e
--- /dev/null
+++ b/AWGL/Abstract/Volume.cs
@@ -0,0 +1,27 @@
+﻿using OpenTK;
+
+namespace AWGL.Abstract
+{
+    public abstract class Volume
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Rotation = Vector3.Zero;
+        public Vector3 Scale = Vector3.One;
+
+        public int VertCount;
+        public int IndiceCount;
+        public int ColorDataCount;
+        public Matrix4 ModelMatrix = Matrix4.Identity;
+        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
+        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
+
+        public abstract Vector3[] GetVerts();
+        public abstract int[] GetIndices(int offset = 0);
+        public abstract Vector3[] GetColorData();
+        public abstract void CalculateModelMatrix();
+
+
+
+    } // class
+
+} // namespace
diff --git a/AWGL/Shapes/ColourCube.cs b/AWGL/Shapes/ColourCube.cs
new file mode 100644
index 0000000..18eb637
--- /dev/null
+++ b/AWGL/Shapes/ColourCube.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK;
+
+namespace AWGL.Shapes
+{
+    class ColourCube : Cube
+    {
+        Vector3 Color = new Vector3(1, 1, 1);
+ 
+        public ColourCube(Vector3 color) : base() {
+            Color = color;
+        }
+
+        public ColourCube()
+        {
+
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] { 
+                Color,
+                Color, 
+                Color,
+                Color,
+                Color, 
+                Color, 
+                Color, 
+                Color
+            };
+        }
+    }
+}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
new file mode 100644
index 0000000..aef1266
--- /dev/null
+++ b/AWGL/Shapes/Cube.cs
@@ -0,0 +1,83 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+
+namespace AWGL.Shapes
+{
+    public class Cube : Volume
+    {
+        public Cube()
+        {
+            VertCount = 8;
+            IndiceCount = 36;
+            ColorDataCount = 8;
+        }
+
+        public override Vector3[] GetVerts()
+        {
+            return new Vector3[] {new Vector3(-0.5f, -0.5f,  -0.5f),
+                new Vector3(0.5f, -0.5f,  -0.5f),
+                new Vector3(0.5f, 0.5f,  -0.5f),
+                new Vector3(-0.5f, 0.5f,  -0.5f),
+                new Vector3(-0.5f, -0.5f,  0.5f),
+                new Vector3(0.5f, -0.5f,  0.5f),
+                new Vector3(0.5f, 0.5f,  0.5f),
+                new Vector3(-0.5f, 0.5f,  0.5f),
+            };
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = new int[] {
+                //left
+                0, 2, 1,
+                0, 3, 2,
+                //back
+                1, 2, 6,
+                6, 5, 1,
+                //right
+                4, 5, 6,
+                6, 7, 4,
+                //top
+                2, 3, 6,
+                6, 3, 7,
+                //front
+                0, 7, 3,
+                0, 4, 7,
+                //bottom
+                0, 1, 5,
+                0, 5, 4
+            };
+
+
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] {
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f),
+                new Vector3( 0f, 1f, 0f),
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f),
+                new Vector3( 0f, 1f, 0f),
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f)
+            };
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
new file mode 100644
index 0000000..822db60
--- /dev/null
+++ b/AWGL/Shapes/Sierpinski.cs
@@ -0,0 +1,71 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+using System;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    class Sierpinski : Volume
+    {
+        public Sierpinski(int numSubdivisions = 1)
+        {
+            int NumTris = (int)Math.Pow(4, numSubdivisions + 1);
+
+            VertCount = NumTris;
+            ColorDataCount = NumTris;
+            IndiceCount = 3 * NumTris;
+
+            Tetra twhole = new Tetra(
+                new Vector3(0.0f, 0.0f, 1.0f),  // Apex center 
+                new Vector3(0.943f, 0.0f, -0.333f),  // Base center top
+                new Vector3(-0.471f, 0.816f, -0.333f),  // Base left bottom
+                new Vector3(-0.471f, -0.816f, -0.333f));
+
+            List<Tetra> allTets = twhole.Divide(numSubdivisions);
+
+            int offset = 0;
+            foreach (Tetra t in allTets)
+            {
+                verts.AddRange(t.GetVerts());
+                indices.AddRange(t.GetIndices(offset * 4));
+                colors.AddRange(t.GetColorData());
+                offset++;
+            }
+
+        }
+
+        private List<Vector3> verts = new List<Vector3>();
+        private List<int> indices = new List<int>();
+        private List<Vector3> colors = new List<Vector3>();
+
+        public override Vector3[] GetVerts()
+        {
+            return verts.ToArray();
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return colors.ToArray();
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = indices.ToArray();
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
new file mode 100644
index 0000000..5003fa9
--- /dev/null
+++ b/AWGL/Shapes/Tetra.cs
@@ -0,0 +1,97 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    class Tetra : Volume
+    {
+        Vector3 PointApex;
+        Vector3 PointA;
+        Vector3 PointB;
+        Vector3 PointC;
+
+        public Tetra(Vector3 apex, Vector3 a, Vector3 b, Vector3 c)
+        {
+            PointApex = apex;
+            PointA = a;
+            PointB = b;
+            PointC = c;
+
+            VertCount = 4;
+            IndiceCount = 12;
+            ColorDataCount = 4;
+        }
+
+        public List<Tetra> Divide(int n = 0)
+        {
+            if (n == 0)
+            {
+                return new List<Tetra>(new Tetra[] { this });
+            }
+            else
+            {
+
+                Vector3 halfa = (PointApex + PointA) / 2.0f;
+                Vector3 halfb = (PointApex + PointB) / 2.0f;
+                Vector3 halfc = (PointApex + PointC) / 2.0f;
+
+                // Calculate points half way between base points
+                Vector3 halfab = (PointA + PointB) / 2.0f;
+                Vector3 halfbc = (PointB + PointC) / 2.0f;
+                Vector3 halfac = (PointA + PointC) / 2.0f;
+
+                Tetra t1 = new Tetra(PointApex, halfa, halfb, halfc);
+                Tetra t2 = new Tetra(halfa, PointA, halfab, halfac);
+                Tetra t3 = new Tetra(halfb, halfab, PointB, halfbc);
+                Tetra t4 = new Tetra(halfc, halfac, halfbc, PointC);
+
+                List<Tetra> output = new List<Tetra>();
+
+                output.AddRange(t1.Divide(n - 1));
+                output.AddRange(t2.Divide(n - 1));
+                output.AddRange(t3.Divide(n - 1));
+                output.AddRange(t4.Divide(n - 1));
+
+                return output;
+
+            }
+        }
+
+        public override Vector3[] GetVerts()
+        {
+            return new Vector3[] { PointApex, PointA, PointB, PointC };
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = new int[] { //bottom
+                                1,3,2,
+                                //other sides
+                                0,1,2,
+                                0,2,3,
+                                0,3,1
+        };
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] { new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f), new Vector3(1f, 1f, 0f) };
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bc8096d463353702661c263277d3b6428256b14a">Adding primitives to rendering code.</a>  -  bc8096d</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 147 insertions(+), 5 deletions(-)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 437ab75..4d4e0d8 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -1,2 +1,4 @@
-﻿using ObjLoader.Loader.Loaders;
+﻿using AWGL.Abstract;
+using AWGL.Shapes;
+using ObjLoader.Loader.Loaders;
 using OpenTK;
@@ -17,3 +19,19 @@ namespace AWGL
 
-        private int compiledShaderProgramID;
+        private int programID;
+
+        private int attribute_vpos;
+        private int attribute_vcolor;
+        private int uniform_mview;
+
+        private int vbo_position;
+        private int vbo_color;
+        private int vbo_mview;
+        private int ibo_elements;
+
+        private Vector3[] vertData;
+        private Vector3[] colorData;
+        protected List<Volume> objects = new List<Volume>();
+        private int[] indiceData;
+
+        private float time = 0.0f;
 
@@ -26,5 +44,43 @@ namespace AWGL
         {
-            compiledShaderProgramID = GL.CreateProgram();
-   
-            
+            programID = GL.CreateProgram();
+
+            loadShader("VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
+            loadShader("FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
+
+            // Links shaders and output any errors
+            GL.LinkProgram(programID);
+            Console.WriteLine(GL.GetProgramInfoLog(programID));
+
+            // Get the values we need, and also do a simple check to make sure the attributes were found.
+            attribute_vpos = GL.GetAttribLocation(programID, "vPosition");
+            attribute_vcolor = GL.GetAttribLocation(programID, "vColor");
+            uniform_mview = GL.GetUniformLocation(programID, "modelview");
+
+            if (attribute_vpos == -1 || attribute_vcolor == -1 || uniform_mview == -1)
+            {
+                Console.WriteLine("Error binding attributes");
+            }
+
+            // This generates 4 separate buffers and stores their addresses in our variables. 
+            // For multiple buffers like this, there's an option for generating multiple buffers 
+            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
+            GL.GenBuffers(1, out vbo_position);
+            GL.GenBuffers(1, out vbo_color);
+            GL.GenBuffers(1, out vbo_mview);
+            GL.GenBuffers(1, out ibo_elements);
+
+            Random rand = new Random();
+
+            float xPos = -1.0f;
+            for (int i = 0; i < 2; i++)
+            {
+                Sierpinski sier = new Sierpinski();
+
+                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
+                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
+                sier.Scale = Vector3.One;
+                objects.Add(sier);
+
+                xPos = 1.0f;
+            }
         }
@@ -34,2 +90,8 @@ namespace AWGL
             base.OnLoad(e);
+
+            initProgram();
+
+            Title = "AWGL - High level OpenTK wrapper";
+            GL.ClearColor(Color.Black);
+            GL.PointSize(3f);
         }
@@ -39,2 +101,25 @@ namespace AWGL
             base.OnRenderFrame(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.EnableVertexAttribArray(attribute_vpos);
+            GL.EnableVertexAttribArray(attribute_vcolor);
+
+            int indiceAt = 0;
+            
+            foreach (Volume v in objects)
+            {
+                GL.UniformMatrix4(uniform_mview, false, ref v.ModelViewProjectionMatrix);
+                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
+                indiceAt += v.IndiceCount;
+            }
+
+            // Keep things clean:
+            GL.DisableVertexAttribArray(attribute_vpos);
+            GL.DisableVertexAttribArray(attribute_vcolor);
+            GL.Flush();
+
+            SwapBuffers();
         }
@@ -44,2 +129,59 @@ namespace AWGL
             base.OnUpdateFrame(e);
+
+            time += (float)e.Time;
+
+            List<Vector3> verts = new List<Vector3>();
+            List<int> inds = new List<int>();
+            List<Vector3> colors = new List<Vector3>();
+
+            int vertCount = 0;
+
+            foreach (Volume v in objects)
+            {
+                verts.AddRange(v.GetVerts().ToList());
+                inds.AddRange(v.GetIndices().ToList());
+                colors.AddRange(v.GetColorData().ToList());
+                vertCount += v.VertCount;
+            }
+
+            vertData = verts.ToArray();
+            indiceData = inds.ToArray();
+            colorData = colors.ToArray();
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_position);  // 1. Bind vertex data to the buffer.
+            GL.BufferData<Vector3>(                                 // 2. Send data.
+                BufferTarget.ArrayBuffer, (IntPtr)(vertData.Length * Vector3.SizeInBytes), 
+                vertData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                attribute_vpos, 3, VertexAttribPointerType.Float, false, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_color);     // 1. Bind color data to the buffer
+            GL.BufferData<Vector3>(                                 // 2. Send Data
+                BufferTarget.ArrayBuffer, (IntPtr)(colorData.Length * Vector3.SizeInBytes),
+                colorData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                attribute_vcolor, 3, VertexAttribPointerType.Float, true, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ibo_elements);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, (IntPtr)(indiceData.Length * sizeof(int)),
+                indiceData, BufferUsageHint.StaticDraw);
+            
+            // Rotate objects
+            for (int i = 0; i < objects.Count; i++)
+            {
+                objects[i].Rotation = new Vector3(0.55f * time, 0.25f * time, 0);
+            }
+
+            // Send model view matrix
+            foreach (Volume v in objects)
+            {
+                v.CalculateModelMatrix();
+                v.ViewProjectionMatrix = 
+                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
+                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
+            }
+
+            GL.UseProgram(programID);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8f18ddaf450540bb6feef0bd5f89162a2e43c948">More shaders</a>  -  8f18dda</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 4d4e0d8..3083443 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -46,4 +46,4 @@ namespace AWGL
 
-            loadShader("VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
-            loadShader("FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
+            loadShader("Simple_VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
+            loadShader("Simple_FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
 
diff --git a/AWGL/Shaders/Simple_FS.glsl b/AWGL/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/AWGL/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_VS.glsl b/AWGL/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/AWGL/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8619c275f52b518cdb20ff98043d94f50a4821a7">Rearranged Namespace</a>  -  8619c27</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 6 files changed, 7 insertions(+), 233 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index ae051f1..bfade2c 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -10,2 +10,4 @@ using System.Linq;
 
+using AWGL.Scene;
+
 namespace AWGL
@@ -17,5 +19,5 @@ namespace AWGL
         {
-            using (Display display = new Display())
+            using (Display mainDisplay = new Display())
             {
-                display.Run(30.0);
+                mainDisplay.Run(30.0);
             }
diff --git a/AWGL/Abstract/Volume.cs b/AWGL/Abstract/Volume.cs
deleted file mode 100644
index 8963d9e..0000000
--- a/AWGL/Abstract/Volume.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Abstract
-{
-    public abstract class Volume
-    {
-        public Vector3 Position = Vector3.Zero;
-        public Vector3 Rotation = Vector3.Zero;
-        public Vector3 Scale = Vector3.One;
-
-        public int VertCount;
-        public int IndiceCount;
-        public int ColorDataCount;
-        public Matrix4 ModelMatrix = Matrix4.Identity;
-        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
-        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
-
-        public abstract Vector3[] GetVerts();
-        public abstract int[] GetIndices(int offset = 0);
-        public abstract Vector3[] GetColorData();
-        public abstract void CalculateModelMatrix();
-
-
-
-    } // class
-
-} // namespace
diff --git a/AWGL/Display.cs b/AWGL/Display.cs
deleted file mode 100644
index 3083443..0000000
--- a/AWGL/Display.cs
+++ /dev/null
@@ -1,201 +0,0 @@
-﻿using AWGL.Abstract;
-using AWGL.Shapes;
-using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.IO;
-using System.Linq;
-
-namespace AWGL
-{
-    public class Display : GameWindow
-    {
-        private int vertexShaderID;
-        private int fragmentShaderID;
-
-        private int programID;
-
-        private int attribute_vpos;
-        private int attribute_vcolor;
-        private int uniform_mview;
-
-        private int vbo_position;
-        private int vbo_color;
-        private int vbo_mview;
-        private int ibo_elements;
-
-        private Vector3[] vertData;
-        private Vector3[] colorData;
-        protected List<Volume> objects = new List<Volume>();
-        private int[] indiceData;
-
-        private float time = 0.0f;
-
-        public Display() : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-
-        }   
-
-        private void initProgram()
-        {
-            programID = GL.CreateProgram();
-
-            loadShader("Simple_VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
-            loadShader("Simple_FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
-
-            // Links shaders and output any errors
-            GL.LinkProgram(programID);
-            Console.WriteLine(GL.GetProgramInfoLog(programID));
-
-            // Get the values we need, and also do a simple check to make sure the attributes were found.
-            attribute_vpos = GL.GetAttribLocation(programID, "vPosition");
-            attribute_vcolor = GL.GetAttribLocation(programID, "vColor");
-            uniform_mview = GL.GetUniformLocation(programID, "modelview");
-
-            if (attribute_vpos == -1 || attribute_vcolor == -1 || uniform_mview == -1)
-            {
-                Console.WriteLine("Error binding attributes");
-            }
-
-            // This generates 4 separate buffers and stores their addresses in our variables. 
-            // For multiple buffers like this, there's an option for generating multiple buffers 
-            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
-            GL.GenBuffers(1, out vbo_position);
-            GL.GenBuffers(1, out vbo_color);
-            GL.GenBuffers(1, out vbo_mview);
-            GL.GenBuffers(1, out ibo_elements);
-
-            Random rand = new Random();
-
-            float xPos = -1.0f;
-            for (int i = 0; i < 2; i++)
-            {
-                Sierpinski sier = new Sierpinski();
-
-                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
-                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
-                sier.Scale = Vector3.One;
-                objects.Add(sier);
-
-                xPos = 1.0f;
-            }
-        }
-
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            initProgram();
-
-            Title = "AWGL - High level OpenTK wrapper";
-            GL.ClearColor(Color.Black);
-            GL.PointSize(3f);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.EnableVertexAttribArray(attribute_vpos);
-            GL.EnableVertexAttribArray(attribute_vcolor);
-
-            int indiceAt = 0;
-            
-            foreach (Volume v in objects)
-            {
-                GL.UniformMatrix4(uniform_mview, false, ref v.ModelViewProjectionMatrix);
-                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
-                indiceAt += v.IndiceCount;
-            }
-
-            // Keep things clean:
-            GL.DisableVertexAttribArray(attribute_vpos);
-            GL.DisableVertexAttribArray(attribute_vcolor);
-            GL.Flush();
-
-            SwapBuffers();
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            time += (float)e.Time;
-
-            List<Vector3> verts = new List<Vector3>();
-            List<int> inds = new List<int>();
-            List<Vector3> colors = new List<Vector3>();
-
-            int vertCount = 0;
-
-            foreach (Volume v in objects)
-            {
-                verts.AddRange(v.GetVerts().ToList());
-                inds.AddRange(v.GetIndices().ToList());
-                colors.AddRange(v.GetColorData().ToList());
-                vertCount += v.VertCount;
-            }
-
-            vertData = verts.ToArray();
-            indiceData = inds.ToArray();
-            colorData = colors.ToArray();
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_position);  // 1. Bind vertex data to the buffer.
-            GL.BufferData<Vector3>(                                 // 2. Send data.
-                BufferTarget.ArrayBuffer, (IntPtr)(vertData.Length * Vector3.SizeInBytes), 
-                vertData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                attribute_vpos, 3, VertexAttribPointerType.Float, false, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_color);     // 1. Bind color data to the buffer
-            GL.BufferData<Vector3>(                                 // 2. Send Data
-                BufferTarget.ArrayBuffer, (IntPtr)(colorData.Length * Vector3.SizeInBytes),
-                colorData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                attribute_vcolor, 3, VertexAttribPointerType.Float, true, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ibo_elements);
-            GL.BufferData(
-                BufferTarget.ElementArrayBuffer, (IntPtr)(indiceData.Length * sizeof(int)),
-                indiceData, BufferUsageHint.StaticDraw);
-            
-            // Rotate objects
-            for (int i = 0; i < objects.Count; i++)
-            {
-                objects[i].Rotation = new Vector3(0.55f * time, 0.25f * time, 0);
-            }
-
-            // Send model view matrix
-            foreach (Volume v in objects)
-            {
-                v.CalculateModelMatrix();
-                v.ViewProjectionMatrix = 
-                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
-                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
-            }
-
-            GL.UseProgram(programID);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-        }
-
-        private void loadShader(String filename, ShaderType type, int program, out int address)
-        {
-            address = GL.CreateShader(type);
-            using (StreamReader sr = new StreamReader("Shaders/" + filename))
-            {
-                GL.ShaderSource(address, sr.ReadToEnd());
-            }
-            GL.CompileShader(address);
-            GL.AttachShader(program, address);
-            Console.WriteLine(GL.GetShaderInfoLog(address));
-        }
-    }
-}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
index aef1266..8e1dc3c 100644
--- a/AWGL/Shapes/Cube.cs
+++ b/AWGL/Shapes/Cube.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
index 822db60..4270204 100644
--- a/AWGL/Shapes/Sierpinski.cs
+++ b/AWGL/Shapes/Sierpinski.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 using System;
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
index 5003fa9..c29c8fe 100644
--- a/AWGL/Shapes/Tetra.cs
+++ b/AWGL/Shapes/Tetra.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 using System.Collections.Generic;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8da4ecd2bc793901ddb191f415f4dae1cda96c4a">Bit more tweaking and fiddling.</a>  -  8da4ecd</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 342 insertions(+)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
new file mode 100644
index 0000000..4881483
--- /dev/null
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -0,0 +1,301 @@
+﻿using AWGL.Shapes;
+using AWGL.Shapes.Base;
+using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+namespace AWGL.Scene.Base
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public abstract class DefaultScene : GameWindow
+    {
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+        }   
+
+        #region Private Fields
+
+        // GLSL Objects
+        private int m_VertexShaderObject, m_FragmentShaderObject, m_ProgramObject, m_TextureObject;
+
+        private int m_AttributeVertexPosition, m_AttributeVertexColor, m_UniformModelView;
+
+        private int m_Position_VBO, m_Color_VBO, m_ModelView_VBO, m_Elements_IBO;
+
+        private Vector3[] m_VertexData, m_ColorData;
+        protected List<Volume> m_Objects = new List<Volume>();
+        private int[] m_IndiceData;
+
+        private float m_Time = 0.0f;
+
+        private Version m_Version, m_TargetLow, m_TargetHigh;
+
+        #endregion Private Fields
+
+        #region InitProgram
+        
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        private void InitProgram()
+        {
+            m_ProgramObject = GL.CreateProgram();
+
+            loadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
+            loadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
+
+            // Links shaders and output any errors
+            GL.LinkProgram(m_ProgramObject);
+            Console.WriteLine(GL.GetProgramInfoLog(m_ProgramObject));
+
+            // Get the values we need, and also do a simple check to make sure the attributes were found.
+            m_AttributeVertexPosition = GL.GetAttribLocation(m_ProgramObject, "vPosition");
+            m_AttributeVertexColor = GL.GetAttribLocation(m_ProgramObject, "vColor");
+            m_UniformModelView = GL.GetUniformLocation(m_ProgramObject, "modelview");
+
+            if (m_AttributeVertexPosition == -1 || m_AttributeVertexColor == -1 || m_UniformModelView == -1)
+            {
+                Console.WriteLine("Error binding attributes");
+            }
+
+            // This generates 4 separate buffers and stores their addresses in our variables. 
+            // For multiple buffers like this, there's an option for generating multiple buffers 
+            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
+            GL.GenBuffers(1, out m_Position_VBO);
+            GL.GenBuffers(1, out m_Color_VBO);
+            GL.GenBuffers(1, out m_ModelView_VBO);
+            GL.GenBuffers(1, out m_Elements_IBO);
+
+            Random rand = new Random();
+
+            float xPos = -1.0f;
+            for (int i = 0; i < 2; i++)
+            {
+                Sierpinski sier = new Sierpinski();
+
+                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
+                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
+                sier.Scale = Vector3.One;
+                m_Objects.Add(sier);
+
+                xPos = 1.0f;
+            }
+        }
+
+        #endregion
+
+        #region OnLoad
+
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GetOpenGLVersion();
+
+            InitProgram();
+
+            Title = "AWGL: High level OpenTK wrapper   -   OpenGL " + m_Version.ToString();
+            GL.ClearColor(Color.MidnightBlue);
+            GL.PointSize(3f);
+        }
+
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+
+        }
+
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.EnableVertexAttribArray(m_AttributeVertexPosition);
+            GL.EnableVertexAttribArray(m_AttributeVertexColor);
+
+            int indiceAt = 0;
+            
+            foreach (Volume v in m_Objects)
+            {
+                GL.UniformMatrix4(m_UniformModelView, false, ref v.ModelViewProjectionMatrix);
+                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
+                indiceAt += v.IndiceCount;
+            }
+
+            // Keep things clean:
+            GL.DisableVertexAttribArray(m_AttributeVertexPosition);
+            GL.DisableVertexAttribArray(m_AttributeVertexColor);
+            GL.Flush();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Keyboard[OpenTK.Input.Key.Escape])
+            {
+                this.Exit();
+            }
+
+            m_Time += (float)e.Time;
+
+            List<Vector3> verts = new List<Vector3>();
+            List<int> inds = new List<int>();
+            List<Vector3> colors = new List<Vector3>();
+
+            int vertCount = 0;
+
+            foreach (Volume v in m_Objects)
+            {
+                verts.AddRange(v.GetVerts().ToList());
+                inds.AddRange(v.GetIndices().ToList());
+                colors.AddRange(v.GetColorData().ToList());
+                vertCount += v.VertCount;
+            }
+
+            m_VertexData = verts.ToArray();
+            m_IndiceData = inds.ToArray();
+            m_ColorData = colors.ToArray();
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Position_VBO);  // 1. Bind vertex data to the buffer.
+            GL.BufferData<Vector3>(                                 // 2. Send data.
+                BufferTarget.ArrayBuffer, (IntPtr)(m_VertexData.Length * Vector3.SizeInBytes), 
+                m_VertexData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                m_AttributeVertexPosition, 3, VertexAttribPointerType.Float, false, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Color_VBO);     // 1. Bind color data to the buffer
+            GL.BufferData<Vector3>(                                 // 2. Send Data
+                BufferTarget.ArrayBuffer, (IntPtr)(m_ColorData.Length * Vector3.SizeInBytes),
+                m_ColorData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                m_AttributeVertexColor, 3, VertexAttribPointerType.Float, true, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, m_Elements_IBO);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, (IntPtr)(m_IndiceData.Length * sizeof(int)),
+                m_IndiceData, BufferUsageHint.StaticDraw);
+            
+            // Rotate objects
+            for (int i = 0; i < m_Objects.Count; i++)
+            {
+                m_Objects[i].Rotation = new Vector3(0.55f * m_Time, 0.25f * m_Time, 0);
+            }
+
+            // Send model view matrix
+            foreach (Volume v in m_Objects)
+            {
+                v.CalculateModelMatrix();
+                v.ViewProjectionMatrix = 
+                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
+                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
+            }
+
+            GL.UseProgram(m_ProgramObject);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+        }
+
+        #endregion
+
+        #region GetOpenGLVersion
+
+        /// <summary>
+        /// Get OpenGL Version Information and check system meets requirements
+        /// </summary>
+        private void GetOpenGLVersion()
+        {
+            m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            m_TargetLow = new Version(3, 1);
+            m_TargetHigh = new Version(4, 1);
+            if (m_Version < m_TargetLow)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
+            }
+            else if (m_Version > m_TargetHigh)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
+            }
+        }
+
+        #endregion
+
+        #region loadShader
+
+        /// <summary>
+        /// Helper Funtion for loading shaders
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <param name="program">Program ID to add Shader too</param>
+        /// <param name="address">Shader Pointer</param>
+        private void loadShader(String filename, ShaderType type, int program, out int address)
+        {
+            address = GL.CreateShader(type);
+            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            {
+                GL.ShaderSource(address, sr.ReadToEnd());
+            }
+            GL.CompileShader(address);
+            GL.AttachShader(program, address);
+            Console.WriteLine(GL.GetShaderInfoLog(address));
+        }
+
+        #endregion
+
+    }
+}
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
new file mode 100644
index 0000000..f416196
--- /dev/null
+++ b/AWGL/Scene/Display.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using AWGL.Scene.Base;
+
+namespace AWGL.Scene
+{
+    public class Display : DefaultScene
+    {
+
+    }
+}
diff --git a/AWGL/Shapes/Base/Volume.cs b/AWGL/Shapes/Base/Volume.cs
new file mode 100644
index 0000000..5435f94
--- /dev/null
+++ b/AWGL/Shapes/Base/Volume.cs
@@ -0,0 +1,27 @@
+﻿using OpenTK;
+
+namespace AWGL.Shapes.Base
+{
+    public abstract class Volume
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Rotation = Vector3.Zero;
+        public Vector3 Scale = Vector3.One;
+
+        public int VertCount;
+        public int IndiceCount;
+        public int ColorDataCount;
+        public Matrix4 ModelMatrix = Matrix4.Identity;
+        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
+        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
+
+        public abstract Vector3[] GetVerts();
+        public abstract int[] GetIndices(int offset = 0);
+        public abstract Vector3[] GetColorData();
+        public abstract void CalculateModelMatrix();
+
+
+
+    } // class
+
+} // namespace

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e4a83e843565af0d6283be83bf84611d2ba277db">~</a>  -  e4a83e8</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index bfade2c..7565562 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -17,10 +17,2 @@ namespace AWGL
         
-        public static void Main(string[] args)
-        {
-            using (Display mainDisplay = new Display())
-            {
-                mainDisplay.Run(30.0);
-            }
-        }
-        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 4881483..eb96537 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -34,3 +34,3 @@ namespace AWGL.Scene.Base
         private Vector3[] m_VertexData, m_ColorData;
-        protected List<Volume> m_Objects = new List<Volume>();
+        private List<Volume> m_Objects = new List<Volume>();
         private int[] m_IndiceData;
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index c75c740..7cf872d 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -7,2 +7,5 @@ using System.Threading.Tasks;
 using AWGL;
+using AWGL.Scene;
+
+using OpenTK;
 
@@ -15,3 +18,6 @@ namespace TestApplication
         {
-            AWGL.AWGL.Main(args);
+            using (Display mainDisplay = new Display())
+            {
+                mainDisplay.Run(30.0);
+            }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e66febde0fcee39d753125bfaa08d77e5b8ee009">~</a>  -  e66febd</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
index 607bcb0..2d62a94 100644
--- a/AWGL/Graphic.cs
+++ b/AWGL/Graphic.cs
@@ -8,3 +8,3 @@ namespace AWGL
 {
-    abstract class Graphic
+    public abstract class Graphic
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/54150ceec67eb4e5536e4857f4bddc9f104ab311">Adding various primitive shapes from the OpenTK Example project.</a>  -  54150ce</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 25 files changed, 2627 insertions(+), 332 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index eb96537..fa3ebd3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -6,2 +6,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
@@ -12,3 +13,3 @@ using System.Linq;
 
-namespace AWGL.Scene.Base
+namespace AWGL.Scene
 {
@@ -22,2 +23,4 @@ namespace AWGL.Scene.Base
         {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
         }   
@@ -34,3 +37,3 @@ namespace AWGL.Scene.Base
         private Vector3[] m_VertexData, m_ColorData;
-        private List<Volume> m_Objects = new List<Volume>();
+        private List<DrawableShape> m_Objects = new List<DrawableShape>();
         private int[] m_IndiceData;
@@ -43,2 +46,23 @@ namespace AWGL.Scene.Base
 
+        #region Keyboard_KeyDown
+
+        /// <summary>
+        /// Occurs when a key is pressed.
+        /// </summary>
+        /// <param name="sender">The KeyboardDevice which generated this event.</param>
+        /// <param name="e">The key that was pressed.</param>
+        void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                this.Exit();
+
+            if (e.Key == Key.F11)
+                if (this.WindowState == WindowState.Fullscreen)
+                    this.WindowState = WindowState.Normal;
+                else
+                    this.WindowState = WindowState.Fullscreen;
+        }
+
+        #endregion
+
         #region InitProgram
@@ -52,4 +76,4 @@ namespace AWGL.Scene.Base
 
-            loadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
-            loadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
+            LoadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
+            LoadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
 
@@ -80,13 +104,13 @@ namespace AWGL.Scene.Base
             float xPos = -1.0f;
-            for (int i = 0; i < 2; i++)
-            {
-                Sierpinski sier = new Sierpinski();
+            //for (int i = 0; i < 2; i++)
+            //{
+                Place plane = new Plane();
 
-                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
-                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
-                sier.Scale = Vector3.One;
-                m_Objects.Add(sier);
+                plane.Position = new Vector3(xPos, 0.0f, -2.5f);
+                plane.Rotation = new Vector3(0.55f, 0.25f, 0);
+                plane.Scale = Vector3.One;
+                m_Objects.Add(plane);
 
                 xPos = 1.0f;
-            }
+            //}
         }
@@ -104,3 +128,3 @@ namespace AWGL.Scene.Base
 
-            GetOpenGLVersion();
+            TestOpenGLVersion();
 
@@ -108,3 +132,4 @@ namespace AWGL.Scene.Base
 
-            Title = "AWGL: High level OpenTK wrapper   -   OpenGL " + m_Version.ToString();
+            Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
             GL.ClearColor(Color.MidnightBlue);
@@ -187,7 +212,2 @@ namespace AWGL.Scene.Base
 
-            if (Keyboard[OpenTK.Input.Key.Escape])
-            {
-                this.Exit();
-            }
-
             m_Time += (float)e.Time;
@@ -257,3 +277,3 @@ namespace AWGL.Scene.Base
         /// </summary>
-        private void GetOpenGLVersion()
+        private void TestOpenGLVersion()
         {
@@ -276,3 +296,3 @@ namespace AWGL.Scene.Base
 
-        #region loadShader
+        #region LoadShader
 
@@ -285,3 +305,3 @@ namespace AWGL.Scene.Base
         /// <param name="address">Shader Pointer</param>
-        private void loadShader(String filename, ShaderType type, int program, out int address)
+        private void LoadShader(String filename, ShaderType type, int program, out int address)
         {
@@ -299,2 +319,37 @@ namespace AWGL.Scene.Base
 
+        #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
+
+        Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
+        {
+            Vbo handle = new Vbo();
+            int size;
+
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. Check that the buffer was uploaded correctly.
+
+            GL.GenBuffers(1, out handle.VboID);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(vertices.Length * BlittableValueType.StrideOf(vertices)), vertices,
+                          BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (vertices.Length * BlittableValueType.StrideOf(vertices) != size)
+                throw new ApplicationException("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out handle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(elements.Length * sizeof(short)), elements,
+                          BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (elements.Length * sizeof(short) != size)
+                throw new ApplicationException("Element data not uploaded correctly");
+
+            handle.NumElements = elements.Length;
+            return handle;
+        }
+
+        #endregion
+
+
     }
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
new file mode 100644
index 0000000..d8d71ca
--- /dev/null
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -0,0 +1,181 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL.Shapes
+{
+    // Abstract base class for procedurally generated geometry
+    // 
+    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
+    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
+    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
+    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
+    // Can use a Display List to prevent repeated immediate mode draws.
+    //
+
+    public abstract class DrawableShape: IDisposable
+    {
+        protected BeginMode PrimitiveMode;
+        protected VertexT2dN3dV3d[] VertexArray;
+        protected uint[] IndexArray;
+
+        public int GetTriangleCount
+        {
+            get
+            {
+                switch ( PrimitiveMode )
+                { 
+                case BeginMode.Triangles:
+                    if ( IndexArray != null )
+                    {
+                        return IndexArray.Length / 3;
+                    } else
+                    {
+                        return VertexArray.Length / 3;
+                    }
+                  //  break;
+                default: throw new NotImplementedException("Unknown primitive type.");
+                }
+            }
+        }
+
+        #region Display List
+
+        private bool UseDisplayList;
+        private int DisplayListHandle = 0;
+
+        #endregion Display List
+
+        public DrawableShape( bool useDisplayList )
+        {
+            UseDisplayList = useDisplayList;
+            PrimitiveMode = BeginMode.Triangles;
+            VertexArray = null;
+            IndexArray = null;
+        }
+
+        #region Convert to VBO
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2dN3dV3d[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = VertexArray[i].TexCoord;
+                vertices[i].Normal = VertexArray[i].Normal;
+                vertices[i].Position = VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2fN3fV3f[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2hN3hV3h[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3h)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        #endregion Convert to VBO
+
+        private void DrawImmediateMode()
+        {
+            GL.Begin( PrimitiveMode );
+            {
+                if ( IndexArray == null )
+                    foreach ( VertexT2dN3dV3d v in VertexArray )
+                    {
+                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
+                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
+                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
+                    } else
+                {
+                    for ( uint i = 0; i < IndexArray.Length; i++ )
+                    {
+                        uint index = IndexArray[i];
+                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
+                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
+                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
+                    }
+                }
+            }
+            GL.End();
+        }
+
+        /// <summary>
+        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
+        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
+        /// </summary>
+        public void Draw()
+        {
+            if ( !UseDisplayList )
+                DrawImmediateMode();
+            else
+                if ( DisplayListHandle == 0 )
+                {
+                    if ( VertexArray == null )
+                        throw new Exception("Cannot draw null Vertex Array.");
+                    DisplayListHandle = GL.GenLists( 1 );
+                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
+                    DrawImmediateMode();
+                    GL.EndList();
+                } else
+                    GL.CallList( DisplayListHandle );
+        }
+
+        #region IDisposable Members
+
+        /// <summary>
+        /// Removes reference to VertexArray and IndexArray.
+        /// Deletes the Display List, so it requires an OpenGL context.
+        /// The instance is effectively destroyed.
+        /// </summary>
+        public void Dispose()
+        {
+            if ( VertexArray != null )
+                VertexArray = null;
+            if ( IndexArray != null )
+                IndexArray = null;
+            if ( DisplayListHandle != 0 )
+            {
+                GL.DeleteLists( DisplayListHandle, 1 );
+                DisplayListHandle = 0;
+            }
+        }
+
+        #endregion
+    }
+
+}
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
new file mode 100644
index 0000000..670eb9f
--- /dev/null
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -0,0 +1,36 @@
+using System;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public struct VertexT2dN3dV3d
+    {
+        public Vector2d TexCoord;
+        public Vector3d Normal;
+        public Vector3d Position;
+
+        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        {
+            TexCoord = texcoord;
+            Normal = normal;
+            Position = position;
+        }
+    }
+
+    public struct VertexT2fN3fV3f
+    {
+        public Vector2 TexCoord;
+        public Vector3 Normal;
+        public Vector3 Position;
+    }
+
+    public struct VertexT2hN3hV3h
+    {
+        public Vector2h TexCoord;
+        public Vector3h Normal;
+        public Vector3h Position;
+    }
+
+   
+}
diff --git a/AWGL/Shapes/Base/Volume.cs b/AWGL/Shapes/Base/Volume.cs
deleted file mode 100644
index 5435f94..0000000
--- a/AWGL/Shapes/Base/Volume.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Shapes.Base
-{
-    public abstract class Volume
-    {
-        public Vector3 Position = Vector3.Zero;
-        public Vector3 Rotation = Vector3.Zero;
-        public Vector3 Scale = Vector3.One;
-
-        public int VertCount;
-        public int IndiceCount;
-        public int ColorDataCount;
-        public Matrix4 ModelMatrix = Matrix4.Identity;
-        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
-        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
-
-        public abstract Vector3[] GetVerts();
-        public abstract int[] GetIndices(int offset = 0);
-        public abstract Vector3[] GetColorData();
-        public abstract void CalculateModelMatrix();
-
-
-
-    } // class
-
-} // namespace
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
new file mode 100644
index 0000000..60abd5b
--- /dev/null
+++ b/AWGL/Shapes/Capsule.cs
@@ -0,0 +1,110 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class Capsule: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+        }
+
+
+        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            uint HoseSubDivs = 0;
+            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+                HoseSubDivs = 0;
+                break;
+            case eSubdivisions.One:
+                spheresubdivs = SlicedSphere.eSubdivisions.One;
+                HoseSubDivs = 1;
+                break;
+            case eSubdivisions.Two:
+                spheresubdivs = SlicedSphere.eSubdivisions.Two;
+                HoseSubDivs = 3;
+                break;
+            case eSubdivisions.Three:
+                spheresubdivs = SlicedSphere.eSubdivisions.Three;
+                HoseSubDivs = 7;
+                break;
+            case eSubdivisions.Four:
+                spheresubdivs = SlicedSphere.eSubdivisions.Four;
+                HoseSubDivs = 15;
+                break;
+            }
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
+                     offset2 = new Vector3d( 0.0, 0.0, -height );
+            for ( int i = 0; i < 4; i++ )
+            {
+                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
+                switch ( i )
+                {
+                case 0:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    break;
+                }
+                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+
+            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
+                                                       new SlicedSphere.eDir[] {
+                                                           SlicedSphere.eDir.BackBottomRight,
+                                                           SlicedSphere.eDir.FrontTopRight,
+                                                           SlicedSphere.eDir.BackTopRight,
+                                                           SlicedSphere.eDir.FrontBottomRight, 
+                                                          },
+                                                       false );
+
+            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            front.Dispose();
+
+            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
+                                                      new SlicedSphere.eDir[] { 
+                                                          SlicedSphere.eDir.FrontBottomLeft,
+                                                          SlicedSphere.eDir.FrontTopLeft, 
+                                                          SlicedSphere.eDir.BackTopLeft,
+                                                          SlicedSphere.eDir.BackBottomLeft },
+                                                      false );
+            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            back.Dispose();
+
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+        }
+    }
+}
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
new file mode 100644
index 0000000..da8df0a
--- /dev/null
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -0,0 +1,280 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class ChamferCube: DrawableShape
+    {
+
+        public enum SubDivs: byte
+        {
+            Zero,
+            One,
+            Two,
+            Three,
+            Four,
+        }
+
+        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
+            : base( useDL )
+        {   
+            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+            uint hoseSubDivs = 0;
+
+            switch ( subdivs )
+            {
+            case SubDivs.Zero:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+                hoseSubDivs = 0;
+                break;
+            case SubDivs.One:
+                sphereSubDivs = SlicedSphere.eSubdivisions.One;
+                hoseSubDivs = 1;
+                break;
+            case SubDivs.Two:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
+                hoseSubDivs = 3;
+                break;
+            case SubDivs.Three:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
+                hoseSubDivs = 7;
+                break;
+            case SubDivs.Four:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
+                hoseSubDivs = 15;
+                break;
+            }
+
+            #region Temporary Storage
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            #endregion Temporary Storage
+
+            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
+            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
+            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
+            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
+            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
+            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
+            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
+            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
+
+            #region 8 sliced Spheres
+            SlicedSphere tempSphere;
+            Vector3d tempVector = Vector3d.Zero;
+            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
+
+            for ( int i = 0; i < 8; i++ )
+            {
+                switch ( i )
+                {
+                case 0:
+                    tempVector = FrontTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
+                    break;
+                case 1:
+                    tempVector = FrontTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
+                    break;
+                case 2:
+                    tempVector = FrontBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
+                    break;
+                case 3:
+                    tempVector = FrontBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
+                    break;
+                case 4:
+                    tempVector = BackBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
+                    break;
+                case 5:
+                    tempVector = BackBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
+                    break;
+                case 6:
+                    tempVector = BackTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
+                    break;
+                case 7:
+                    tempVector = BackTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
+                    break;
+                }
+                tempSphere = new SlicedSphere( radius,
+                                                 tempVector,
+                                                 sphereSubDivs,
+                                                 tempEdge,
+                                                 false );
+                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempSphere.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 8 sliced Spheres
+
+            #region 12 sliced Hoses
+
+            SlicedHose tempHose;
+            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
+            Vector3d tempHoseStart = Vector3d.Zero;
+            Vector3d tempHoseEnd = Vector3d.Zero;
+
+            for ( int i = 0; i < 12; i++ )
+            {
+                switch ( i )
+                {
+                #region Around X Axis
+                case 0:
+                    tempSide = SlicedHose.eSide.BottomRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = FrontBottomRightEdge;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.TopRight;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.TopLeft;
+                    tempHoseStart = BackTopLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.BottomLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around X Axis
+                #region Around Y Axis
+                case 4:
+                    tempSide = SlicedHose.eSide.FrontRight;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 5:
+                    tempSide = SlicedHose.eSide.BackRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackTopRightEdge;
+                    break;
+                case 6:
+                    tempSide = SlicedHose.eSide.BackLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 7:
+                    tempSide = SlicedHose.eSide.FrontLeft;
+                    tempHoseStart = FrontBottomLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                #endregion Around Y Axis
+                #region Around Z Axis
+                case 8:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    tempHoseStart = FrontTopRightEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 9:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 10:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackBottomLeftEdge;
+                    break;
+                case 11:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around Z Axis
+                }
+                tempHose = new SlicedHose( tempSide,
+                                             hoseSubDivs,
+                                             radius,
+                                             tempHoseStart,
+                                             tempHoseEnd,
+                                             false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 12 sliced Hoses
+
+            #region 6 quads for the sides
+
+            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
+            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
+
+            // all quads use the same texcoords
+            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
+            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
+            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
+            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
+
+            // front face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
+            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // back face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
+            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // top face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // bottom face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
+            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // right face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // left face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
+            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+
+            #endregion 6 quads for the sides
+
+            #region Final Assembly of Chunks
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+            #endregion Final Assembly of Chunks
+        }
+    }
+}
diff --git a/AWGL/Shapes/ColourCube.cs b/AWGL/Shapes/ColourCube.cs
deleted file mode 100644
index 18eb637..0000000
--- a/AWGL/Shapes/ColourCube.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Shapes
-{
-    class ColourCube : Cube
-    {
-        Vector3 Color = new Vector3(1, 1, 1);
- 
-        public ColourCube(Vector3 color) : base() {
-            Color = color;
-        }
-
-        public ColourCube()
-        {
-
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] { 
-                Color,
-                Color, 
-                Color,
-                Color,
-                Color, 
-                Color, 
-                Color, 
-                Color
-            };
-        }
-    }
-}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
deleted file mode 100644
index 8e1dc3c..0000000
--- a/AWGL/Shapes/Cube.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-
-namespace AWGL.Shapes
-{
-    public class Cube : Volume
-    {
-        public Cube()
-        {
-            VertCount = 8;
-            IndiceCount = 36;
-            ColorDataCount = 8;
-        }
-
-        public override Vector3[] GetVerts()
-        {
-            return new Vector3[] {new Vector3(-0.5f, -0.5f,  -0.5f),
-                new Vector3(0.5f, -0.5f,  -0.5f),
-                new Vector3(0.5f, 0.5f,  -0.5f),
-                new Vector3(-0.5f, 0.5f,  -0.5f),
-                new Vector3(-0.5f, -0.5f,  0.5f),
-                new Vector3(0.5f, -0.5f,  0.5f),
-                new Vector3(0.5f, 0.5f,  0.5f),
-                new Vector3(-0.5f, 0.5f,  0.5f),
-            };
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = new int[] {
-                //left
-                0, 2, 1,
-                0, 3, 2,
-                //back
-                1, 2, 6,
-                6, 5, 1,
-                //right
-                4, 5, 6,
-                6, 7, 4,
-                //top
-                2, 3, 6,
-                6, 3, 7,
-                //front
-                0, 7, 3,
-                0, 4, 7,
-                //bottom
-                0, 1, 5,
-                0, 5, 4
-            };
-
-
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] {
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f),
-                new Vector3( 0f, 1f, 0f),
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f),
-                new Vector3( 0f, 1f, 0f),
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f)
-            };
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
new file mode 100644
index 0000000..40e7ebd
--- /dev/null
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -0,0 +1,82 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace AWGL.Shapes
+{
+    public class Chunk
+    {
+        public VertexT2dN3dV3d[] Vertices;
+        public uint[] Indices;
+
+        public uint VertexCount
+        {
+            get
+            {
+                return (uint)Vertices.Length;
+            }
+        }
+        public uint IndexCount
+        {
+            get
+            {
+                return (uint)Indices.Length;
+            }
+        }
+
+        public Chunk( uint vertexcount, uint indexcount )
+        {
+            Vertices = new VertexT2dN3dV3d[vertexcount];
+            Indices = new uint[indexcount];
+        }
+
+        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
+        {
+            Vertices = new VertexT2dN3dV3d[vbo.Length];
+            for ( int i = 0; i < Vertices.Length; i++ )
+            {
+                Vertices[i] = vbo[i];
+            } 
+            Indices = new uint[ibo.Length];
+            for ( int i = 0; i < Indices.Length; i++ )
+            {
+                Indices[i] = ibo[i];
+            }
+        }
+
+        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
+        {
+
+            uint VertexCounter = 0;
+            uint IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                VertexCounter += ch.VertexCount;
+                IndexCounter += ch.IndexCount;
+            }
+
+            vbo = new VertexT2dN3dV3d[VertexCounter];
+            ibo = new uint[IndexCounter];
+
+            VertexCounter = 0;
+            IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    vbo[VertexCounter + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
+                }
+
+                VertexCounter += (uint)ch.VertexCount;
+                IndexCounter += (uint)ch.IndexCount;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
new file mode 100644
index 0000000..cc08332
--- /dev/null
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -0,0 +1,422 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class MengerSponge
+    {
+        private struct MengerCube
+        {
+            private Vector3d Center;
+            private double SideLength;
+            private eSides[] VisibleSides;
+            private eSides[] VisibilityToInherit;
+
+            public void GetArraySizes( out uint vertexcount, out uint indexcount )
+            {
+                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
+                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
+            }
+
+            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
+            {
+                Center = center;
+                SideLength = sidelength;
+
+                /*  List<eSides> Sides = new List<eSides>();
+                  foreach ( eSides s in visibleSides )
+                  {
+                      bool isVisible = false;
+                      foreach ( eSides p in parentsVisibility )
+                      {
+                          if ( (int)p == (int)s )
+                          {
+                              isVisible = true;
+                              break;
+                          }
+                      }
+                      if ( isVisible )
+                      {
+                          Sides.Add( s );
+                      }
+                  }
+                  VisibleSides = Sides.ToArray();*/
+                VisibleSides = visibleSides;
+                VisibilityToInherit = visibleSides;
+            }
+
+            public void Subdivide( out MengerCube[] cubes )
+            {
+                cubes = new MengerCube[20]; // 8 + 4 + 8
+
+                double NewLength = this.SideLength / 3.0;
+                double six = this.SideLength * 2.0 / 3.0;
+                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
+
+                // front
+                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
+                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
+                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
+
+                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
+                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
+                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
+
+                // center
+                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                // back
+                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
+
+                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+
+                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
+                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
+
+            }
+
+            public enum eSides: byte
+            {
+                Front,
+                Back,
+                Right,
+                Left,
+                Top,
+                Bottom
+            }
+
+            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
+
+            public void GetVboAndIbo( ref List<Chunk> chunks )
+            {
+                foreach ( eSides s in AllSides )
+                {
+                    DrawSide( s, ref chunks );
+                }
+            }
+
+            private void DrawSide( eSides side, ref List<Chunk> chunks )
+            {
+                #region Setup constants for current direction
+
+                double _Zero = 0.0; // 0/3
+                double _Three = 0.3333333333333; // 1/3
+                double _Six = 0.66666666666666; // 2/3
+                double _One = 1.0; // 3/3 
+
+                double ThirdLength = SideLength / 3f;
+
+                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
+                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
+                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
+                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
+
+                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
+                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
+                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
+                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
+
+                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    P0 = C0;
+                    P1 = C1;
+                    P2 = C2;
+                    P3 = C3;
+
+                    P4 = C4;
+                    P5 = C5;
+                    P6 = C6;
+                    P7 = C7;
+                    break;
+                case eSides.Back:
+                    P0 = C5;
+                    P1 = C4;
+                    P2 = C7;
+                    P3 = C6;
+
+                    P4 = C1;
+                    P5 = C0;
+                    P6 = C3;
+                    P7 = C2;
+                    break;
+                case eSides.Right:
+                    P0 = C1;
+                    P1 = C5;
+                    P2 = C6;
+                    P3 = C2;
+
+                    P4 = C0;
+                    P5 = C4;
+                    P6 = C7;
+                    P7 = C3;
+                    break;
+                case eSides.Left:
+                    P0 = C4;
+                    P1 = C0;
+                    P2 = C3;
+                    P3 = C7;
+
+                    P4 = C5;
+                    P5 = C1;
+                    P6 = C2;
+                    P7 = C6;
+                    break;
+                case eSides.Top:
+                    P0 = C3;
+                    P1 = C2;
+                    P2 = C6;
+                    P3 = C7;
+
+                    P4 = C0;
+                    P5 = C1;
+                    P6 = C5;
+                    P7 = C4;
+                    break;
+                case eSides.Bottom:
+                    P0 = C1;
+                    P1 = C0;
+                    P2 = C4;
+                    P3 = C5;
+
+                    P4 = C2;
+                    P5 = C3;
+                    P6 = C7;
+                    P7 = C6;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+
+                #endregion Setup constants for current direction
+
+                #region Set Normal
+
+                Vector3d FaceNormal;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    FaceNormal = Vector3d.UnitZ;
+                    break;
+                case eSides.Back:
+                    FaceNormal = -Vector3d.UnitZ;
+                    break;
+                case eSides.Right:
+                    FaceNormal = Vector3d.UnitX;
+                    break;
+                case eSides.Left:
+                    FaceNormal = -Vector3d.UnitX;
+                    break;
+                case eSides.Top:
+                    FaceNormal = Vector3d.UnitY;
+                    break;
+                case eSides.Bottom:
+                    FaceNormal = -Vector3d.UnitY;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+                #endregion Set Normal
+
+                bool FaceIsVisible = false;
+                foreach ( eSides s in VisibleSides )
+                {
+                    if ( s == side )
+                    {
+                        FaceIsVisible = true;
+                        break;
+                    }
+                }
+
+                if ( FaceIsVisible )
+                {
+                    #region Define Layer1 Vertices
+                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
+
+                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
+                    Layer1.Vertices[0].Normal = FaceNormal;
+                    Layer1.Vertices[0].Position = P0;
+
+                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
+                    Layer1.Vertices[1].Normal = FaceNormal;
+                    Layer1.Vertices[1].Position = P1;
+
+                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
+                    Layer1.Vertices[2].Normal = FaceNormal;
+                    Layer1.Vertices[2].Position = P2;
+
+                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
+                    Layer1.Vertices[3].Normal = FaceNormal;
+                    Layer1.Vertices[3].Position = P3;
+
+                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
+                    Layer1.Vertices[4].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
+
+                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
+                    Layer1.Vertices[5].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
+
+                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
+                    Layer1.Vertices[6].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
+
+                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
+                    Layer1.Vertices[7].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
+                    #endregion Define Layer1 Vertices
+
+                    #region Define Layer1 Indices
+                    Layer1.Indices[0] = 0;
+                    Layer1.Indices[1] = 5;
+                    Layer1.Indices[2] = 4;
+
+                    Layer1.Indices[3] = 0;
+                    Layer1.Indices[4] = 1;
+                    Layer1.Indices[5] = 5;
+
+                    Layer1.Indices[6] = 5;
+                    Layer1.Indices[7] = 1;
+                    Layer1.Indices[8] = 2;
+
+                    Layer1.Indices[9] = 6;
+                    Layer1.Indices[10] = 5;
+                    Layer1.Indices[11] = 2;
+
+                    Layer1.Indices[12] = 7;
+                    Layer1.Indices[13] = 6;
+                    Layer1.Indices[14] = 2;
+
+                    Layer1.Indices[15] = 3;
+                    Layer1.Indices[16] = 7;
+                    Layer1.Indices[17] = 2;
+
+                    Layer1.Indices[18] = 0;
+                    Layer1.Indices[19] = 7;
+                    Layer1.Indices[20] = 3;
+
+                    Layer1.Indices[21] = 0;
+                    Layer1.Indices[22] = 4;
+                    Layer1.Indices[23] = 7;
+
+                    chunks.Add( Layer1 );
+                    #endregion Define Layer1 Indices
+                }
+
+                #region Define Layer2 Vertices
+                Chunk Layer2 = new Chunk( 12, 8 * 3 );
+
+                Vector3d T0, T1, T2, T3;
+                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
+                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
+                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
+                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
+
+                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
+                Layer2.Vertices[0].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
+
+                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
+                Layer2.Vertices[1].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
+
+                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
+                Layer2.Vertices[3].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
+
+                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
+                Layer2.Vertices[4].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
+
+                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
+                Layer2.Vertices[6].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
+
+                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
+                Layer2.Vertices[7].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
+
+                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
+                Layer2.Vertices[9].Normal = FaceNormal;
+                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
+
+                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
+                Layer2.Vertices[10].Normal = FaceNormal;
+                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
+
+                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
+                Layer2.Vertices[2].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
+
+                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
+                Layer2.Vertices[5].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
+
+                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
+                Layer2.Vertices[8].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
+
+                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
+                Layer2.Vertices[11].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
+                #endregion Define Layer2 Vertices
+
+                #region Define Layer2 Indices
+                Layer2.Indices[0] = 0;
+                Layer2.Indices[1] = 2;
+                Layer2.Indices[2] = 11;
+
+                Layer2.Indices[3] = 0;
+                Layer2.Indices[4] = 1;
+                Layer2.Indices[5] = 2;
+
+                Layer2.Indices[6] = 2;
+                Layer2.Indices[7] = 3;
+                Layer2.Indices[8] = 4;
+
+                Layer2.Indices[9] = 2;
+                Layer2.Indices[10] = 4;
+                Layer2.Indices[11] = 5;
+
+                Layer2.Indices[12] = 5;
+                Layer2.Indices[13] = 6;
+                Layer2.Indices[14] = 8;
+
+                Layer2.Indices[15] = 8;
+                Layer2.Indices[16] = 6;
+                Layer2.Indices[17] = 7;
+
+                Layer2.Indices[18] = 11;
+                Layer2.Indices[19] = 8;
+                Layer2.Indices[20] = 10;
+
+                Layer2.Indices[21] = 10;
+                Layer2.Indices[22] = 8;
+                Layer2.Indices[23] = 9;
+
+                chunks.Add( Layer2 );
+                #endregion Define Layer2 Indices
+            }
+        }
+    }
+
+   
+}
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
new file mode 100644
index 0000000..65f7f0b
--- /dev/null
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -0,0 +1,230 @@
+using System;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+
+    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
+    internal struct TetrahedronFace
+    {
+        private Vector3d APosition, BPosition, CPosition;
+        private Vector3d DPosition, Normal;
+        private Vector2d ATexCoord, BTexCoord, CTexCoord;
+
+        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
+                                   ref Vector3d bpos, ref Vector2d btc,
+                                   ref Vector3d cpos, ref Vector2d ctc,
+                                   ref Vector3d dpos,
+                                   ref Vector3d normal )
+        {
+            APosition = apos; ATexCoord = atc;
+            BPosition = bpos; BTexCoord = btc;
+            CPosition = cpos; CTexCoord = ctc;
+            DPosition = dpos;
+            Normal = normal;
+        }
+
+        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
+        /// <param name="first">1st output Triangle</param>
+        /// <param name="second">2nd output Triangle</param>
+        /// <param name="third">3rd output Triangle</param>
+        /// <param name="fourth">4th output Triangle</param>
+        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
+        {
+            Vector3d temp;
+
+            // find the 3 points AB, BC, CA 
+            Vector3d CenterAB;
+            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
+
+            Vector3d CenterBC;
+            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
+
+            Vector3d CenterCA;
+            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
+
+            // find the 3 points AD, BD, CD 
+            Vector3d CenterAD;
+            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
+
+            Vector3d CenterBD;
+            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
+
+            Vector3d CenterCD;
+            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
+
+            // emit 4 new CCW triangles
+            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
+                              ref CenterAB, ref this.BTexCoord,
+                              ref CenterCA, ref this.CTexCoord,
+                              ref CenterAD,
+                              ref this.Normal );
+
+            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
+                               ref this.BPosition, ref this.BTexCoord,
+                               ref CenterBC, ref this.CTexCoord,
+                               ref CenterBD,
+                               ref this.Normal );
+
+            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
+                              ref CenterBC, ref this.BTexCoord,
+                              ref this.CPosition, ref this.CTexCoord,
+                              ref CenterCD,
+                              ref this.Normal );
+
+            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
+                               ref CenterBD, ref this.BTexCoord,
+                               ref CenterCD, ref this.CTexCoord,
+                               ref this.DPosition,
+                               ref this.Normal );
+        }
+
+
+        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
+        {
+            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
+            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
+
+            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
+            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
+            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
+            CenterD = CenterAB;
+            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
+            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
+            CenterD /= 3.0;
+            Vector3d E = CenterD + ( this.Normal * 0.5 );
+            Vector3d temp = this.Normal;
+            temp *= height;
+            Vector3d.Add(ref CenterD, ref temp, out CenterD);
+
+            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
+            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
+            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
+            TexCoordD = TexCoordAB;
+            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
+            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
+            TexCoordD /= 3.0;
+            #region 1
+            first.APosition = this.APosition;
+            first.ATexCoord = this.ATexCoord;
+
+            first.BPosition = CenterAB;
+            first.BTexCoord = TexCoordAB;
+
+            first.CPosition = CenterCA;
+            first.CTexCoord = TexCoordCA;
+
+            first.Normal = this.Normal;
+            temp = ( this.APosition + CenterAB + CenterCA );
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            first.DPosition = temp;
+            #endregion 1
+            #region 2
+            second.APosition = CenterAB;
+            second.ATexCoord = TexCoordAB;
+
+            second.BPosition = this.BPosition;
+            second.BTexCoord = this.BTexCoord;
+
+            second.CPosition = CenterBC;
+            second.CTexCoord = TexCoordBC;
+
+            second.Normal = this.Normal;
+
+            temp = CenterAB + this.BPosition + CenterBC;
+            temp /=  3.0;
+            temp += this.Normal * -1.0;
+            second.DPosition = temp;
+
+            #endregion 2
+            #region 3
+            third.APosition = CenterBC;
+            third.ATexCoord = TexCoordBC;
+
+            third.BPosition = this.CPosition;
+            third.BTexCoord = this.CTexCoord;
+
+            third.CPosition = CenterCA;
+            third.CTexCoord = TexCoordCA;
+
+            third.Normal = this.Normal;
+            temp = CenterBC + this.CPosition + CenterCA;
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            third.DPosition = temp;
+            #endregion 3
+            #region 4
+            fourth.APosition = CenterAB;
+            fourth.ATexCoord = TexCoordAB;
+
+            fourth.BPosition = CenterD;
+            fourth.BTexCoord = TexCoordD;
+
+            fourth.CPosition = CenterCA;
+            fourth.CTexCoord = TexCoordCA;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
+            fourth.DPosition = E;
+            #endregion 4
+            #region 5
+            fifth.APosition = CenterAB;
+            fifth.ATexCoord = TexCoordAB;
+
+            fifth.BPosition = CenterBC;
+            fifth.BTexCoord = TexCoordBC;
+
+            fifth.CPosition = CenterD;
+            fifth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
+            fifth.DPosition = E;
+
+            #endregion 5
+            #region 6
+            sixth.APosition = CenterBC;
+            sixth.ATexCoord = TexCoordBC;
+
+            sixth.BPosition = CenterCA;
+            sixth.BTexCoord = TexCoordCA;
+
+            sixth.CPosition = CenterD;
+            sixth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
+            sixth.DPosition = E;
+            #endregion 6
+        }
+
+        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
+        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            first.TexCoord = this.ATexCoord;
+            first.Normal = this.Normal;
+            first.Position = this.APosition;
+
+            second.TexCoord = this.BTexCoord;
+            second.Normal = this.Normal;
+            second.Position = this.BPosition;
+
+            third.TexCoord = this.CTexCoord;
+            third.Normal = this.Normal;
+            third.Position = this.CPosition;
+        }
+
+        /// <summary>Debugging Aid, no real purpose</summary>
+        public override string ToString()
+        {
+            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "Normal= " + this.Normal.ToString();
+        }
+    }
+
+
+}
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
new file mode 100644
index 0000000..c791eb8
--- /dev/null
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -0,0 +1,27 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace AWGL.Shapes
+{
+    public sealed class VboShape: DrawableShape
+    {
+        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = primitives;
+
+            VertexArray = new VertexT2dN3dV3d[vertices.Length];
+            for ( uint i = 0; i < vertices.Length; i++ )
+            {
+                VertexArray[i] = vertices[i];
+            }
+
+            IndexArray = new uint[indices.Length];
+            for ( uint i = 0; i < indices.Length; i++ )
+            {
+                IndexArray[i] = indices[i];
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
new file mode 100644
index 0000000..1334082
--- /dev/null
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -0,0 +1,71 @@
+using System;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    public sealed class KochTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
+                    Triangles = temp;
+                    extrusionHeight *= extrusionMultiplier;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
+        {
+            output = new TetrahedronFace[input.Length * 6];
+
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
+                counter += 6; // every source triangle emits 6 new triangles
+            }
+
+        }
+    }
+}
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
new file mode 100644
index 0000000..f81c6ad
--- /dev/null
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -0,0 +1,116 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class MengerSponge: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+        }
+
+        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            List<MengerCube> Cubes;
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    List<MengerCube> temp;
+                    SubdivideMengerSponge( ref Cubes, out temp );
+                    Cubes = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            #region Get Array Dimensions
+            uint
+                VertexCount = 0,
+                IndexCount = 0;
+
+            foreach ( MengerCube c in Cubes )
+            {
+                uint t1, t2;
+                c.GetArraySizes( out t1, out t2 );
+                VertexCount += t1;
+                IndexCount += t2;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[VertexCount];
+            IndexArray = new uint[IndexCount];
+            #endregion Get Array Dimensions
+
+            List<Chunk> AllChunks = new List<Chunk>();
+
+            #region Build a temporary List of all loose pieces
+            foreach ( MengerCube c in Cubes )
+            {
+                c.GetVboAndIbo( ref AllChunks );
+            }
+            #endregion Build a temporary List of all loose pieces
+
+            #region Assemble pieces into a single VBO and IBO
+            VertexCount = 0;
+            IndexCount = 0;
+
+            foreach ( Chunk ch in AllChunks )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    VertexArray[VertexCount + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
+                }
+
+                VertexCount += (uint)ch.Vertices.Length;
+                IndexCount += (uint)ch.Indices.Length;
+            }
+
+            #endregion Assemble pieces into a single VBO and IBO
+
+            AllChunks.Clear();
+        }
+
+        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( 1 );
+            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
+        }
+
+        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( input.Count * 20 );
+            foreach ( MengerCube InputCube in input )
+            {
+                MengerCube[] SubdividedCubes;
+                InputCube.Subdivide( out SubdividedCubes );
+                for ( int i = 0; i < SubdividedCubes.Length; i++ )
+                {
+                    output.Add( SubdividedCubes[i] );
+                }
+            }
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
new file mode 100644
index 0000000..b24f97e
--- /dev/null
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -0,0 +1,75 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Drawing;
+
+using System.Runtime.InteropServices;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public class Cube : Shape
+    {
+        public Cube()
+        {
+            Vertices = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f), 
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f)
+            };
+
+            Indices = new int[]
+            {
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1,
+            };
+
+            Normals = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f),
+            };
+
+            Colors = new int[]
+            {
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.Gold),
+            };
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
new file mode 100644
index 0000000..f10a171
--- /dev/null
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    class IsoSphere : Shape
+    {
+        const double DoublePI = System.Math.PI * 2.0;
+
+        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
+        {
+            int count = 4 * s_steps * t_steps ;
+            
+            Vertices = new Vector3[count];
+            Normals = new Vector3[count];
+            Texcoords = new Vector2[count];
+            Indices = new int[6 * count / 4];
+
+            int i = 0;
+            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
+            {
+                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
+                {
+                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
+                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
+                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
+                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
+                    Normals[i] = Vector3.Normalize(Vertices[i]);
+
+                    ++i;
+                }
+            }
+            
+            for (i = 0; i < 6*count/4; i+=6)
+            {
+                Indices[i] = i;
+                Indices[i + 1] = i + 1;
+                Indices[i + 2] = i + 2 * s_steps + 1;
+                Indices[i + 3] = i + 2 * s_steps;
+                Indices[i + 4] = i;
+                Indices[i + 5] = i + 2 * s_steps + 1;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
new file mode 100644
index 0000000..6c4801c
--- /dev/null
+++ b/AWGL/Shapes/Old/Plane.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public class Plane : Shape
+    {
+        public Plane(int x_res, int y_res, float x_scale, float y_scale)
+        {
+            Vertices = new Vector3[x_res * y_res];
+            Normals = new Vector3[x_res * y_res];
+            Indices = new int[6 * x_res * y_res];
+            Texcoords = new Vector2[x_res * y_res];
+
+            int i = 0;
+            for (int y = -y_res / 2; y < y_res / 2; y++)
+            {
+                for (int x = -x_res / 2; x < x_res / 2; x++)
+                {
+                    Vertices[i].X = x_scale * (float)x / (float)x_res;
+                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
+                    Vertices[i].Z = 0;
+                    Normals[i].X = Normals[i].Y = 0;
+                    Normals[i].Z = 1;
+                    i++;
+                }
+            }
+
+            i = 0;
+            for (int y = 0; y < y_res - 1; y++)
+            {
+                for (int x = 0; x < x_res - 1; x++)
+                {
+                    Indices[i++] = (y + 0) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x + 1;
+                }
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
new file mode 100644
index 0000000..e151ed1
--- /dev/null
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -0,0 +1,70 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using System.Runtime.InteropServices;
+using System.Drawing;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public abstract class Shape
+    {
+        private Vector3[] vertices, normals;
+        private Vector2[] texcoords;
+        private int[] indices;
+        private int[] colors;
+
+        public Vector3[] Vertices
+        {
+            get { return vertices; }
+            protected set
+            {
+                vertices = value;
+            }
+        }
+
+        public Vector3[] Normals
+        {
+            get { return normals; }
+            protected set
+            {
+                normals = value;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get { return texcoords; }
+            protected set
+            {
+                texcoords = value;
+            }
+        }
+
+        public int[] Indices
+        {
+            get { return indices; }
+            protected set
+            {
+                indices = value;
+            }
+        }
+
+        public int[] Colors
+        {
+            get { return colors; }
+            protected set
+            {
+                colors = value;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
new file mode 100644
index 0000000..da9a161
--- /dev/null
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -0,0 +1,173 @@
+using System;
+using System.Diagnostics;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class SierpinskiTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
+            Zero = 0,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
+            One = 1,
+            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
+            Two = 2,
+            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
+            Three = 3,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
+            Four = 4,
+            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
+            Five = 5,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
+            Six = 6,
+            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
+            Seven = 7,
+            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
+            Eight = 8,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
+            Nine = 9,
+        }
+
+        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
+        /// <param name="scale">Default: 1f.</param>
+        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
+        /// <param name="useDL"></param>
+        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+            case eSubdivisions.Nine:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    SubdivideTetrahedron( ref Triangles, out temp );
+                    Triangles = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
+        {
+            output = new VertexT2dN3dV3d[input.Length * 3];
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
+                counter += 3;
+            }
+        }
+
+        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
+        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
+        {
+            Vector3d[] Points = new Vector3d[4];
+            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
+            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
+
+            Vector2d[] TexCoords = new Vector2d[4];
+            TexCoords[0] = new Vector2d( 0.0, 0.0 );
+            TexCoords[1] = new Vector2d( 1.0, 0.0 );
+            TexCoords[2] = new Vector2d( 0.0, 1.0 );
+            TexCoords[3] = new Vector2d( 1.0, 1.0 );
+
+            Vector3d Normal;
+            array = new TetrahedronFace[4];
+
+            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
+            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[2], ref TexCoords[0],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
+            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[1],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
+            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3], ref TexCoords[3],
+                                                   ref Points[2],
+                                                   ref Normal );
+
+            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
+            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[0],
+                                                   ref Normal );
+        }
+
+        /// <summary>Subdivides each triangle into 4 new ones.</summary>
+        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
+        {
+
+            output = new TetrahedronFace[source.Length * 4];
+
+            int counter = 0;
+            for ( int i = 0; i < source.Length; i++ )
+            {
+                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
+                counter += 4; // every source triangle emits 4 new triangles
+            }
+        }
+
+        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
+        {
+            Vector3d temp1, temp2, temp3;
+
+            Vector3d.Subtract( ref A, ref D, out temp1 );
+            Vector3d.Subtract( ref B, ref D, out temp2 );
+            Vector3d.Subtract( ref C, ref D, out temp3 );
+
+            Vector3d.Add( ref temp1, ref temp2, out result );
+            Vector3d.Add(ref result, ref temp3, out result);
+            result.Normalize();
+        }
+
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
+        {
+            Vector3d temp1, temp2;
+            Vector3d.Subtract( ref A, ref B, out temp1 );
+            temp1.Normalize();
+            Vector3d.Subtract(ref C, ref B, out temp2);
+            temp2.Normalize();
+            Vector3d.Cross( ref temp1, ref temp2, out result );
+            result *=  -1.0;
+            result.Normalize();
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
deleted file mode 100644
index 4270204..0000000
--- a/AWGL/Shapes/Sierpinski.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-using System;
-using System.Collections.Generic;
-
-namespace AWGL.Shapes
-{
-    class Sierpinski : Volume
-    {
-        public Sierpinski(int numSubdivisions = 1)
-        {
-            int NumTris = (int)Math.Pow(4, numSubdivisions + 1);
-
-            VertCount = NumTris;
-            ColorDataCount = NumTris;
-            IndiceCount = 3 * NumTris;
-
-            Tetra twhole = new Tetra(
-                new Vector3(0.0f, 0.0f, 1.0f),  // Apex center 
-                new Vector3(0.943f, 0.0f, -0.333f),  // Base center top
-                new Vector3(-0.471f, 0.816f, -0.333f),  // Base left bottom
-                new Vector3(-0.471f, -0.816f, -0.333f));
-
-            List<Tetra> allTets = twhole.Divide(numSubdivisions);
-
-            int offset = 0;
-            foreach (Tetra t in allTets)
-            {
-                verts.AddRange(t.GetVerts());
-                indices.AddRange(t.GetIndices(offset * 4));
-                colors.AddRange(t.GetColorData());
-                offset++;
-            }
-
-        }
-
-        private List<Vector3> verts = new List<Vector3>();
-        private List<int> indices = new List<int>();
-        private List<Vector3> colors = new List<Vector3>();
-
-        public override Vector3[] GetVerts()
-        {
-            return verts.ToArray();
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return colors.ToArray();
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = indices.ToArray();
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
new file mode 100644
index 0000000..4d7a536
--- /dev/null
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -0,0 +1,194 @@
+using System;
+using System.Collections.Generic;
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+	public sealed class SlicedHose : DrawableShape
+	{
+
+        public enum eSide:byte
+        {
+            // Around X Axis
+            BottomRight,
+            TopRight,
+            TopLeft,
+            BottomLeft,
+
+            // Around Y Axis
+
+            FrontRight,
+            BackRight,
+            BackLeft,
+            FrontLeft,
+
+            // Around Z Axis
+            FrontBottom,
+            BackBottom,
+            BackTop,
+            FrontTop,
+        }
+
+        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            Vector3d start = Vector3d.Zero,
+                     end = Vector3d.Zero;
+            double TexCoordStart=0f, TexCoordEnd=0f;
+
+            switch ( side )
+            {
+            #region Around X Axis
+            case eSide.BottomRight:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.TopRight:
+                start = Vector3d.UnitZ;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.TopLeft:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.BottomLeft:
+                start = -Vector3d.UnitZ;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+            #endregion Around X Axis
+            #region Around Y Axis
+            case eSide.FrontRight:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackRight:
+                start = Vector3d.UnitZ;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackLeft:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontLeft:
+                start = -Vector3d.UnitZ;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Y Axis
+            #region Around Z Axis
+            case eSide.FrontBottom:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackBottom:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackTop:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontTop:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Z Axis
+
+            }
+
+            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
+
+            double divisor = 1.0/ ((double)temp.Length-1.0);
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                float Multiplier = (float)( i * divisor );
+
+                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
+
+                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
+                temp[i].Normal.Normalize();
+                temp[i].Position = temp[i].Normal;
+                temp[i].Position *= scale;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
+            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
+
+            uint VertexCounter = 0,
+                 IndexCounter = 0,
+                 QuadCounter = 0;
+
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
+                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
+
+
+                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
+                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
+                VertexCounter += 2;
+
+                if ( i < temp.Length - 1 )
+                {
+                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
+                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
+
+                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
+                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
+
+                    IndexCounter += 6;
+                    QuadCounter += 2;
+                }
+            }
+
+        }
+ 
+    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
+    {
+        double t1;
+        Vector3d.Dot( ref a, ref b, out t1 );
+        double theta = System.Math.Acos( t1 );
+
+        double temp = 1.0 / System.Math.Sin( theta );
+        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
+        double t3 = System.Math.Sin( factor * theta ) * temp;
+
+        Vector3d v1 = Vector3d.Multiply( a, t2);
+        Vector3d v2 = Vector3d.Multiply( b, t3 );
+        result = Vector3d.Add( v1, v2 );
+    }
+
+
+    }
+}
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
new file mode 100644
index 0000000..772629e
--- /dev/null
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -0,0 +1,196 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class SlicedSphere: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public enum eDir
+        {
+            All,
+            FrontTopRight,
+            FrontBottomRight,
+            FrontBottomLeft,
+            FrontTopLeft,
+            BackTopRight,
+            BackBottomRight,
+            BackBottomLeft,
+            BackTopLeft,
+
+        }
+
+        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
+            : base( useDL )
+        {
+            double Diameter = radius;
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            if ( sides[0] == eDir.All )
+            {
+                sides = new eDir[] {  eDir.FrontTopRight,
+            eDir.FrontBottomRight,
+            eDir.FrontBottomLeft,
+            eDir.FrontTopLeft,
+            eDir.BackTopRight,
+            eDir.BackBottomRight,
+            eDir.BackBottomLeft,
+            eDir.BackTopLeft,};
+            }
+
+            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
+            IndexArray = new uint[sides.Length * 3];
+
+            uint counter = 0;
+            foreach ( eDir s in sides )
+            {
+                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
+                IndexArray[counter + 0] = counter + 0;
+                IndexArray[counter + 1] = counter + 1;
+                IndexArray[counter + 2] = counter + 2;
+                counter += 3;
+            }
+
+            if ( subdivs != eSubdivisions.Zero )
+            {
+
+                for ( int s = 0; s < (int)subdivs; s++ )
+                {
+                    #region Assemble Chunks and convert to Arrays
+                    List<Chunk> AllChunks = new List<Chunk>();
+                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
+                    {
+                        Chunk chu;
+                        Subdivide( Diameter,
+                                   ref VertexArray[IndexArray[i + 0]],
+                                   ref VertexArray[IndexArray[i + 1]],
+                                   ref VertexArray[IndexArray[i + 2]],
+                                   out chu );
+                        AllChunks.Add( chu );
+                    }
+
+                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+                    AllChunks.Clear();
+                    #endregion Assemble Chunks and convert to Arrays
+                }
+            }
+
+            for (int i=0; i<VertexArray.Length;i++)
+            {
+                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
+            }
+        }
+
+        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
+                            t2 = new VertexT2dN3dV3d(),
+                            t3 = new VertexT2dN3dV3d();
+            switch ( s )
+            {
+            case eDir.FrontTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.FrontBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                break;
+            case eDir.FrontBottomLeft: 
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.FrontTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.BackTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            case eDir.BackBottomLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            }
+            first = t1;
+            second = t2;
+            third = t3;
+        }
+
+
+        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
+        {
+            c = new Chunk(6, 12);
+
+            c.Vertices[0] = first;
+            
+            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
+            c.Vertices[1].Normal.Normalize();
+            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
+            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
+
+            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
+            c.Vertices[2].Normal.Normalize();
+            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
+            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
+
+            c.Vertices[3] = second;
+    
+            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
+            c.Vertices[4].Normal.Normalize();
+            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
+            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
+
+            c.Vertices[5] = third;
+
+            #region Indices
+            c.Indices[0]=0;
+            c.Indices[1]=1;
+            c.Indices[2]=2;
+            c.Indices[3]=2;
+            c.Indices[4]=1;
+            c.Indices[5]=4;
+            c.Indices[6]=1;
+            c.Indices[7]=3;
+            c.Indices[8]=4;
+            c.Indices[9]=2;
+            c.Indices[10]=4;
+            c.Indices[11]=5;
+            #endregion Indices
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
deleted file mode 100644
index c29c8fe..0000000
--- a/AWGL/Shapes/Tetra.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-using System.Collections.Generic;
-
-namespace AWGL.Shapes
-{
-    class Tetra : Volume
-    {
-        Vector3 PointApex;
-        Vector3 PointA;
-        Vector3 PointB;
-        Vector3 PointC;
-
-        public Tetra(Vector3 apex, Vector3 a, Vector3 b, Vector3 c)
-        {
-            PointApex = apex;
-            PointA = a;
-            PointB = b;
-            PointC = c;
-
-            VertCount = 4;
-            IndiceCount = 12;
-            ColorDataCount = 4;
-        }
-
-        public List<Tetra> Divide(int n = 0)
-        {
-            if (n == 0)
-            {
-                return new List<Tetra>(new Tetra[] { this });
-            }
-            else
-            {
-
-                Vector3 halfa = (PointApex + PointA) / 2.0f;
-                Vector3 halfb = (PointApex + PointB) / 2.0f;
-                Vector3 halfc = (PointApex + PointC) / 2.0f;
-
-                // Calculate points half way between base points
-                Vector3 halfab = (PointA + PointB) / 2.0f;
-                Vector3 halfbc = (PointB + PointC) / 2.0f;
-                Vector3 halfac = (PointA + PointC) / 2.0f;
-
-                Tetra t1 = new Tetra(PointApex, halfa, halfb, halfc);
-                Tetra t2 = new Tetra(halfa, PointA, halfab, halfac);
-                Tetra t3 = new Tetra(halfb, halfab, PointB, halfbc);
-                Tetra t4 = new Tetra(halfc, halfac, halfbc, PointC);
-
-                List<Tetra> output = new List<Tetra>();
-
-                output.AddRange(t1.Divide(n - 1));
-                output.AddRange(t2.Divide(n - 1));
-                output.AddRange(t3.Divide(n - 1));
-                output.AddRange(t4.Divide(n - 1));
-
-                return output;
-
-            }
-        }
-
-        public override Vector3[] GetVerts()
-        {
-            return new Vector3[] { PointApex, PointA, PointB, PointC };
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = new int[] { //bottom
-                                1,3,2,
-                                //other sides
-                                0,1,2,
-                                0,2,3,
-                                0,3,1
-        };
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] { new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f), new Vector3(1f, 1f, 0f) };
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
new file mode 100644
index 0000000..ff7ec7d
--- /dev/null
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -0,0 +1,128 @@
+﻿using System;
+using System.Diagnostics;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class TorusKnot: DrawableShape
+    {
+        #region Constants
+        // hard minimums to make sure the created Torusknot is 3D
+        private const int MINShapeVertices = 3;
+        private const int MINPathSteps = 32;
+        private const double TwoPi = ( 2.0 * System.Math.PI );
+        #endregion Constants
+
+        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
+            : base( useDL )
+        {
+            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
+            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
+            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+
+            Vector3d[] PathPositions = new Vector3d[pathsteps];
+
+            #region Find the center Points for each step on the path
+
+            for ( int i = 0; i < pathsteps; i++ )
+            {
+                double Angle = ( i / (double)pathsteps ) * TwoPi;
+                double AngleTimesP = Angle * p;
+                double AngleTimesQ = Angle * q;
+                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
+
+                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
+                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
+                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
+
+            }
+            #endregion Find the center Points for each step on the path
+
+            #region Find the Torus length
+            Vector3d result;
+            double[] Lengths = new double[pathsteps];
+            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
+            Lengths[0] = result.Length;
+            double TotalLength = result.Length;
+            for ( int i = 1; i < pathsteps; i++ ) // skipping 
+            {
+                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
+                Lengths[i] = result.Length;
+                TotalLength += result.Length;
+            }
+            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
+            #endregion Find the Torus length
+
+            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
+
+            #region Loft a circle Shape along the path
+            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                Vector3d last, next, normal, tangent;
+                if ( i == pathsteps - 1 )
+                    next = PathPositions[0];
+                else
+                    next = PathPositions[i + 1];
+                if ( i == 0 )
+                    last = PathPositions[pathsteps - 1];
+                else
+                    last = PathPositions[i - 1];
+
+                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
+                tangent.Normalize();
+
+                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
+                normal.Normalize();
+                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
+
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    uint index = i * (uint)shapevertices + j;
+
+                    // Create a point on the plane and rotate it
+                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
+                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
+                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
+                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
+                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
+                    VertexArray[index].Normal.Normalize();
+                    // just generate some semi-useful UVs to fill blanks
+                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
+                }
+            }
+            #endregion Loft a circle Shape along the path
+
+            PathPositions = null; // not needed anymore
+
+            uint currentindex = 0;
+
+            #region Build a Triangle strip from the Vertices
+            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                uint RowCurrent = i * (uint)shapevertices;
+                uint RowBelow;
+                if ( i == pathsteps - 1 )
+                    RowBelow = 0; // for the last row, the first row is the following
+                else
+                    RowBelow = ( i + 1 ) * (uint)shapevertices;
+
+                // new ring begins here
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    IndexArray[currentindex++] = RowCurrent + j;
+                    IndexArray[currentindex++] = RowBelow + j;
+                }
+                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
+                IndexArray[currentindex++] = RowCurrent;
+                IndexArray[currentindex++] = RowBelow;
+            }
+            #endregion Build a Triangle strip from the Vertices
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
new file mode 100644
index 0000000..4643452
--- /dev/null
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -0,0 +1,51 @@
+﻿#region License
+//
+// The Open Toolkit Library License
+//
+// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights to 
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+// OTHER DEALINGS IN THE SOFTWARE.
+//
+#endregion
+
+using System.Drawing;
+using System.Runtime.InteropServices;
+using OpenTK;
+
+namespace AWGL.Tutorial
+{
+    [StructLayout(LayoutKind.Sequential, Pack = 1)]
+    struct VertexPositionColor
+    {
+        public Vector3 Position;
+        public uint Color;
+
+        public VertexPositionColor(float x, float y, float z, Color color)
+        {
+            Position = new Vector3(x, y, z);
+            Color = ToRgba(color);
+        }
+
+        static uint ToRgba(Color color)
+        {
+            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/33c67b20348e42365482e8ed4ff9d87ecf681d86">~</a>  -  33c67b2</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 7565562..04bd107 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -16,3 +16,10 @@ namespace AWGL
     {
-        
+        [STAThread]
+        public static void Main(string[] args)
+        {
+            using (Display mainDisplay = new Display())
+            {
+                mainDisplay.Run(30.0);
+            }
+        }
     }
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
index f416196..e2d7ff5 100644
--- a/AWGL/Scene/Display.cs
+++ b/AWGL/Scene/Display.cs
@@ -5,3 +5,2 @@ using System.Text;
 using System.Threading.Tasks;
-using AWGL.Scene.Base;
 
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index 7cf872d..595ae6e 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -9,4 +9,2 @@ using AWGL.Scene;
 
-using OpenTK;
-
 namespace TestApplication
@@ -16,8 +14,5 @@ namespace TestApplication
         [STAThread]
-        static void Main(string[] args)
+        public static void Main(string[] args)
         {
-            using (Display mainDisplay = new Display())
-            {
-                mainDisplay.Run(30.0);
-            }
+            AWGL.AWGL.Main(args);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2e6e60b1687f9366229c86177918e2c4a58a2486">Added simple VBO Struct.</a>  -  2e6e60b</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 7 insertions(+)

diff --git a/AWGL/VBO.cs b/AWGL/VBO.cs
new file mode 100644
index 0000000..0dd834c
--- /dev/null
+++ b/AWGL/VBO.cs
@@ -0,0 +1,7 @@
+﻿namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, EboID, NumElements;
+    }
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/806282cb768b34fdd3a7c4e4e12478d1a1502c90">Static VBO</a>  -  806282c</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 4 files changed, 117 insertions(+), 173 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 04bd107..d4f61a0 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -24,2 +24,4 @@ namespace AWGL
         }
+
+        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fa3ebd3..a452631 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -1,3 +1,3 @@
 ﻿using AWGL.Shapes;
-using AWGL.Shapes.Base;
+using AWGL.Tutorial;
 using ObjLoader.Loader.Loaders;
@@ -20,8 +20,2 @@ namespace AWGL.Scene
     {
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
-        }   
 
@@ -29,18 +23,38 @@ namespace AWGL.Scene
 
-        // GLSL Objects
-        private int m_VertexShaderObject, m_FragmentShaderObject, m_ProgramObject, m_TextureObject;
+        private const float rotation_speed = 180.0f;
+        private float angle;
 
-        private int m_AttributeVertexPosition, m_AttributeVertexColor, m_UniformModelView;
+        private struct Vbo { public int VboID, EboID, NumElements; }
+        private Vbo[] vbo = new Vbo[2];
 
-        private int m_Position_VBO, m_Color_VBO, m_ModelView_VBO, m_Elements_IBO;
-
-        private Vector3[] m_VertexData, m_ColorData;
-        private List<DrawableShape> m_Objects = new List<DrawableShape>();
-        private int[] m_IndiceData;
-
-        private float m_Time = 0.0f;
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
 
-        private Version m_Version, m_TargetLow, m_TargetHigh;
+        #endregion  
 
-        #endregion Private Fields
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
+        }   
 
@@ -67,54 +81,2 @@ namespace AWGL.Scene
 
-        #region InitProgram
-        
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        private void InitProgram()
-        {
-            m_ProgramObject = GL.CreateProgram();
-
-            LoadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
-            LoadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
-
-            // Links shaders and output any errors
-            GL.LinkProgram(m_ProgramObject);
-            Console.WriteLine(GL.GetProgramInfoLog(m_ProgramObject));
-
-            // Get the values we need, and also do a simple check to make sure the attributes were found.
-            m_AttributeVertexPosition = GL.GetAttribLocation(m_ProgramObject, "vPosition");
-            m_AttributeVertexColor = GL.GetAttribLocation(m_ProgramObject, "vColor");
-            m_UniformModelView = GL.GetUniformLocation(m_ProgramObject, "modelview");
-
-            if (m_AttributeVertexPosition == -1 || m_AttributeVertexColor == -1 || m_UniformModelView == -1)
-            {
-                Console.WriteLine("Error binding attributes");
-            }
-
-            // This generates 4 separate buffers and stores their addresses in our variables. 
-            // For multiple buffers like this, there's an option for generating multiple buffers 
-            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
-            GL.GenBuffers(1, out m_Position_VBO);
-            GL.GenBuffers(1, out m_Color_VBO);
-            GL.GenBuffers(1, out m_ModelView_VBO);
-            GL.GenBuffers(1, out m_Elements_IBO);
-
-            Random rand = new Random();
-
-            float xPos = -1.0f;
-            //for (int i = 0; i < 2; i++)
-            //{
-                Place plane = new Plane();
-
-                plane.Position = new Vector3(xPos, 0.0f, -2.5f);
-                plane.Rotation = new Vector3(0.55f, 0.25f, 0);
-                plane.Scale = Vector3.One;
-                m_Objects.Add(plane);
-
-                xPos = 1.0f;
-            //}
-        }
-
-        #endregion
-
         #region OnLoad
@@ -130,3 +92,3 @@ namespace AWGL.Scene
 
-            InitProgram();
+            //InitProgram();
 
@@ -134,13 +96,7 @@ namespace AWGL.Scene
 
-            GL.ClearColor(Color.MidnightBlue);
-            GL.PointSize(3f);
-        }
-
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.Enable(EnableCap.DepthTest);
 
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
         }
@@ -161,2 +117,21 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+        
+        #region OnUpdateFrame
+
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
         }
@@ -175,22 +150,13 @@ namespace AWGL.Scene
             base.OnRenderFrame(e);
-            
+
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-            GL.Enable(EnableCap.DepthTest);
 
-            GL.EnableVertexAttribArray(m_AttributeVertexPosition);
-            GL.EnableVertexAttribArray(m_AttributeVertexColor);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
 
-            int indiceAt = 0;
-            
-            foreach (Volume v in m_Objects)
-            {
-                GL.UniformMatrix4(m_UniformModelView, false, ref v.ModelViewProjectionMatrix);
-                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
-                indiceAt += v.IndiceCount;
-            }
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
 
-            // Keep things clean:
-            GL.DisableVertexAttribArray(m_AttributeVertexPosition);
-            GL.DisableVertexAttribArray(m_AttributeVertexColor);
-            GL.Flush();
+            Draw(vbo[0]);
 
@@ -201,69 +167,7 @@ namespace AWGL.Scene
 
-        #region OnUpdateFrame
+        #region OnUnload
 
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnUpdateFrame(FrameEventArgs e)
+        protected override void OnUnload(EventArgs e)
         {
-            base.OnUpdateFrame(e);
-
-            m_Time += (float)e.Time;
-
-            List<Vector3> verts = new List<Vector3>();
-            List<int> inds = new List<int>();
-            List<Vector3> colors = new List<Vector3>();
-
-            int vertCount = 0;
-
-            foreach (Volume v in m_Objects)
-            {
-                verts.AddRange(v.GetVerts().ToList());
-                inds.AddRange(v.GetIndices().ToList());
-                colors.AddRange(v.GetColorData().ToList());
-                vertCount += v.VertCount;
-            }
-
-            m_VertexData = verts.ToArray();
-            m_IndiceData = inds.ToArray();
-            m_ColorData = colors.ToArray();
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Position_VBO);  // 1. Bind vertex data to the buffer.
-            GL.BufferData<Vector3>(                                 // 2. Send data.
-                BufferTarget.ArrayBuffer, (IntPtr)(m_VertexData.Length * Vector3.SizeInBytes), 
-                m_VertexData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                m_AttributeVertexPosition, 3, VertexAttribPointerType.Float, false, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Color_VBO);     // 1. Bind color data to the buffer
-            GL.BufferData<Vector3>(                                 // 2. Send Data
-                BufferTarget.ArrayBuffer, (IntPtr)(m_ColorData.Length * Vector3.SizeInBytes),
-                m_ColorData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                m_AttributeVertexColor, 3, VertexAttribPointerType.Float, true, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, m_Elements_IBO);
-            GL.BufferData(
-                BufferTarget.ElementArrayBuffer, (IntPtr)(m_IndiceData.Length * sizeof(int)),
-                m_IndiceData, BufferUsageHint.StaticDraw);
-            
-            // Rotate objects
-            for (int i = 0; i < m_Objects.Count; i++)
-            {
-                m_Objects[i].Rotation = new Vector3(0.55f * m_Time, 0.25f * m_Time, 0);
-            }
 
-            // Send model view matrix
-            foreach (Volume v in m_Objects)
-            {
-                v.CalculateModelMatrix();
-                v.ViewProjectionMatrix = 
-                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
-                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
-            }
-
-            GL.UseProgram(m_ProgramObject);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
         }
@@ -279,5 +183,5 @@ namespace AWGL.Scene
         {
-            m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            m_TargetLow = new Version(3, 1);
-            m_TargetHigh = new Version(4, 1);
+            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetHigh = new Version(4, 1);
             if (m_Version < m_TargetLow)
@@ -353,2 +257,22 @@ namespace AWGL.Scene
 
+        void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
 
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index d8d71ca..019722b 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -10,2 +10,3 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using System.Drawing;
 
@@ -157,2 +158,4 @@ namespace AWGL.Shapes
 
+        
+
         #region IDisposable Members
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index b24f97e..fd8e0c0 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -14,2 +14,3 @@ using System.Runtime.InteropServices;
 using OpenTK;
+using AWGL;
 
@@ -63,12 +64,26 @@ namespace AWGL.Shapes
             {
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
             };
         }
+
+        /// <summary>
+        /// Converts a Color instance into an int representation
+        /// </summary>
+        /// <param name="c">
+        /// A <see cref="Color"/> instance to be converted
+        /// </param>
+        /// <returns>
+        /// A <see cref="System.Int32"/>
+        /// </returns>
+        public static int ColorToRgba32(Color c)
+        {
+            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0360a0cd636b00fb27f4878be7f4658fd88ffd4d">Tweaks</a>  -  0360a0c</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index a452631..27f30b2 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -20,2 +20,8 @@ namespace AWGL.Scene
     {
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
+        }   
 
@@ -53,9 +59,2 @@ namespace AWGL.Scene
 
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
-        }   
-
         #region Keyboard_KeyDown
@@ -232,4 +231,6 @@ namespace AWGL.Scene
             // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. Check that the buffer was uploaded correctly.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
 
@@ -257,2 +258,4 @@ namespace AWGL.Scene
 
+        #region Draw(Vbo handle)
+
         void Draw(Vbo handle)
@@ -278,2 +281,3 @@ namespace AWGL.Scene
 
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a5b8d1816321819b334ef58f2710720954995780">Particles</a>  -  a5b8d18</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 133 insertions(+), 17 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 27f30b2..76dd42a 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -25,2 +25,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
+            this.VSync = VSyncMode.Off;
         }   
@@ -59,2 +60,34 @@ namespace AWGL.Scene
 
+        #region Particles
+
+        private static int MaxParticleCount = 2000;
+        private int VisibleParticleCount;
+        private VertexC4ubV3f[] VBO = new VertexC4ubV3f[MaxParticleCount];
+        private ParticleAttribut[] ParticleAttributes = new ParticleAttribut[MaxParticleCount];
+
+        // this struct is used for drawing
+        struct VertexC4ubV3f
+        {
+            public byte R, G, B, A;
+            public Vector3 Position;
+
+            public static int SizeInBytes = 16;
+        }
+
+        // this struct is used for updates
+        struct ParticleAttribut
+        {
+            public Vector3 Direction;
+            public uint Age;
+
+            //  more stuff could be here: Rotation, Radius, whatever
+        }
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+
+        #endregion Particles
+
         #region Keyboard_KeyDown
@@ -91,13 +124,61 @@ namespace AWGL.Scene
 
-            //InitProgram();
-
             Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
 
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.ClearColor(.1f, 0f, .1f, 0f);
             GL.Enable(EnableCap.DepthTest);
 
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+            // Set our point parameters
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSprite);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceatd as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = new Vector3();
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < MaxParticleCount; i++)
+            {
+                if (xPos >= 4.0f)
+                {
+                    xPos = -4.0f;
+                }
+                if (yPos >= 4.0f)
+                {
+                    yPos = -4.0f;
+                }
+                VBO[i].R = (byte)rndNum.Next(0, 256);
+                VBO[i].G = (byte)rndNum.Next(0, 256);
+                VBO[i].B = (byte)rndNum.Next(0, 256);
+                VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                ParticleAttributes[i].Direction = tmp; // copy 
+                ParticleAttributes[i].Age = 0;
+
+                xPos = xPos + 0.0231f;
+                yPos = yPos + 0.0253f;
+            }
+
+            VisibleParticleCount = 0;
+
         }
 
+        //private void
         #endregion
@@ -117,6 +198,9 @@ namespace AWGL.Scene
 
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
             GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
         }
@@ -134,3 +218,26 @@ namespace AWGL.Scene
         {
-            base.OnUpdateFrame(e);
+            //base.OnUpdateFrame(e);
+
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (VisibleParticleCount < MaxParticleCount)
+                VisibleParticleCount++;
+
+            Vector3 temp;
+
+            for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
+            {
+                if (ParticleAttributes[i].Age >= MaxParticleCount)
+                {
+                    // reset particle
+                    ParticleAttributes[i].Age = 0;
+                    VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
+                    Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
+                }
+            }
         }
@@ -148,3 +255,5 @@ namespace AWGL.Scene
         {
-            base.OnRenderFrame(e);
+            //base.OnRenderFrame(e);
+
+            this.Title = "AWGL: High level OpenTK wrapper - " + VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
 
@@ -152,10 +261,15 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
+            GL.PushMatrix();
 
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+            GL.Translate(0f, 0f, -5f);
 
-            Draw(vbo[0]);
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+
+            GL.PopMatrix();
 
@@ -170,3 +284,3 @@ namespace AWGL.Scene
         {
-
+            GL.DeleteBuffers(1, ref VBOHandle);
         }
@@ -282,2 +396,4 @@ namespace AWGL.Scene
         #endregion
+
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ee23372a2eba2813ac7f9abfa03d058f6fe70606">Implemented Simple Texture</a>  -  ee23372</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 125 insertions(+), 84 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 76dd42a..e2e7646 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -10,2 +10,3 @@ using System.Collections.Generic;
 using System.Drawing;
+using System.Drawing.Imaging;
 using System.IO;
@@ -62,3 +63,3 @@ namespace AWGL.Scene
 
-        private static int MaxParticleCount = 2000;
+        protected static int MaxParticleCount = 2000;
         private int VisibleParticleCount;
@@ -92,2 +93,9 @@ namespace AWGL.Scene
 
+        #region Textures
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");//("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
         #region Keyboard_KeyDown
@@ -127,54 +135,72 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Texture2D);
 
-            // Set our point parameters
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSprite);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+            //// Set our point parameters
+            //GL.PointSize(5f);
+            //GL.Enable(EnableCap.PointSprite);
 
-            // set up vbo state - depreceatd as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
 
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
 
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            Random rndNum = new Random();
-            Vector3 tmp = new Vector3();
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
 
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < MaxParticleCount; i++)
-            {
-                if (xPos >= 4.0f)
-                {
-                    xPos = -4.0f;
-                }
-                if (yPos >= 4.0f)
-                {
-                    yPos = -4.0f;
-                }
-                VBO[i].R = (byte)rndNum.Next(0, 256);
-                VBO[i].G = (byte)rndNum.Next(0, 256);
-                VBO[i].B = (byte)rndNum.Next(0, 256);
-                VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                ParticleAttributes[i].Direction = tmp; // copy 
-                ParticleAttributes[i].Age = 0;
-
-                xPos = xPos + 0.0231f;
-                yPos = yPos + 0.0253f;
-            }
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
 
-            VisibleParticleCount = 0;
+            bitmap.UnlockBits(data);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            #region particles
+            //GL.EnableClientState(ArrayCap.ColorArray);
+            //GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            //GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            //GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            //GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            //Random rndNum = new Random();
+            //Vector3 tmp = new Vector3();
+
+            //// generate some random stuff for the particle system
+            //for (uint i = 0; i < MaxParticleCount; i++)
+            //{
+            //    if (xPos >= 4.0f)
+            //    {
+            //        xPos = -4.0f;
+            //    }
+            //    if (yPos >= 4.0f)
+            //    {
+            //        yPos = -4.0f;
+            //    }
+            //    VBO[i].R = (byte)rndNum.Next(0, 256);
+            //    VBO[i].G = (byte)rndNum.Next(0, 256);
+            //    VBO[i].B = (byte)rndNum.Next(0, 256);
+            //    VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+            //    VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
+
+            //    // generate direction vector in the range [-0.25f...+0.25f] 
+            //    // that's slow enough so you can see particles 'disappear' when they are respawned
+            //    tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    ParticleAttributes[i].Direction = tmp; // copy 
+            //    ParticleAttributes[i].Age = 0;
+
+            //    xPos = xPos + 0.0231f;
+            //    yPos = yPos + 0.0253f;
+            //}
+
+            //VisibleParticleCount = 0;
+            #endregion
 
@@ -182,3 +208,2 @@ namespace AWGL.Scene
 
-        //private void
         #endregion
@@ -199,8 +224,4 @@ namespace AWGL.Scene
             GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
         }
@@ -220,24 +241,27 @@ namespace AWGL.Scene
 
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (VisibleParticleCount < MaxParticleCount)
-                VisibleParticleCount++;
+            #region Particles
+            //// will update particles here. When using a Physics SDK, it's update rate is much higher than
+            //// the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            //if (VisibleParticleCount < MaxParticleCount)
+            //    VisibleParticleCount++;
+
+            //Vector3 temp;
+
+            //for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
+            //{
+            //    if (ParticleAttributes[i].Age >= MaxParticleCount)
+            //    {
+            //        // reset particle
+            //        ParticleAttributes[i].Age = 0;
+            //        VBO[i].Position = Vector3.Zero;
+            //    }
+            //    else
+            //    {
+            //        ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
+            //        Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
+            //        Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
+            //    }
+            //}
+            #endregion
 
-            Vector3 temp;
-
-            for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
-            {
-                if (ParticleAttributes[i].Age >= MaxParticleCount)
-                {
-                    // reset particle
-                    ParticleAttributes[i].Age = 0;
-                    VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
-                    Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
-                }
-            }
         }
@@ -261,15 +285,32 @@ namespace AWGL.Scene
 
-            GL.PushMatrix();
+            #region Particles
+            //GL.PushMatrix();
+
+            //GL.Translate(0f, 0f, -5f);
+
+            //// Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            //// without this, GL would wait until draw operations on old VBO are complete before writing to it
+            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            //// Fill newly allocated buffer
+            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
+            //// Only draw particles that are alive
+            //GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+
+            //GL.PopMatrix();
+            #endregion
+
+            #region Textures
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            GL.Translate(0f, 0f, -5f);
+            GL.Begin(BeginMode.Quads);
 
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
 
-            GL.PopMatrix();
+            GL.End();
+            #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7a38e0262b0c7d4c7340a52ba1c8e09f28c38f65">3D Glasses effect (old school red and blue)</a>  -  7a38e02</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 150 insertions(+), 32 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index e2e7646..225dadc 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -26,3 +26,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.Off;
+            this.VSync = VSyncMode.On;
         }   
@@ -95,3 +95,3 @@ namespace AWGL.Scene
 
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");//("Data/Textures/logo.jpg");
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
         private int texture;
@@ -100,2 +100,4 @@ namespace AWGL.Scene
 
+        private MengerSponge sponge;
+
         #region Keyboard_KeyDown
@@ -135,25 +137,33 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.DepthTest);
 
-            //// Set our point parameters
-            //GL.PointSize(5f);
-            //GL.Enable(EnableCap.PointSprite);
+            #region 3D Glasses Effect
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
 
+            sponge= new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true);
 
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            #endregion
 
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
+            #region Texture
+            //// Set our point parameters
+            //GL.PointSize(5f);
+            //GL.Enable(EnableCap.PointSprite);
 
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            
+            //GL.GenTextures(1, out texture);
+            //GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            //BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+            //    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
 
-            bitmap.UnlockBits(data);
+            //GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+            //    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
 
+            //bitmap.UnlockBits(data);
+            #endregion
             // set up vbo state - depreceted as of 3.0>> (?)
@@ -221,7 +231,3 @@ namespace AWGL.Scene
 
-            GL.Viewport(0, 0, Width, Height);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+            GL.Viewport(ClientRectangle);
         }
@@ -239,3 +245,3 @@ namespace AWGL.Scene
         {
-            //base.OnUpdateFrame(e);
+            base.OnUpdateFrame(e);
 
@@ -266,4 +272,100 @@ namespace AWGL.Scene
 
+            #region 3D Lighting Effect
+            
+            #endregion
+        }
+
+        #endregion
+
+        #region 3D Lighting Effect
+        struct Camera
+        {
+            public Vector3 Position, Direction, Up;
+            public double NearPlane, FarPlane;
+            public double EyeSeparation;
+            public double Aperture; // FOV in degrees
+            public double FocalLength;
+        }
+
+        enum Eye
+        {
+            left,
+            right,
+        }
+
+        void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+
         }
 
+        float Angle;
+
+        void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            sponge.Draw();
+        }
         #endregion
@@ -280,2 +382,3 @@ namespace AWGL.Scene
             //base.OnRenderFrame(e);
+            Angle += (float)(e.Time * 20.0);
 
@@ -302,14 +405,27 @@ namespace AWGL.Scene
             #region Textures
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //GL.LoadIdentity();
+            //GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            //GL.Begin(BeginMode.Quads);
+
+            //GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            //GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            //GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            //GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            //GL.End();
+            #endregion
 
-            GL.Begin(BeginMode.Quads);
+            #region 3D Lighting Effect
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
 
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
 
-            GL.End();
+            GL.ColorMask(true, true, true, true);
             #endregion
@@ -325,3 +441,5 @@ namespace AWGL.Scene
         {
-            GL.DeleteBuffers(1, ref VBOHandle);
+            base.OnUnload(e);
+            //GL.DeleteBuffers(1, ref VBOHandle);
+            sponge.Dispose();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c38fb47d4bcb2bcc242d490df3839cca85f3fd5d">Torus</a>  -  c38fb47</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 225dadc..169c1e2 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -26,3 +26,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.On;
+            this.VSync = VSyncMode.Off;
         }   
@@ -100,3 +100,3 @@ namespace AWGL.Scene
 
-        private MengerSponge sponge;
+        private TorusKnot obj;
 
@@ -143,3 +143,3 @@ namespace AWGL.Scene
 
-            sponge= new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true);
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
 
@@ -368,3 +368,3 @@ namespace AWGL.Scene
             GL.Rotate(Angle, Vector3.UnitY);
-            sponge.Draw();
+            obj.Draw();
         }
@@ -443,3 +443,3 @@ namespace AWGL.Scene
             //GL.DeleteBuffers(1, ref VBOHandle);
-            sponge.Dispose();
+            obj.Dispose();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/03cf089ec55f6c00e4167a6763804f64314edd6a">Stereo Vision</a>  -  03cf089</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 189 insertions(+), 360 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index d4f61a0..31cc877 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,5 +19,5 @@ namespace AWGL
         {
-            using (Display mainDisplay = new Display())
+            using (VBOCube particles = new VBOCube())
             {
-                mainDisplay.Run(30.0);
+                particles.Run(30.0);
             }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 169c1e2..9572a51 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -2,3 +2,2 @@
 using AWGL.Tutorial;
-using ObjLoader.Loader.Loaders;
 using OpenTK;
@@ -26,77 +25,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.Off;
-        }   
-
-        #region Private Fields
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private struct Vbo { public int VboID, EboID, NumElements; }
-        private Vbo[] vbo = new Vbo[2];
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-
-        #endregion  
-
-        #region Particles
-
-        protected static int MaxParticleCount = 2000;
-        private int VisibleParticleCount;
-        private VertexC4ubV3f[] VBO = new VertexC4ubV3f[MaxParticleCount];
-        private ParticleAttribut[] ParticleAttributes = new ParticleAttribut[MaxParticleCount];
-
-        // this struct is used for drawing
-        struct VertexC4ubV3f
-        {
-            public byte R, G, B, A;
-            public Vector3 Position;
-
-            public static int SizeInBytes = 16;
-        }
-
-        // this struct is used for updates
-        struct ParticleAttribut
-        {
-            public Vector3 Direction;
-            public uint Age;
-
-            //  more stuff could be here: Rotation, Radius, whatever
-        }
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-
-        #endregion Particles
-
-        #region Textures
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        private TorusKnot obj;
+        }       
 
@@ -109,3 +34,3 @@ namespace AWGL.Scene
         /// <param name="e">The key that was pressed.</param>
-        void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
         {
@@ -137,81 +62,3 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.DepthTest);
-
-            #region 3D Glasses Effect
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-
-            #endregion
-
-            #region Texture
-            //// Set our point parameters
-            //GL.PointSize(5f);
-            //GL.Enable(EnableCap.PointSprite);
-
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
             
-            //GL.GenTextures(1, out texture);
-            //GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            //BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-            //    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            //GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-            //    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            //bitmap.UnlockBits(data);
-            #endregion
-            // set up vbo state - depreceted as of 3.0>> (?)
-            #region particles
-            //GL.EnableClientState(ArrayCap.ColorArray);
-            //GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            //GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            //GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            //GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            //Random rndNum = new Random();
-            //Vector3 tmp = new Vector3();
-
-            //// generate some random stuff for the particle system
-            //for (uint i = 0; i < MaxParticleCount; i++)
-            //{
-            //    if (xPos >= 4.0f)
-            //    {
-            //        xPos = -4.0f;
-            //    }
-            //    if (yPos >= 4.0f)
-            //    {
-            //        yPos = -4.0f;
-            //    }
-            //    VBO[i].R = (byte)rndNum.Next(0, 256);
-            //    VBO[i].G = (byte)rndNum.Next(0, 256);
-            //    VBO[i].B = (byte)rndNum.Next(0, 256);
-            //    VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-            //    VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
-
-            //    // generate direction vector in the range [-0.25f...+0.25f] 
-            //    // that's slow enough so you can see particles 'disappear' when they are respawned
-            //    tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    ParticleAttributes[i].Direction = tmp; // copy 
-            //    ParticleAttributes[i].Age = 0;
-
-            //    xPos = xPos + 0.0231f;
-            //    yPos = yPos + 0.0253f;
-            //}
-
-            //VisibleParticleCount = 0;
-            #endregion
-
         }
@@ -246,31 +93,2 @@ namespace AWGL.Scene
             base.OnUpdateFrame(e);
-
-            #region Particles
-            //// will update particles here. When using a Physics SDK, it's update rate is much higher than
-            //// the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            //if (VisibleParticleCount < MaxParticleCount)
-            //    VisibleParticleCount++;
-
-            //Vector3 temp;
-
-            //for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
-            //{
-            //    if (ParticleAttributes[i].Age >= MaxParticleCount)
-            //    {
-            //        // reset particle
-            //        ParticleAttributes[i].Age = 0;
-            //        VBO[i].Position = Vector3.Zero;
-            //    }
-            //    else
-            //    {
-            //        ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
-            //        Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
-            //        Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
-            //    }
-            //}
-            #endregion
-
-            #region 3D Lighting Effect
-            
-            #endregion
         }
@@ -279,95 +97,2 @@ namespace AWGL.Scene
 
-        #region 3D Lighting Effect
-        struct Camera
-        {
-            public Vector3 Position, Direction, Up;
-            public double NearPlane, FarPlane;
-            public double EyeSeparation;
-            public double Aperture; // FOV in degrees
-            public double FocalLength;
-        }
-
-        enum Eye
-        {
-            left,
-            right,
-        }
-
-        void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-
-        }
-
-        float Angle;
-
-        void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-
         #region OnRenderFrame
@@ -381,54 +106,3 @@ namespace AWGL.Scene
         {
-            //base.OnRenderFrame(e);
-            Angle += (float)(e.Time * 20.0);
-
-            this.Title = "AWGL: High level OpenTK wrapper - " + VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            #region Particles
-            //GL.PushMatrix();
-
-            //GL.Translate(0f, 0f, -5f);
-
-            //// Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            //// without this, GL would wait until draw operations on old VBO are complete before writing to it
-            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            //// Fill newly allocated buffer
-            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
-            //// Only draw particles that are alive
-            //GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
-
-            //GL.PopMatrix();
-            #endregion
-
-            #region Textures
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //GL.LoadIdentity();
-            //GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            //GL.Begin(BeginMode.Quads);
-
-            //GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            //GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            //GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            //GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            //GL.End();
-            #endregion
-
-            #region 3D Lighting Effect
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-            #endregion
-
-            SwapBuffers();
+            base.OnRenderFrame(e);
         }
@@ -442,4 +116,2 @@ namespace AWGL.Scene
             base.OnUnload(e);
-            //GL.DeleteBuffers(1, ref VBOHandle);
-            obj.Dispose();
         }
@@ -497,3 +169,3 @@ namespace AWGL.Scene
 
-        Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
+        protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
         {
@@ -531,28 +203,2 @@ namespace AWGL.Scene
 
-        #region Draw(Vbo handle)
-
-        void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-
-
     }
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
new file mode 100644
index 0000000..3e0276e
--- /dev/null
+++ b/AWGL/Scene/StereoVision.cs
@@ -0,0 +1,183 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVision : DefaultScene
+    {
+        public StereoVision()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(ClientRectangle);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            //base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            Angle += (float)(e.Time * 20.0);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    }
+
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/57f2055936bb0d8425d3b05966d411d5979b3b43">Separated VBO Cube</a>  -  57f2055</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 130 insertions(+)

diff --git a/AWGL/Scene/VBOCube.cs b/AWGL/Scene/VBOCube.cs
new file mode 100644
index 0000000..09da741
--- /dev/null
+++ b/AWGL/Scene/VBOCube.cs
@@ -0,0 +1,130 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+
+namespace AWGL.Scene
+{
+    public class VBOCube : DefaultScene
+    {
+        #region Private Members
+        
+        private Vbo[] vbo = new Vbo[2];
+
+        private const float rotation_speed = 180.0f;
+        private float angle;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+
+            Draw(vbo[0]);
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region Draw(Vbo handle)
+
+        private void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+
+        #endregion
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5d2eda142c1739dd3dec61fcd10edff784ae849e">Tweaks</a>  -  5d2eda1</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 9572a51..18037c8 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -68,3 +68,2 @@ namespace AWGL.Scene
         #region OnResize
-
         /// <summary>
@@ -77,6 +76,3 @@ namespace AWGL.Scene
             base.OnResize(e);
-
-            GL.Viewport(ClientRectangle);
         }
-
         #endregion
@@ -107,2 +103,4 @@ namespace AWGL.Scene
             base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
         }
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
index 3e0276e..9844b96 100644
--- a/AWGL/Scene/StereoVision.cs
+++ b/AWGL/Scene/StereoVision.cs
@@ -61,4 +61,2 @@ namespace AWGL.Scene
 
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
             Angle += (float)(e.Time * 20.0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1a712d9e138ebaa02dc741bc5a9730f64165fa64">Successfully extracted examples into their own classes.</a>  -  1a712d9</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 11 files changed, 632 insertions(+), 350 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 31cc877..ec667aa 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,3 +19,3 @@ namespace AWGL
         {
-            using (VBOCube particles = new VBOCube())
+            using (Texture2DScene particles = new Texture2DScene())
             {
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
new file mode 100644
index 0000000..af7ef4d
--- /dev/null
+++ b/AWGL/Data.cs
@@ -0,0 +1,26 @@
+﻿using OpenTK;
+namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, EboID, NumElements;
+    }
+    
+    // this struct is used for drawing
+    public struct VertexC4ubV3f
+    {
+        public byte R, G, B, A;
+        public Vector3 Position;
+
+        public static int SizeInBytes = 16;
+    }
+
+    // this struct is used for updates
+    public struct ParticleAttribut
+    {
+        public Vector3 Direction;
+        public uint Age;
+
+        //  more stuff could be here: Rotation, Radius, whatever
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 18037c8..610829a 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -61,4 +61,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(.1f, 0f, .1f, 0f);
-            
+            GL.ClearColor(.1f, 0f, .1f, 0f);         
         }
@@ -76,2 +75,4 @@ namespace AWGL.Scene
             base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
         }
@@ -93,18 +94,2 @@ namespace AWGL.Scene
 
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-        }
-
-        #endregion
-
         #region OnUnload
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
deleted file mode 100644
index e2d7ff5..0000000
--- a/AWGL/Scene/Display.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL.Scene
-{
-    public class Display : DefaultScene
-    {
-
-    }
-}
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
new file mode 100644
index 0000000..d46e66e
--- /dev/null
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -0,0 +1,179 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class DynamicVBOScene : DefaultScene
+    {
+        public DynamicVBOScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        private int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+        #endregion
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+        }
+
+        #region OnUpdateFrame
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)e.Time, out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            this.Title = "AWGL: High level OpenTK wrapper - " + m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+
+            GL.Translate(0f, 0f, -5f);
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(BeginMode.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteBuffers(1, ref VBOHandle);
+        }
+
+        #endregion        
+    }
+
+    
+
+}
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
new file mode 100644
index 0000000..e93d3ed
--- /dev/null
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -0,0 +1,132 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+
+namespace AWGL.Scene
+{
+    public class StaticVBOScene : DefaultScene
+    {
+        #region Private Members
+        
+        private Vbo[] vbo = new Vbo[2];
+
+        private const float rotation_speed = 180.0f;
+        private float angle;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+
+            Draw(vbo[0]);
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region Draw(Vbo handle)
+
+        private void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+
+        #endregion
+    }
+}
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
deleted file mode 100644
index 9844b96..0000000
--- a/AWGL/Scene/StereoVision.cs
+++ /dev/null
@@ -1,181 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVision : DefaultScene
-    {
-        public StereoVision()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-        #endregion
-
-        #region OnResize
-
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(ClientRectangle);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            //base.OnRenderFrame(e);
-
-            Angle += (float)(e.Time * 20.0);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    }
-
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
new file mode 100644
index 0000000..3ab21de
--- /dev/null
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -0,0 +1,179 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVisionScene : DefaultScene
+    {
+        public StereoVisionScene()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            Angle += (float)(e.Time * 20.0);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    }
+
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
new file mode 100644
index 0000000..8944273
--- /dev/null
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -0,0 +1,112 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class Texture2DScene : DefaultScene
+    {
+
+        #region Private Members
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.Texture2D);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+        }
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref texture);
+        }
+
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.Begin(BeginMode.Quads);
+
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            GL.End();
+
+            SwapBuffers();
+        }
+        #endregion
+    }
+}
diff --git a/AWGL/Scene/VBOCube.cs b/AWGL/Scene/VBOCube.cs
deleted file mode 100644
index 09da741..0000000
--- a/AWGL/Scene/VBOCube.cs
+++ /dev/null
@@ -1,130 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-
-namespace AWGL.Scene
-{
-    public class VBOCube : DefaultScene
-    {
-        #region Private Members
-        
-        private Vbo[] vbo = new Vbo[2];
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
-        }
-        #endregion
-
-        #region OnResize
-
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            Draw(vbo[0]);
-
-            SwapBuffers();
-        }
-        #endregion
-
-        #region Draw(Vbo handle)
-
-        private void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-    }
-}
diff --git a/AWGL/VBO.cs b/AWGL/VBO.cs
deleted file mode 100644
index 0dd834c..0000000
--- a/AWGL/VBO.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, EboID, NumElements;
-    }
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a8f0f93697a6059586658782926d45b48315e18b">Added shaders. Added new scenes.</a>  -  a8f0f93</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 22 files changed, 883 insertions(+), 65 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index ec667aa..15604b8 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,5 +19,52 @@ namespace AWGL
         {
-            using (Texture2DScene particles = new Texture2DScene())
+            Int32 Selection;
+
+            Console.WriteLine("Please select a scene to load:");
+            Console.WriteLine("");
+            Console.WriteLine("1. Static VBO");
+            Console.WriteLine("2. Dynamic VBO");
+            Console.WriteLine("3. Texture 2D");
+            Console.WriteLine("4. Anaylgraph Stereo");
+            Console.WriteLine("5. FBO");
+            Console.WriteLine("6. Picker");
+            Int32.TryParse(Console.ReadLine(), out Selection);
+
+            switch (Selection)
             {
-                particles.Run(30.0);
+                case 1:
+                    using (StaticVBOScene scene = new StaticVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 2:
+                    using (DynamicVBOScene scene = new DynamicVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 3:
+                    using (Texture2DScene scene = new Texture2DScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 4:
+                    using (StereoVisionScene scene = new StereoVisionScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 5:
+                    using (FBOScene scene = new FBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 6:
+                    using (PickerScene scene = new PickerScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
@@ -25,3 +72,2 @@ namespace AWGL
 
-        
     }
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index af7ef4d..ee0651e 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -1,2 +1,3 @@
 ﻿using OpenTK;
+using System;
 namespace AWGL
@@ -7,3 +8,4 @@ namespace AWGL
     }
-    
+
+    #region Particles
     // this struct is used for drawing
@@ -25,2 +27,38 @@ namespace AWGL
     }
+    #endregion
+
+    #region Picker
+    public struct Byte4
+    {
+        public byte R, G, B, A;
+
+        public Byte4(byte[] input)
+        {
+            R = input[0];
+            G = input[1];
+            B = input[2];
+            A = input[3];
+        }
+
+        public uint ToUInt32()
+        {
+            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
+            return BitConverter.ToUInt32(temp, 0);
+        }
+
+        public override string ToString()
+        {
+            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
+        }
+    }
+
+    struct Vertex
+    {
+        public Byte4 Color; // 4 bytes
+        public Vector3 Position; // 12 bytes
+
+        public const byte SizeInBytes = 16;
+    }
+    #endregion
+
 }
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_FS.glsl b/AWGL/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/AWGL/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_VS.glsl b/AWGL/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/AWGL/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/FS.glsl b/AWGL/Data/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/AWGL/Data/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_VS.glsl b/AWGL/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_FS.glsl b/AWGL/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/AWGL/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_VS.glsl b/AWGL/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/AWGL/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_FS.glsl b/AWGL/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/AWGL/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_VS.glsl b/AWGL/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/AWGL/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_FS.glsl b/AWGL/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/AWGL/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_VS.glsl b/AWGL/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/AWGL/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/VS.glsl b/AWGL/Data/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/AWGL/Data/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 610829a..6f7134d 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -28,3 +28,2 @@ namespace AWGL.Scene
         #region Keyboard_KeyDown
-
         /// <summary>
@@ -45,3 +44,2 @@ namespace AWGL.Scene
         }
-
         #endregion
@@ -49,3 +47,2 @@ namespace AWGL.Scene
         #region OnLoad
-
         /// <summary>
@@ -79,25 +76,2 @@ namespace AWGL.Scene
         #endregion
-        
-        #region OnUpdateFrame
-
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-        }
-
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-
-        #endregion
 
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
new file mode 100644
index 0000000..000fb1d
--- /dev/null
+++ b/AWGL/Scene/FBOScene.cs
@@ -0,0 +1,260 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Input;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class FBOScene : DefaultScene
+    {
+        #region Private Member Variables
+        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
+
+        private uint ColorTexture;
+        private uint DepthTexture;
+        private uint FBOHandle;
+
+        private const int TextureSize = 512;
+
+        private DrawableShape Object;
+        #endregion
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
+            {
+                throw new NotSupportedException(
+                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
+                Exit();
+            }
+
+            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearDepth(1.0);
+            GL.DepthFunc(DepthFunction.Lequal);
+
+            GL.Enable(EnableCap.CullFace);
+
+            // Create Color Tex
+            GL.GenTextures(1, out ColorTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create Depth Tex
+            GL.GenTextures(1, out DepthTexture);
+            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
+            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create a FBO and attach the textures
+            GL.Ext.GenFramebuffers(1, out FBOHandle);
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
+
+            #region Test for Error
+
+            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
+            {
+                case FramebufferErrorCode.FramebufferCompleteExt:
+                    {
+                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: There are no attachments.");
+                        break;
+                    }
+                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
+                     {
+                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
+                         break;
+                     }*/
+                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
+                    {
+                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
+                    {
+                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
+                    {
+                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
+                    {
+                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferUnsupportedExt:
+                    {
+                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
+                        break;
+                    }
+                default:
+                    {
+                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
+                        break;
+                    }
+            }
+
+            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
+            int[] queryinfo = new int[6];
+            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
+            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
+            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
+            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
+            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
+            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
+            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
+                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
+
+            Console.WriteLine("Last GL Error: " + GL.GetError());
+
+            #endregion Test for Error
+
+            GL.PushAttrib(AttribMask.ViewportBit);
+            {
+                GL.Viewport(0, 0, TextureSize, TextureSize);
+
+                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
+                GL.ClearColor(1f, 0f, 0f, 0f);
+                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
+                GL.MatrixMode(MatrixMode.Projection);
+                GL.LoadMatrix(ref perspective);
+
+                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
+                GL.MatrixMode(MatrixMode.Modelview);
+                GL.LoadMatrix(ref lookat);
+
+                // draw some complex object into the FBO's textures
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.Light0);
+                GL.Enable(EnableCap.ColorMaterial);
+                GL.Color3(0f, 1f, 0f);
+                Object.Draw();
+                GL.Disable(EnableCap.ColorMaterial);
+                GL.Disable(EnableCap.Light0);
+                GL.Disable(EnableCap.Lighting);
+
+            }
+            GL.PopAttrib();
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
+
+            GL.ClearColor(.1f, .2f, .3f, 0f);
+            GL.Color3(1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
+            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            double aspect_ratio = Width / (double)Height;
+
+            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            base.OnResize(e);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+
+    }
+}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
new file mode 100644
index 0000000..7065a96
--- /dev/null
+++ b/AWGL/Scene/PickerScene.cs
@@ -0,0 +1,261 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
+using AWGL.Shapes;
+using System.Drawing;
+using System.IO;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
+    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
+    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
+    /// </summary>
+    public class PickerScene : DefaultScene
+    {
+        public PickerScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Member variable
+        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
+        private float angle;
+        private BeginMode VBO_PrimMode;
+        private Vertex[] VBO_Array;
+        uint VBO_Handle;
+
+        private uint SelectedTriangle;
+
+        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
+        #endregion
+
+        #region OnLoad
+        /// <summary>Load resources here.</summary>
+        /// <param name="e">Not used.</param>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.CullFace);
+
+            #region prepare data for VBO from procedural object
+            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
+            VertexT2fN3fV3f[] temp_VBO;
+            uint[] temp_IBO;
+            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
+            temp_obj.Dispose();
+            if (temp_IBO != null)
+                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
+
+            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
+            VBO_Array = new Vertex[temp_VBO.Length];
+            int TriangleCounter = -1;
+            for (int i = 0; i < temp_VBO.Length; i++)
+            {
+                // Position
+                VBO_Array[i].Position = temp_VBO[i].Position;
+
+                // Index
+                if (i % 3 == 0)
+                    TriangleCounter++;
+                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
+            }
+            #endregion prepare data for VBO from procedural object
+
+            #region Setup VBO for drawing
+            GL.GenBuffers(1, out VBO_Handle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
+            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
+            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
+            #endregion Setup VBO for drawing
+
+            #region Shader
+            
+            // Load&Compile Vertex Shader
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_VS.glsl"))
+            {
+                VertexShaderObject = GL.CreateShader(ShaderType.VertexShader);
+                GL.ShaderSource(VertexShaderObject, sr.ReadToEnd());
+                GL.CompileShader(VertexShaderObject);
+            }
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Vertex Shader: " + err);
+
+            string LogInfo;
+            GL.GetShaderInfoLog(VertexShaderObject, out LogInfo);
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+                Trace.WriteLine("Vertex Shader failed!\nLog:\n" + LogInfo);
+            else
+                Trace.WriteLine("Vertex Shader compiled without complaint.");
+
+            // Load&Compile Fragment Shader
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_FS.glsl"))
+            {
+                FragmentShaderObject = GL.CreateShader(ShaderType.FragmentShader);
+                GL.ShaderSource(FragmentShaderObject, sr.ReadToEnd());
+                GL.CompileShader(FragmentShaderObject);
+            }
+            GL.GetShaderInfoLog(FragmentShaderObject, out LogInfo);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Fragment Shader: " + err);
+
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+                Trace.WriteLine("Fragment Shader failed!\nLog:\n" + LogInfo);
+            else
+                Trace.WriteLine("Fragment Shader compiled without complaint.");
+
+            // Link the Shaders to a usable Program
+            ProgramObject = GL.CreateProgram();
+            GL.AttachShader(ProgramObject, VertexShaderObject);
+            GL.AttachShader(ProgramObject, FragmentShaderObject);
+
+            // link it all together
+            GL.LinkProgram(ProgramObject);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("LinkProgram: " + err);
+
+            GL.UseProgram(ProgramObject);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("UseProgram: " + err);
+
+            // flag ShaderObjects for delete when not used anymore
+            GL.DeleteShader(VertexShaderObject);
+            GL.DeleteShader(FragmentShaderObject);
+
+            int temp;
+            GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);
+            Trace.WriteLine("Linking Program (" + ProgramObject + ") " + ((temp == 1) ? "succeeded." : "FAILED!"));
+            if (temp != 1)
+            {
+                GL.GetProgramInfoLog(ProgramObject, out LogInfo);
+                Trace.WriteLine("Program Log:\n" + LogInfo);
+            }
+
+            Trace.WriteLine("End of Shader build. GL Error: " + GL.GetError());
+
+            GL.UseProgram(0);
+
+            #endregion Shader
+
+        }
+        #endregion
+
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DeleteBuffers(1, ref VBO_Handle);
+
+            base.OnUnload(e);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Called when your window is resized. Set your viewport here. It is also
+        /// a good place to set up your projection matrix (which probably changes
+        /// along when the aspect ratio of your window).
+        /// </summary>
+        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref projection);
+        }
+        #endregion
+
+        #region OnRenderFrae
+        /// <summary>
+        /// Called when it is time to render the next frame. Add your rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Color3(Color.White);
+            GL.EnableClientState(EnableCap.ColorArray);
+
+            #region Pass 1: Draw Object and pick Triangle
+            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref modelview);
+            GL.Translate(0f, 0f, -3f);
+            GL.Rotate(angle, Vector3.UnitX);
+            GL.Rotate(angle, Vector3.UnitY);
+            angle += (float)e.Time * 3.0f;
+
+            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
+             GL.UseProgram(ProgramObject);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            // GL.UseProgram(0);
+
+            // Read Pixel under mouse cursor
+            Byte4 Pixel = new Byte4();
+            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
+            SelectedTriangle = Pixel.ToUInt32();
+            #endregion Pass 1: Draw Object and pick Triangle
+
+            GL.Color3(Color.White);
+            GL.DisableClientState(EnableCap.ColorArray);
+
+            #region Pass 2: Draw Shape
+            if (SelectedTriangle == uint.MaxValue)
+                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
+            else
+                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.Color3(1f, 1f, 1f);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+            GL.Color3(Color.Red);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+
+            if (SelectedTriangle != uint.MaxValue)
+            {
+                GL.Disable(EnableCap.DepthTest);
+                GL.Color3(Color.Green);
+                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
+                GL.Enable(EnableCap.DepthTest);
+            }
+            #endregion Pass 2: Draw Shape
+
+            this.SwapBuffers();
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Error at Swapbuffers: " + err);
+        }
+        #endregion
+    }
+}
diff --git a/AWGL/Shaders/FS.glsl b/AWGL/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/AWGL/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_FS.glsl b/AWGL/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/AWGL/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_VS.glsl b/AWGL/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/AWGL/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/VS.glsl b/AWGL/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/AWGL/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5fe72f4b9e451e21020f4e7c3035ecbaab740f06">Added shader to picker example and refactored code to use LoadShader helper function.</a>  -  5fe72f4</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 61 insertions(+), 72 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 6f7134d..b6efb3d 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -8,2 +8,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Drawing;
@@ -25,22 +26,5 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-        }       
-
-        #region Keyboard_KeyDown
-        /// <summary>
-        /// Occurs when a key is pressed.
-        /// </summary>
-        /// <param name="sender">The KeyboardDevice which generated this event.</param>
-        /// <param name="e">The key that was pressed.</param>
-        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                this.Exit();
-
-            if (e.Key == Key.F11)
-                if (this.WindowState == WindowState.Fullscreen)
-                    this.WindowState = WindowState.Normal;
-                else
-                    this.WindowState = WindowState.Fullscreen;
         }
-        #endregion
+
+        protected ErrorCode err;
 
@@ -60,3 +44,2 @@ namespace AWGL.Scene
         }
-
         #endregion
@@ -71,4 +54,2 @@ namespace AWGL.Scene
         {
-            base.OnResize(e);
-
             GL.Viewport(0, 0, Width, Height);
@@ -77,4 +58,3 @@ namespace AWGL.Scene
 
-        #region GetOpenGLVersion
-
+        #region TestOpenGLVersion
         /// <summary>
@@ -98,7 +78,5 @@ namespace AWGL.Scene
         }
-
         #endregion
 
-        #region LoadShader
-
+        #region LoadShader(String filename, ShaderType type, int program, out int address)
         /// <summary>
@@ -110,12 +88,38 @@ namespace AWGL.Scene
         /// <param name="address">Shader Pointer</param>
-        private void LoadShader(String filename, ShaderType type, int program, out int address)
+        protected void LoadShader(String filename, ShaderType type, int program, out int address)
         {
             address = GL.CreateShader(type);
-            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            string sType = "";
+
+            switch (type)
+            {
+                case ShaderType.VertexShader:
+                    sType = "Vertex ";
+                    break;
+                case ShaderType.FragmentShader:
+                    sType = "Fragment ";
+                    break;
+            }
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/" + filename))
             {
                 GL.ShaderSource(address, sr.ReadToEnd());
+                GL.CompileShader(address);
+            }
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine(sType + "Shader: " + err);
+
+            string LogInfo;
+            GL.GetShaderInfoLog(address, out LogInfo);
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+            {
+                Trace.WriteLine(sType + "Shader failed!\nLog:\n" + LogInfo);
+            }
+            else
+            {
+                Trace.WriteLine(sType + "Shader compiled without complaint.");
+                GL.AttachShader(program, address);
             }
-            GL.CompileShader(address);
-            GL.AttachShader(program, address);
-            Console.WriteLine(GL.GetShaderInfoLog(address));
         }
@@ -125,3 +129,2 @@ namespace AWGL.Scene
         #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
-
         protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
@@ -160,2 +163,21 @@ namespace AWGL.Scene
 
+        #region Keyboard_KeyDown
+        /// <summary>
+        /// Occurs when a key is pressed.
+        /// </summary>
+        /// <param name="sender">The KeyboardDevice which generated this event.</param>
+        /// <param name="e">The key that was pressed.</param>
+        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                this.Exit();
+
+            if (e.Key == Key.F11)
+                if (this.WindowState == WindowState.Fullscreen)
+                    this.WindowState = WindowState.Normal;
+                else
+                    this.WindowState = WindowState.Fullscreen;
+        }
+        #endregion
+
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 7065a96..1cacd88 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -85,46 +85,12 @@ namespace AWGL.Scene
             #region Shader
-            
-            // Load&Compile Vertex Shader
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_VS.glsl"))
-            {
-                VertexShaderObject = GL.CreateShader(ShaderType.VertexShader);
-                GL.ShaderSource(VertexShaderObject, sr.ReadToEnd());
-                GL.CompileShader(VertexShaderObject);
-            }
 
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Vertex Shader: " + err);
+            ProgramObject = GL.CreateProgram();
 
-            string LogInfo;
-            GL.GetShaderInfoLog(VertexShaderObject, out LogInfo);
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-                Trace.WriteLine("Vertex Shader failed!\nLog:\n" + LogInfo);
-            else
-                Trace.WriteLine("Vertex Shader compiled without complaint.");
+            // Load&Compile Vertex Shader
+            LoadShader("Picking_VS.glsl", ShaderType.VertexShader, ProgramObject, out VertexShaderObject);
 
             // Load&Compile Fragment Shader
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_FS.glsl"))
-            {
-                FragmentShaderObject = GL.CreateShader(ShaderType.FragmentShader);
-                GL.ShaderSource(FragmentShaderObject, sr.ReadToEnd());
-                GL.CompileShader(FragmentShaderObject);
-            }
-            GL.GetShaderInfoLog(FragmentShaderObject, out LogInfo);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Fragment Shader: " + err);
-
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-                Trace.WriteLine("Fragment Shader failed!\nLog:\n" + LogInfo);
-            else
-                Trace.WriteLine("Fragment Shader compiled without complaint.");
-
+            LoadShader("Picking_FS.glsl", ShaderType.FragmentShader, ProgramObject, out FragmentShaderObject);
+            
             // Link the Shaders to a usable Program
-            ProgramObject = GL.CreateProgram();
-            GL.AttachShader(ProgramObject, VertexShaderObject);
-            GL.AttachShader(ProgramObject, FragmentShaderObject);
 
@@ -148,2 +114,3 @@ namespace AWGL.Scene
             int temp;
+            string LogInfo;
             GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3a17726dd6db63ed8bf7ec29df5a9fc2d8939fed">This sample demonstrates the use of the stencil buffer for rendering constructive solid geometry (or CSG in short).</a>  -  3a17726</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 304 insertions(+)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 15604b8..b838149 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -29,2 +29,3 @@ namespace AWGL
             Console.WriteLine("6. Picker");
+            Console.WriteLine("7. Stencil CSG");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -69,2 +70,8 @@ namespace AWGL
                     break;
+                case 7:
+                    using (StencilCSGScene scene = new StencilCSGScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
new file mode 100644
index 0000000..a17e666
--- /dev/null
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -0,0 +1,297 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Input;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class StencilCSGScene : DefaultScene
+    {
+        #region Model Related
+        private DrawableShape OperandB;
+        private DrawableShape OperandA;
+        private float MySphereZOffset = 0f;
+        private float MySphereXOffset = 0f;
+
+        private int Texture;
+        #endregion Model Related
+
+        private bool ShowDebugWireFrame = true;
+
+        private float CameraZoom;
+        private float CameraRotX;
+        private float CameraRotY;
+        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
+
+        #region Window
+        public StencilCSGScene()
+        {
+            base.VSync = VSyncMode.Off;
+            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
+            {
+                switch (e.Key)
+                {
+                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
+                }
+            };
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
+            GL.LoadMatrix(ref p);
+        }
+        #endregion Window
+
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            #region Abort on platforms which will not be able to execute the ops properly
+            /*
+            if (!GL.SupportsExtension("VERSION_1_2"))
+            {
+                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
+                this.Exit();
+            }
+
+            int[] t = new int[2];
+            GL.GetInteger(GetPName.MajorVersion, out t[0]);
+            GL.GetInteger(GetPName.MinorVersion, out t[1]);
+            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
+
+            GL.GetInteger(GetPName.DepthBits, out t[0]);
+            Trace.WriteLine("Depth Bits: " + t[0]);
+            GL.GetInteger(GetPName.StencilBits, out t[1]);
+            Trace.WriteLine("Stencil Bits: " + t[1]);
+
+            if (t[0] < 16)
+            {
+                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
+                this.Exit();
+            }
+
+            if (t[1] < 1)
+            {
+                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
+                this.Exit();
+            }
+            */
+            #endregion Abort on platforms which will not be able to execute the ops properly
+
+            #region GL States
+            GL.ClearColor(.08f, .12f, .16f, 1f);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Less);
+            GL.ClearDepth(1.0);
+
+            GL.Enable(EnableCap.StencilTest);
+            GL.ClearStencil(0);
+            GL.StencilMask(0xFFFFFFFF); // read&write
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+            GL.CullFace(CullFaceMode.Back);
+
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+
+            GL.Color4(1f, 1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.ShadeModel(ShadingModel.Smooth);
+
+            #endregion GL States
+
+            #region Load Texture
+            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
+            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
+
+            GL.GenTextures(1, out Texture);
+            GL.BindTexture(TextureTarget.Texture2D, Texture);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.Finish();
+            bitmap.UnlockBits(data);
+            #endregion Load Texture
+
+            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
+            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
+                                           SlicedSphere.eSubdivisions.Three,
+                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
+                                           true);
+
+            #region Invert Operand B's Normals
+            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
+            BeginMode tempPrimMode;
+            VertexT2dN3dV3d[] tempVertices;
+            uint[] tempIndices;
+
+            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
+            OperandB.Dispose();
+
+            for (int i = 0; i < tempVertices.Length; i++)
+            {
+                tempVertices[i].Normal *= -1.0;
+                tempVertices[i].Normal.Normalize();
+            }
+
+            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
+            #endregion Invert Operand B's Normals
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref Texture);
+
+            OperandA.Dispose();
+            OperandB.Dispose();
+
+            base.OnUnload(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Magic numbers for camera
+            CameraRotX = -Mouse.X * .5f;
+            CameraRotY = Mouse.Y * .5f;
+            CameraZoom = Mouse.Wheel * .2f;
+            #endregion Magic numbers for camera
+        }
+
+        public void DrawOperandB()
+        {
+            GL.PushMatrix();
+            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
+            OperandB.Draw();
+            GL.PopMatrix();
+        }
+
+        public void DrawOperandA()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            OperandA.Draw();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        public void RenderCsg()
+        {
+            // first pass
+            GL.Disable(EnableCap.StencilTest);
+
+            GL.ColorMask(false, false, false, false);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB();// draw front-faces into depth buffer
+
+            // use stencil plane to find parts of b in a 
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // increment the stencil where the front face of a is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
+            DrawOperandB(); // draw the part of b that's in a
+
+            // fix depth
+            GL.ColorMask(false, false, false, false);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Disable(EnableCap.StencilTest);
+            GL.DepthFunc(DepthFunction.Always);
+            DrawOperandA();
+            GL.DepthFunc(DepthFunction.Less);
+
+            // second pass
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA();
+
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            DrawOperandB(); // increment the stencil where the front face of b is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Equal, 0, 1);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // draw the part of a that's in b
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
+
+            MySphereZOffset += (float)(e.Time * 3.1);
+            MySphereXOffset += (float)(e.Time * 4.2);
+
+            #region Transform setup
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
+
+            // Camera
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+
+            GL.Translate(0f, 0f, CameraZoom);
+            GL.Rotate(CameraRotX, Vector3.UnitY);
+            GL.Rotate(CameraRotY, Vector3.UnitX);
+            #endregion Transform setup
+
+            RenderCsg();
+
+            // ---------------------------------
+
+            if (ShowDebugWireFrame)
+            {
+                GL.Color3(System.Drawing.Color.LightGray);
+                GL.Disable(EnableCap.StencilTest);
+                GL.Disable(EnableCap.Lighting);
+                //GL.Disable( EnableCap.DepthTest );
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+                DrawOperandB();
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+                GL.Enable(EnableCap.DepthTest);
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.StencilTest);
+            }
+            SwapBuffers();
+        }
+
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/640930ac41f404de7636a8d608862168d59bba9d">~</a>  -  640930a</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 9 files changed, 38 insertions(+), 8 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index b838149..76e99e2 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -14,9 +14,25 @@ namespace AWGL
 {
-    public static class AWGL 
+    public sealed class OGL
     {
+        private static OGL instance = new OGL();
+
+        private OGL()
+        {
+        }
+
+        public static OGL getInstance()
+        {
+            return instance;
+        }
+
+        public static void SetupScene()
+        {
+            Run();
+        }
+
         [STAThread]
-        public static void Main(string[] args)
+        public static void Run()
         {
             Int32 Selection;
-
+            
             Console.WriteLine("Please select a scene to load:");
@@ -78,3 +94,3 @@ namespace AWGL
         }
-
+        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index b6efb3d..7770253 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -38,3 +38,9 @@ namespace AWGL.Scene
 
-            TestOpenGLVersion();
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            //TestOpenGLVersion();
 
@@ -182,2 +188,7 @@ namespace AWGL.Scene
 
+        public new void Run()
+        {
+            base.Run();
+        }
+
     }
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index d46e66e..3ed70c9 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -174,2 +174,3 @@ namespace AWGL.Scene
         #endregion        
+    
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 1cacd88..1262556 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -6,3 +6,2 @@ using System.Text;
 using System.Threading.Tasks;
-using OpenTK;
 using OpenTK.Graphics.OpenGL;
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index e93d3ed..8b6f074 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -130,2 +130,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index a17e666..17bc239 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -294,3 +294,2 @@ namespace AWGL.Scene
 
-
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 3ab21de..880a930 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -160,2 +160,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 8944273..756c596 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -110,2 +110,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index 595ae6e..2cceac7 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -13,2 +13,3 @@ namespace TestApplication
     {
+
         [STAThread]
@@ -16,3 +17,3 @@ namespace TestApplication
         {
-            AWGL.AWGL.Main(args);
+            OGL.Run();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d91942a78e3a0f610719d6555dd0a5170d559b45">OGL Singleton partially implemented</a>  -  d91942a</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 99 insertions(+), 98 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
deleted file mode 100644
index 76e99e2..0000000
--- a/AWGL/AWGL.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.IO;
-using System.Linq;
-
-using AWGL.Scene;
-
-namespace AWGL
-{
-    public sealed class OGL
-    {
-        private static OGL instance = new OGL();
-
-        private OGL()
-        {
-        }
-
-        public static OGL getInstance()
-        {
-            return instance;
-        }
-
-        public static void SetupScene()
-        {
-            Run();
-        }
-
-        [STAThread]
-        public static void Run()
-        {
-            Int32 Selection;
-            
-            Console.WriteLine("Please select a scene to load:");
-            Console.WriteLine("");
-            Console.WriteLine("1. Static VBO");
-            Console.WriteLine("2. Dynamic VBO");
-            Console.WriteLine("3. Texture 2D");
-            Console.WriteLine("4. Anaylgraph Stereo");
-            Console.WriteLine("5. FBO");
-            Console.WriteLine("6. Picker");
-            Console.WriteLine("7. Stencil CSG");
-            Int32.TryParse(Console.ReadLine(), out Selection);
-
-            switch (Selection)
-            {
-                case 1:
-                    using (StaticVBOScene scene = new StaticVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 2:
-                    using (DynamicVBOScene scene = new DynamicVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
-                    using (Texture2DScene scene = new Texture2DScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 4:
-                    using (StereoVisionScene scene = new StereoVisionScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 5:
-                    using (FBOScene scene = new FBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 6:
-                    using (PickerScene scene = new PickerScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 7:
-                    using (StencilCSGScene scene = new StencilCSGScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-            }
-        }
-        
-    }
-}
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
new file mode 100644
index 0000000..d4af983
--- /dev/null
+++ b/AWGL/OGL.cs
@@ -0,0 +1,96 @@
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+using AWGL.Scene;
+
+namespace AWGL
+{
+    public sealed class OGL
+    {
+        private static OGL instance = new OGL();
+
+        private OGL()
+        {
+        }
+
+        public static OGL getInstance()
+        {
+            return instance;
+        }
+
+        public static void SetupScene(Color backgroundColor)
+        {
+        }
+
+        [STAThread]
+        public static void Run()
+        {
+            Int32 Selection;
+            
+            Console.WriteLine("Please select a scene to load:");
+            Console.WriteLine("");
+            Console.WriteLine("1. Static VBO");
+            Console.WriteLine("2. Dynamic VBO");
+            Console.WriteLine("3. Texture 2D");
+            Console.WriteLine("4. Anaylgraph Stereo");
+            Console.WriteLine("5. FBO");
+            Console.WriteLine("6. Picker");
+            Console.WriteLine("7. Stencil CSG");
+            Int32.TryParse(Console.ReadLine(), out Selection);
+
+            switch (Selection)
+            {
+                case 1:
+                    using (StaticVBOScene scene = new StaticVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 2:
+                    using (DynamicVBOScene scene = new DynamicVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 3:
+                    using (Texture2DScene scene = new Texture2DScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 4:
+                    using (StereoVisionScene scene = new StereoVisionScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 5:
+                    using (FBOScene scene = new FBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 6:
+                    using (PickerScene scene = new PickerScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 7:
+                    using (StencilCSGScene scene = new StencilCSGScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+            }
+        }
+        
+    }
+}
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7770253..ebfcebe 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -28,2 +28,4 @@ namespace AWGL.Scene
 
+        private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
+
         protected ErrorCode err;
@@ -48,3 +50,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(.1f, 0f, .1f, 0f);         
+            GL.ClearColor(m_backgroundColor);         
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bc530808eb1083fc578f5feff34edecb7632e798">Trying to hide OpenTK methods behind friendlier names</a>  -  bc53080</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 8 files changed, 130 insertions(+), 67 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index ebfcebe..7e613f4 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -50,4 +50,9 @@ namespace AWGL.Scene
 
-            GL.ClearColor(m_backgroundColor);         
+            GL.ClearColor(m_backgroundColor);
+
+            Setup(e);
         }
+
+        protected abstract void Setup(EventArgs e);
+
         #endregion
@@ -63,3 +68,8 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
+
+            Resize(e);
         }
+
+        protected abstract void Resize(EventArgs e);
+
         #endregion
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 3ed70c9..91eb923 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -175,2 +175,12 @@ namespace AWGL.Scene
     
+    
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index 000fb1d..4c82565 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -29,6 +29,63 @@ namespace AWGL.Scene
 
-        protected override void OnLoad(EventArgs e)
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
         {
-            base.OnLoad(e);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
 
+            SwapBuffers();
+        }
+
+
+        protected override void Setup(EventArgs e)
+        {
             if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
@@ -183,21 +240,4 @@ namespace AWGL.Scene
 
-        protected override void OnUnload(EventArgs e)
+        protected override void Resize(EventArgs e)
         {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-
             double aspect_ratio = Width / (double)Height;
@@ -211,49 +251,3 @@ namespace AWGL.Scene
             GL.LoadMatrix(ref lookat);
-
-            base.OnResize(e);
         }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 1262556..de2ddab 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -225,2 +225,12 @@ namespace AWGL.Scene
         #endregion
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 8b6f074..f9971fa 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -131,2 +131,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 17bc239..36984f6 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -294,2 +294,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 880a930..dfd8a27 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -161,2 +161,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 756c596..9bfbf4a 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -111,2 +111,11 @@ namespace AWGL.Scene
 
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/dfa83a4a29ab95c6abfd9e263bf8eb1c21c1e8fc">Added Utility Class</a>  -  dfa83a4</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 9 files changed, 261 insertions(+), 266 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7e613f4..5e637ec 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -29,5 +29,3 @@ namespace AWGL.Scene
         private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-
-        protected ErrorCode err;
-
+        
         #region OnLoad
@@ -46,3 +44,3 @@ namespace AWGL.Scene
             Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            //TestOpenGLVersion();
+            TestOpenGLVersion();
 
@@ -54,5 +52,2 @@ namespace AWGL.Scene
         }
-
-        protected abstract void Setup(EventArgs e);
-
         #endregion
@@ -68,3 +63,2 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
-
             Resize(e);
@@ -72,6 +66,8 @@ namespace AWGL.Scene
 
-        protected abstract void Resize(EventArgs e);
-
         #endregion
 
+        new public abstract void Setup(EventArgs e);
+
+        new public abstract void Resize(EventArgs e);
+
         #region TestOpenGLVersion
@@ -98,86 +94,3 @@ namespace AWGL.Scene
 
-        #region LoadShader(String filename, ShaderType type, int program, out int address)
-        /// <summary>
-        /// Helper Funtion for loading shaders
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <param name="program">Program ID to add Shader too</param>
-        /// <param name="address">Shader Pointer</param>
-        protected void LoadShader(String filename, ShaderType type, int program, out int address)
-        {
-            address = GL.CreateShader(type);
-            string sType = "";
-
-            switch (type)
-            {
-                case ShaderType.VertexShader:
-                    sType = "Vertex ";
-                    break;
-                case ShaderType.FragmentShader:
-                    sType = "Fragment ";
-                    break;
-            }
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/" + filename))
-            {
-                GL.ShaderSource(address, sr.ReadToEnd());
-                GL.CompileShader(address);
-            }
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine(sType + "Shader: " + err);
-
-            string LogInfo;
-            GL.GetShaderInfoLog(address, out LogInfo);
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-            {
-                Trace.WriteLine(sType + "Shader failed!\nLog:\n" + LogInfo);
-            }
-            else
-            {
-                Trace.WriteLine(sType + "Shader compiled without complaint.");
-                GL.AttachShader(program, address);
-            }
-        }
-
-        #endregion
-
-        #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
-        protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
-        {
-            Vbo handle = new Vbo();
-            int size;
-
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-
-            GL.GenBuffers(1, out handle.VboID);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(vertices.Length * BlittableValueType.StrideOf(vertices)), vertices,
-                          BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (vertices.Length * BlittableValueType.StrideOf(vertices) != size)
-                throw new ApplicationException("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out handle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(elements.Length * sizeof(short)), elements,
-                          BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (elements.Length * sizeof(short) != size)
-                throw new ApplicationException("Element data not uploaded correctly");
-
-            handle.NumElements = elements.Length;
-            return handle;
-        }
-
-        #endregion
-
-        #region Keyboard_KeyDown
+        #region Input
         /// <summary>
@@ -200,8 +113,3 @@ namespace AWGL.Scene
 
-        public new void Run()
-        {
-            base.Run();
-        }
-
     }
-}
+}
\ No newline at end of file
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 91eb923..3ae9627 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -32,67 +32,2 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-        #endregion
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-        }
-
         #region OnUpdateFrame
@@ -174,17 +109,62 @@ namespace AWGL.Scene
         #endregion        
-    
-    
-        protected override void Setup(EventArgs e)
+
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            GL.Enable(EnableCap.DepthTest);
+
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
-        }
-    }
 
-    
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
 
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+        }
+    
+    
+    } 
 }
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index 4c82565..efe295d 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -87,4 +87,3 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
@@ -240,3 +239,3 @@ namespace AWGL.Scene
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index de2ddab..a7c9ce6 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -9,2 +9,3 @@ using System.Diagnostics;
 using AWGL.Shapes;
+using AWGL;
 using System.Drawing;
@@ -85,24 +86,8 @@ namespace AWGL.Scene
 
-            ProgramObject = GL.CreateProgram();
+            //create and compile shaders
+            VertexShaderObject = Utils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = Utils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
 
-            // Load&Compile Vertex Shader
-            LoadShader("Picking_VS.glsl", ShaderType.VertexShader, ProgramObject, out VertexShaderObject);
-
-            // Load&Compile Fragment Shader
-            LoadShader("Picking_FS.glsl", ShaderType.FragmentShader, ProgramObject, out FragmentShaderObject);
-            
-            // Link the Shaders to a usable Program
-
-            // link it all together
-            GL.LinkProgram(ProgramObject);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("LinkProgram: " + err);
-
-            GL.UseProgram(ProgramObject);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("UseProgram: " + err);
+            //create program object, attach shaders and link
+            ProgramObject = Utils.BuildProgram(VertexShaderObject, FragmentShaderObject);
 
@@ -112,14 +97,2 @@ namespace AWGL.Scene
 
-            int temp;
-            string LogInfo;
-            GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);
-            Trace.WriteLine("Linking Program (" + ProgramObject + ") " + ((temp == 1) ? "succeeded." : "FAILED!"));
-            if (temp != 1)
-            {
-                GL.GetProgramInfoLog(ProgramObject, out LogInfo);
-                Trace.WriteLine("Program Log:\n" + LogInfo);
-            }
-
-            Trace.WriteLine("End of Shader build. GL Error: " + GL.GetError());
-
             GL.UseProgram(0);
@@ -158,3 +131,3 @@ namespace AWGL.Scene
 
-        #region OnRenderFrae
+        #region OnRenderFrame
         /// <summary>
@@ -226,10 +199,10 @@ namespace AWGL.Scene
 
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index f9971fa..ad2361b 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -19,3 +19,3 @@ namespace AWGL.Scene
         
-        private Vbo[] vbo = new Vbo[2];
+        private Vbo vbo = new Vbo();
 
@@ -47,28 +47,11 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.Enable(EnableCap.DepthTest);
 
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+            vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
         }
-        #endregion
-
-        #region OnResize
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            base.OnResize(e);
-
             float aspect_ratio = Width / (float)Height;
@@ -79,4 +62,2 @@ namespace AWGL.Scene
 
-        #endregion
-
         #region OnRenderFrame
@@ -100,3 +81,3 @@ namespace AWGL.Scene
 
-            Draw(vbo[0]);
+            Draw(vbo);
 
@@ -130,13 +111,2 @@ namespace AWGL.Scene
         #endregion
-
-
-        protected override void Setup(EventArgs e)
-        {
-            throw new NotImplementedException();
-        }
-
-        protected override void Resize(EventArgs e)
-        {
-            throw new NotImplementedException();
-        }
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 36984f6..b4abc6b 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -55,3 +55,2 @@ namespace AWGL.Scene
 
-
         protected override void OnLoad(EventArgs e)
@@ -294,11 +293,10 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index dfd8a27..28629f9 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -161,14 +161,13 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
+    
     }
-
     #region StereoVison Structs
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 9bfbf4a..7e5f167 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -111,10 +111,10 @@ namespace AWGL.Scene
 
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
new file mode 100644
index 0000000..b42e2aa
--- /dev/null
+++ b/AWGL/Utils.cs
@@ -0,0 +1,168 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Utility functions
+    /// </summary>
+    public class Utils
+    {
+        /// <summary>
+        /// Helper Funtion for loading shaders. Returns Shader Source from file.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <returns>Shader Source Code</returns>
+        public static string LoadShader(String filename)
+        {
+            string dataPath = "Data/Shaders/";
+            string shaderSource;
+
+            using (StreamReader sr = new StreamReader(dataPath + filename))
+            {
+                shaderSource = sr.ReadToEnd();
+            }
+
+            return shaderSource;
+        }     
+        
+        /// <summary>
+        /// Load the shader file, creates an OpenGL shader object, compiles the 
+        /// source code and returns the handle to the internal shader object. 
+        /// If the compilation fails, the application will exit.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <returns>Shader Handle</returns>
+        public static int BuildShader(string filename, ShaderType shaderType)
+        {
+            string shaderSource = LoadShader(filename);
+
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, shaderSource);
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// Creates a program object, attaches the shaders, links them and 
+        /// returns the OpenGL handle of the program.
+        /// </summary>
+        /// <param name="vertexShaderId">Shader Handle</param>
+        /// <param name="fragmentShaderId">Shader Handle</param>
+        /// <returns>Shader Program Handle</returns>
+        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
+        {
+            int programHandle = GL.CreateProgram();
+            GL.AttachShader(programHandle, vertexShaderId);
+            GL.AttachShader(programHandle, fragmentShaderId);
+            GL.LinkProgram(programHandle);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+
+            return programHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <typeparam name="TVertex"></typeparam>
+        /// <param name="vertices"></param>
+        /// <param name="elements"></param>
+        /// <param name="elementSize"></param>
+        /// <param name="typeSize"></param>
+        /// <param name="bufferUsageTypeGL"></param>
+        /// <returns></returns>
+        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements, 
+                                           int elementSize, 
+                                           int typeSize, 
+                                           BufferUsageHint bufferUsageTypeGL) 
+            where TVertex : struct
+        {
+            Vbo vboHandle = new Vbo();
+
+            vboHandle.NumElements = elements.Length;
+
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+
+            #region
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
+            #endregion
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != vbo_Size)
+                throw new Exception("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != ebo_Size)
+                throw new Exception("Element data not uploaded correctly");
+
+            return vboHandle;
+        }
+    
+    
+    }
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d09826c871a64744e28c418ab3ff615a1bff5d94">jiggled some stuff around</a>  -  d09826c</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 17 insertions(+), 76 deletions(-)

diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index b4abc6b..5236b05 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -55,6 +55,4 @@ namespace AWGL.Scene
 
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             #region Abort on platforms which will not be able to execute the ops properly
@@ -156,2 +154,7 @@ namespace AWGL.Scene
 
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
         protected override void OnUnload(EventArgs e)
@@ -293,11 +296,2 @@ namespace AWGL.Scene
 
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 28629f9..2b84210 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -19,10 +19,4 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.Enable(EnableCap.DepthTest);
@@ -34,17 +28,8 @@ namespace AWGL.Scene
         }
-        #endregion
-
-        #region OnResize
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        protected override void OnResize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            base.OnResize(e);
+            //throw new NotImplementedException();
         }
 
-        #endregion
-
         #region OnRenderFrame
@@ -160,12 +145,2 @@ namespace AWGL.Scene
         #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 7e5f167..2db8d57 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -18,3 +18,2 @@ namespace AWGL.Scene
     {
-
         #region Private Members
@@ -26,10 +25,4 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.PointSize(5f);
@@ -53,27 +46,15 @@ namespace AWGL.Scene
         }
-        #endregion
-
-        #region OnUnload
 
-        protected override void OnUnload(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            GL.DeleteTextures(1, ref texture);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
         }
 
-        #endregion
-
-        #region OnResize
+        #region OnUnload
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
+        protected override void OnUnload(EventArgs e)
         {
-            base.OnResize(e);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+            GL.DeleteTextures(1, ref texture);
         }
@@ -111,11 +92,2 @@ namespace AWGL.Scene
 
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/951c5a1a8b288b5c805be06611f3870ec92bc278">Sorted all usings</a>  -  951c5a1</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 28 files changed, 23 insertions(+), 126 deletions(-)

diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index ee0651e..4ebbf45 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -2,2 +2,3 @@
 using System;
+
 namespace AWGL
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index d4af983..6f74820 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -1,12 +1,4 @@
-﻿using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
+﻿using AWGL.Scene;
 using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.IO;
-using System.Linq;
-
-using AWGL.Scene;
 
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 5e637ec..fb7b696 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -1,4 +1,2 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
+﻿using OpenTK;
 using OpenTK.Graphics;
@@ -7,8 +5,2 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
 
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 3ae9627..5bc302e 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -1,11 +1,4 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics;
+﻿using OpenTK;
 using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index efe295d..ee33056 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -2,12 +2,5 @@
 using OpenTK;
-using OpenTK.Input;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-
 using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index a7c9ce6..fa67844 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -1,13 +1,7 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿using AWGL.Shapes;
+using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using System;
 using System.Diagnostics;
-using AWGL.Shapes;
-using AWGL;
 using System.Drawing;
-using System.IO;
 
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index ad2361b..7361dc9 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -1,13 +1,6 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿using AWGL.Tutorial;
 using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
+using System;
+using System.Drawing;
 
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 5236b05..8acb843 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -2,10 +2,5 @@
 using OpenTK;
-using OpenTK.Input;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.Drawing;
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 2db8d57..ec53ee7 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -1,14 +1,6 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics;
+﻿using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
 using System;
-using System.Collections.Generic;
 using System.Drawing;
 using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index 019722b..908685b 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -6,7 +6,5 @@
 
-using System;
-
 using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using System.Drawing;
+using System;
 
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index 670eb9f..7988a3f 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -1,3 +1 @@
-using System;
-
 using OpenTK;
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
index 60abd5b..be7248a 100644
--- a/AWGL/Shapes/Capsule.cs
+++ b/AWGL/Shapes/Capsule.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Collections.Generic;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
index da8df0a..e72266a 100644
--- a/AWGL/Shapes/ChamferCube.cs
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Collections.Generic;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
index 40e7ebd..1d029c9 100644
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -1,4 +1,2 @@
-using System;
 using System.Collections.Generic;
-using System.Text;
 
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
index cc08332..96d04a5 100644
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -1 +1,2 @@
+using OpenTK;
 using System;
@@ -3,4 +4,2 @@ using System.Collections.Generic;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
index 65f7f0b..b6dd18e 100644
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -1,3 +1 @@
-using System;
-
 using OpenTK;
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
index c791eb8..935452e 100644
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -1,5 +1 @@
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
index 1334082..b83ee64 100644
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -1,3 +1,2 @@
 using System;
-using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
index f81c6ad..a7821e3 100644
--- a/AWGL/Shapes/MengerSponge.cs
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -1 +1,2 @@
+using OpenTK;
 using System;
@@ -3,4 +4,2 @@ using System.Collections.Generic;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index fd8e0c0..d9fb493 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -6,11 +6,4 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Drawing;
-
-using System.Runtime.InteropServices;
-
 using OpenTK;
-using AWGL;
+using System.Drawing;
 
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
index f10a171..dea9734 100644
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -6,7 +6,4 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using OpenTK;
+using System;
 
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
index e151ed1..18ba007 100644
--- a/AWGL/Shapes/Old/Shape.cs
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -6,8 +6,3 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 
-using System.Runtime.InteropServices;
-using System.Drawing;
 
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
index da9a161..4d7db8e 100644
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Diagnostics;
-
 using OpenTK;
+using System;
 
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
index 4d7a536..3718073 100644
--- a/AWGL/Shapes/SlicedHose.cs
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -1,3 +1 @@
-using System;
-using System.Collections.Generic;
 using OpenTK;
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
index 772629e..0562c49 100644
--- a/AWGL/Shapes/SlicedSphere.cs
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -1,6 +1,3 @@
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
index ff7ec7d..e8953f0 100644
--- a/AWGL/Shapes/TorusKnot.cs
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -1,6 +1,4 @@
-﻿using System;
+﻿using OpenTK;
 using System.Diagnostics;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
index 4643452..e194506 100644
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -27,5 +27,5 @@
 
+using OpenTK;
 using System.Drawing;
 using System.Runtime.InteropServices;
-using OpenTK;
 
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
index b42e2aa..c8a14ea 100644
--- a/AWGL/Utils.cs
+++ b/AWGL/Utils.cs
@@ -3,8 +3,3 @@ using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/064a885dd2bc9cdea12d12677101dbae3c691a2b">Text Renderer Class</a>  -  064a885</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 172 insertions(+)

diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 7361dc9..6b60cf9 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -10,2 +10,7 @@ namespace AWGL.Scene
     {
+        TextRenderer renderer;
+        Font serif = new Font(FontFamily.GenericSerif, 24);
+        Font sans = new Font(FontFamily.GenericSansSerif, 24);
+        Font mono = new Font(FontFamily.GenericMonospace, 24);
+
         #region Private Members
@@ -45,2 +50,13 @@ namespace AWGL.Scene
             vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+
+            renderer = new TextRenderer(Width, Height);
+            PointF position = PointF.Empty;
+
+            renderer.Clear(Color.MidnightBlue);
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", serif, Brushes.White, position);
+            position.Y += serif.Height;
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", sans, Brushes.White, position);
+            position.Y += sans.Height;
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", mono, Brushes.White, position);
+            position.Y += mono.Height;
         }
@@ -77,2 +93,3 @@ namespace AWGL.Scene
             SwapBuffers();
+
         }
diff --git a/AWGL/TextRenderer.cs b/AWGL/TextRenderer.cs
new file mode 100644
index 0000000..cc94917
--- /dev/null
+++ b/AWGL/TextRenderer.cs
@@ -0,0 +1,155 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using System.Drawing;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Uses System.Drawing for 2d text rendering.
+    /// </summary>
+    public class TextRenderer : IDisposable
+    {
+        Bitmap bmp;
+        Graphics gfx;
+        int texture;
+        Rectangle dirty_region;
+        bool disposed;
+
+        #region Constructors
+
+        /// <summary>
+        /// Constructs a new instance.
+        /// </summary>
+        /// <param name="width">The width of the backing store in pixels.</param>
+        /// <param name="height">The height of the backing store in pixels.</param>
+        public TextRenderer(int width, int height)
+        {
+            if (width <= 0)
+                throw new ArgumentOutOfRangeException("width");
+            if (height <= 0)
+                throw new ArgumentOutOfRangeException("height ");
+            if (GraphicsContext.CurrentContext == null)
+                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
+
+            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            gfx = Graphics.FromImage(bmp);
+            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
+
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
+                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+        }
+
+        #endregion
+
+        #region Public Members
+
+        /// <summary>
+        /// Clears the backing store to the specified color.
+        /// </summary>
+        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
+        public void Clear(Color color)
+        {
+            gfx.Clear(color);
+            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
+        }
+
+        /// <summary>
+        /// Draws the specified string to the backing store.
+        /// </summary>
+        /// <param name="text">The <see cref="System.String"/> to draw.</param>
+        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
+        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
+        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
+        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
+        public void DrawString(string text, Font font, Brush brush, PointF point)
+        {
+            gfx.DrawString(text, font, brush, point);
+
+            SizeF size = gfx.MeasureString(text, font);
+            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
+            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
+        }
+
+        /// <summary>
+        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
+        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
+        /// in order to render the drawn text on screen.
+        /// </summary>
+        public int Texture
+        {
+            get
+            {
+                UploadBitmap();
+                return texture;
+            }
+        }
+
+        #endregion
+
+        #region Private Members
+
+        // Uploads the dirty regions of the backing store to the OpenGL texture.
+        void UploadBitmap()
+        {
+            if (dirty_region != RectangleF.Empty)
+            {
+                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
+                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+                GL.BindTexture(TextureTarget.Texture2D, texture);
+                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
+                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
+                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+                bmp.UnlockBits(data);
+
+                dirty_region = Rectangle.Empty;
+            }
+        }
+
+        #endregion
+
+        #region IDisposable Members
+
+        void Dispose(bool manual)
+        {
+            if (!disposed)
+            {
+                if (manual)
+                {
+                    bmp.Dispose();
+                    gfx.Dispose();
+                    if (GraphicsContext.CurrentContext != null)
+                        GL.DeleteTexture(texture);
+                }
+
+                disposed = true;
+            }
+        }
+
+        public void Dispose()
+        {
+            Dispose(true);
+            GC.SuppressFinalize(this);
+        }
+
+        ~TextRenderer()
+        {
+            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
+        }
+
+        #endregion
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/766a9f153ec6733f9fa2fa0bbe1878459492313b">Win Forms Test</a>  -  766a9f1</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 6 files changed, 433 insertions(+)

diff --git a/WinFormTest/GameLoopForm.Designer.cs b/WinFormTest/GameLoopForm.Designer.cs
new file mode 100644
index 0000000..bd47093
--- /dev/null
+++ b/WinFormTest/GameLoopForm.Designer.cs
@@ -0,0 +1,61 @@
+﻿namespace WinFormTest
+{
+    partial class GameLoopForm
+    {
+        /// <summary>
+        /// Required designer variable.
+        /// </summary>
+        private System.ComponentModel.IContainer components = null;
+
+        /// <summary>
+        /// Clean up any resources being used.
+        /// </summary>
+        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
+        protected override void Dispose(bool disposing)
+        {
+            if (disposing && (components != null))
+            {
+                components.Dispose();
+            }
+            base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// <summary>
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// </summary>
+        private void InitializeComponent()
+        {
+            this.glControl = new OpenTK.GLControl();
+            this.SuspendLayout();
+            // 
+            // glControl
+            // 
+            this.glControl.BackColor = System.Drawing.Color.Black;
+            this.glControl.Dock = System.Windows.Forms.DockStyle.Top;
+            this.glControl.Location = new System.Drawing.Point(0, 0);
+            this.glControl.Name = "glControl";
+            this.glControl.Size = new System.Drawing.Size(717, 403);
+            this.glControl.TabIndex = 0;
+            this.glControl.VSync = false;
+            // 
+            // GameLoopForm
+            // 
+            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+            this.ClientSize = new System.Drawing.Size(717, 477);
+            this.Controls.Add(this.glControl);
+            this.Name = "GameLoopForm";
+            this.Text = "Form1";
+            this.ResumeLayout(false);
+
+        }
+
+        #endregion
+
+        private OpenTK.GLControl glControl;
+    }
+}
+
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
new file mode 100644
index 0000000..0443296
--- /dev/null
+++ b/WinFormTest/GameLoopForm.cs
@@ -0,0 +1,213 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace WinFormTest
+{
+    public partial class GameLoopForm : Form
+    {
+        static float angle = 0.0f;
+
+        #region --- Constructor ---
+
+        public GameLoopForm()
+        {
+            InitializeComponent();
+        }
+        
+        #endregion
+
+        #region OnLoad
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            glControl.KeyDown += new KeyEventHandler(glControl_KeyDown);
+            glControl.KeyUp += new KeyEventHandler(glControl_KeyUp);
+            glControl.Resize += new EventHandler(glControl_Resize);
+            glControl.Paint += new PaintEventHandler(glControl_Paint);
+
+            Text =
+                GL.GetString(StringName.Vendor) + " " +
+                GL.GetString(StringName.Renderer) + " " +
+                GL.GetString(StringName.Version);
+
+            GL.ClearColor(Color.MidnightBlue);
+            GL.Enable(EnableCap.DepthTest);
+
+            Application.Idle += Application_Idle;
+
+            // Ensure that the viewport and projection matrix are set correctly.
+            glControl_Resize(glControl, EventArgs.Empty);
+        }
+
+        void glControl_KeyUp(object sender, KeyEventArgs e)
+        {
+            if (e.KeyCode == Keys.F12)
+            {
+                GrabScreenshot().Save("screenshot.png");
+            }
+        }
+
+        #endregion
+
+        #region OnClosing
+
+        protected override void OnClosing(CancelEventArgs e)
+        {
+            Application.Idle -= Application_Idle;
+
+            base.OnClosing(e);
+        }
+
+        #endregion
+
+        #region Application_Idle event
+
+        void Application_Idle(object sender, EventArgs e)
+        {
+            while (glControl.IsIdle)
+            {
+                Render();
+            }
+        }
+
+        #endregion
+
+        #region GLControl.Resize event handler
+
+        void glControl_Resize(object sender, EventArgs e)
+        {
+            OpenTK.GLControl c = sender as OpenTK.GLControl;
+
+            if (c.ClientSize.Height == 0)
+                c.ClientSize = new System.Drawing.Size(c.ClientSize.Width, 1);
+
+            GL.Viewport(0, 0, c.ClientSize.Width, c.ClientSize.Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region GLControl.KeyDown event handler
+
+        void glControl_KeyDown(object sender, KeyEventArgs e)
+        {
+            switch (e.KeyData)
+            {
+                case Keys.Escape:
+                    this.Close();
+                    break;
+            }
+        }
+
+        #endregion
+
+        #region GLControl.Paint event handler
+
+        void glControl_Paint(object sender, PaintEventArgs e)
+        {
+            Render();
+        }
+
+        #endregion
+
+        #region private void Render()
+
+        private void Render()
+        {
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+            angle += 0.5f;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            DrawCube();
+
+            glControl.SwapBuffers();
+        }
+
+        #endregion
+
+        #region private void DrawCube()
+
+        private void DrawCube()
+        {
+            GL.Begin(BeginMode.Quads);
+
+            GL.Color3(Color.Silver);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+
+            GL.Color3(Color.Honeydew);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+
+            GL.Color3(Color.Moccasin);
+
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.IndianRed);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+
+            GL.Color3(Color.PaleVioletRed);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.ForestGreen);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+
+            GL.End();
+        }
+
+        #endregion
+
+        #region private void GrabScreenshot()
+
+        Bitmap GrabScreenshot()
+        {
+            Bitmap bmp = new Bitmap(this.ClientSize.Width, this.ClientSize.Height);
+            System.Drawing.Imaging.BitmapData data =
+            bmp.LockBits(this.ClientRectangle, System.Drawing.Imaging.ImageLockMode.WriteOnly,
+                System.Drawing.Imaging.PixelFormat.Format24bppRgb);
+            GL.ReadPixels(0, 0, this.ClientSize.Width, this.ClientSize.Height, PixelFormat.Bgr, PixelType.UnsignedByte,
+                data.Scan0);
+            bmp.UnlockBits(data);
+            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);
+            return bmp;
+        }
+
+        #endregion
+    }
+}
diff --git a/WinFormTest/Program.cs b/WinFormTest/Program.cs
new file mode 100644
index 0000000..b301879
--- /dev/null
+++ b/WinFormTest/Program.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace WinFormTest
+{
+    static class Program
+    {
+        /// <summary>
+        /// The main entry point for the application.
+        /// </summary>
+        [STAThread]
+        static void Main()
+        {
+            Application.EnableVisualStyles();
+            Application.SetCompatibleTextRenderingDefault(false);
+            Application.Run(new GameLoopForm());
+        }
+    }
+}
new file mode 100644
index 0000000..f2a9af5
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("WinFormTest")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("WinFormTest")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("59ce37cf-9660-4196-991a-0a3039839f38")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
new file mode 100644
index 0000000..8f82795
--- /dev/null
@@ -0,0 +1,71 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18052
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace WinFormTest.Properties
+{
+
+
+    /// <summary>
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// </summary>
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources
+    {
+
+        private static global::System.Resources.ResourceManager resourceMan;
+
+        private static global::System.Globalization.CultureInfo resourceCulture;
+
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
+        internal Resources()
+        {
+        }
+
+        /// <summary>
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager
+        {
+            get
+            {
+                if ((resourceMan == null))
+                {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("WinFormTest.Properties.Resources", typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+
+        /// <summary>
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture
+        {
+            get
+            {
+                return resourceCulture;
+            }
+            set
+            {
+                resourceCulture = value;
+            }
+        }
+    }
+}
new file mode 100644
index 0000000..0394d77
--- /dev/null
@@ -0,0 +1,30 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18052
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace WinFormTest.Properties
+{
+
+
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
+    {
+
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+
+        public static Settings Default
+        {
+            get
+            {
+                return defaultInstance;
+            }
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb6e824a3fe400f0c7158778ff3edcf32f3cfbfc">more setup</a>  -  bb6e824</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 100 insertions(+), 4 deletions(-)

diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index 4ebbf45..9517898 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -7,3 +7,3 @@ namespace AWGL
     {
-        public int VboID, EboID, NumElements;
+        public int VboID, CboID ,EboID;
     }
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
index 0443296..d47f2b5 100644
--- a/WinFormTest/GameLoopForm.cs
+++ b/WinFormTest/GameLoopForm.cs
@@ -11,2 +11,4 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using AWGL;
+using AWGL.Shapes;
 
@@ -17,2 +19,6 @@ namespace WinFormTest
         static float angle = 0.0f;
+        private int programObject;
+
+        private int vertex_buffer_object, color_buffer_object, element_buffer_object;
+        Shape shape = new Cube();
 
@@ -46,2 +52,16 @@ namespace WinFormTest
 
+            CreateVBO();
+
+            // create and compile shader objects
+            int vertexShader = Utils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
+            int fragmentShader = Utils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
+
+            // attach and link to main program then use
+            programObject = Utils.BuildProgram(vertexShader, fragmentShader);
+            GL.UseProgram(programObject);
+
+            // clean up
+            GL.DeleteShader(vertexShader);
+            GL.DeleteShader(fragmentShader);
+            
             Application.Idle += Application_Idle;
@@ -62,2 +82,45 @@ namespace WinFormTest
 
+        #region private void CreateVBO()
+
+        void CreateVBO()
+        {
+            int size;
+
+            GL.GenBuffers(1, out vertex_buffer_object);
+            GL.GenBuffers(1, out color_buffer_object);
+            GL.GenBuffers(1, out element_buffer_object);
+
+            // Upload the vertex buffer.
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Vertices.Length * 3 * sizeof(float)), shape.Vertices,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Vertices.Length * 3 * sizeof(Single))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Vertices.Length * 3 * sizeof(Single), size));
+
+            // Upload the color buffer.
+            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Colors.Length * sizeof(int)), shape.Colors,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Colors.Length * sizeof(int))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (colors). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Colors.Length * sizeof(int), size));
+
+            // Upload the index buffer (elements inside the vertex buffer, not color indices as per the IndexPointer function!)
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(shape.Indices.Length * sizeof(Int32)), shape.Indices,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Indices.Length * sizeof(int))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (offsets). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Indices.Length * sizeof(int), size));
+        }
+
+        #endregion
+
         #region OnClosing
@@ -66,2 +129,10 @@ namespace WinFormTest
         {
+            if (programObject != 0)
+                GL.DeleteProgram(programObject);
+            if (vboHandle.VboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.VboID);
+            if (vboHandle.CboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.CboID);
+            if (vboHandle.EboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.EboID);
             Application.Idle -= Application_Idle;
@@ -129,4 +200,11 @@ namespace WinFormTest
 
+        private Vbo vboHandle = new Vbo();
+        private float rotation_speed = 3.0f;
+
+
         private void Render()
         {
+            GL.Clear(ClearBufferMask.ColorBufferBit |
+         ClearBufferMask.DepthBufferBit);
+
             Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
@@ -135,8 +213,26 @@ namespace WinFormTest
 
+            //angle += rotation_speed * (float)Time;
             GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-            angle += 0.5f;
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.EnableClientState(ArrayCap.VertexArray);
+            GL.EnableClientState(ArrayCap.ColorArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
+            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
+
+            GL.DrawElements(BeginMode.Triangles, shape.Indices.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            //GL.DrawArrays(GL.Enums.BeginMode.POINTS, 0, shape.Vertices.Length);
+
+            GL.DisableClientState(ArrayCap.VertexArray);
+            GL.DisableClientState(ArrayCap.ColorArray);
+
 
-            DrawCube();
+            //int error = GL.GetError();
+            //if (error != 0)
+            //    Debug.Print(Glu.ErrorString(Glu.Enums.ErrorCode.INVALID_OPERATION));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e657fdc0529e8b2f4e5bd6806a690fb5ff5e5953">Added basic shader manager class</a>  -  e657fdc</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 105 insertions(+)

diff --git a/AWGL/ShaderManager.cs b/AWGL/ShaderManager.cs
new file mode 100644
index 0000000..18eb1fb
--- /dev/null
+++ b/AWGL/ShaderManager.cs
@@ -0,0 +1,105 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class ShaderManager
+    {
+        /// <summary>
+        /// Shader Pointers
+        /// </summary>
+        private int vShader, fShader, linkedProgram;
+
+        private string defaultDataPath = "Data/Shaders/";
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename">Shader Filename</param>
+        /// <returns>Shader Source Code</returns>
+        private string LoadShader(string filename) 
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+        
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename"></param>
+        /// <param name="shaderType"></param>
+        /// <returns></returns>
+        private int BuildShader(string filename, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(filename));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        private void BuildProgram() 
+        {
+            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
+            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+
+            this.linkedProgram = GL.CreateProgram();
+            GL.AttachShader(linkedProgram, vShader);
+            GL.AttachShader(linkedProgram, fShader);
+            GL.LinkProgram(linkedProgram);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(this.linkedProgram);
+            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+        }
+
+        public int getShaderProgram() 
+        {
+            BuildProgram();
+
+            return linkedProgram;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/25a1ff5c3825ea9999b838a52fdb3dc1e9b2e45f">class stubs</a>  -  25a1ff5</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 24 insertions(+)

diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
new file mode 100644
index 0000000..8f58090
--- /dev/null
+++ b/AWGL/BufferManager.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class BufferManager
+    {
+    }
+}
diff --git a/AWGL/SceneManager.cs b/AWGL/SceneManager.cs
new file mode 100644
index 0000000..f4c15d9
--- /dev/null
+++ b/AWGL/SceneManager.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class SceneManager
+    {
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cdd5cfa57dbb0493d3452cd0b91218d7376f28f4">Added basic implementation of BufferManager.cs</a>  -  cdd5cfa</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 62 insertions(+), 1 deletion(-)

diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
index 8f58090..a8efd7c 100644
--- a/AWGL/BufferManager.cs
+++ b/AWGL/BufferManager.cs
@@ -1,2 +1,4 @@
-﻿using System;
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
@@ -8,4 +10,63 @@ namespace AWGL
 {
+    /// <summary>
+    /// 
+    /// </summary>
     class BufferManager
     {
+        #region
+        // To create a VBO:
+        // 1) Generate the buffer handles for the vertex and element buffers.
+        // 2) Bind the vertex buffer handle and upload your vertex data. 
+        //    Check that the buffer was uploaded correctly.
+        // 3) Bind the element buffer handle and upload your element data. 
+        //    Check that the buffer was uploaded correctly.
+        #endregion
+
+        private Vbo vboHandle;
+
+        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements,
+                                           int elementSize,
+                                           int typeSize,
+                                           BufferUsageHint bufferUsageTypeGL)
+            where TVertex : struct
+        {
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            CheckForErrors(vbo_Size);
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            CheckForErrors(ebo_Size);
+
+            return vboHandle;
+        }
+
+        private static void CheckForErrors(int size)
+        {
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != size)
+                throw new Exception("Data not uploaded correctly");
+        }
+
+
+        public Vbo getBufferObjects()
+        {
+            return new Vbo();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a164502b6626f52f2957e7a1173638fdf158871b">Renaming Files</a>  -  a164502</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 15 files changed, 465 insertions(+), 437 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
new file mode 100644
index 0000000..3b297f7
--- /dev/null
+++ b/AWGL/AWBufferManager.cs
@@ -0,0 +1,83 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    class AWBufferManager : IDisposable
+    {
+        #region
+        // To create a VBO:
+        // 1) Generate the buffer handles for the vertex and element buffers.
+        // 2) Bind the vertex buffer handle and upload your vertex data. 
+        //    Check that the buffer was uploaded correctly.
+        // 3) Bind the element buffer handle and upload your element data. 
+        //    Check that the buffer was uploaded correctly.
+        #endregion
+
+        private Vbo vboHandle;
+
+        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements,
+                                           int elementSize,
+                                           int typeSize,
+                                           BufferUsageHint bufferUsageTypeGL)
+            where TVertex : struct
+        {
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            CheckForErrors(vbo_Size);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.EboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            CheckForErrors(ebo_Size);
+
+            return this.vboHandle;
+        }
+
+        private static void CheckForErrors(int size)
+        {
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != size)
+                throw new Exception("Data not uploaded correctly");
+        }
+
+        public Vbo getBufferObjects(DrawableShape shape)
+        {
+            return new Vbo();//GenerateVBO(
+        }
+
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
new file mode 100644
index 0000000..526fb4b
--- /dev/null
+++ b/AWGL/AWData.cs
@@ -0,0 +1,67 @@
+﻿using OpenTK;
+using System;
+
+namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, CboID ,EboID;
+
+        public int NumElements { get; set; }
+    }
+
+    #region Particles
+    // this struct is used for drawing
+    public struct VertexC4ubV3f
+    {
+        public byte R, G, B, A;
+        public Vector3 Position;
+
+        public static int SizeInBytes = 16;
+    }
+
+    // this struct is used for updates
+    public struct ParticleAttribut
+    {
+        public Vector3 Direction;
+        public uint Age;
+
+        //  more stuff could be here: Rotation, Radius, whatever
+    }
+    #endregion
+
+    #region Picker
+    public struct Byte4
+    {
+        public byte R, G, B, A;
+
+        public Byte4(byte[] input)
+        {
+            R = input[0];
+            G = input[1];
+            B = input[2];
+            A = input[3];
+        }
+
+        public uint ToUInt32()
+        {
+            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
+            return BitConverter.ToUInt32(temp, 0);
+        }
+
+        public override string ToString()
+        {
+            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
+        }
+    }
+
+    struct Vertex
+    {
+        public Byte4 Color; // 4 bytes
+        public Vector3 Position; // 12 bytes
+
+        public const byte SizeInBytes = 16;
+    }
+    #endregion
+
+}
\ No newline at end of file
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
new file mode 100644
index 0000000..a5eb49d
--- /dev/null
+++ b/AWGL/AWNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public abstract class AWNode
+    {
+
+    }
+}
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
new file mode 100644
index 0000000..1e26a65
--- /dev/null
+++ b/AWGL/AWSceneManager.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    class AWSceneManager : ISceneNode
+    {
+        private List<AWNode> graphic;
+    }
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
new file mode 100644
index 0000000..dcf64ca
--- /dev/null
+++ b/AWGL/AWShaderManager.cs
@@ -0,0 +1,117 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class AWShaderManager : IDisposable
+    {
+        /// <summary>
+        /// Shader Pointers
+        /// </summary>
+        private int vShader, fShader, linkedProgram;
+
+        private string defaultDataPath = "Data/Shaders/";
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename">Shader Filename</param>
+        /// <returns>Shader Source Code</returns>
+        private string LoadShader(string filename) 
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+        
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename"></param>
+        /// <param name="shaderType"></param>
+        /// <returns></returns>
+        private int BuildShader(string filename, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(filename));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        private void BuildProgram() 
+        {
+            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
+            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+
+            this.linkedProgram = GL.CreateProgram();
+            GL.AttachShader(linkedProgram, vShader);
+            GL.AttachShader(linkedProgram, fShader);
+            GL.LinkProgram(linkedProgram);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(this.linkedProgram);
+            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public int getShaderProgram() 
+        {
+            BuildProgram();
+
+            return linkedProgram;
+        }
+
+        public void Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
new file mode 100644
index 0000000..56b81b2
--- /dev/null
+++ b/AWGL/AWUtils.cs
@@ -0,0 +1,162 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.IO;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Utility functions
+    /// </summary>
+    public class AWUtils
+    {
+        /// <summary>
+        /// Helper Funtion for loading shaders. Returns Shader Source from file.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <returns>Shader Source Code</returns>
+        public static string LoadShader(String filename)
+        {
+            string dataPath = "Data/Shaders/";
+            string shaderSource;
+
+            using (StreamReader sr = new StreamReader(dataPath + filename))
+            {
+                shaderSource = sr.ReadToEnd();
+            }
+
+            return shaderSource;
+        }     
+        
+        /// <summary>
+        /// Load the shader file, creates an OpenGL shader object, compiles the 
+        /// source code and returns the handle to the internal shader object. 
+        /// If the compilation fails, the application will exit.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <returns>Shader Handle</returns>
+        public static int BuildShader(string filename, ShaderType shaderType)
+        {
+            string shaderSource = LoadShader(filename);
+
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, shaderSource);
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// Creates a program object, attaches the shaders, links them and 
+        /// returns the OpenGL handle of the program.
+        /// </summary>
+        /// <param name="vertexShaderId">Shader Handle</param>
+        /// <param name="fragmentShaderId">Shader Handle</param>
+        /// <returns>Shader Program Handle</returns>
+        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
+        {
+            int programHandle = GL.CreateProgram();
+            GL.AttachShader(programHandle, vertexShaderId);
+            GL.AttachShader(programHandle, fragmentShaderId);
+            GL.LinkProgram(programHandle);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+
+            return programHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <typeparam name="TVertex"></typeparam>
+        /// <param name="vertices"></param>
+        /// <param name="elements"></param>
+        /// <param name="elementSize"></param>
+        /// <param name="typeSize"></param>
+        /// <param name="bufferUsageTypeGL"></param>
+        /// <returns></returns>
+        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements, 
+                                           int elementSize, 
+                                           int typeSize, 
+                                           BufferUsageHint bufferUsageTypeGL) 
+            where TVertex : struct
+        {
+            Vbo vboHandle = new Vbo();
+
+            //vboHandle.NumElements = elements.Length;
+
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            #region
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
+            #endregion
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != vbo_Size)
+                throw new Exception("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != ebo_Size)
+                throw new Exception("Element data not uploaded correctly");
+
+            return vboHandle;
+        }
+    
+    
+    }
+}
\ No newline at end of file
diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
deleted file mode 100644
index a8efd7c..0000000
--- a/AWGL/BufferManager.cs
+++ /dev/null
@@ -1,73 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class BufferManager
-    {
-        #region
-        // To create a VBO:
-        // 1) Generate the buffer handles for the vertex and element buffers.
-        // 2) Bind the vertex buffer handle and upload your vertex data. 
-        //    Check that the buffer was uploaded correctly.
-        // 3) Bind the element buffer handle and upload your element data. 
-        //    Check that the buffer was uploaded correctly.
-        #endregion
-
-        private Vbo vboHandle;
-
-        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements,
-                                           int elementSize,
-                                           int typeSize,
-                                           BufferUsageHint bufferUsageTypeGL)
-            where TVertex : struct
-        {
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            CheckForErrors(vbo_Size);
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            CheckForErrors(ebo_Size);
-
-            return vboHandle;
-        }
-
-        private static void CheckForErrors(int size)
-        {
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != size)
-                throw new Exception("Data not uploaded correctly");
-        }
-
-
-        public Vbo getBufferObjects()
-        {
-            return new Vbo();
-        }
-    }
-}
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
deleted file mode 100644
index 9517898..0000000
--- a/AWGL/Data.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿using OpenTK;
-using System;
-
-namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, CboID ,EboID;
-    }
-
-    #region Particles
-    // this struct is used for drawing
-    public struct VertexC4ubV3f
-    {
-        public byte R, G, B, A;
-        public Vector3 Position;
-
-        public static int SizeInBytes = 16;
-    }
-
-    // this struct is used for updates
-    public struct ParticleAttribut
-    {
-        public Vector3 Direction;
-        public uint Age;
-
-        //  more stuff could be here: Rotation, Radius, whatever
-    }
-    #endregion
-
-    #region Picker
-    public struct Byte4
-    {
-        public byte R, G, B, A;
-
-        public Byte4(byte[] input)
-        {
-            R = input[0];
-            G = input[1];
-            B = input[2];
-            A = input[3];
-        }
-
-        public uint ToUInt32()
-        {
-            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
-            return BitConverter.ToUInt32(temp, 0);
-        }
-
-        public override string ToString()
-        {
-            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
-        }
-    }
-
-    struct Vertex
-    {
-        public Byte4 Color; // 4 bytes
-        public Vector3 Position; // 12 bytes
-
-        public const byte SizeInBytes = 16;
-    }
-    #endregion
-
-}
\ No newline at end of file
diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
deleted file mode 100644
index 2d62a94..0000000
--- a/AWGL/Graphic.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class Graphic
-    {
-    }
-}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index fa67844..3aca921 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -81,7 +81,7 @@ namespace AWGL.Scene
             //create and compile shaders
-            VertexShaderObject = Utils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = Utils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
+            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
 
             //create program object, attach shaders and link
-            ProgramObject = Utils.BuildProgram(VertexShaderObject, FragmentShaderObject);
+            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
 
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 6b60cf9..f162f26 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -49,3 +49,3 @@ namespace AWGL.Scene
 
-            vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
 
diff --git a/AWGL/SceneManager.cs b/AWGL/SceneManager.cs
deleted file mode 100644
index f4c15d9..0000000
--- a/AWGL/SceneManager.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class SceneManager
-    {
-    }
-}
diff --git a/AWGL/ShaderManager.cs b/AWGL/ShaderManager.cs
deleted file mode 100644
index 18eb1fb..0000000
--- a/AWGL/ShaderManager.cs
+++ /dev/null
@@ -1,105 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.IO;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    class ShaderManager
-    {
-        /// <summary>
-        /// Shader Pointers
-        /// </summary>
-        private int vShader, fShader, linkedProgram;
-
-        private string defaultDataPath = "Data/Shaders/";
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename">Shader Filename</param>
-        /// <returns>Shader Source Code</returns>
-        private string LoadShader(string filename) 
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-        
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <param name="shaderType"></param>
-        /// <returns></returns>
-        private int BuildShader(string filename, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(filename));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        private void BuildProgram() 
-        {
-            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
-            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
-
-            this.linkedProgram = GL.CreateProgram();
-            GL.AttachShader(linkedProgram, vShader);
-            GL.AttachShader(linkedProgram, fShader);
-            GL.LinkProgram(linkedProgram);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program validation failed", message);
-            }
-        }
-
-        public int getShaderProgram() 
-        {
-            BuildProgram();
-
-            return linkedProgram;
-        }
-    }
-}
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
deleted file mode 100644
index c8a14ea..0000000
--- a/AWGL/Utils.cs
+++ /dev/null
@@ -1,163 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.IO;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Utility functions
-    /// </summary>
-    public class Utils
-    {
-        /// <summary>
-        /// Helper Funtion for loading shaders. Returns Shader Source from file.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <returns>Shader Source Code</returns>
-        public static string LoadShader(String filename)
-        {
-            string dataPath = "Data/Shaders/";
-            string shaderSource;
-
-            using (StreamReader sr = new StreamReader(dataPath + filename))
-            {
-                shaderSource = sr.ReadToEnd();
-            }
-
-            return shaderSource;
-        }     
-        
-        /// <summary>
-        /// Load the shader file, creates an OpenGL shader object, compiles the 
-        /// source code and returns the handle to the internal shader object. 
-        /// If the compilation fails, the application will exit.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <returns>Shader Handle</returns>
-        public static int BuildShader(string filename, ShaderType shaderType)
-        {
-            string shaderSource = LoadShader(filename);
-
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, shaderSource);
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        /// <summary>
-        /// Creates a program object, attaches the shaders, links them and 
-        /// returns the OpenGL handle of the program.
-        /// </summary>
-        /// <param name="vertexShaderId">Shader Handle</param>
-        /// <param name="fragmentShaderId">Shader Handle</param>
-        /// <returns>Shader Program Handle</returns>
-        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
-        {
-            int programHandle = GL.CreateProgram();
-            GL.AttachShader(programHandle, vertexShaderId);
-            GL.AttachShader(programHandle, fragmentShaderId);
-            GL.LinkProgram(programHandle);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program validation failed", message);
-            }
-
-            return programHandle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <typeparam name="TVertex"></typeparam>
-        /// <param name="vertices"></param>
-        /// <param name="elements"></param>
-        /// <param name="elementSize"></param>
-        /// <param name="typeSize"></param>
-        /// <param name="bufferUsageTypeGL"></param>
-        /// <returns></returns>
-        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements, 
-                                           int elementSize, 
-                                           int typeSize, 
-                                           BufferUsageHint bufferUsageTypeGL) 
-            where TVertex : struct
-        {
-            Vbo vboHandle = new Vbo();
-
-            vboHandle.NumElements = elements.Length;
-
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-
-            #region
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-            #endregion
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != vbo_Size)
-                throw new Exception("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != ebo_Size)
-                throw new Exception("Element data not uploaded correctly");
-
-            return vboHandle;
-        }
-    
-    
-    }
-}
\ No newline at end of file
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
index d47f2b5..7a857d2 100644
--- a/WinFormTest/GameLoopForm.cs
+++ b/WinFormTest/GameLoopForm.cs
@@ -55,7 +55,7 @@ namespace WinFormTest
             // create and compile shader objects
-            int vertexShader = Utils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
-            int fragmentShader = Utils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
+            int vertexShader = AWUtils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
+            int fragmentShader = AWUtils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
 
             // attach and link to main program then use
-            programObject = Utils.BuildProgram(vertexShader, fragmentShader);
+            programObject = AWUtils.BuildProgram(vertexShader, fragmentShader);
             GL.UseProgram(programObject);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8546ab04153686d8398af7a478e63643fdb3a3d2">Initial Simple Graph</a>  -  8546ab0</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 5 files changed, 112 insertions(+), 3 deletions(-)

diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index a5eb49d..c3ab3c8 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -10,3 +10,3 @@ namespace AWGL
     {
-
+        public abstract void Render();
     }
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
new file mode 100644
index 0000000..15d803d
--- /dev/null
+++ b/AWGL/AWPolygon.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies, m_Normals, m_TexCoords;
+
+        public override void Render()
+        {
+            GL.Begin(BeginMode.Polygon);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if(i < m_Normals.Length){
+                    GL.Normal3(m_Normals[i]);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(Vector3 v) 
+        {
+            m_Verticies.SetValue(v, m_Verticies.Length + 1);
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals.SetValue(n, m_Normals.Length + 1);
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
index 1e26a65..0e969a6 100644
--- a/AWGL/AWSceneManager.cs
+++ b/AWGL/AWSceneManager.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK;
+using System;
 using System.Collections.Generic;
@@ -13,3 +14,3 @@ namespace AWGL
     {
-        private List<AWNode> graphic;
+        
     }
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 6f74820..2a5682c 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -37,2 +37,3 @@ namespace AWGL
             Console.WriteLine("7. Stencil CSG");
+            Console.WriteLine("8. Scene Graph Test");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -83,2 +84,8 @@ namespace AWGL
                     break;
+                case 8:
+                    using (SceneGraphTest scene = new SceneGraphTest())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
new file mode 100644
index 0000000..0643e86
--- /dev/null
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -0,0 +1,56 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    class SceneGraphTest : DefaultScene
+    {
+        AWNode m_sceneGraph;
+
+        public void CreateSceneGraph()
+        {
+            AWPolygon poly = new AWPolygon();
+            
+            poly.AddNormal(new Vector3(0.861411f, 0.269191f, 0.430706f));
+
+            poly.AddVertex(new Vector3(.0f, 4.0f, .0f));
+            poly.AddVertex(new Vector3(.0f, .0f, 2.5f));
+            poly.AddVertex(new Vector3(2.5f, .0f, -2.5f));
+
+            m_sceneGraph = poly;
+        }
+        public override void Setup(EventArgs e)
+        {
+            CreateSceneGraph();
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/56eecae713a477383e9cf256a916ef77412a1ddb">IEnumerater Setup</a>  -  56eecae</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 5 files changed, 88 insertions(+), 4 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
new file mode 100644
index 0000000..e5a7f50
--- /dev/null
+++ b/AWGL/AWGroupNode.cs
@@ -0,0 +1,64 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+    } 
+}
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index c3ab3c8..247ec9d 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -12,2 +12,3 @@ namespace AWGL
     }
+
 }
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
new file mode 100644
index 0000000..f45afaf
--- /dev/null
+++ b/AWGL/IGroupNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
new file mode 100644
index 0000000..29c9dc4
--- /dev/null
+++ b/AWGL/ISceneNode.cs
@@ -0,0 +1,7 @@
+﻿
+namespace AWGL
+{
+    interface ISceneNode
+    {
+    }
+}
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0643e86..a8caa1e 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -20,5 +20,5 @@ namespace AWGL.Scene
 
-            poly.AddVertex(new Vector3(.0f, 4.0f, .0f));
-            poly.AddVertex(new Vector3(.0f, .0f, 2.5f));
-            poly.AddVertex(new Vector3(2.5f, .0f, -2.5f));
+            poly.AddVertex(0, new Vector3(.0f, 4.0f, .0f));
+            poly.AddVertex(1, new Vector3(.0f, .0f, 2.5f));
+            poly.AddVertex(2, new Vector3(2.5f, .0f, -2.5f));
 
@@ -46,3 +46,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(0, 10, 10, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e257be39d1841b7d23561624ec6703677e0afc73">More work towards having a working, yet simple scene-graph using IEnumerator.</a>  -  e257be3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 4 files changed, 28 insertions(+), 10 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index e5a7f50..abfbb54 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -9,3 +9,3 @@ namespace AWGL
 {
-    class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
     {
@@ -48,2 +48,3 @@ namespace AWGL
 
+        #region IEnumerator Implementation
         public IEnumerator<ISceneNode> GetEnumerator()
@@ -57,2 +58,5 @@ namespace AWGL
         }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
 
@@ -62,2 +66,4 @@ namespace AWGL
         }
+
+        #endregion IGroupNode Implementation
     } 
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
index 15d803d..a619ff0 100644
--- a/AWGL/AWPolygon.cs
+++ b/AWGL/AWPolygon.cs
@@ -12,4 +12,10 @@ namespace AWGL
     {
-        Vector3[] m_Verticies, m_Normals, m_TexCoords;
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
 
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
         public override void Render()
@@ -19,4 +25,5 @@ namespace AWGL
             {
-                if(i < m_Normals.Length){
-                    GL.Normal3(m_Normals[i]);
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
                 }
@@ -28,5 +35,5 @@ namespace AWGL
 
-        public void AddVertex(Vector3 v) 
+        public void AddVertex(int index, Vector3 v) 
         {
-            m_Verticies.SetValue(v, m_Verticies.Length + 1);
+            m_Verticies[index] = v;
         }
@@ -35,3 +42,3 @@ namespace AWGL
         {
-            m_Normals.SetValue(n, m_Normals.Length + 1);
+            m_Normals = n;
         }
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
index f45afaf..7a8f5e7 100644
--- a/AWGL/IGroupNode.cs
+++ b/AWGL/IGroupNode.cs
@@ -7,3 +7,3 @@ namespace AWGL
 {
-    interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
     {
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index 29c9dc4..e7bd38d 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -1,6 +1,11 @@
-﻿
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
 namespace AWGL
 {
-    interface ISceneNode
+    public interface ISceneNode
     {
+        
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9d1d47e0c76cbe11ef9ebdb66019df9b976ca465">Added code to iterate through all child nodes.</a>  -  9d1d47e</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index abfbb54..fc343da 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections;
@@ -45,3 +46,14 @@ namespace AWGL
         {
-            throw new NotImplementedException();
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+            while (GetEnumerator().Current != null)
+            {
+                GetEnumerator().Current.Render();
+                GetEnumerator().MoveNext();
+            }
+            GL.PopMatrix();
         }
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
index 0e969a6..adf29da 100644
--- a/AWGL/AWSceneManager.cs
+++ b/AWGL/AWSceneManager.cs
@@ -12,5 +12,5 @@ namespace AWGL
     /// </summary>
-    class AWSceneManager : ISceneNode
+    class AWSceneManager
     {
-        
+
     }
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index e7bd38d..67bc773 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -9,3 +9,3 @@ namespace AWGL
     {
-        
+        void Render();
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9261bb7c18edc34afb9c25b410687a9d4a39d015">Fixed infinite loop while rendering children.</a>  -  9261bb7</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 42 insertions(+), 11 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index fc343da..98b4008 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -16,2 +16,3 @@ namespace AWGL
         private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
 
@@ -52,6 +53,6 @@ namespace AWGL
             }
-            while (GetEnumerator().Current != null)
+
+            foreach (ISceneNode child in m_children)
             {
-                GetEnumerator().Current.Render();
-                GetEnumerator().MoveNext();
+                child.Render();
             }
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index 247ec9d..39bef32 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -8,3 +8,3 @@ namespace AWGL
 {
-    public abstract class AWNode
+    public abstract class AWNode : ISceneNode
     {
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index a8caa1e..c87c5ee 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -16,12 +16,42 @@ namespace AWGL.Scene
         {
-            AWPolygon poly = new AWPolygon();
+
+            AWPolygon poly1 = new AWPolygon();
+            AWPolygon poly2 = new AWPolygon();
+            AWPolygon poly3 = new AWPolygon();
+            AWPolygon poly4 = new AWPolygon();
+            AWGroupNode root = new AWGroupNode();
             
-            poly.AddNormal(new Vector3(0.861411f, 0.269191f, 0.430706f));
+            Vector3 a = new Vector3(.0f, .0f, 2.5f);
+            Vector3 b = new Vector3(2.5f, .0f, -2.5f);
+            Vector3 c = new Vector3(-2.5f, .0f, 2.5f);
+            Vector3 d = new Vector3(.0f, 4.0f, .0f);
+
+            poly1.AddNormal(new Vector3(.0f, -1.0f, .0f));
+            poly1.AddVertex(0, c);
+            poly1.AddVertex(1, b);
+            poly1.AddVertex(2, c);
+
+            poly2.AddNormal(new Vector3(.861411f, .269191f, .430706f));
+            poly2.AddVertex(0, d);
+            poly2.AddVertex(1, a);
+            poly2.AddVertex(2, b);
 
-            poly.AddVertex(0, new Vector3(.0f, 4.0f, .0f));
-            poly.AddVertex(1, new Vector3(.0f, .0f, 2.5f));
-            poly.AddVertex(2, new Vector3(2.5f, .0f, -2.5f));
+            poly3.AddNormal(new Vector3(.0f, .529999f, -.847998f));
+            poly3.AddVertex(0, d);
+            poly3.AddVertex(1, b);
+            poly3.AddVertex(2, c);
 
-            m_sceneGraph = poly;
+            poly4.AddNormal(new Vector3(-.861411f, .269191f, .430706f));
+            poly4.AddVertex(0, d);
+            poly4.AddVertex(1, c);
+            poly4.AddVertex(2, a);
+
+            root.AddChild(poly1);
+            root.AddChild(poly2);
+            root.AddChild(poly3);
+            root.AddChild(poly4);
+
+            m_sceneGraph = root;
         }
+
         public override void Setup(EventArgs e)
@@ -46,3 +76,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 10, 10, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(0, 20, 20, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/508c449e7e326b8807f12aab230199f115501da3">Basic Scene-graph with hooks.</a>  -  508c449</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index c87c5ee..0aecff2 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -13,2 +13,4 @@ namespace AWGL.Scene
         AWNode m_sceneGraph;
+        AWGroupNode m_hook1;
+        AWGroupNode m_hook2;
 
@@ -21,4 +23,4 @@ namespace AWGL.Scene
             AWPolygon poly4 = new AWPolygon();
-            AWGroupNode root = new AWGroupNode();
-            
+            AWGroupNode rt = new AWGroupNode();
+
             Vector3 a = new Vector3(.0f, .0f, 2.5f);
@@ -48,8 +50,24 @@ namespace AWGL.Scene
 
-            root.AddChild(poly1);
-            root.AddChild(poly2);
-            root.AddChild(poly3);
-            root.AddChild(poly4);
+            AWGroupNode root = new AWGroupNode();
+            AWGroupNode rt1 = new AWGroupNode();
+            AWGroupNode rt2 = new AWGroupNode();
+
+            root.AddChild(rt1);
+            root.AddChild(rt2);
+
+            rt1.AddChild(rt);
+            rt2.AddChild(rt);
+
+            rt1.SetTranslation(5, 0, 0);
+            rt2.SetTranslation(-5, 0, 0);
+
+            rt.AddChild(poly1);
+            rt.AddChild(poly2);
+            rt.AddChild(poly3);
+            rt.AddChild(poly4);
 
             m_sceneGraph = root;
+
+            m_hook1 = rt1;
+            m_hook2 = rt2;
         }
@@ -80,2 +98,5 @@ namespace AWGL.Scene
 
+            m_hook1.SetRotation(20, 0, 1, 0);
+            m_hook2.SetRotation(-20, 0, 0, 1);
+
             m_sceneGraph.Render();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/33ed8b666d6cf0798ecb23ce087667cde876b4a4">Set default window mode to non-fullscreen.</a>  -  33ed8b6</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fb7b696..93eafe3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -16,3 +16,3 @@ namespace AWGL.Scene
         {
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
             Keyboard.KeyDown += Keyboard_KeyDown;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/222a78c980b4238ac1d445f5dae4ff396926ec1a">Simple Graph</a>  -  222a78c</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index 67bc773..6f6da08 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -7,3 +7,3 @@ namespace AWGL
 {
-    public interface ISceneNode
+    public interface ISceneNode 
     {
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0aecff2..56adb60 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -12,5 +12,7 @@ namespace AWGL.Scene
     {
-        AWNode m_sceneGraph;
-        AWGroupNode m_hook1;
-        AWGroupNode m_hook2;
+        private AWNode m_sceneGraph;
+        private AWGroupNode m_hook1, m_hook2;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle;
 
@@ -51,2 +53,3 @@ namespace AWGL.Scene
             AWGroupNode root = new AWGroupNode();
+            AWGraphLines graph = new AWGraphLines();
             AWGroupNode rt1 = new AWGroupNode();
@@ -54,4 +57,3 @@ namespace AWGL.Scene
 
-            root.AddChild(rt1);
-            root.AddChild(rt2);
+            root.AddChild(graph);
 
@@ -92,2 +94,4 @@ namespace AWGL.Scene
 
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
@@ -98,4 +102,4 @@ namespace AWGL.Scene
 
-            m_hook1.SetRotation(20, 0, 1, 0);
-            m_hook2.SetRotation(-20, 0, 0, 1);
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+            m_hook2.SetRotation(-m_spinangle, 0, 0, 1);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c26759c20c1ec1f74bc6a093701d240ff803365d">Added basic graphlines on the xplane.</a>  -  c26759c</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 57 insertions(+)

diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
new file mode 100644
index 0000000..9bbd5e9
--- /dev/null
+++ b/AWGL/AWGraphLines.cs
@@ -0,0 +1,39 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGraphLines : AWNode
+    {
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+
+        public override void Render()
+        {
+            GL.Color3(.3d, .3f, .3f);
+            GL.Begin(PrimitiveType.Quads);
+            GL.Vertex3(.0f, -.001f, .0f);
+            GL.Vertex3(.0f, -.001f, 10.0f);
+            GL.Vertex3(10.0f, -.001f, 10.0f);
+            GL.Vertex3(10.0f, -.001f, .0f);
+            GL.End();
+
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = 0; i <= 10; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(.25f, .25f, .25f); }
+                GL.Vertex3((float)i, .0f, .0f);
+                GL.Vertex3((float)i, .0f, 10.0f);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(.25f, .25f, .25f); }
+                GL.Vertex3(.0f, .0f, (float)i);
+                GL.Vertex3(10.0f, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/AWMesh.cs b/AWGL/AWMesh.cs
new file mode 100644
index 0000000..bd58995
--- /dev/null
+++ b/AWGL/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 56adb60..7e55758 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -58,2 +58,4 @@ namespace AWGL.Scene
             root.AddChild(graph);
+            root.AddChild(rt1);
+            root.AddChild(rt2);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e460feb0dd7dff93c2f5b6af669b9550211a410d">Very Basic Camera Control</a>  -  e460feb</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 93eafe3..7e99c9b 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -21,3 +21,9 @@ namespace AWGL.Scene
         private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-        
+
+        #region Camera
+        protected float m_eyeX = .0f;
+        protected float m_eyeY = 10.0f;
+        protected float m_eyeZ = 10.0f;
+        #endregion
+
         #region OnLoad
@@ -40,3 +46,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(m_backgroundColor);
+            GL.ClearColor(Color4.Gray);
 
@@ -102,2 +108,14 @@ namespace AWGL.Scene
                     this.WindowState = WindowState.Fullscreen;
+            if (e.Key == Key.Up)
+            {
+                m_eyeY += 2f;
+            }
+            if (e.Key == Key.Down)
+            {
+                m_eyeY -= 2f;
+            }
+            if (e.Key == Key.Right)
+                m_eyeX += 2f;
+            if (e.Key == Key.Left)
+                m_eyeX -= 2f;
         }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 7e55758..0492073 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -12,4 +12,6 @@ namespace AWGL.Scene
     {
+        #region SceneGraph
         private AWNode m_sceneGraph;
         private AWGroupNode m_hook1, m_hook2;
+        #endregion
 
@@ -100,3 +102,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 20, 20, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(m_eyeX, m_eyeY, m_eyeZ, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a1125c6010294af19c52f22f40653f893ce74d72">Simple Grid Implemented for testing purposes. Includes some controls which don't completely work just yet.</a>  -  a1125c6</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 42 insertions(+), 37 deletions(-)

diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
index 9bbd5e9..7f280ce 100644
--- a/AWGL/AWGraphLines.cs
+++ b/AWGL/AWGraphLines.cs
@@ -4,2 +4,3 @@ using System.Collections;
 using System.Collections.Generic;
+using System.Drawing;
 using System.Linq;
@@ -12,3 +13,3 @@ namespace AWGL
     {
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        private int m_gridSize = 20;
 
@@ -16,19 +17,11 @@ namespace AWGL
         {
-            GL.Color3(.3d, .3f, .3f);
-            GL.Begin(PrimitiveType.Quads);
-            GL.Vertex3(.0f, -.001f, .0f);
-            GL.Vertex3(.0f, -.001f, 10.0f);
-            GL.Vertex3(10.0f, -.001f, 10.0f);
-            GL.Vertex3(10.0f, -.001f, .0f);
-            GL.End();
-
             GL.Begin(PrimitiveType.Lines);
-            for (int i = 0; i <= 10; i++)
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
             {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(.25f, .25f, .25f); }
-                GL.Vertex3((float)i, .0f, .0f);
-                GL.Vertex3((float)i, .0f, 10.0f);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(.25f, .25f, .25f); }
-                GL.Vertex3(.0f, .0f, (float)i);
-                GL.Vertex3(10.0f, .0f, (float)i);
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
             }
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
index a619ff0..eb2ca03 100644
--- a/AWGL/AWPolygon.cs
+++ b/AWGL/AWPolygon.cs
@@ -4,2 +4,3 @@ using System;
 using System.Collections.Generic;
+using System.Drawing;
 using System.Linq;
@@ -22,3 +23,4 @@ namespace AWGL
         {
-            GL.Begin(BeginMode.Polygon);
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
             for (int i = 0; i < m_Verticies.Length; i++)
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7e99c9b..fd1d068 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -66,3 +66,3 @@ namespace AWGL.Scene
 
-        new public abstract void Setup(EventArgs e);
+        public abstract void Setup(EventArgs e);
 
@@ -100,22 +100,32 @@ namespace AWGL.Scene
         {
-            if (e.Key == Key.Escape)
-                this.Exit();
-
-            if (e.Key == Key.F11)
-                if (this.WindowState == WindowState.Fullscreen)
-                    this.WindowState = WindowState.Normal;
-                else
-                    this.WindowState = WindowState.Fullscreen;
-            if (e.Key == Key.Up)
-            {
-                m_eyeY += 2f;
-            }
-            if (e.Key == Key.Down)
+
+            switch (e.Key)
             {
-                m_eyeY -= 2f;
-            }
-            if (e.Key == Key.Right)
-                m_eyeX += 2f;
-            if (e.Key == Key.Left)
-                m_eyeX -= 2f;
+                #region Window Controls
+
+                case Key.Escape: this.Exit();
+                    break;
+                case Key.F11:
+                    if (this.WindowState == WindowState.Fullscreen)
+                        this.WindowState = WindowState.Normal;
+                    else
+                        this.WindowState = WindowState.Fullscreen;
+                    break;
+
+                #endregion
+
+                #region Camera Controls
+
+                case Key.Up: m_eyeY += 2f;
+                    break;
+                case Key.Down: m_eyeY += -2f;
+                    break;
+                case Key.Right: m_eyeX += 2f;
+                    break;
+                case Key.Left: m_eyeX += -2f;
+                    break;
+
+                #endregion
+
+            }   
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d7bd2635d6c08e2b72624dd86c42491bbf48a71e">new cube node</a>  -  d7bd263</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 71 insertions(+)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
new file mode 100644
index 0000000..fcb02d9
--- /dev/null
+++ b/AWGL/AWCube.cs
@@ -0,0 +1,71 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        private Cube Cube;
+
+        private Vbo vbo;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        public AWCube()
+        {
+            vbo = new Vbo();
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+        }
+
+        public override void Render()
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+            
+            GL.DrawElements(BeginMode.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/53b333e1c9e8d168d923a2a5cc371e9e4c8aeab6">Removed TextRenderer</a>  -  53b333e</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 15 deletions(-)

diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index f162f26..557a659 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -10,6 +10,2 @@ namespace AWGL.Scene
     {
-        TextRenderer renderer;
-        Font serif = new Font(FontFamily.GenericSerif, 24);
-        Font sans = new Font(FontFamily.GenericSansSerif, 24);
-        Font mono = new Font(FontFamily.GenericMonospace, 24);
 
@@ -50,13 +46,2 @@ namespace AWGL.Scene
             vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-
-            renderer = new TextRenderer(Width, Height);
-            PointF position = PointF.Empty;
-
-            renderer.Clear(Color.MidnightBlue);
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", serif, Brushes.White, position);
-            position.Y += serif.Height;
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", sans, Brushes.White, position);
-            position.Y += sans.Height;
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", mono, Brushes.White, position);
-            position.Y += mono.Height;
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb4fed84365385914c83087fb2360ffdab490d06">rolled back vbo struct, needs more work</a>  -  bb4fed8</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
index 526fb4b..4ebbf45 100644
--- a/AWGL/AWData.cs
+++ b/AWGL/AWData.cs
@@ -7,5 +7,3 @@ namespace AWGL
     {
-        public int VboID, CboID ,EboID;
-
-        public int NumElements { get; set; }
+        public int VboID, EboID, NumElements;
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/76616d383f0e1ff9ae649e6c44903a29f123f74f">added NumElements back into buffer creation</a>  -  76616d3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 56b81b2..1d47a04 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -118,3 +118,3 @@ namespace AWGL
 
-            //vboHandle.NumElements = elements.Length;
+            vboHandle.NumElements = elements.Length;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/31c23c57e3521dd85d2cef3a460d579d94ae305e">VBO's now correctly draw in scene graph</a>  -  31c23c5</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 7 insertions(+), 37 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0492073..8e011de 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -22,36 +22,5 @@ namespace AWGL.Scene
         {
-
-            AWPolygon poly1 = new AWPolygon();
-            AWPolygon poly2 = new AWPolygon();
-            AWPolygon poly3 = new AWPolygon();
-            AWPolygon poly4 = new AWPolygon();
-            AWGroupNode rt = new AWGroupNode();
-
-            Vector3 a = new Vector3(.0f, .0f, 2.5f);
-            Vector3 b = new Vector3(2.5f, .0f, -2.5f);
-            Vector3 c = new Vector3(-2.5f, .0f, 2.5f);
-            Vector3 d = new Vector3(.0f, 4.0f, .0f);
-
-            poly1.AddNormal(new Vector3(.0f, -1.0f, .0f));
-            poly1.AddVertex(0, c);
-            poly1.AddVertex(1, b);
-            poly1.AddVertex(2, c);
-
-            poly2.AddNormal(new Vector3(.861411f, .269191f, .430706f));
-            poly2.AddVertex(0, d);
-            poly2.AddVertex(1, a);
-            poly2.AddVertex(2, b);
-
-            poly3.AddNormal(new Vector3(.0f, .529999f, -.847998f));
-            poly3.AddVertex(0, d);
-            poly3.AddVertex(1, b);
-            poly3.AddVertex(2, c);
-
-            poly4.AddNormal(new Vector3(-.861411f, .269191f, .430706f));
-            poly4.AddVertex(0, d);
-            poly4.AddVertex(1, c);
-            poly4.AddVertex(2, a);
-
             AWGroupNode root = new AWGroupNode();
             AWGraphLines graph = new AWGraphLines();
+
             AWGroupNode rt1 = new AWGroupNode();
@@ -59,3 +28,7 @@ namespace AWGL.Scene
 
+            AWGroupNode rt = new AWGroupNode();
+            AWCube cube = new AWCube();
+
             root.AddChild(graph);
+
             root.AddChild(rt1);
@@ -67,8 +40,5 @@ namespace AWGL.Scene
             rt1.SetTranslation(5, 0, 0);
-            rt2.SetTranslation(-5, 0, 0);
+            rt2.SetTranslation(-10, 2, 0);
 
-            rt.AddChild(poly1);
-            rt.AddChild(poly2);
-            rt.AddChild(poly3);
-            rt.AddChild(poly4);
+            rt.AddChild(cube);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ad33998aa7bc6d28915771c440b954d9688cce22">Added new method to group nodes for removing child nodes.</a>  -  ad33998</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 8 insertions(+)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index 98b4008..52c7b8e 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -80,3 +80,10 @@ namespace AWGL
 
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
         #endregion IGroupNode Implementation
+
+
     } 
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
index 7a8f5e7..5ac83e3 100644
--- a/AWGL/IGroupNode.cs
+++ b/AWGL/IGroupNode.cs
@@ -10,2 +10,3 @@ namespace AWGL
         void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b6f15d48344858a170c242f874f628ec7c8608af">Removed old examples.</a>  -  b6f15d4</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 112 insertions(+), 271 deletions(-)

diff --git a/AWGL/AWParticles.cs b/AWGL/AWParticles.cs
new file mode 100644
index 0000000..2b2f7c6
--- /dev/null
+++ b/AWGL/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
deleted file mode 100644
index 5bc302e..0000000
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ /dev/null
@@ -1,163 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class DynamicVBOScene : DefaultScene
-    {
-        public DynamicVBOScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        private int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        #region OnUpdateFrame
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)e.Time, out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            this.Title = "AWGL: High level OpenTK wrapper - " + m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-
-            GL.Translate(0f, 0f, -5f);
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(BeginMode.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteBuffers(1, ref VBOHandle);
-        }
-
-        #endregion        
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public override void Resize(EventArgs e)
-        {
-
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-        }
-    
-    
-    } 
-}
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
deleted file mode 100644
index 557a659..0000000
--- a/AWGL/Scene/StaticVBOScene.cs
+++ /dev/null
@@ -1,108 +0,0 @@
-﻿using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class StaticVBOScene : DefaultScene
-    {
-
-        #region Private Members
-        
-        private Vbo vbo = new Vbo();
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            Draw(vbo);
-
-            SwapBuffers();
-
-        }
-        #endregion
-
-        #region Draw(Vbo handle)
-
-        private void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2242df6f73c14922f18c70d3046b81626b27611c">Removed menu options.</a>  -  2242df6</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 14 insertions(+), 27 deletions(-)

diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 2a5682c..3802f15 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -28,12 +28,11 @@ namespace AWGL
             
-            Console.WriteLine("Please select a scene to load:");
-            Console.WriteLine("");
-            Console.WriteLine("1. Static VBO");
-            Console.WriteLine("2. Dynamic VBO");
-            Console.WriteLine("3. Texture 2D");
-            Console.WriteLine("4. Anaylgraph Stereo");
-            Console.WriteLine("5. FBO");
-            Console.WriteLine("6. Picker");
-            Console.WriteLine("7. Stencil CSG");
-            Console.WriteLine("8. Scene Graph Test");
+            Console.WriteLine("Please select a scene to load:\n");
+
+            Console.WriteLine("1. Dynamic VBO");
+            Console.WriteLine("2. Texture 2D");
+            Console.WriteLine("3. Anaylgraph Stereo");
+            Console.WriteLine("4. FBO");
+            Console.WriteLine("5. Picker");
+            Console.WriteLine("6. Stencil CSG");
+            Console.WriteLine("7. Scene Graph Test\n");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -42,15 +41,3 @@ namespace AWGL
             {
-                case 1:
-                    using (StaticVBOScene scene = new StaticVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
                 case 2:
-                    using (DynamicVBOScene scene = new DynamicVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
                     using (Texture2DScene scene = new Texture2DScene())
@@ -60,3 +47,3 @@ namespace AWGL
                     break;
-                case 4:
+                case 3:
                     using (StereoVisionScene scene = new StereoVisionScene())
@@ -66,3 +53,3 @@ namespace AWGL
                     break;
-                case 5:
+                case 4:
                     using (FBOScene scene = new FBOScene())
@@ -72,3 +59,3 @@ namespace AWGL
                     break;
-                case 6:
+                case 5:
                     using (PickerScene scene = new PickerScene())
@@ -78,3 +65,3 @@ namespace AWGL
                     break;
-                case 7:
+                case 6:
                     using (StencilCSGScene scene = new StencilCSGScene())
@@ -84,3 +71,3 @@ namespace AWGL
                     break;
-                case 8:
+                case 7:
                     using (SceneGraphTest scene = new SceneGraphTest())

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/854d4e1e82d41034cf911b26bba612053e4778ea">Removed obsolete OpenTK BeginMode in favor of PrimitiveType.</a>  -  854d4e1</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
index fcb02d9..d6c112a 100644
--- a/AWGL/AWCube.cs
+++ b/AWGL/AWCube.cs
@@ -67,3 +67,3 @@ namespace AWGL
             
-            GL.DrawElements(BeginMode.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e57d6e3b8e6de2d0dc5ec2f10dcc59bafe566252">Refactoring SceneGraph client code.</a>  -  e57d6e3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 26 insertions(+), 9 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 8e011de..ea3e770 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -14,2 +14,9 @@ namespace AWGL.Scene
         private AWNode m_sceneGraph;
+
+        AWGroupNode root, rt1, rt2, rt, rtt;
+        AWGraphLines graph;
+
+        AWCube cube;
+        AWParticles particles;
+
         private AWGroupNode m_hook1, m_hook2;
@@ -22,10 +29,3 @@ namespace AWGL.Scene
         {
-            AWGroupNode root = new AWGroupNode();
-            AWGraphLines graph = new AWGraphLines();
-
-            AWGroupNode rt1 = new AWGroupNode();
-            AWGroupNode rt2 = new AWGroupNode();
-
-            AWGroupNode rt = new AWGroupNode();
-            AWCube cube = new AWCube();
+            InitialiseNodes();
 
@@ -37,3 +37,3 @@ namespace AWGL.Scene
             rt1.AddChild(rt);
-            rt2.AddChild(rt);
+            rt2.AddChild(rtt);
 
@@ -43,2 +43,3 @@ namespace AWGL.Scene
             rt.AddChild(cube);
+            //rt.AddChild(particles);
 
@@ -50,2 +51,15 @@ namespace AWGL.Scene
 
+        private void InitialiseNodes()
+        {
+            root = new AWGroupNode();
+            rt1 = new AWGroupNode();
+            rt2 = new AWGroupNode();
+            rt = new AWGroupNode();
+            rtt = new AWGroupNode();
+
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            particles = new AWParticles(); ;
+        }
+
         public override void Setup(EventArgs e)
@@ -68,2 +82,5 @@ namespace AWGL.Scene
 
+            Title = "AWGL: High level OpenTK wrapper - " + particles.m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+
             m_spinangle += m_rotationspeed * (float)e.Time;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e485e92f6ec8b0d6fffc7c6b41104df30b97111c">Trimmed nodes.</a>  -  e485e92</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 13 insertions(+), 32 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index 52c7b8e..0e656cc 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -17,3 +17,2 @@ namespace AWGL
         
-
         public AWGroupNode()
@@ -51,3 +50,3 @@ namespace AWGL
             {
-                GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
             }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index ea3e770..61c4dd4 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -15,9 +15,8 @@ namespace AWGL.Scene
 
-        AWGroupNode root, rt1, rt2, rt, rtt;
-        AWGraphLines graph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
 
-        AWCube cube;
-        AWParticles particles;
+        private AWCube cube;
 
-        private AWGroupNode m_hook1, m_hook2;
+        private AWGroupNode m_hook1;
         #endregion
@@ -31,20 +30,11 @@ namespace AWGL.Scene
 
-            root.AddChild(graph);
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
 
-            root.AddChild(rt1);
-            root.AddChild(rt2);
+            landRoot.SetTranslation(0, 0, -10);
+            landRoot.AddChild(cube);
 
-            rt1.AddChild(rt);
-            rt2.AddChild(rtt);
+            m_sceneGraph = worldRoot;
 
-            rt1.SetTranslation(5, 0, 0);
-            rt2.SetTranslation(-10, 2, 0);
-
-            rt.AddChild(cube);
-            //rt.AddChild(particles);
-
-            m_sceneGraph = root;
-
-            m_hook1 = rt1;
-            m_hook2 = rt2;
+            m_hook1 = landRoot;
         }
@@ -53,7 +43,4 @@ namespace AWGL.Scene
         {
-            root = new AWGroupNode();
-            rt1 = new AWGroupNode();
-            rt2 = new AWGroupNode();
-            rt = new AWGroupNode();
-            rtt = new AWGroupNode();
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
 
@@ -61,3 +48,2 @@ namespace AWGL.Scene
             cube = new AWCube();
-            particles = new AWParticles(); ;
         }
@@ -82,5 +68,2 @@ namespace AWGL.Scene
 
-            Title = "AWGL: High level OpenTK wrapper - " + particles.m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-
             m_spinangle += m_rotationspeed * (float)e.Time;
@@ -94,3 +77,2 @@ namespace AWGL.Scene
             m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-            m_hook2.SetRotation(-m_spinangle, 0, 0, 1);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/97ea4889745a892b7f511183a84661b181ce629f">Basic camera implementation from Neo Kabuto's blog: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html</a>  -  97ea488</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 3 files changed, 113 insertions(+), 33 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
new file mode 100644
index 0000000..71a2527
--- /dev/null
+++ b/AWGL/AWCamera.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWCamera
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public float MoveSpeed = 0.2f;
+        public float MouseSensitivity = 0.01f;
+
+        public Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+        }
+
+        public void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fd1d068..1c124e3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -5,2 +5,3 @@ using OpenTK.Input;
 using System;
+using System.Drawing;
 
@@ -17,3 +18,2 @@ namespace AWGL.Scene
             //this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
         }
@@ -23,5 +23,3 @@ namespace AWGL.Scene
         #region Camera
-        protected float m_eyeX = .0f;
-        protected float m_eyeY = 10.0f;
-        protected float m_eyeZ = 10.0f;
+        protected AWCamera camera;
         #endregion
@@ -48,2 +46,3 @@ namespace AWGL.Scene
 
+            camera = new AWCamera();
             Setup(e);
@@ -66,2 +65,26 @@ namespace AWGL.Scene
 
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+ 	         base.OnUpdateFrame(e);
+
+             if (Focused)
+             {
+                 Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                 Point delta = new Point(center.X - OpenTK.Input.Mouse.GetState().X, center.Y - OpenTK.Input.Mouse.GetState().Y);
+
+                 camera.AddRotation(delta.X, delta.Y);
+                 ResetCursor();
+             }
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
         public abstract void Setup(EventArgs e);
@@ -93,39 +116,38 @@ namespace AWGL.Scene
         #region Input
-        /// <summary>
-        /// Occurs when a key is pressed.
-        /// </summary>
-        /// <param name="sender">The KeyboardDevice which generated this event.</param>
-        /// <param name="e">The key that was pressed.</param>
-        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        protected override void OnKeyPress(KeyPressEventArgs e)
         {
+            base.OnKeyPress(e);
 
-            switch (e.Key)
+            if (e.KeyChar == 27)
             {
-                #region Window Controls
+                Exit();
+            }
 
-                case Key.Escape: this.Exit();
+            switch (e.KeyChar)
+            {
+                case 'w':
+                    camera.Move(0f, 0.1f, 0f);
                     break;
-                case Key.F11:
-                    if (this.WindowState == WindowState.Fullscreen)
-                        this.WindowState = WindowState.Normal;
-                    else
-                        this.WindowState = WindowState.Fullscreen;
+                case 'a':
+                    camera.Move(-0.1f, 0f, 0f);
                     break;
-
-                #endregion
-
-                #region Camera Controls
-
-                case Key.Up: m_eyeY += 2f;
+                case 's':
+                    camera.Move(0f, -0.1f, 0f);
                     break;
-                case Key.Down: m_eyeY += -2f;
+                case 'd':
+                    camera.Move(0.1f, 0f, 0f);
                     break;
-                case Key.Right: m_eyeX += 2f;
+                case 'q':
+                    camera.Move(0f, 0f, 0.1f);
                     break;
-                case Key.Left: m_eyeX += -2f;
+                case 'e':
+                    camera.Move(0f, 0f, -0.1f);
                     break;
-
-                #endregion
-
-            }   
+                case 'f':
+                    if (this.WindowState == WindowState.Fullscreen)
+                        this.WindowState = WindowState.Normal;
+                    else
+                        this.WindowState = WindowState.Fullscreen;
+                    break;
+            }
         }
@@ -133,2 +155,6 @@ namespace AWGL.Scene
 
+        void ResetCursor()
+        {
+            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
     }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 61c4dd4..009b774 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -59,3 +59,3 @@ namespace AWGL.Scene
             float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            Matrix4 perpective = camera.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
             GL.MatrixMode(MatrixMode.Projection);
@@ -72,3 +72,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(m_eyeX, m_eyeY, m_eyeZ, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = camera.GetViewMatrix();
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8a31553ad76be1cb435dec29005567efa60edaa0">fixed camera issues using System.Windows.Forms.Cursor</a>  -  8a31553</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 3 insertions(+), 11 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 1c124e3..47638c6 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -17,3 +17,3 @@ namespace AWGL.Scene
         {
-            //this.WindowState = WindowState.Fullscreen;
+            this.WindowState = WindowState.Fullscreen;
         }
@@ -22,5 +22,3 @@ namespace AWGL.Scene
 
-        #region Camera
         protected AWCamera camera;
-        #endregion
 
@@ -72,3 +70,3 @@ namespace AWGL.Scene
                  Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                 Point delta = new Point(center.X - OpenTK.Input.Mouse.GetState().X, center.Y - OpenTK.Input.Mouse.GetState().Y);
+                 Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
@@ -145,8 +143,2 @@ namespace AWGL.Scene
                     break;
-                case 'f':
-                    if (this.WindowState == WindowState.Fullscreen)
-                        this.WindowState = WindowState.Normal;
-                    else
-                        this.WindowState = WindowState.Fullscreen;
-                    break;
             }
@@ -157,3 +149,3 @@ namespace AWGL.Scene
         {
-            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ac1f10c6e04072030182c337f4d98678d12dffbe">added keylist to handle multiple key presses simultaneously</a>  -  ac1f10c</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 66 insertions(+), 36 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 47638c6..f06d9b6 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -5,2 +5,3 @@ using OpenTK.Input;
 using System;
+using System.Collections.Generic;
 using System.Drawing;
@@ -17,3 +18,3 @@ namespace AWGL.Scene
         {
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
         }
@@ -23,2 +24,3 @@ namespace AWGL.Scene
         protected AWCamera camera;
+        private List<Key> keyList;
 
@@ -45,2 +47,5 @@ namespace AWGL.Scene
             camera = new AWCamera();
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
             Setup(e);
@@ -49,2 +54,59 @@ namespace AWGL.Scene
 
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
         #region OnResize
@@ -66,5 +128,7 @@ namespace AWGL.Scene
  	         base.OnUpdateFrame(e);
-
+             
              if (Focused)
              {
+                 MoveCamera();
+
                  Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
@@ -113,36 +177,2 @@ namespace AWGL.Scene
 
-        #region Input
-        protected override void OnKeyPress(KeyPressEventArgs e)
-        {
-            base.OnKeyPress(e);
-
-            if (e.KeyChar == 27)
-            {
-                Exit();
-            }
-
-            switch (e.KeyChar)
-            {
-                case 'w':
-                    camera.Move(0f, 0.1f, 0f);
-                    break;
-                case 'a':
-                    camera.Move(-0.1f, 0f, 0f);
-                    break;
-                case 's':
-                    camera.Move(0f, -0.1f, 0f);
-                    break;
-                case 'd':
-                    camera.Move(0.1f, 0f, 0f);
-                    break;
-                case 'q':
-                    camera.Move(0f, 0f, 0.1f);
-                    break;
-                case 'e':
-                    camera.Move(0f, 0f, -0.1f);
-                    break;
-            }
-        }
-        #endregion
-
         void ResetCursor()

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/48fd39c656af080a22bca7f4ae5bb665811434b2">~</a>  -  48fd39c</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 19 files changed, 25 insertions(+), 1264 deletions(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
deleted file mode 100644
index d6c112a..0000000
--- a/AWGL/AWCube.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWCube : AWNode
-    {
-        #region Private Members
-        private Cube Cube;
-
-        private Vbo vbo;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public AWCube()
-        {
-            vbo = new Vbo();
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Render()
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-            
-            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
deleted file mode 100644
index 7f280ce..0000000
--- a/AWGL/AWGraphLines.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWGraphLines : AWNode
-    {
-        private int m_gridSize = 20;
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
deleted file mode 100644
index 0e656cc..0000000
--- a/AWGL/AWGroupNode.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-    } 
-}
diff --git a/AWGL/AWMesh.cs b/AWGL/AWMesh.cs
deleted file mode 100644
index bd58995..0000000
--- a/AWGL/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
deleted file mode 100644
index 39bef32..0000000
--- a/AWGL/AWNode.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class AWNode : ISceneNode
-    {
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/AWParticles.cs b/AWGL/AWParticles.cs
deleted file mode 100644
index 2b2f7c6..0000000
--- a/AWGL/AWParticles.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWParticles : AWNode
-    {
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
deleted file mode 100644
index eb2ca03..0000000
--- a/AWGL/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 1d47a04..9489bce 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -158,3 +158,24 @@ namespace AWGL
         }
-    
+
+        #region TestOpenGLVersion
+        /// <summary>
+        /// Get OpenGL Version Information and check system meets requirements
+        /// </summary>
+        public static void TestOpenGLVersion()
+        {
+            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetHigh = new Version(4, 1);
+            if (m_Version < m_TargetLow)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
+            }
+            else if (m_Version > m_TargetHigh)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
+            }
+        }
+        #endregion
     
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
deleted file mode 100644
index 5ac83e3..0000000
--- a/AWGL/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
deleted file mode 100644
index 6f6da08..0000000
--- a/AWGL/ISceneNode.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 3802f15..9fb38cb 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -1,2 +1,3 @@
 ﻿using AWGL.Scene;
+using OpenTK;
 using System;
@@ -19,6 +20,2 @@ namespace AWGL
 
-        public static void SetupScene(Color backgroundColor)
-        {
-        }
-
         [STAThread]
@@ -26,53 +23,5 @@ namespace AWGL
         {
-            Int32 Selection;
-            
-            Console.WriteLine("Please select a scene to load:\n");
-
-            Console.WriteLine("1. Dynamic VBO");
-            Console.WriteLine("2. Texture 2D");
-            Console.WriteLine("3. Anaylgraph Stereo");
-            Console.WriteLine("4. FBO");
-            Console.WriteLine("5. Picker");
-            Console.WriteLine("6. Stencil CSG");
-            Console.WriteLine("7. Scene Graph Test\n");
-            Int32.TryParse(Console.ReadLine(), out Selection);
-
-            switch (Selection)
+            using (DefaultScene game = new DefaultScene())
             {
-                case 2:
-                    using (Texture2DScene scene = new Texture2DScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
-                    using (StereoVisionScene scene = new StereoVisionScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 4:
-                    using (FBOScene scene = new FBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 5:
-                    using (PickerScene scene = new PickerScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 6:
-                    using (StencilCSGScene scene = new StencilCSGScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 7:
-                    using (SceneGraphTest scene = new SceneGraphTest())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
+                game.Run(30,0);
             }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
deleted file mode 100644
index f06d9b6..0000000
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ /dev/null
@@ -1,183 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public abstract class DefaultScene : GameWindow
-    {
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            //this.WindowState = WindowState.Fullscreen;
-        }
-
-        private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-
-        protected AWCamera camera;
-        private List<Key> keyList;
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            TestOpenGLVersion();
-
-            Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-
-            GL.ClearColor(Color4.Gray);
-
-            camera = new AWCamera();
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-            Setup(e);
-        }
-        #endregion
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
-                }
-            }
-        }
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-            Resize(e);
-        }
-
-        #endregion
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
- 	         base.OnUpdateFrame(e);
-             
-             if (Focused)
-             {
-                 MoveCamera();
-
-                 Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                 Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                 camera.AddRotation(delta.X, delta.Y);
-                 ResetCursor();
-             }
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        public abstract void Setup(EventArgs e);
-
-        new public abstract void Resize(EventArgs e);
-
-        #region TestOpenGLVersion
-        /// <summary>
-        /// Get OpenGL Version Information and check system meets requirements
-        /// </summary>
-        private void TestOpenGLVersion()
-        {
-            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 1);
-            Version m_TargetHigh = new Version(4, 1);
-            if (m_Version < m_TargetLow)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
-            }
-            else if (m_Version > m_TargetHigh)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
-            }
-        }
-        #endregion
-
-        void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
deleted file mode 100644
index 009b774..0000000
--- a/AWGL/Scene/SceneGraphTest.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL.Scene
-{
-    class SceneGraphTest : DefaultScene
-    {
-        #region SceneGraph
-        private AWNode m_sceneGraph;
-
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-
-        private AWCube cube;
-
-        private AWGroupNode m_hook1;
-        #endregion
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle;
-
-        public void CreateSceneGraph()
-        {
-            InitialiseNodes();
-
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, 0, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-        }
-
-        private void InitialiseNodes()
-        {
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            CreateSceneGraph();
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = camera.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-    }
-}
diff --git a/WinFormTest/GameLoopForm.Designer.cs b/WinFormTest/GameLoopForm.Designer.cs
deleted file mode 100644
index bd47093..0000000
--- a/WinFormTest/GameLoopForm.Designer.cs
+++ /dev/null
@@ -1,61 +0,0 @@
-﻿namespace WinFormTest
-{
-    partial class GameLoopForm
-    {
-        /// <summary>
-        /// Required designer variable.
-        /// </summary>
-        private System.ComponentModel.IContainer components = null;
-
-        /// <summary>
-        /// Clean up any resources being used.
-        /// </summary>
-        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing && (components != null))
-            {
-                components.Dispose();
-            }
-            base.Dispose(disposing);
-        }
-
-        #region Windows Form Designer generated code
-
-        /// <summary>
-        /// Required method for Designer support - do not modify
-        /// the contents of this method with the code editor.
-        /// </summary>
-        private void InitializeComponent()
-        {
-            this.glControl = new OpenTK.GLControl();
-            this.SuspendLayout();
-            // 
-            // glControl
-            // 
-            this.glControl.BackColor = System.Drawing.Color.Black;
-            this.glControl.Dock = System.Windows.Forms.DockStyle.Top;
-            this.glControl.Location = new System.Drawing.Point(0, 0);
-            this.glControl.Name = "glControl";
-            this.glControl.Size = new System.Drawing.Size(717, 403);
-            this.glControl.TabIndex = 0;
-            this.glControl.VSync = false;
-            // 
-            // GameLoopForm
-            // 
-            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
-            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
-            this.ClientSize = new System.Drawing.Size(717, 477);
-            this.Controls.Add(this.glControl);
-            this.Name = "GameLoopForm";
-            this.Text = "Form1";
-            this.ResumeLayout(false);
-
-        }
-
-        #endregion
-
-        private OpenTK.GLControl glControl;
-    }
-}
-
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
deleted file mode 100644
index 7a857d2..0000000
--- a/WinFormTest/GameLoopForm.cs
+++ /dev/null
@@ -1,309 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Data;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Windows.Forms;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using AWGL;
-using AWGL.Shapes;
-
-namespace WinFormTest
-{
-    public partial class GameLoopForm : Form
-    {
-        static float angle = 0.0f;
-        private int programObject;
-
-        private int vertex_buffer_object, color_buffer_object, element_buffer_object;
-        Shape shape = new Cube();
-
-        #region --- Constructor ---
-
-        public GameLoopForm()
-        {
-            InitializeComponent();
-        }
-        
-        #endregion
-
-        #region OnLoad
-
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            glControl.KeyDown += new KeyEventHandler(glControl_KeyDown);
-            glControl.KeyUp += new KeyEventHandler(glControl_KeyUp);
-            glControl.Resize += new EventHandler(glControl_Resize);
-            glControl.Paint += new PaintEventHandler(glControl_Paint);
-
-            Text =
-                GL.GetString(StringName.Vendor) + " " +
-                GL.GetString(StringName.Renderer) + " " +
-                GL.GetString(StringName.Version);
-
-            GL.ClearColor(Color.MidnightBlue);
-            GL.Enable(EnableCap.DepthTest);
-
-            CreateVBO();
-
-            // create and compile shader objects
-            int vertexShader = AWUtils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
-            int fragmentShader = AWUtils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
-
-            // attach and link to main program then use
-            programObject = AWUtils.BuildProgram(vertexShader, fragmentShader);
-            GL.UseProgram(programObject);
-
-            // clean up
-            GL.DeleteShader(vertexShader);
-            GL.DeleteShader(fragmentShader);
-            
-            Application.Idle += Application_Idle;
-
-            // Ensure that the viewport and projection matrix are set correctly.
-            glControl_Resize(glControl, EventArgs.Empty);
-        }
-
-        void glControl_KeyUp(object sender, KeyEventArgs e)
-        {
-            if (e.KeyCode == Keys.F12)
-            {
-                GrabScreenshot().Save("screenshot.png");
-            }
-        }
-
-        #endregion
-
-        #region private void CreateVBO()
-
-        void CreateVBO()
-        {
-            int size;
-
-            GL.GenBuffers(1, out vertex_buffer_object);
-            GL.GenBuffers(1, out color_buffer_object);
-            GL.GenBuffers(1, out element_buffer_object);
-
-            // Upload the vertex buffer.
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Vertices.Length * 3 * sizeof(float)), shape.Vertices,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Vertices.Length * 3 * sizeof(Single))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Vertices.Length * 3 * sizeof(Single), size));
-
-            // Upload the color buffer.
-            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Colors.Length * sizeof(int)), shape.Colors,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Colors.Length * sizeof(int))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (colors). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Colors.Length * sizeof(int), size));
-
-            // Upload the index buffer (elements inside the vertex buffer, not color indices as per the IndexPointer function!)
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(shape.Indices.Length * sizeof(Int32)), shape.Indices,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Indices.Length * sizeof(int))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (offsets). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Indices.Length * sizeof(int), size));
-        }
-
-        #endregion
-
-        #region OnClosing
-
-        protected override void OnClosing(CancelEventArgs e)
-        {
-            if (programObject != 0)
-                GL.DeleteProgram(programObject);
-            if (vboHandle.VboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.VboID);
-            if (vboHandle.CboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.CboID);
-            if (vboHandle.EboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.EboID);
-            Application.Idle -= Application_Idle;
-
-            base.OnClosing(e);
-        }
-
-        #endregion
-
-        #region Application_Idle event
-
-        void Application_Idle(object sender, EventArgs e)
-        {
-            while (glControl.IsIdle)
-            {
-                Render();
-            }
-        }
-
-        #endregion
-
-        #region GLControl.Resize event handler
-
-        void glControl_Resize(object sender, EventArgs e)
-        {
-            OpenTK.GLControl c = sender as OpenTK.GLControl;
-
-            if (c.ClientSize.Height == 0)
-                c.ClientSize = new System.Drawing.Size(c.ClientSize.Width, 1);
-
-            GL.Viewport(0, 0, c.ClientSize.Width, c.ClientSize.Height);
-
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #endregion
-
-        #region GLControl.KeyDown event handler
-
-        void glControl_KeyDown(object sender, KeyEventArgs e)
-        {
-            switch (e.KeyData)
-            {
-                case Keys.Escape:
-                    this.Close();
-                    break;
-            }
-        }
-
-        #endregion
-
-        #region GLControl.Paint event handler
-
-        void glControl_Paint(object sender, PaintEventArgs e)
-        {
-            Render();
-        }
-
-        #endregion
-
-        #region private void Render()
-
-        private Vbo vboHandle = new Vbo();
-        private float rotation_speed = 3.0f;
-
-
-        private void Render()
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit |
-         ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            //angle += rotation_speed * (float)Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            GL.EnableClientState(ArrayCap.VertexArray);
-            GL.EnableClientState(ArrayCap.ColorArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
-            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
-
-            GL.DrawElements(BeginMode.Triangles, shape.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
-
-            //GL.DrawArrays(GL.Enums.BeginMode.POINTS, 0, shape.Vertices.Length);
-
-            GL.DisableClientState(ArrayCap.VertexArray);
-            GL.DisableClientState(ArrayCap.ColorArray);
-
-
-            //int error = GL.GetError();
-            //if (error != 0)
-            //    Debug.Print(Glu.ErrorString(Glu.Enums.ErrorCode.INVALID_OPERATION));
-
-            glControl.SwapBuffers();
-        }
-
-        #endregion
-
-        #region private void DrawCube()
-
-        private void DrawCube()
-        {
-            GL.Begin(BeginMode.Quads);
-
-            GL.Color3(Color.Silver);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-
-            GL.Color3(Color.Honeydew);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-
-            GL.Color3(Color.Moccasin);
-
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.IndianRed);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-
-            GL.Color3(Color.PaleVioletRed);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.ForestGreen);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-
-            GL.End();
-        }
-
-        #endregion
-
-        #region private void GrabScreenshot()
-
-        Bitmap GrabScreenshot()
-        {
-            Bitmap bmp = new Bitmap(this.ClientSize.Width, this.ClientSize.Height);
-            System.Drawing.Imaging.BitmapData data =
-            bmp.LockBits(this.ClientRectangle, System.Drawing.Imaging.ImageLockMode.WriteOnly,
-                System.Drawing.Imaging.PixelFormat.Format24bppRgb);
-            GL.ReadPixels(0, 0, this.ClientSize.Width, this.ClientSize.Height, PixelFormat.Bgr, PixelType.UnsignedByte,
-                data.Scan0);
-            bmp.UnlockBits(data);
-            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);
-            return bmp;
-        }
-
-        #endregion
-    }
-}
diff --git a/WinFormTest/Program.cs b/WinFormTest/Program.cs
deleted file mode 100644
index b301879..0000000
--- a/WinFormTest/Program.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Threading.Tasks;
-using System.Windows.Forms;
-
-namespace WinFormTest
-{
-    static class Program
-    {
-        /// <summary>
-        /// The main entry point for the application.
-        /// </summary>
-        [STAThread]
-        static void Main()
-        {
-            Application.EnableVisualStyles();
-            Application.SetCompatibleTextRenderingDefault(false);
-            Application.Run(new GameLoopForm());
-        }
-    }
-}
deleted file mode 100644
index f2a9af5..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("WinFormTest")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("WinFormTest")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("59ce37cf-9660-4196-991a-0a3039839f38")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
deleted file mode 100644
index 8f82795..0000000
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-//     Runtime Version:4.0.30319.18052
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace WinFormTest.Properties
-{
-
-
-    /// <summary>
-    ///   A strongly-typed resource class, for looking up localized strings, etc.
-    /// </summary>
-    // This class was auto-generated by the StronglyTypedResourceBuilder
-    // class via a tool like ResGen or Visual Studio.
-    // To add or remove a member, edit your .ResX file then rerun ResGen
-    // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
-    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    internal class Resources
-    {
-
-        private static global::System.Resources.ResourceManager resourceMan;
-
-        private static global::System.Globalization.CultureInfo resourceCulture;
-
-        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
-        internal Resources()
-        {
-        }
-
-        /// <summary>
-        ///   Returns the cached ResourceManager instance used by this class.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Resources.ResourceManager ResourceManager
-        {
-            get
-            {
-                if ((resourceMan == null))
-                {
-                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("WinFormTest.Properties.Resources", typeof(Resources).Assembly);
-                    resourceMan = temp;
-                }
-                return resourceMan;
-            }
-        }
-
-        /// <summary>
-        ///   Overrides the current thread's CurrentUICulture property for all
-        ///   resource lookups using this strongly typed resource class.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Globalization.CultureInfo Culture
-        {
-            get
-            {
-                return resourceCulture;
-            }
-            set
-            {
-                resourceCulture = value;
-            }
-        }
-    }
-}
deleted file mode 100644
index 0394d77..0000000
+++ /dev/null
@@ -1,30 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-//     Runtime Version:4.0.30319.18052
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace WinFormTest.Properties
-{
-
-
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
-    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
-    {
-
-        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
-
-        public static Settings Default
-        {
-            get
-            {
-                return defaultInstance;
-            }
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0720e6a0468cd39fe03106c2e994c5051dbce810">Backing Up old source for reference.</a>  -  0720e6a</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 10 files changed, 660 insertions(+)

diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
new file mode 100644
index 0000000..d6c112a
--- /dev/null
+++ b/AWGL/Scene/AWCube.cs
@@ -0,0 +1,71 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        private Cube Cube;
+
+        private Vbo vbo;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        public AWCube()
+        {
+            vbo = new Vbo();
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+        }
+
+        public override void Render()
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+            
+            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+    }
+}
diff --git a/AWGL/Scene/AWGraphLines.cs b/AWGL/Scene/AWGraphLines.cs
new file mode 100644
index 0000000..7f280ce
--- /dev/null
+++ b/AWGL/Scene/AWGraphLines.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGraphLines : AWNode
+    {
+        private int m_gridSize = 20;
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/Scene/AWGroupNode.cs b/AWGL/Scene/AWGroupNode.cs
new file mode 100644
index 0000000..0e656cc
--- /dev/null
+++ b/AWGL/Scene/AWGroupNode.cs
@@ -0,0 +1,89 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+    } 
+}
diff --git a/AWGL/Scene/AWMesh.cs b/AWGL/Scene/AWMesh.cs
new file mode 100644
index 0000000..bd58995
--- /dev/null
+++ b/AWGL/Scene/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
new file mode 100644
index 0000000..39bef32
--- /dev/null
+++ b/AWGL/Scene/AWNode.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public abstract class AWNode : ISceneNode
+    {
+        public abstract void Render();
+    }
+
+}
diff --git a/AWGL/Scene/AWParticles.cs b/AWGL/Scene/AWParticles.cs
new file mode 100644
index 0000000..2b2f7c6
--- /dev/null
+++ b/AWGL/Scene/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Scene/AWPolygon.cs b/AWGL/Scene/AWPolygon.cs
new file mode 100644
index 0000000..eb2ca03
--- /dev/null
+++ b/AWGL/Scene/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/Scene/DefaultScene.cs b/AWGL/Scene/DefaultScene.cs
new file mode 100644
index 0000000..e7d2e4d
--- /dev/null
+++ b/AWGL/Scene/DefaultScene.cs
@@ -0,0 +1,247 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class DefaultScene : GameWindow
+    {
+        #region Constructor
+        
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            //set context
+            this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.0f;
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            AWUtils.TestOpenGLVersion();
+
+            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/IGroupNode.cs b/AWGL/Scene/IGroupNode.cs
new file mode 100644
index 0000000..5ac83e3
--- /dev/null
+++ b/AWGL/Scene/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/ISceneNode.cs b/AWGL/Scene/ISceneNode.cs
new file mode 100644
index 0000000..6f6da08
--- /dev/null
+++ b/AWGL/Scene/ISceneNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d7a760d683e1751305aa7188edc800e4466e5dba">Removing more old junk code.</a>  -  d7a760d</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
index d6c112a..6635235 100644
--- a/AWGL/Scene/AWCube.cs
+++ b/AWGL/Scene/AWCube.cs
@@ -22,10 +22,10 @@ namespace AWGL
         {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.Khaki),
                 new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Black),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Black),
                 new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.Khaki), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Black),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Black) 
         };

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0ac588a59098aee3397319293f3609b7754c2ec6">Minor refactoring.</a>  -  0ac588a</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 3 files changed, 258 insertions(+), 249 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index dcf64ca..cbbbeaa 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -104,5 +104,6 @@ namespace AWGL
         /// <returns></returns>
-        public int getShaderProgram() 
+        public int programID() 
         {
-            BuildProgram();
+            if(linkedProgram == null)
+                BuildProgram();
 
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
new file mode 100644
index 0000000..32f76fc
--- /dev/null
+++ b/AWGL/DefaultScene.cs
@@ -0,0 +1,255 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class DefaultScene : GameWindow
+    {
+        #region Constructor
+        
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            //set context
+            this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+
+            shaderManager = new AWShaderManager();
+            GL.UseProgram(shaderManager.programID());
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private AWShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            AWUtils.TestOpenGLVersion();
+
+            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/DefaultScene.cs b/AWGL/Scene/DefaultScene.cs
deleted file mode 100644
index e7d2e4d..0000000
--- a/AWGL/Scene/DefaultScene.cs
+++ /dev/null
@@ -1,247 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class DefaultScene : GameWindow
-    {
-        #region Constructor
-        
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            //set context
-            this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new AWCamera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.0f;
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected AWCamera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            AWUtils.TestOpenGLVersion();
-
-            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ed3837b166071d3d1bc02e9a23f5b376166226d4">Move player view up Y axis OnLoad.</a>  -  ed3837b</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 32f76fc..dba482a 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -52,2 +52,3 @@ namespace AWGL.Scene
             cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eb79d20616b11591ac04535b622c8ea810b25e74">Add Contructor to ShaderManager to specify different Vertex and Fragment shader files.</a>  -  eb79d20</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index cbbbeaa..2d448f6 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -21,2 +21,15 @@ namespace AWGL
         private string defaultDataPath = "Data/Shaders/";
+        private string m_vsFilePath, m_fsFilePath;
+
+        public AWShaderManager(string vs_path, string fs_path)
+        {
+            this.m_vsFilePath = vs_path;
+            this.m_fsFilePath = fs_path;
+        }
+
+        public AWShaderManager()
+        {
+            this.m_vsFilePath   = "Simple_VS";
+            this.m_fsFilePath   = "Simple_FS";
+        }
 
@@ -70,4 +83,4 @@ namespace AWGL
         {
-            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
-            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+            this.vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
+            this.fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f7e325982686f76e72d512b5f9d374de88887727">Simple Colour Animation</a>  -  f7e3259</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 52 insertions(+)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
new file mode 100644
index 0000000..719bdf9
--- /dev/null
+++ b/AWGL/ShaderTutorials.cs
@@ -0,0 +1,52 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL4;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class ShaderTutorials : GameWindow
+    {
+        static Timer timer;
+        static double elapsedSeconds;
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Title = AWUtils.PrintOpenGLInfo();
+            elapsedSeconds = 0;
+
+            timer = new Timer(1000);
+            timer.Elapsed += new ElapsedEventHandler(OnTimerElapsed);
+            timer.Enabled = true;
+        }
+
+        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
+        {
+            elapsedSeconds++;
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            float[] color = new float[] 
+            { 
+                (float)(Math.Sin(elapsedSeconds) * 0.5f + 0.5f), 
+                (float)(Math.Cos(elapsedSeconds) * 0.5f + 0.5f),
+                0.0f, 
+                1.0f 
+            };
+
+            GL.ClearBuffer(ClearBuffer.Color, 0, color);
+
+            SwapBuffers();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/559e08b87df4f8c4fd5ff19931c1fad3c6a3a454">Add initial chapter2 shader.</a>  -  559e08b</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 6 insertions(+)

diff --git a/AWGL/Data/Shaders/CH01_VS.glsl b/AWGL/Data/Shaders/CH01_VS.glsl
new file mode 100644
index 0000000..90a7a31
--- /dev/null
+++ b/AWGL/Data/Shaders/CH01_VS.glsl
@@ -0,0 +1,6 @@
+﻿#version 410 core
+
+void main(void)
+{
+	gl_Position = vec4(0.0, 0.0, 0.5, 1.0);
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2e05f815e3bc4d2e480e520ce0799810f8699d21">Corrected check for ProgramID failing.</a>  -  2e05f81</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 2d448f6..b5ea776 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -119,3 +119,3 @@ namespace AWGL
         {
-            if(linkedProgram == null)
+            if(linkedProgram == 0)
                 BuildProgram();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e39ac8c3e65cedefb86a3fcfcfa079fd3d379ece">Moved Printing of OpenGL info to utility class.</a>  -  e39ac8c</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 9489bce..78a6d70 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -180,2 +180,16 @@ namespace AWGL
         #endregion
+
+        public static string PrintOpenGLInfo()
+        {
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            
+            TestOpenGLVersion();
+
+            return "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+        }
     
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index dba482a..5be1708 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -90,11 +90,3 @@ namespace AWGL.Scene
 
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            AWUtils.TestOpenGLVersion();
-
-            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            Title = AWUtils.PrintOpenGLInfo();
 
@@ -104,2 +96,3 @@ namespace AWGL.Scene
         }
+
         #endregion

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6f398574b1bcc04fc2ff67e1d9903adba5c6364f">Added ShaderTutorial as default launch.</a>  -  6f39857</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 9fb38cb..773fa24 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -23,3 +23,3 @@ namespace AWGL
         {
-            using (DefaultScene game = new DefaultScene())
+            using (ShaderTutorials game = new ShaderTutorials())
             {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b96c4e17b5ad753a75acb051785e588ea99d1046">Set explicit profiles. Added sb6 shaders.</a>  -  b96c4e1</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 8 files changed, 97 insertions(+), 44 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b5ea776..00deea2 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL;
+using OpenTK.Graphics.OpenGL4;
 
@@ -27,2 +27,3 @@ namespace AWGL
             this.m_fsFilePath = fs_path;
+            BuildProgram();
         }
@@ -93,3 +94,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(this.linkedProgram, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -104,3 +105,3 @@ namespace AWGL
             GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.GetProgram(this.linkedProgram, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -111,19 +112,19 @@ namespace AWGL
             }
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(vShader);
+            GL.DeleteShader(fShader);
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns></returns>
-        public int programID() 
+        public void Dispose()
         {
-            if(linkedProgram == 0)
-                BuildProgram();
-
-            return linkedProgram;
+            GL.DeleteProgram(this.linkedProgram);
         }
 
-        public void Dispose()
+        public int ProgramID
         {
-            throw new NotImplementedException();
+            get
+            {
+                return this.linkedProgram;
+            }
         }
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 78a6d70..9b8c7df 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -77,3 +77,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess);
             if (linkSuccess == 0)
@@ -88,3 +88,3 @@ namespace AWGL
             GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess);
             if (validateSuccess == 0)
@@ -194,3 +194,3 @@ namespace AWGL
         }
-    
+
     }
diff --git a/AWGL/Data/Shaders/CH01_VS.glsl b/AWGL/Data/Shaders/CH01_VS.glsl
deleted file mode 100644
index 90a7a31..0000000
--- a/AWGL/Data/Shaders/CH01_VS.glsl
+++ /dev/null
@@ -1,6 +0,0 @@
-﻿#version 410 core
-
-void main(void)
-{
-	gl_Position = vec4(0.0, 0.0, 0.5, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
new file mode 100644
index 0000000..410ba8d
--- /dev/null
+++ b/AWGL/Data/Shaders/CH02_FS.glsl
@@ -0,0 +1,8 @@
+#version 330 core
+
+out vec4 color;
+
+void main(void)
+{
+	color = vec4(0.0, 0.8, 0.0, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
new file mode 100644
index 0000000..4513442
--- /dev/null
+++ b/AWGL/Data/Shaders/CH02_VS.glsl
@@ -0,0 +1,12 @@
+﻿#version 330 core
+
+void main(void)
+{
+	const vec4 vertices[3] = vec4[3](
+		vec4(0.25, -0.25, 0.5, 1.0),
+		vec4(-0.25, 0.25, 0.5, 1.0),
+		vec4(0.25, 0.25, 0.5, 1.0)
+		);
+	// Index into our array using gl_VertexID
+	gl_Position = vertices[gl_VertexID];
+}
\ No newline at end of file
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 5be1708..27a08e1 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -17,8 +17,9 @@ namespace AWGL.Scene
         #region Constructor
-        
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+
+        public DefaultScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
         {
             //set context
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
             m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
@@ -54,4 +55,4 @@ namespace AWGL.Scene
 
-            shaderManager = new AWShaderManager();
-            GL.UseProgram(shaderManager.programID());
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
         }
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 773fa24..c5cb1b2 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -21,3 +21,3 @@ namespace AWGL
         [STAThread]
-        public static void Run()
+        public static void Main()
         {
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 719bdf9..417ec4e 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -2,3 +2,3 @@
 using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL4;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -15,3 +15,12 @@ namespace AWGL
         static Timer timer;
-        static double elapsedSeconds;
+        static double elapsedSeconds = 0;
+        static AWShaderManager shaderManager;
+        private int programObject, vertexObject, fragmentObject, VAO;
+
+        public ShaderTutorials()
+            : base(800, 600, GraphicsMode.Default, "HI", GameWindowFlags.Default,
+            DisplayDevice.Default, 2, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        {
+            
+        }
 
@@ -19,7 +28,21 @@ namespace AWGL
         {
-            base.OnLoad(e);
+            //base.OnLoad(e);
 
-            Title = AWUtils.PrintOpenGLInfo();
-            elapsedSeconds = 0;
+            // Shaders
+            shaderManager = new AWShaderManager("CH02_VS", "CH02_FS");
+            //vertexObject = AWUtils.BuildShader("CH02_VS", ShaderType.VertexShader);
 
+            int attachedShaders;
+            GL.GetProgram(shaderManager.ProgramID, GetProgramParameterName.AttachedShaders, out attachedShaders);
+
+            Console.WriteLine("Attached Shaders: " + attachedShaders);
+
+            // VAO Setup
+            GL.GenVertexArrays(1, out VAO);
+            GL.BindVertexArray(VAO);
+            
+
+            Title = AWUtils.PrintOpenGLInfo();
+            
+            // Timer Setup
             timer = new Timer(1000);
@@ -29,2 +52,10 @@ namespace AWGL
 
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+
+            GL.DeleteBuffer(VAO);
+            
+        }
+
         private void OnTimerElapsed(object sender, ElapsedEventArgs e)
@@ -36,13 +67,18 @@ namespace AWGL
         {
-            base.OnRenderFrame(e);
+            //base.OnRenderFrame(e);
 
-            float[] color = new float[] 
-            { 
-                (float)(Math.Sin(elapsedSeconds) * 0.5f + 0.5f), 
-                (float)(Math.Cos(elapsedSeconds) * 0.5f + 0.5f),
-                0.0f, 
-                1.0f 
-            };
+            Color4 color = new Color4(0.0f, 0.0f, 0.2f, 1.0f);            
+            
+            GL.ClearColor(color);
 
-            GL.ClearBuffer(ClearBuffer.Color, 0, color);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            // Use program object created by the shaderManager
+            GL.UseProgram(shaderManager.ProgramID);
+
+            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
+
+            ErrorCode err;
+            
+            err = GL.GetError();
 
@@ -50,2 +86,3 @@ namespace AWGL
         }
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cda71ecbdd44e1c8a1e575fd307c5d3aae264df1">successfully got vao working from example code</a>  -  cda71ec</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 5 files changed, 205 insertions(+), 73 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 00deea2..62e5e60 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -6,3 +6,4 @@ using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL4;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
 
@@ -18,3 +19,3 @@ namespace AWGL
         /// </summary>
-        private int vShader, fShader, linkedProgram;
+        private int vShader, fShader, programHandle;
 
@@ -72,3 +73,3 @@ namespace AWGL
                 GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
                 return -1;
@@ -84,13 +85,19 @@ namespace AWGL
         {
-            this.vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
-            this.fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
+            vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
+            fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
 
-            this.linkedProgram = GL.CreateProgram();
-            GL.AttachShader(linkedProgram, vShader);
-            GL.AttachShader(linkedProgram, fShader);
-            GL.LinkProgram(linkedProgram);
+            Debug.WriteLine(GL.GetShaderInfoLog(vShader));
+            Debug.WriteLine(GL.GetShaderInfoLog(fShader));
+
+            programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, vShader);
+            GL.AttachShader(programHandle, fShader);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
 
-            // Check linker success
             int linkSuccess;
-            GL.GetProgram(this.linkedProgram, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(this.programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -98,10 +105,13 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program link failed: " + message);
+                GL.GetProgramInfoLog(this.programHandle, out message);
+                Debug.WriteLine("Program link failed: " + message);
             }
 
-            // Validate program
+            #endregion
+
+            #region Validate Program
+
             int validateSuccess;
-            GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.ValidateProgram(this.programHandle);
+            GL.GetProgram(this.programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -109,5 +119,6 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program validation failed", message);
+                GL.GetProgramInfoLog(this.programHandle, out message);
+                Debug.WriteLine("Program validation failed", message);
             }
+            #endregion
 
@@ -120,6 +131,6 @@ namespace AWGL
         {
-            GL.DeleteProgram(this.linkedProgram);
+            GL.DeleteProgram(this.programHandle);
         }
 
-        public int ProgramID
+        public int ProgramHandle
         {
@@ -127,3 +138,3 @@ namespace AWGL
             {
-                return this.linkedProgram;
+                return this.programHandle;
             }
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 9b8c7df..6bd3868 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -3,2 +3,3 @@ using OpenTK.Graphics.OpenGL;
 using System;
+using System.Diagnostics;
 using System.IO;
@@ -54,3 +55,3 @@ namespace AWGL
                 GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
                 return -1;
@@ -82,3 +83,3 @@ namespace AWGL
                 GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program link failed: " + message);
+                Debug.WriteLine("Program link failed: " + message);
             }
@@ -93,3 +94,3 @@ namespace AWGL
                 GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program validation failed", message);
+                Debug.WriteLine("Program validation failed", message);
             }
@@ -166,3 +167,3 @@ namespace AWGL
             Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetLow = new Version(3, 0);
             Version m_TargetHigh = new Version(4, 1);
@@ -183,8 +184,6 @@ namespace AWGL
         {
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            Debug.WriteLine("Graphics card vendor: " + GL.GetString(StringName.Vendor));
+            Debug.WriteLine("Renderer: " + GL.GetString(StringName.Renderer));
+            Debug.WriteLine("Version: " + GL.GetString(StringName.Version));
+            Debug.WriteLine("Shading Language Version: " + GL.GetString(StringName.ShadingLanguageVersion));
             
@@ -192,3 +191,3 @@ namespace AWGL
 
-            return "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            return "AWGL Engine Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
new file mode 100644
index 0000000..46f2251
--- /dev/null
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -0,0 +1,17 @@
+﻿#version 130
+
+precision highp float;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(0.9, 0.9, 0.7);
+
+in vec3 normal;
+
+out vec4 out_frag_color;
+
+void main(void)
+{
+  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
+  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
new file mode 100644
index 0000000..3975262
--- /dev/null
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -0,0 +1,19 @@
+﻿#version 130
+
+precision highp float;
+
+uniform mat4 projection_matrix;
+uniform mat4 modelview_matrix;
+
+in vec3 in_position;
+in vec3 in_normal;
+
+out vec3 normal;
+
+void main(void)
+{
+  //works only for orthogonal modelview
+  normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  
+  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
+}
\ No newline at end of file
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 417ec4e..dc55df1 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -5,2 +5,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
@@ -14,10 +15,42 @@ namespace AWGL
     {
-        static Timer timer;
-        static double elapsedSeconds = 0;
-        static AWShaderManager shaderManager;
-        private int programObject, vertexObject, fragmentObject, VAO;
+        private AWShaderManager shaderManager;
+
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        private Vector3[] positionVboData = new Vector3[] {
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f)
+        };
+
+        private int[] indicesVboData = new int[]{
+             // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        Matrix4 projectionMatrix, modelviewMatrix;
 
         public ShaderTutorials()
-            : base(800, 600, GraphicsMode.Default, "HI", GameWindowFlags.Default,
-            DisplayDevice.Default, 2, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(800, 600, new GraphicsMode(), "", 0,
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         {
@@ -28,57 +61,110 @@ namespace AWGL
         {
-            //base.OnLoad(e);
+            base.OnLoad(e);
 
-            // Shaders
-            shaderManager = new AWShaderManager("CH02_VS", "CH02_FS");
-            //vertexObject = AWUtils.BuildShader("CH02_VS", ShaderType.VertexShader);
+            VSync = VSyncMode.On;
 
-            int attachedShaders;
-            GL.GetProgram(shaderManager.ProgramID, GetProgramParameterName.AttachedShaders, out attachedShaders);
-
-            Console.WriteLine("Attached Shaders: " + attachedShaders);
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
 
-            // VAO Setup
-            GL.GenVertexArrays(1, out VAO);
-            GL.BindVertexArray(VAO);
-            
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
 
             Title = AWUtils.PrintOpenGLInfo();
-            
-            // Timer Setup
-            timer = new Timer(1000);
-            timer.Elapsed += new ElapsedEventHandler(OnTimerElapsed);
-            timer.Enabled = true;
         }
 
-        protected override void OnUnload(EventArgs e)
+        private void CreateShaders()
         {
-            base.OnUnload(e);
+            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
 
-            GL.DeleteBuffer(VAO);
-            
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            // Set uniforms
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+
+            int attachedShaders;
+            GL.GetProgram(shaderManager.ProgramHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            Debug.WriteLine("/nAttached Shaders: " + attachedShaders);
         }
 
-        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
+        private void CreateVBOs()
         {
-            elapsedSeconds++;
+            GL.GenBuffers(1, out positionVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out normalVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer,
+                new IntPtr(sizeof(uint) * indicesVboData.Length),
+                indicesVboData, BufferUsageHint.StaticDraw);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
 
-        protected override void OnRenderFrame(FrameEventArgs e)
+        private void CreateVAOs()
         {
-            //base.OnRenderFrame(e);
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+            GL.GenVertexArrays(1, out vaoHandle);
+            GL.BindVertexArray(vaoHandle);
+
+            GL.EnableVertexAttribArray(0);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
+
+            GL.EnableVertexAttribArray(1);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        }
 
-            Color4 color = new Color4(0.0f, 0.0f, 0.2f, 1.0f);            
-            
-            GL.ClearColor(color);
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
-            // Use program object created by the shaderManager
-            GL.UseProgram(shaderManager.ProgramID);
+            if (Keyboard[OpenTK.Input.Key.Escape])
+                Exit();
+        }
 
-            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
 
-            ErrorCode err;
-            
-            err = GL.GetError();
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(PrimitiveType.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0d0da7559fc7816218569d27925192be0f4c4830">Half complete implementation of HelloGL3. This will be used as a starting point for full support of OpenGL 3.3 Core Profle by the engine.</a>  -  0d0da75</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 3 files changed, 127 insertions(+), 93 deletions(-)

diff --git a/AWGL/Data/Shaders/spincube-fs.glsl b/AWGL/Data/Shaders/spincube-fs.glsl
new file mode 100644
index 0000000..a8d60b9
--- /dev/null
+++ b/AWGL/Data/Shaders/spincube-fs.glsl
@@ -0,0 +1,13 @@
+#version 330 core                                                  
+                                                                               
+out vec4 color;                                                    
+                                                                               
+in VS_OUT                                                          
+{                                                                  
+    vec4 color;                                                    
+} fs_in;                                                           
+                                                                               
+void main(void)                                                    
+{                                                                  
+    color = fs_in.color;                                           
+}    
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-vs.glsl b/AWGL/Data/Shaders/spincube-vs.glsl
new file mode 100644
index 0000000..9de1ae1
--- /dev/null
+++ b/AWGL/Data/Shaders/spincube-vs.glsl
@@ -0,0 +1,17 @@
+#version 330 core                                                   
+                                                                                
+in vec4 position;                                                   
+                                                                                
+out VS_OUT                                                          
+{                                                                   
+    vec4 color;                                                     
+} vs_out;                                                           
+                                                                                
+uniform mat4 mv_matrix;                                             
+uniform mat4 proj_matrix;                                           
+                                                                                
+void main(void)                                                     
+{                                                                   
+    gl_Position = proj_matrix * mv_matrix * position;               
+    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
+}   
\ No newline at end of file
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index dc55df1..6e6b5af 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -19,34 +19,8 @@ namespace AWGL
             projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        private Vector3[] positionVboData = new Vector3[] {
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f)
-        };
-
-        private int[] indicesVboData = new int[]{
-             // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
+            buffer,
+            vao,
+            mv_location,
+            proj_location;
 
-        Matrix4 projectionMatrix, modelviewMatrix;
+        Matrix4 proj_matrix, modelviewMatrix;
 
@@ -59,2 +33,53 @@ namespace AWGL
 
+        private Vector3[] vertex_positions = new Vector3[]
+        {
+            new Vector3(0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f, -0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+            new Vector3(0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f, -0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f,  0.25f),
+
+            new Vector3(-0.25f,  0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3( 0.25f,  0.25f,  0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+            new Vector3(0.25f,  0.25f, -0.25f)
+        };
+
         protected override void OnLoad(EventArgs e)
@@ -66,7 +91,21 @@ namespace AWGL
             CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
 
-            // Other state
+            GL.GenVertexArrays(1, out vao);
+            GL.BindVertexArray(vao);
+
+            GL.GenBuffers(1, out buffer);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer);
+            GL.BufferData(BufferTarget.ArrayBuffer,
+                         new IntPtr(vertex_positions.Length * Vector3.SizeInBytes),
+                         vertex_positions,
+                         BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, Vector3.SizeInBytes, 0);
+            GL.EnableVertexAttribArray(0);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Cw);
+
             GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Lequal);
+
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
@@ -87,6 +126,6 @@ namespace AWGL
             float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
             modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
             GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
@@ -98,51 +137,3 @@ namespace AWGL
 
-        private void CreateVBOs()
-        {
-            GL.GenBuffers(1, out positionVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out normalVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out eboHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer,
-                new IntPtr(sizeof(uint) * indicesVboData.Length),
-                indicesVboData, BufferUsageHint.StaticDraw);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
-
-        private void CreateVAOs()
-        {
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-            GL.GenVertexArrays(1, out vaoHandle);
-            GL.BindVertexArray(vaoHandle);
-
-            GL.EnableVertexAttribArray(0);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
-
-            GL.EnableVertexAttribArray(1);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
+       protected override void OnUpdateFrame(FrameEventArgs e)
         {
@@ -150,6 +141,2 @@ namespace AWGL
 
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-
             if (Keyboard[OpenTK.Input.Key.Escape])
@@ -162,9 +149,26 @@ namespace AWGL
 
+            float[] green = { 0.0f, 0.25f, 0.0f, 1.0f };
+            float one = 1.0f;
+
             GL.Viewport(0, 0, Width, Height);
+            GL.ClearBuffer(ClearBuffer.Color, 0, green);
+            GL.ClearBuffer(ClearBuffer.Depth, 0, ref one);
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(PrimitiveType.Triangles, indicesVboData.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.UniformMatrix4(proj_location, 1, false, proj_matrix);
+
+            int i;
+            for (i = 0; i < 24; i++)
+            {
+                float f = (float)i + (float)currentTime * 0.3f;
+                vmath::mat4 mv_matrix = vmath::translate(0.0f, 0.0f, -6.0f) *
+                                        vmath::rotate((float)currentTime * 45.0f, 0.0f, 1.0f, 0.0f) *
+                                        vmath::rotate((float)currentTime * 21.0f, 1.0f, 0.0f, 0.0f) *
+                                        vmath::translate(sinf(2.1f * f) * 2.0f,
+                                                         cosf(1.7f * f) * 2.0f,
+                                                         sinf(1.3f * f) * cosf(1.5f * f) * 2.0f);
+                GL.UniformMatrix4fv(mv_location, 1, GL_FALSE, mv_matrix);
+                GL.DrawArrays(GL_TRIANGLES, 0, 36);
+            }
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/171bcd8fe60c4c8705d9cd5df819e1ca219728d1">Removing test app.</a>  -  171bcd8</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 57 deletions(-)

diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
deleted file mode 100644
index 2cceac7..0000000
--- a/TestApplication/Program.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-using AWGL;
-using AWGL.Scene;
-
-namespace TestApplication
-{
-    class Program
-    {
-
-        [STAThread]
-        public static void Main(string[] args)
-        {
-            OGL.Run();
-        }
-    }
-}
deleted file mode 100644
index 5e3ef72..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("TestApplication")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("TestApplication")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("3b8899cd-4523-439e-892a-a7ecfc8390ed")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6aadb894ebeee6107e0d0fb3ffc29557d37318e9">More Trial and Error.</a>  -  6aadb89</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 30 insertions(+), 24 deletions(-)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 6e6b5af..0656286 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -17,5 +17,3 @@ namespace AWGL
 
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            buffer,
+        int buffer,
             vao,
@@ -24,3 +22,5 @@ namespace AWGL
 
-        Matrix4 proj_matrix, modelviewMatrix;
+        Matrix4 proj_matrix, mv_matrix;
+
+        float aspectRatio;
 
@@ -119,14 +119,12 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.ProgramHandle);
-
             // Set uniforms
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            mv_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            proj_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
 
-            float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
-            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+            //aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            //Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
+            //mv_matrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            //GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
 
@@ -137,3 +135,11 @@ namespace AWGL
 
-       protected override void OnUpdateFrame(FrameEventArgs e)
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 0.1f, 1000.0f, out proj_matrix); 
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
         {
@@ -158,3 +164,3 @@ namespace AWGL
 
-            GL.UniformMatrix4(proj_location, 1, false, proj_matrix);
+            GL.UniformMatrix4(proj_location, false, ref proj_matrix);   //(proj_location, 1, false, proj_matrix); ??
 
@@ -163,11 +169,11 @@ namespace AWGL
             {
-                float f = (float)i + (float)currentTime * 0.3f;
-                vmath::mat4 mv_matrix = vmath::translate(0.0f, 0.0f, -6.0f) *
-                                        vmath::rotate((float)currentTime * 45.0f, 0.0f, 1.0f, 0.0f) *
-                                        vmath::rotate((float)currentTime * 21.0f, 1.0f, 0.0f, 0.0f) *
-                                        vmath::translate(sinf(2.1f * f) * 2.0f,
-                                                         cosf(1.7f * f) * 2.0f,
-                                                         sinf(1.3f * f) * cosf(1.5f * f) * 2.0f);
-                GL.UniformMatrix4fv(mv_location, 1, GL_FALSE, mv_matrix);
-                GL.DrawArrays(GL_TRIANGLES, 0, 36);
+                float f = (float)i + (float)e.Time * 0.3f;
+                mv_matrix = Matrix4.CreateTranslation(0.0f, 0.0f, -6.0f) *
+                                        Matrix4.CreateRotationY((float)e.Time * 45.0f) *
+                                        Matrix4.CreateRotationX((float)e.Time * 21.0f) *
+                                        Matrix4.CreateTranslation((float)Math.Sin(2.1f * f) * 2.0f,
+                                                         (float)(Math.Cos(1.7f * f) * 2.0f),
+                                                         (float)(Math.Sin(1.3f * f) * (float)(Math.Cos(1.5f * f) * 2.0f)));
+                GL.UniformMatrix4(mv_location, false, ref mv_matrix);
+                GL.DrawArrays(PrimitiveType.Triangles, 0, 36);
             }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a3273f159d50049a14d0d294d4d5c6a51a71a333">- Logger. - Refactor of Application Name</a>  -  a3273f1</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 8 files changed, 103 insertions(+), 62 deletions(-)

diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
new file mode 100644
index 0000000..0e08d78
--- /dev/null
+++ b/AWGL/AWEngine.cs
@@ -0,0 +1,40 @@
+﻿using AWGL.Scene;
+using OpenTK;
+using System;
+using System.Drawing;
+
+namespace AWGL
+{
+    public sealed class AWEngine
+    {
+        private static AWEngine instance = new AWEngine();
+
+        private AWEngine()
+        {
+        }
+
+        public static AWEngine getInstance()
+        {
+            return instance;
+        }
+
+        [STAThread]
+        public static void Main()
+        {
+            using (ShaderTutorials game = new ShaderTutorials())
+            {
+                game.Run(30,0);
+            }
+        }
+
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+            
+        }
+    }
+}
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
new file mode 100644
index 0000000..df611ff
--- /dev/null
+++ b/AWGL/AWLogger.cs
@@ -0,0 +1,53 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    internal static class AWLogger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 62e5e60..b7067ee 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -65,14 +65,4 @@ namespace AWGL
 
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
+            AWLogger.ShaderInfo(shaderHandle);
+            
             return shaderHandle;
@@ -88,5 +78,2 @@ namespace AWGL
 
-            Debug.WriteLine(GL.GetShaderInfoLog(vShader));
-            Debug.WriteLine(GL.GetShaderInfoLog(fShader));
-
             programHandle = GL.CreateProgram();
@@ -134,3 +121,3 @@ namespace AWGL
 
-        public int ProgramHandle
+        public int Program
         {
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 6bd3868..66624c7 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -184,6 +184,2 @@ namespace AWGL
         {
-            Debug.WriteLine("Graphics card vendor: " + GL.GetString(StringName.Vendor));
-            Debug.WriteLine("Renderer: " + GL.GetString(StringName.Renderer));
-            Debug.WriteLine("Version: " + GL.GetString(StringName.Version));
-            Debug.WriteLine("Shading Language Version: " + GL.GetString(StringName.ShadingLanguageVersion));
             
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 27a08e1..fb9ae28 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -91,3 +91,3 @@ namespace AWGL.Scene
 
-            Title = AWUtils.PrintOpenGLInfo();
+            //Title = AWUtils.PrintOpenGLInfo();
 
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
deleted file mode 100644
index c5cb1b2..0000000
--- a/AWGL/OGL.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-﻿using AWGL.Scene;
-using OpenTK;
-using System;
-using System.Drawing;
-
-namespace AWGL
-{
-    public sealed class OGL
-    {
-        private static OGL instance = new OGL();
-
-        private OGL()
-        {
-        }
-
-        public static OGL getInstance()
-        {
-            return instance;
-        }
-
-        [STAThread]
-        public static void Main()
-        {
-            using (ShaderTutorials game = new ShaderTutorials())
-            {
-                game.Run(30,0);
-            }
-        }
-        
-    }
-}
diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
index 6635235..09747c3 100644
--- a/AWGL/Scene/AWCube.cs
+++ b/AWGL/Scene/AWCube.cs
@@ -46,3 +46,3 @@ namespace AWGL
             vbo = new Vbo();
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+            //vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 0656286..855ec06 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -30,3 +30,3 @@ namespace AWGL
         {
-            
+            AWLogger.PlatformInfo();
         }
@@ -112,3 +112,3 @@ namespace AWGL
 
-            Title = AWUtils.PrintOpenGLInfo();
+            Title = AWEngine.AppName + " Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
@@ -120,4 +120,4 @@ namespace AWGL
             // Set uniforms
-            mv_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            proj_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            mv_location = GL.GetUniformLocation(shaderManager.Program, "projection_matrix");
+            proj_location = GL.GetUniformLocation(shaderManager.Program, "modelview_matrix");
 
@@ -129,6 +129,2 @@ namespace AWGL
             //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
-
-            int attachedShaders;
-            GL.GetProgram(shaderManager.ProgramHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            Debug.WriteLine("/nAttached Shaders: " + attachedShaders);
         }
@@ -162,3 +158,3 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.ProgramHandle);
+            GL.UseProgram(shaderManager.Program);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3b812a849fc30e27f6f4ca967fd4ee054de55780">minor tweaks</a>  -  3b812a8</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 855ec06..6c5561f 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -33,2 +33,4 @@ namespace AWGL
 
+        #region Vector3[] vertex_positions
+
         private Vector3[] vertex_positions = new Vector3[]
@@ -83,2 +85,4 @@ namespace AWGL
         };
+        
+        #endregion
 
@@ -112,3 +116,3 @@ namespace AWGL
 
-            Title = AWEngine.AppName + " Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            Title = AWEngine.AppName + " Prototype: " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
@@ -151,3 +155,3 @@ namespace AWGL
 
-            float[] green = { 0.0f, 0.25f, 0.0f, 1.0f };
+            float[] green = { 0.0f, 0.25f, 0.60f, 1.0f };
             float one = 1.0f;
@@ -163,3 +167,3 @@ namespace AWGL
             int i;
-            for (i = 0; i < 24; i++)
+            for (i = 0; i < 2; i++)
             {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9d7e1c35fa8aecbb96fb9c2ae8ce67344149b530">Still works.</a>  -  9d7e1c3</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 120 insertions(+), 129 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b7067ee..faec827 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -8,2 +8,4 @@ using OpenTK.Graphics.OpenGL;
 using System.Diagnostics;
+using OpenTK;
+using System.Drawing;
 
@@ -128,2 +130,15 @@ namespace AWGL
         }
+
+        internal void SetUniforms(out int projMatrixHandle, out int mvMatrixHandle, out Matrix4 projMatrix, out Matrix4 mvMatrix, Size dimensions)
+        {
+            projMatrixHandle = GL.GetUniformLocation(this.Program, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.Program, "modelview_matrix");
+
+            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+            mvMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+
+            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        }
     }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 6c5561f..897f53f 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -15,79 +15,47 @@ namespace AWGL
     {
-        private AWShaderManager shaderManager;
 
-        int buffer,
-            vao,
-            mv_location,
-            proj_location;
-
-        Matrix4 proj_matrix, mv_matrix;
-
-        float aspectRatio;
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Vector3[] positionVboData = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) };
+
+        int[] indicesVboData = new int[]{
+             // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, };
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        AWShaderManager shaderManager;
 
         public ShaderTutorials()
-            : base(800, 600, new GraphicsMode(), "", 0,
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        {
-            AWLogger.PlatformInfo();
-        }
-
-        #region Vector3[] vertex_positions
-
-        private Vector3[] vertex_positions = new Vector3[]
-        {
-            new Vector3(0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f, -0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-            new Vector3(0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f, -0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f,  0.25f),
-
-            new Vector3(-0.25f,  0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3( 0.25f,  0.25f,  0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-            new Vector3(0.25f,  0.25f, -0.25f)
-        };
+            : base(800, 600,
+            new GraphicsMode(), "OpenGL 3 Example", 0,
+            DisplayDevice.Default, 3, 0,
+            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
         
-        #endregion
-
-        protected override void OnLoad(EventArgs e)
+        protected override void OnLoad (System.EventArgs e)
         {
-            base.OnLoad(e);
-
             VSync = VSyncMode.On;
@@ -95,27 +63,11 @@ namespace AWGL
             CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
 
-            GL.GenVertexArrays(1, out vao);
-            GL.BindVertexArray(vao);
-
-            GL.GenBuffers(1, out buffer);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer);
-            GL.BufferData(BufferTarget.ArrayBuffer,
-                         new IntPtr(vertex_positions.Length * Vector3.SizeInBytes),
-                         vertex_positions,
-                         BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, Vector3.SizeInBytes, 0);
-            GL.EnableVertexAttribArray(0);
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Cw);
-
+            // Other state
             GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Lequal);
-
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
-
-            Title = AWEngine.AppName + " Prototype: " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
 
-        private void CreateShaders()
+        void CreateShaders()
         {
@@ -123,20 +75,60 @@ namespace AWGL
 
-            // Set uniforms
-            mv_location = GL.GetUniformLocation(shaderManager.Program, "projection_matrix");
-            proj_location = GL.GetUniformLocation(shaderManager.Program, "modelview_matrix");
+            GL.UseProgram(shaderManager.Program);
 
-            //aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            //Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
-            //mv_matrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+            shaderManager.SetUniforms
+            (
+                out projectionMatrixLocation,
+                out modelviewMatrixLocation,
+                out projectionMatrix,
+                out modelviewMatrix,
+                ClientSize
+            );
+        }
 
-            //GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
+        void CreateVBOs()
+        {
+            GL.GenBuffers(1, out positionVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out normalVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer,
+                new IntPtr(sizeof(uint) * indicesVboData.Length),
+                indicesVboData, BufferUsageHint.StaticDraw);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
 
-        protected override void OnResize(EventArgs e)
+        void CreateVAOs()
         {
-            base.OnResize(e);
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+            GL.GenVertexArrays(1, out vaoHandle);
+            GL.BindVertexArray(vaoHandle);
+
+            GL.EnableVertexAttribArray(0);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.Program, 0, "in_position");
+
+            GL.EnableVertexAttribArray(1);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.Program, 1, "in_normal");
 
-            aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 0.1f, 1000.0f, out proj_matrix); 
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
         }
@@ -145,3 +137,5 @@ namespace AWGL
         {
-            base.OnUpdateFrame(e);
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
@@ -153,28 +147,9 @@ namespace AWGL
         {
-            base.OnRenderFrame(e);
-
-            float[] green = { 0.0f, 0.25f, 0.60f, 1.0f };
-            float one = 1.0f;
-
             GL.Viewport(0, 0, Width, Height);
-            GL.ClearBuffer(ClearBuffer.Color, 0, green);
-            GL.ClearBuffer(ClearBuffer.Depth, 0, ref one);
+            
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
-            GL.UseProgram(shaderManager.Program);
-
-            GL.UniformMatrix4(proj_location, false, ref proj_matrix);   //(proj_location, 1, false, proj_matrix); ??
-
-            int i;
-            for (i = 0; i < 2; i++)
-            {
-                float f = (float)i + (float)e.Time * 0.3f;
-                mv_matrix = Matrix4.CreateTranslation(0.0f, 0.0f, -6.0f) *
-                                        Matrix4.CreateRotationY((float)e.Time * 45.0f) *
-                                        Matrix4.CreateRotationX((float)e.Time * 21.0f) *
-                                        Matrix4.CreateTranslation((float)Math.Sin(2.1f * f) * 2.0f,
-                                                         (float)(Math.Cos(1.7f * f) * 2.0f),
-                                                         (float)(Math.Sin(1.3f * f) * (float)(Math.Cos(1.5f * f) * 2.0f)));
-                GL.UniformMatrix4(mv_location, false, ref mv_matrix);
-                GL.DrawArrays(PrimitiveType.Triangles, 0, 36);
-            }
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(BeginMode.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -183,2 +158,3 @@ namespace AWGL
 
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ed51c898af59b489392f18ace7153f633c92bf7e">Refactoring of shader manager.</a>  -  ed51c89</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 64 insertions(+), 56 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index faec827..b11f15e 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -18,31 +18,34 @@ namespace AWGL
     {
-        /// <summary>
-        /// Shader Pointers
-        /// </summary>
-        private int vShader, fShader, programHandle;
+        #region Private Members
+
+        // Handles
+        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
 
         private string defaultDataPath = "Data/Shaders/";
-        private string m_vsFilePath, m_fsFilePath;
+        private string m_vertexShaderPath = "Simple_VS";
+        private string m_fragmentShaderPath = "Simple_FS";
+        
+        #endregion
 
-        public AWShaderManager(string vs_path, string fs_path)
-        {
-            this.m_vsFilePath = vs_path;
-            this.m_fsFilePath = fs_path;
-            BuildProgram();
+        #region Contructors
+
+        public AWShaderManager() 
+        { 
+            m_programHandle = BuildProgram(); 
         }
 
-        public AWShaderManager()
+        public AWShaderManager(string vertexShaderPath, string fragmentShaderPath)
         {
-            this.m_vsFilePath   = "Simple_VS";
-            this.m_fsFilePath   = "Simple_FS";
+            m_vertexShaderPath = vertexShaderPath;
+            m_fragmentShaderPath = fragmentShaderPath;
+            m_programHandle = BuildProgram();
         }
+        
+        #endregion
+
+        #region Shader and Program Contruction Methods
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename">Shader Filename</param>
-        /// <returns>Shader Source Code</returns>
-        private string LoadShader(string filename) 
+        internal string LoadShader(string shaderSourcePath)
         {
-            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
             {
@@ -51,10 +54,4 @@ namespace AWGL
         }
-        
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <param name="shaderType"></param>
-        /// <returns></returns>
-        private int BuildShader(string filename, ShaderType shaderType)
+
+        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
         {
@@ -62,3 +59,3 @@ namespace AWGL
             int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(filename));
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
 
@@ -68,3 +65,3 @@ namespace AWGL
             AWLogger.ShaderInfo(shaderHandle);
-            
+
             return shaderHandle;
@@ -72,14 +69,11 @@ namespace AWGL
 
-        /// <summary>
-        /// 
-        /// </summary>
-        private void BuildProgram() 
+        internal int BuildProgram()
         {
-            vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
-            fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
+            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
 
-            programHandle = GL.CreateProgram();
+            int programHandle = GL.CreateProgram();
 
-            GL.AttachShader(programHandle, vShader);
-            GL.AttachShader(programHandle, fShader);
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
 
@@ -90,3 +84,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(this.programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -94,3 +88,3 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.programHandle, out message);
+                GL.GetProgramInfoLog(programHandle, out message);
                 Debug.WriteLine("Program link failed: " + message);
@@ -103,4 +97,4 @@ namespace AWGL
             int validateSuccess;
-            GL.ValidateProgram(this.programHandle);
-            GL.GetProgram(this.programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -108,3 +102,3 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.programHandle, out message);
+                GL.GetProgramInfoLog(programHandle, out message);
                 Debug.WriteLine("Program validation failed", message);
@@ -114,5 +108,11 @@ namespace AWGL
             // Delete the shaders as the program has them now
-            GL.DeleteShader(vShader);
-            GL.DeleteShader(fShader);
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
         }
+        
+        #endregion
+
+        #region IDisposable
 
@@ -120,6 +120,10 @@ namespace AWGL
         {
-            GL.DeleteProgram(this.programHandle);
+            GL.DeleteProgram(m_programHandle);
         }
+        
+        #endregion
+
+        #region Public Methods
 
-        public int Program
+        public int ProgramHandle
         {
@@ -127,3 +131,3 @@ namespace AWGL
             {
-                return this.programHandle;
+                return m_programHandle;
             }
@@ -131,6 +135,9 @@ namespace AWGL
 
-        internal void SetUniforms(out int projMatrixHandle, out int mvMatrixHandle, out Matrix4 projMatrix, out Matrix4 mvMatrix, Size dimensions)
+        public void SetUniforms(
+            out int projMatrixHandle, out int mvMatrixHandle,
+            out Matrix4 projMatrix, out Matrix4 mvMatrix,
+            Size dimensions)
         {
-            projMatrixHandle = GL.GetUniformLocation(this.Program, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.Program, "modelview_matrix");
+            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
 
@@ -142,3 +149,4 @@ namespace AWGL
             GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        }
+        } 
+        #endregion
     }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 897f53f..bd9c1fd 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -75,3 +75,3 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.Program);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
@@ -123,3 +123,3 @@ namespace AWGL
             GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.Program, 0, "in_position");
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
 
@@ -128,3 +128,3 @@ namespace AWGL
             GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.Program, 1, "in_normal");
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e683e2c5c952a9aa8a41c2eb9477c08de4e93a19">Success.</a>  -  e683e2c</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 97 insertions(+), 34 deletions(-)

diff --git a/AWGL/AWBufferManager_2.cs b/AWGL/AWBufferManager_2.cs
new file mode 100644
index 0000000..9f0966e
--- /dev/null
+++ b/AWGL/AWBufferManager_2.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    class AWBufferManager
+    {
+        internal void SetupBuffer(
+            out int handle, Vector3[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupBuffer(
+            out int handle, int[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType, 
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal void GenerateVaoBuffer(out int handle)
+        {
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+        }
+    }
+}
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index bd9c1fd..f4eba04 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿
+using OpenTK;
 using OpenTK.Graphics;
@@ -50,2 +51,3 @@ namespace AWGL
         AWShaderManager shaderManager;
+        AWBufferManager bufferManager;
 
@@ -77,4 +79,3 @@ namespace AWGL
 
-            shaderManager.SetUniforms
-            (
+            shaderManager.SetUniforms(
                 out projectionMatrixLocation,
@@ -89,19 +90,21 @@ namespace AWGL
         {
-            GL.GenBuffers(1, out positionVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out normalVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out eboHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer,
-                new IntPtr(sizeof(uint) * indicesVboData.Length),
-                indicesVboData, BufferUsageHint.StaticDraw);
+            bufferManager = new AWBufferManager();
+
+            bufferManager.SetupBuffer(
+                out positionVboHandle, positionVboData, 
+                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw);
+
+            bufferManager.SetupBuffer(
+                out normalVboHandle,
+                positionVboData,
+                BufferTarget.ArrayBuffer,
+                BufferUsageHint.StaticDraw
+                );
+
+            bufferManager.SetupBuffer(
+                out eboHandle,
+                indicesVboData,  //indicesVboData, // change this!!!
+                BufferTarget.ElementArrayBuffer,
+                BufferUsageHint.StaticDraw
+                );
 
@@ -117,14 +120,20 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
-            GL.GenVertexArrays(1, out vaoHandle);
-            GL.BindVertexArray(vaoHandle);
-
-            GL.EnableVertexAttribArray(0);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
-
-            GL.EnableVertexAttribArray(1);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
+            bufferManager.GenerateVaoBuffer(out vaoHandle);
+            bufferManager.SetupVaoBuffer(
+                BufferTarget.ArrayBuffer, 
+                positionVboHandle,
+                shaderManager.ProgramHandle,
+                "in_position",
+                VertexAttribPointerType.Float,
+                0, 3
+                );
+
+            bufferManager.SetupVaoBuffer(
+                BufferTarget.ArrayBuffer, 
+                normalVboHandle, 
+                shaderManager.ProgramHandle, 
+                "in_normal", 
+                VertexAttribPointerType.Float, 
+                1, 3
+                );
 
@@ -152,4 +161,6 @@ namespace AWGL
             GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(BeginMode.Triangles, indicesVboData.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(
+                PrimitiveType.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero
+                );
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e95349ec47c5f73182a27b530b099bbffa3ec609">~</a>  -  e95349e</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 83 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
deleted file mode 100644
index 3b297f7..0000000
--- a/AWGL/AWBufferManager.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class AWBufferManager : IDisposable
-    {
-        #region
-        // To create a VBO:
-        // 1) Generate the buffer handles for the vertex and element buffers.
-        // 2) Bind the vertex buffer handle and upload your vertex data. 
-        //    Check that the buffer was uploaded correctly.
-        // 3) Bind the element buffer handle and upload your element data. 
-        //    Check that the buffer was uploaded correctly.
-        #endregion
-
-        private Vbo vboHandle;
-
-        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements,
-                                           int elementSize,
-                                           int typeSize,
-                                           BufferUsageHint bufferUsageTypeGL)
-            where TVertex : struct
-        {
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            CheckForErrors(vbo_Size);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.EboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            CheckForErrors(ebo_Size);
-
-            return this.vboHandle;
-        }
-
-        private static void CheckForErrors(int size)
-        {
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != size)
-                throw new Exception("Data not uploaded correctly");
-        }
-
-        public Vbo getBufferObjects(DrawableShape shape)
-        {
-            return new Vbo();//GenerateVBO(
-        }
-
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d475fdbc0f0100103f998909a513af3b59f70269">~</a>  -  d475fdb</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 52 insertions(+), 52 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
new file mode 100644
index 0000000..9f0966e
--- /dev/null
+++ b/AWGL/AWBufferManager.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    class AWBufferManager
+    {
+        internal void SetupBuffer(
+            out int handle, Vector3[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupBuffer(
+            out int handle, int[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType, 
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal void GenerateVaoBuffer(out int handle)
+        {
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+        }
+    }
+}
diff --git a/AWGL/AWBufferManager_2.cs b/AWGL/AWBufferManager_2.cs
deleted file mode 100644
index 9f0966e..0000000
--- a/AWGL/AWBufferManager_2.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    class AWBufferManager
-    {
-        internal void SetupBuffer(
-            out int handle, Vector3[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-        }
-
-        internal void SetupBuffer(
-            out int handle, int[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-        }
-
-        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, positionVboHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType, 
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal void GenerateVaoBuffer(out int handle)
-        {
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/994c1813e9b6eb81217edf947f3ef872ffb90115">Moved Login to buffermanager.</a>  -  994c181</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 14 insertions(+), 27 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 9f0966e..a780b4d 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -35,6 +35,8 @@ namespace AWGL
 
-        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        internal void SetupVaoBuffer(
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
+            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
         {
             GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.BindBuffer(bufferTarget, bufferHandle);
             GL.VertexAttribPointer(
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index f4eba04..9e0992b 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -80,7 +80,4 @@ namespace AWGL
             shaderManager.SetUniforms(
-                out projectionMatrixLocation,
-                out modelviewMatrixLocation,
-                out projectionMatrix,
-                out modelviewMatrix,
-                ClientSize
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, out modelviewMatrix, ClientSize
             );
@@ -97,6 +94,4 @@ namespace AWGL
             bufferManager.SetupBuffer(
-                out normalVboHandle,
-                positionVboData,
-                BufferTarget.ArrayBuffer,
-                BufferUsageHint.StaticDraw
+                out normalVboHandle, positionVboData,
+                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -104,6 +99,4 @@ namespace AWGL
             bufferManager.SetupBuffer(
-                out eboHandle,
-                indicesVboData,  //indicesVboData, // change this!!!
-                BufferTarget.ElementArrayBuffer,
-                BufferUsageHint.StaticDraw
+                out eboHandle, indicesVboData, 
+                BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -122,8 +115,4 @@ namespace AWGL
             bufferManager.SetupVaoBuffer(
-                BufferTarget.ArrayBuffer, 
-                positionVboHandle,
-                shaderManager.ProgramHandle,
-                "in_position",
-                VertexAttribPointerType.Float,
-                0, 3
+                positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );
@@ -131,8 +120,4 @@ namespace AWGL
             bufferManager.SetupVaoBuffer(
-                BufferTarget.ArrayBuffer, 
-                normalVboHandle, 
-                shaderManager.ProgramHandle, 
-                "in_normal", 
-                VertexAttribPointerType.Float, 
-                1, 3
+                normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e10e3a49b84b0f61cd7c4ce4480d47bbef00eb5f">Better buffer manager.</a>  -  e10e3a4</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 51 insertions(+), 42 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index a780b4d..4cbeb61 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -9,8 +9,30 @@ namespace AWGL
 {
-    class AWBufferManager
+    public sealed class AWBufferManager
     {
-        internal void SetupBuffer(
-            out int handle, Vector3[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        private static volatile AWBufferManager instance = new AWBufferManager();
+        private static object syncRoot = new Object();
+
+        private AWBufferManager() { }
+
+        public static AWBufferManager Instance
+        {
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new AWBufferManager();
+                    }
+                }
+
+                return instance;
+            }
+        }
+
+        internal static int SetupBuffer(
+            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
         {
+            int handle;
             GL.GenBuffers(1, out handle);
@@ -21,8 +43,9 @@ namespace AWGL
                 );
+            return handle;
         }
 
-        internal void SetupBuffer(
-            out int handle, int[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        internal static int SetupBuffer(
+            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
         {
+            int handle;
             GL.GenBuffers(1, out handle);
@@ -33,5 +56,6 @@ namespace AWGL
                 );
+            return handle;
         }
 
-        internal void SetupVaoBuffer(
+        internal static void SetupVaoBuffer(
             int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
@@ -47,6 +71,8 @@ namespace AWGL
 
-        internal void GenerateVaoBuffer(out int handle)
+        internal static int GenerateVaoBuffer()
         {
+            int handle;
             GL.GenVertexArrays(1, out handle);
             GL.BindVertexArray(handle);
+            return handle;
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 9e0992b..801089c 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -24,26 +24,2 @@ namespace AWGL
 
-        Vector3[] positionVboData = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) };
-
-        int[] indicesVboData = new int[]{
-             // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, };
-
         Matrix4 projectionMatrix, modelviewMatrix;
@@ -51,3 +27,7 @@ namespace AWGL
         AWShaderManager shaderManager;
-        AWBufferManager bufferManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
 
@@ -64,2 +44,6 @@ namespace AWGL
 
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+
             CreateShaders();
@@ -87,5 +71,4 @@ namespace AWGL
         {
-            bufferManager = new AWBufferManager();
-
-            bufferManager.SetupBuffer(
+            
+            AWBufferManager.SetupBuffer(
                 out positionVboHandle, positionVboData, 
@@ -93,3 +76,3 @@ namespace AWGL
 
-            bufferManager.SetupBuffer(
+            AWBufferManager.SetupBuffer(
                 out normalVboHandle, positionVboData,
@@ -98,3 +81,3 @@ namespace AWGL
 
-            bufferManager.SetupBuffer(
+            AWBufferManager.SetupBuffer(
                 out eboHandle, indicesVboData, 
@@ -113,4 +96,4 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
-            bufferManager.GenerateVaoBuffer(out vaoHandle);
-            bufferManager.SetupVaoBuffer(
+            vaoHandle = AWBufferManager.GenerateVaoBuffer();
+            AWBufferManager.SetupVaoBuffer(
                 positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
@@ -119,3 +102,3 @@ namespace AWGL
 
-            bufferManager.SetupVaoBuffer(
+            AWBufferManager.SetupVaoBuffer(
                 normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fcad613fcd3e4ec8bdde32eb25b9464c4b68ed70">Buffer Manager</a>  -  fcad613</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 5 files changed, 120 insertions(+), 90 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 4cbeb61..9c673a8 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -59,2 +59,12 @@ namespace AWGL
 
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="bufferHandle"></param>
+        /// <param name="ProgramHandle"></param>
+        /// <param name="index"></param>
+        /// <param name="size"></param>
+        /// <param name="attributeName"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="vertexAttribPointerType"></param>
         internal static void SetupVaoBuffer(
diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
new file mode 100644
index 0000000..3409e23
--- /dev/null
+++ b/AWGL/AWCube.cs
@@ -0,0 +1,65 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public static Vector3[] Vertices 
+        {
+            get { return CubeVertices; }
+        }
+
+        public static int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+        }
+
+    }
+}
diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
deleted file mode 100644
index 09747c3..0000000
--- a/AWGL/Scene/AWCube.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWCube : AWNode
-    {
-        #region Private Members
-        private Cube Cube;
-
-        private Vbo vbo;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.Khaki),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Black),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Black),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.Khaki), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Black),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Black) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public AWCube()
-        {
-            vbo = new Vbo();
-            //vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Render()
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-            
-            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
index 39bef32..4341e13 100644
--- a/AWGL/Scene/AWNode.cs
+++ b/AWGL/Scene/AWNode.cs
@@ -10,2 +10,9 @@ namespace AWGL
     {
+        protected AWBufferManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
         public abstract void Render();
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 801089c..7088979 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -55,4 +55,9 @@ namespace AWGL
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
+
+            #if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+            #endif
         }
 
+        #region Create Shaders
         void CreateShaders()
@@ -67,19 +72,19 @@ namespace AWGL
             );
-        }
+        } 
+        #endregion
 
+        #region Create VBOs
         void CreateVBOs()
         {
-            
-            AWBufferManager.SetupBuffer(
-                out positionVboHandle, positionVboData, 
-                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw);
 
-            AWBufferManager.SetupBuffer(
-                out normalVboHandle, positionVboData,
-                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            positionVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            AWBufferManager.SetupBuffer(
-                out eboHandle, indicesVboData, 
-                BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            normalVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -88,6 +93,9 @@ namespace AWGL
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
+        } 
+        #endregion
 
+        #region Create VAOs
         void CreateVAOs()
         {
+            #region ---
             // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
@@ -96,10 +104,18 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
             vaoHandle = AWBufferManager.GenerateVaoBuffer();
-            AWBufferManager.SetupVaoBuffer(
-                positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
+
+            #region add matrix transform uniforms
+
+            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
+                
+                shaderManager.ProgramHandle, 0, 3, "in_position",
                 BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );
-
-            AWBufferManager.SetupVaoBuffer(
-                normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",
+            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
+                
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
                 BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
@@ -107,2 +123,4 @@ namespace AWGL
 
+            #endregion
+
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
@@ -110,3 +128,4 @@ namespace AWGL
             GL.BindVertexArray(0);
-        }
+        } 
+        #endregion
 
@@ -130,3 +149,3 @@ namespace AWGL
             GL.DrawElements(
-                PrimitiveType.Triangles, indicesVboData.Length,
+                PrimitiveType.Triangles, AWCube.Indices.Length,
                 DrawElementsType.UnsignedInt, IntPtr.Zero

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fcd0516963dc6f0379bb014d4d8672559cc7e8ac">Documentation Update</a>  -  fcd0516</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 8 files changed, 234 insertions(+), 177 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 9c673a8..05d5f7b 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -9,4 +9,8 @@ namespace AWGL
 {
-    public sealed class AWBufferManager
+    /// <summary>
+    /// 
+    /// </summary>
+    public sealed class AWBufferManager : IDisposable
     {
+        #region Singleton Pattern - Thread Safe
         private static volatile AWBufferManager instance = new AWBufferManager();
@@ -31,4 +35,13 @@ namespace AWGL
             }
-        }
+        } 
+        #endregion
 
+        #region Set up Vertex Buffer Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
         internal static int SetupBuffer(
@@ -46,2 +59,9 @@ namespace AWGL
 
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
         internal static int SetupBuffer(
@@ -57,4 +77,6 @@ namespace AWGL
             return handle;
-        }
+        } 
+        #endregion
 
+        #region Set up Vertex Array Objects
         /// <summary>
@@ -70,3 +92,3 @@ namespace AWGL
         internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
             BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
@@ -76,3 +98,3 @@ namespace AWGL
             GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType, 
+                index, size, vertexAttribPointerType,
                 true, Vector3.SizeInBytes, 0);
@@ -87,2 +109,8 @@ namespace AWGL
             return handle;
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
         }
diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index 71a2527..c8035e0 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -9,2 +9,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// Camera
+    /// </summary>
     public class AWCamera
diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
index 3409e23..6515964 100644
--- a/AWGL/AWCube.cs
+++ b/AWGL/AWCube.cs
@@ -13,2 +13,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// Cube Node
+    /// </summary>
     class AWCube : AWNode
@@ -61,4 +64,4 @@ namespace AWGL
         {
+            throw new NotImplementedException();
         }
-
     }
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 0e08d78..17fd964 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -7,14 +7,30 @@ namespace AWGL
 {
+    /// <summary>
+    /// AWEngine Main Entry Piont
+    /// </summary>
     public sealed class AWEngine
     {
-        private static AWEngine instance = new AWEngine();
+        #region Singleton Pattern - Thread Safe
+        private static volatile AWEngine instance = new AWEngine();
+        private static object syncRoot = new Object();
 
-        private AWEngine()
-        {
-        }
+        private AWEngine() { }
 
-        public static AWEngine getInstance()
+        public static AWEngine Instance
         {
-            return instance;
-        }
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new AWEngine();
+                    }
+                }
+
+                return instance;
+            }
+        } 
+        #endregion
 
@@ -23,3 +39,3 @@ namespace AWGL
         {
-            using (ShaderTutorials game = new ShaderTutorials())
+            using (AWScene game = new AWScene())
             {
@@ -29,3 +45,2 @@ namespace AWGL
 
-
         public static string AppName
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
index df611ff..db9d5b1 100644
--- a/AWGL/AWLogger.cs
+++ b/AWGL/AWLogger.cs
@@ -9,2 +9,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// AWLogger
+    /// </summary>
     internal static class AWLogger
@@ -42,3 +45,2 @@ namespace AWGL
 
-
         internal static void ShadersAttached(int programHandle)
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
new file mode 100644
index 0000000..529d6c6
--- /dev/null
+++ b/AWGL/AWScene.cs
@@ -0,0 +1,164 @@
+﻿
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class AWScene : GameWindow, IDisposable
+    {
+
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        AWShaderManager shaderManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
+
+        public AWScene()
+            : base(1366, 768,
+            new GraphicsMode(), AWEngine.AppName, 0,
+            DisplayDevice.Default, 3, 0,
+            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
+        
+        protected override void OnLoad (System.EventArgs e)
+        {
+            VSync = VSyncMode.On;
+
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
+
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+
+            #if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+            #endif
+        }
+
+        #region Create Shaders
+        void CreateShaders()
+        {
+            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
+
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            shaderManager.SetUniforms(
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, out modelviewMatrix, ClientSize
+            );
+        } 
+        #endregion
+
+        #region Create VBOs
+        void CreateVBOs()
+        {
+
+            positionVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            normalVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+        } 
+        #endregion
+
+        #region Create VAOs
+        void CreateVAOs()
+        {
+            #region ---
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
+            vaoHandle = AWBufferManager.GenerateVaoBuffer();
+
+            #region add matrix transform uniforms
+
+            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
+                
+                shaderManager.ProgramHandle, 0, 3, "in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
+                
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+
+            #endregion
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        } 
+        #endregion
+
+        #region MAIN LOOP
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+
+            if (Keyboard[OpenTK.Input.Key.Escape])
+                Exit();
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(
+                PrimitiveType.Triangles, AWCube.Indices.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero
+                );
+
+            SwapBuffers();
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b11f15e..804bd46 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -118,5 +118,6 @@ namespace AWGL
 
-        public void Dispose()
+        void IDisposable.Dispose()
         {
-            GL.DeleteProgram(m_programHandle);
+            throw new NotImplementedException();
+            //GL.DeleteProgram(m_programHandle);
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
deleted file mode 100644
index 7088979..0000000
--- a/AWGL/ShaderTutorials.cs
+++ /dev/null
@@ -1,159 +0,0 @@
-﻿
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-
-namespace AWGL
-{
-    public class ShaderTutorials : GameWindow
-    {
-
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        AWShaderManager shaderManager;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-
-        public ShaderTutorials()
-            : base(800, 600,
-            new GraphicsMode(), "OpenGL 3 Example", 0,
-            DisplayDevice.Default, 3, 0,
-            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        { }
-        
-        protected override void OnLoad (System.EventArgs e)
-        {
-            VSync = VSyncMode.On;
-
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
-
-            #if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-            #endif
-        }
-
-        #region Create Shaders
-        void CreateShaders()
-        {
-            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, out modelviewMatrix, ClientSize
-            );
-        } 
-        #endregion
-
-        #region Create VBOs
-        void CreateVBOs()
-        {
-
-            positionVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            normalVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            eboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        } 
-        #endregion
-
-        #region Create VAOs
-        void CreateVAOs()
-        {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = AWBufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
-                
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
-                
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-
-            #endregion
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        } 
-        #endregion
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-
-            if (Keyboard[OpenTK.Input.Key.Escape])
-                Exit();
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-            
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(
-                PrimitiveType.Triangles, AWCube.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero
-                );
-
-            SwapBuffers();
-        }
-
-
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/18798b16a89d4c1c057a4bd41d4e771ce1d8eea2">Implemented dispose methods.</a>  -  18798b1</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 8 insertions(+), 15 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 529d6c6..f15bb20 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -1,3 +1,2 @@
-﻿
-using OpenTK;
+﻿using OpenTK;
 using OpenTK.Graphics;
@@ -158,6 +157,8 @@ namespace AWGL
 
-        void IDisposable.Dispose()
+        public override void Dispose()
         {
-            throw new NotImplementedException();
+ 	        base.Dispose();
+            shaderManager.Dispose();
         }
+
     }
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 804bd46..1670547 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -19,3 +19,2 @@ namespace AWGL
         #region Private Members
-
         // Handles
@@ -26,3 +25,2 @@ namespace AWGL
         private string m_fragmentShaderPath = "Simple_FS";
-        
         #endregion
@@ -30,3 +28,2 @@ namespace AWGL
         #region Contructors
-
         public AWShaderManager() 
@@ -42,3 +39,2 @@ namespace AWGL
         }
-        
         #endregion
@@ -46,3 +42,2 @@ namespace AWGL
         #region Shader and Program Contruction Methods
-
         internal string LoadShader(string shaderSourcePath)
@@ -113,3 +108,2 @@ namespace AWGL
         }
-        
         #endregion
@@ -117,9 +111,6 @@ namespace AWGL
         #region IDisposable
-
-        void IDisposable.Dispose()
+        public void Dispose()
         {
-            throw new NotImplementedException();
-            //GL.DeleteProgram(m_programHandle);
+            GL.DeleteProgram(m_programHandle);
         }
-        
         #endregion
@@ -152,2 +143,3 @@ namespace AWGL
         #endregion
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fe8df48be5bd9a40b2baad0d99a15e39530385fb">More organisation.</a>  -  fe8df48</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 24 insertions(+), 20 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index f15bb20..000c15a 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -6,2 +6,3 @@ using System.Collections.Generic;
 using System.Diagnostics;
+using System.Drawing;
 using System.Linq;
@@ -15,3 +16,3 @@ namespace AWGL
     {
-
+        #region Members
         int modelviewMatrixLocation,
@@ -30,12 +31,12 @@ namespace AWGL
         AWGroupNode group;
-        AWCube cube;
+        AWCube cube; 
+        #endregion
 
         public AWScene()
-            : base(1366, 768,
-            new GraphicsMode(), AWEngine.AppName, 0,
-            DisplayDevice.Default, 3, 0,
-            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(1366, 768, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Fullscreen, 
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
-        
-        protected override void OnLoad (System.EventArgs e)
+
+        #region OpenGL Setup
+        protected override void OnLoad(System.EventArgs e)
         {
@@ -53,7 +54,7 @@ namespace AWGL
             GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.ClearColor(Color.CornflowerBlue);
 
-            #if Debug
+#if Debug
             AWLogger.WriteLine("...Exiting OnLoad"); 
-            #endif
+#endif
         }
@@ -71,3 +72,3 @@ namespace AWGL
             );
-        } 
+        }
         #endregion
@@ -92,3 +93,3 @@ namespace AWGL
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        } 
+        }
         #endregion
@@ -111,4 +112,4 @@ namespace AWGL
 
-            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
-                
+            AWBufferManager.SetupVaoBuffer(positionVboHandle,
+
                 shaderManager.ProgramHandle, 0, 3, "in_position",
@@ -116,4 +117,4 @@ namespace AWGL
                 );
-            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
-                
+            AWBufferManager.SetupVaoBuffer(normalVboHandle,
+
                 shaderManager.ProgramHandle, 1, 3, "in_normal",
@@ -127,3 +128,4 @@ namespace AWGL
             GL.BindVertexArray(0);
-        } 
+        }
+        #endregion 
         #endregion
@@ -157,7 +159,9 @@ namespace AWGL
 
+        #region GameWindow.Dispose
         public override void Dispose()
         {
- 	        base.Dispose();
+            base.Dispose();
             shaderManager.Dispose();
-        }
+        } 
+        #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/991e844f8fdbbda05e4c6b62a5243cec6b5be232">Refactoring namspaces. Removed AWGL.Scene and added AWGL.Nodes.</a>  -  991e844</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 22 files changed, 671 insertions(+), 670 deletions(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
deleted file mode 100644
index 6515964..0000000
--- a/AWGL/AWCube.cs
+++ /dev/null
@@ -1,68 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    class AWCube : AWNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public static Vector3[] Vertices 
-        {
-            get { return CubeVertices; }
-        }
-
-        public static int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 17fd964..91df2c0 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -1,3 +1,2 @@
-﻿using AWGL.Scene;
-using OpenTK;
+﻿using OpenTK;
 using System;
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
new file mode 100644
index 0000000..7565e90
--- /dev/null
+++ b/AWGL/AWOldScene.cs
@@ -0,0 +1,251 @@
+﻿using AWGL.Nodes;
+using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class AWOldScene : GameWindow
+    {
+        #region Constructor
+
+        public AWOldScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
+        {
+            //set context
+            //this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
+
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private AWShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            //Title = AWUtils.PrintOpenGLInfo();
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 000c15a..5d8f8fc 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿using AWGL.Nodes;
+using OpenTK;
 using OpenTK.Graphics;
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
deleted file mode 100644
index fb9ae28..0000000
--- a/AWGL/DefaultScene.cs
+++ /dev/null
@@ -1,250 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class DefaultScene : GameWindow
-    {
-        #region Constructor
-
-        public DefaultScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new AWCamera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected AWCamera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private AWShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
new file mode 100644
index 0000000..570b597
--- /dev/null
+++ b/AWGL/Nodes/AWCube.cs
@@ -0,0 +1,68 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    /// <summary>
+    /// Cube Node
+    /// </summary>
+    class AWCube : AWNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public static Vector3[] Vertices 
+        {
+            get { return CubeVertices; }
+        }
+
+        public static int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
new file mode 100644
index 0000000..5c1dc64
--- /dev/null
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWGraphLines : AWNode
+    {
+        private int m_gridSize = 20;
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
new file mode 100644
index 0000000..5088673
--- /dev/null
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -0,0 +1,89 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+    } 
+}
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
new file mode 100644
index 0000000..6c266a2
--- /dev/null
+++ b/AWGL/Nodes/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
new file mode 100644
index 0000000..c84a3c2
--- /dev/null
+++ b/AWGL/Nodes/AWNode.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public abstract class AWNode : ISceneNode
+    {
+        protected AWBufferManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
+        public abstract void Render();
+    }
+
+}
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
new file mode 100644
index 0000000..9d9b423
--- /dev/null
+++ b/AWGL/Nodes/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
new file mode 100644
index 0000000..fddd1ad
--- /dev/null
+++ b/AWGL/Nodes/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
new file mode 100644
index 0000000..d909231
--- /dev/null
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Nodes
+{
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
new file mode 100644
index 0000000..9a51902
--- /dev/null
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Nodes
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
diff --git a/AWGL/Scene/AWGraphLines.cs b/AWGL/Scene/AWGraphLines.cs
deleted file mode 100644
index 7f280ce..0000000
--- a/AWGL/Scene/AWGraphLines.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWGraphLines : AWNode
-    {
-        private int m_gridSize = 20;
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/Scene/AWGroupNode.cs b/AWGL/Scene/AWGroupNode.cs
deleted file mode 100644
index 0e656cc..0000000
--- a/AWGL/Scene/AWGroupNode.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-    } 
-}
diff --git a/AWGL/Scene/AWMesh.cs b/AWGL/Scene/AWMesh.cs
deleted file mode 100644
index bd58995..0000000
--- a/AWGL/Scene/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
deleted file mode 100644
index 4341e13..0000000
--- a/AWGL/Scene/AWNode.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class AWNode : ISceneNode
-    {
-        protected AWBufferManager m_BufferManager;
-
-        protected AWNode()
-        {
-            //m_BufferManager = new AWBufferManager();
-        }
-
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/Scene/AWParticles.cs b/AWGL/Scene/AWParticles.cs
deleted file mode 100644
index 2b2f7c6..0000000
--- a/AWGL/Scene/AWParticles.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWParticles : AWNode
-    {
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
diff --git a/AWGL/Scene/AWPolygon.cs b/AWGL/Scene/AWPolygon.cs
deleted file mode 100644
index eb2ca03..0000000
--- a/AWGL/Scene/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/Scene/IGroupNode.cs b/AWGL/Scene/IGroupNode.cs
deleted file mode 100644
index 5ac83e3..0000000
--- a/AWGL/Scene/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Scene/ISceneNode.cs b/AWGL/Scene/ISceneNode.cs
deleted file mode 100644
index 6f6da08..0000000
--- a/AWGL/Scene/ISceneNode.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e5e376a2ba76d389fe023f2c30842c8ea96b2a60">Some changes to nodes.</a>  -  e5e376a</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 8 files changed, 60 insertions(+), 26 deletions(-)

diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
index 7565e90..a67acb8 100644
--- a/AWGL/AWOldScene.cs
+++ b/AWGL/AWOldScene.cs
@@ -38,3 +38,3 @@ namespace AWGL
             landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
+            graph = new AWGraphLines(20); ;
             cube = new AWCube();
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 5d8f8fc..c5fc788 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -32,3 +32,4 @@ namespace AWGL
         AWGroupNode group;
-        AWCube cube; 
+        AWCube cube;
+        AWGraphLines graph;
         #endregion
@@ -48,3 +49,3 @@ namespace AWGL
             cube = new AWCube();
-
+            graph = new AWGraphLines(20);
             CreateShaders();
@@ -81,3 +82,3 @@ namespace AWGL
             positionVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -85,3 +86,3 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -89,3 +90,3 @@ namespace AWGL
             eboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -152,3 +153,3 @@ namespace AWGL
             GL.DrawElements(
-                PrimitiveType.Triangles, AWCube.Indices.Length,
+                PrimitiveType.Triangles, cube.Indices.Length,
                 DrawElementsType.UnsignedInt, IntPtr.Zero
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
index 570b597..536eeeb 100644
--- a/AWGL/Nodes/AWCube.cs
+++ b/AWGL/Nodes/AWCube.cs
@@ -16,3 +16,3 @@ namespace AWGL.Nodes
     /// </summary>
-    class AWCube : AWNode
+    public class AWCube : AWNode, ISceneNode
     {
@@ -48,3 +48,3 @@ namespace AWGL.Nodes
 
-        public static Vector3[] Vertices 
+        public Vector3[] Vertices
         {
@@ -53,3 +53,3 @@ namespace AWGL.Nodes
 
-        public static int[] Indices
+        public int[] Indices
         {
@@ -66,2 +66,3 @@ namespace AWGL.Nodes
         }
+
     }
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index 5c1dc64..d3d493b 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Graphics.OpenGL;
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -11,3 +12,3 @@ namespace AWGL.Nodes
 {
-    class AWGraphLines : AWNode
+    class AWGraphLines : AWNode, ISceneNode
     {
@@ -15,15 +16,35 @@ namespace AWGL.Nodes
 
-        public override void Render()
+        public Vector3[] Vertices
+        {
+            get { return m_vertices; }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        private static Vector3[] m_vertices;
+
+        public AWGraphLines(int gridSize)
         {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            m_gridSize = gridSize;
+            m_vertices = new Vector3[m_gridSize];
+            BuildVertices();
+        }
+
+        private void BuildVertices()
+        {
+            for (int i = 0; i < m_gridSize; i += 4)
             {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
+                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
+                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
+                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
             }
-            GL.End();
+        }
+
+        public override void Render()
+        {
+
         }
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
index 5088673..2190c34 100644
--- a/AWGL/Nodes/AWGroupNode.cs
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -10,3 +10,3 @@ namespace AWGL.Nodes
 {
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
     {
@@ -87,2 +87,12 @@ namespace AWGL.Nodes
 
+
+        public OpenTK.Vector3[] Vertices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
     } 
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index c84a3c2..6d64581 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -8,3 +8,3 @@ namespace AWGL.Nodes
 {
-    public abstract class AWNode : ISceneNode
+    public abstract class AWNode
     {
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
index d909231..abfbd48 100644
--- a/AWGL/Nodes/IGroupNode.cs
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -7,3 +7,3 @@ namespace AWGL.Nodes
 {
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    public interface IGroupNode : IEnumerable<ISceneNode>
     {
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
index 9a51902..b1e3f51 100644
--- a/AWGL/Nodes/ISceneNode.cs
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK;
+using System;
 using System.Collections.Generic;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/78286a1257d0cd64b15301c972ae79903cc38b84">Got some graph lines going on up in here.</a>  -  78286a1</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index c5fc788..edabc91 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -82,3 +82,3 @@ namespace AWGL
             positionVboHandle = AWBufferManager.SetupBuffer(
-                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -86,8 +86,8 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            eboHandle = AWBufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //eboHandle = AWBufferManager.SetupBuffer(
+            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
@@ -127,3 +127,3 @@ namespace AWGL
 
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
@@ -137,5 +137,6 @@ namespace AWGL
         {
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            
+            //Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            //Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
@@ -152,6 +153,7 @@ namespace AWGL
             GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(
-                PrimitiveType.Triangles, cube.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero
-                );
+            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+                //Elements(
+                //PrimitiveType.Lines, cube.Indices.Length,
+                //DrawElementsType.UnsignedInt, IntPtr.Zero
+                //);
 
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index d3d493b..e9d9de0 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -21,7 +21,2 @@ namespace AWGL.Nodes
 
-        public int[] Indices
-        {
-            get { throw new NotImplementedException(); }
-        }
-
         private static Vector3[] m_vertices;
@@ -31,3 +26,3 @@ namespace AWGL.Nodes
             m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize];
+            m_vertices = new Vector3[m_gridSize * 2];
             BuildVertices();
@@ -37,3 +32,3 @@ namespace AWGL.Nodes
         {
-            for (int i = 0; i < m_gridSize; i += 4)
+            for (int i = 0; i < m_gridSize *2; i += 4)
             {
@@ -48,3 +43,13 @@ namespace AWGL.Nodes
         {
-
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a8824acae89b5b6b1c801ca24466dc346136149b">Successfully got camera working with shaders.</a>  -  a8824ac</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 3 files changed, 78 insertions(+), 12 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index c8035e0..a72fadf 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -19,2 +19,9 @@ namespace AWGL
 
+        public Matrix4 LookAtMatrix
+        {
+            get
+            {
+                return GetViewMatrix();
+            }
+        }
         public Matrix4 GetViewMatrix()
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index edabc91..325fde8 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -34,2 +34,3 @@ namespace AWGL
         AWGraphLines graph;
+        AWCamera camera;
         #endregion
@@ -37,3 +38,3 @@ namespace AWGL
         public AWScene()
-            : base(1366, 768, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Fullscreen, 
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -45,3 +46,3 @@ namespace AWGL
             VSync = VSyncMode.On;
-
+            camera = new AWCamera();
             root = new AWGroupNode();
@@ -72,3 +73,3 @@ namespace AWGL
                 out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, out modelviewMatrix, ClientSize
+                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
             );
@@ -137,9 +138,14 @@ namespace AWGL
         {
-            
-            //Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            //Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-            if (Keyboard[OpenTK.Input.Key.Escape])
-                Exit();
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
         }
@@ -171,2 +177,56 @@ namespace AWGL
 
+        protected override void OnKeyPress(KeyPressEventArgs e)
+        {
+            base.OnKeyPress(e);
+
+            if (e.KeyChar == 27)
+            {
+                Exit();
+            }
+
+            switch (e.KeyChar)
+            {
+                case 'w':
+                    camera.Move(0f, 0.1f, 0f);
+                    break;
+                case 'a':
+                    camera.Move(-0.1f, 0f, 0f);
+                    break;
+                case 's':
+                    camera.Move(0f, -0.1f, 0f);
+                    break;
+                case 'd':
+                    camera.Move(0.1f, 0f, 0f);
+                    break;
+                case 'q':
+                    camera.Move(0f, 0f, 0.1f);
+                    break;
+                case 'e':
+                    camera.Move(0f, 0f, -0.1f);
+                    break;
+                case 'f':
+                    this.WindowState = (this.WindowState != WindowState.Fullscreen) 
+                        ? WindowState.Fullscreen: WindowState.Normal;
+                    break;
+                case 'x':
+                    Exit();
+                    break;
+            }
+        }
+
+        void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
     }
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 1670547..2918c1c 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -129,4 +129,4 @@ namespace AWGL
             out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, out Matrix4 mvMatrix,
-            Size dimensions)
+            out Matrix4 projMatrix, Matrix4 mvMatrix,
+            Size dimensions, ref AWCamera camera)
         {
@@ -137,3 +137,2 @@ namespace AWGL
             Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-            mvMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/539c15293980a3e708fe9a590cad7c91f252b4ab">Better Input Control.</a>  -  539c152</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 62 insertions(+), 33 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index a72fadf..c731e69 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -14,3 +14,3 @@ namespace AWGL
     {
-        public Vector3 Position = Vector3.Zero;
+        public Vector3 Position = new Vector3(2, 2, 2);
         public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 325fde8..2430108 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -4,2 +4,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
@@ -35,2 +36,3 @@ namespace AWGL
         AWCamera camera;
+        List<Key> keyList;
         #endregion
@@ -46,3 +48,9 @@ namespace AWGL
             VSync = VSyncMode.On;
+            
             camera = new AWCamera();
+            keyList = new List<Key>();
+
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+            
             root = new AWGroupNode();
@@ -147,2 +155,3 @@ namespace AWGL
 
+            MoveCamera();
 
@@ -177,38 +186,57 @@ namespace AWGL
 
-        protected override void OnKeyPress(KeyPressEventArgs e)
+        #region Input Control
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
         {
-            base.OnKeyPress(e);
+            keyList.Add(e.Key);
+        }
 
-            if (e.KeyChar == 27)
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
             {
-                Exit();
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
             }
+        }
 
-            switch (e.KeyChar)
+        private void MoveCamera()
+        {
+            foreach (Key key in keyList)
             {
-                case 'w':
-                    camera.Move(0f, 0.1f, 0f);
-                    break;
-                case 'a':
-                    camera.Move(-0.1f, 0f, 0f);
-                    break;
-                case 's':
-                    camera.Move(0f, -0.1f, 0f);
-                    break;
-                case 'd':
-                    camera.Move(0.1f, 0f, 0f);
-                    break;
-                case 'q':
-                    camera.Move(0f, 0f, 0.1f);
-                    break;
-                case 'e':
-                    camera.Move(0f, 0f, -0.1f);
-                    break;
-                case 'f':
-                    this.WindowState = (this.WindowState != WindowState.Fullscreen) 
-                        ? WindowState.Fullscreen: WindowState.Normal;
-                    break;
-                case 'x':
-                    Exit();
-                    break;
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
             }
@@ -216,3 +244,3 @@ namespace AWGL
 
-        void ResetCursor()
+        private void ResetCursor()
         {
@@ -229,3 +257,4 @@ namespace AWGL
             }
-        }
+        } 
+        #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/760cb400727a728ef8fc6219ddf70effa09b8cb2">Funky cube error, looks more like a map or summat.</a>  -  760cb40</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 2430108..ea35d54 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -89,5 +89,8 @@ namespace AWGL
         {
+            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
 
             positionVboHandle = AWBufferManager.SetupBuffer(
-                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -95,8 +98,8 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            //eboHandle = AWBufferManager.SetupBuffer(
-            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
+            eboHandle = AWBufferManager.SetupBuffer(
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
 
@@ -136,3 +139,3 @@ namespace AWGL
 
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
@@ -169,3 +172,3 @@ namespace AWGL
             GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-                //Elements(
+            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
                 //PrimitiveType.Lines, cube.Indices.Length,

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/492bf03d733797f5769996eab210dc25b9b7cdd9">Added FPS Counter.</a>  -  492bf03</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index ea35d54..a9b78dd 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -166,2 +166,3 @@ namespace AWGL
         {
+            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             GL.Viewport(0, 0, Width, Height);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ea930771a1da7807a46a01a5765765308cd097f7">A bit of organisation.</a>  -  ea93077</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 15 files changed, 670 insertions(+), 720 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
deleted file mode 100644
index 05d5f7b..0000000
--- a/AWGL/AWBufferManager.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    public sealed class AWBufferManager : IDisposable
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile AWBufferManager instance = new AWBufferManager();
-        private static object syncRoot = new Object();
-
-        private AWBufferManager() { }
-
-        public static AWBufferManager Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new AWBufferManager();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        #region Set up Vertex Buffer Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-            return handle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-            return handle;
-        } 
-        #endregion
-
-        #region Set up Vertex Array Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="bufferHandle"></param>
-        /// <param name="ProgramHandle"></param>
-        /// <param name="index"></param>
-        /// <param name="size"></param>
-        /// <param name="attributeName"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="vertexAttribPointerType"></param>
-        internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
-            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, bufferHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType,
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal static int GenerateVaoBuffer()
-        {
-            int handle;
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-            return handle;
-        } 
-        #endregion
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
deleted file mode 100644
index c731e69..0000000
--- a/AWGL/AWCamera.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Camera
-    /// </summary>
-    public class AWCamera
-    {
-        public Vector3 Position = new Vector3(2, 2, 2);
-        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
-        public float MoveSpeed = 0.2f;
-        public float MouseSensitivity = 0.01f;
-
-        public Matrix4 LookAtMatrix
-        {
-            get
-            {
-                return GetViewMatrix();
-            }
-        }
-        public Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
-            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
-        }
-
-        public void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
-            Position += offset;
-        }
-
-        public void AddRotation(float x, float y)
-        {
-            x = x * MouseSensitivity;
-            y = y * MouseSensitivity;
-
-            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
-            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-        }
-    }
-}
diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
deleted file mode 100644
index 4ebbf45..0000000
--- a/AWGL/AWData.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿using OpenTK;
-using System;
-
-namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, EboID, NumElements;
-    }
-
-    #region Particles
-    // this struct is used for drawing
-    public struct VertexC4ubV3f
-    {
-        public byte R, G, B, A;
-        public Vector3 Position;
-
-        public static int SizeInBytes = 16;
-    }
-
-    // this struct is used for updates
-    public struct ParticleAttribut
-    {
-        public Vector3 Direction;
-        public uint Age;
-
-        //  more stuff could be here: Rotation, Radius, whatever
-    }
-    #endregion
-
-    #region Picker
-    public struct Byte4
-    {
-        public byte R, G, B, A;
-
-        public Byte4(byte[] input)
-        {
-            R = input[0];
-            G = input[1];
-            B = input[2];
-            A = input[3];
-        }
-
-        public uint ToUInt32()
-        {
-            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
-            return BitConverter.ToUInt32(temp, 0);
-        }
-
-        public override string ToString()
-        {
-            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
-        }
-    }
-
-    struct Vertex
-    {
-        public Byte4 Color; // 4 bytes
-        public Vector3 Position; // 12 bytes
-
-        public const byte SizeInBytes = 16;
-    }
-    #endregion
-
-}
\ No newline at end of file
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 91df2c0..85bb98f 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -38,3 +38,3 @@ namespace AWGL
         {
-            using (AWScene game = new AWScene())
+            using (AWEngineWindow game = new AWEngineWindow())
             {
diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
new file mode 100644
index 0000000..5482d11
--- /dev/null
+++ b/AWGL/AWEngineWindow.cs
@@ -0,0 +1,268 @@
+﻿using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class AWEngineWindow : GameWindow, IDisposable
+    {
+        #region Members
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        ShaderManager shaderManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
+        AWGraphLines graph;
+        Camera camera;
+        List<Key> keyList;
+        #endregion
+
+        public AWEngineWindow()
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
+
+        #region OpenGL Setup
+        protected override void OnLoad(System.EventArgs e)
+        {
+            VSync = VSyncMode.On;
+            
+            camera = new Camera();
+            keyList = new List<Key>();
+
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+            
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+            graph = new AWGraphLines(20);
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
+
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.CornflowerBlue);
+
+#if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+#endif
+        }
+
+        #region Create Shaders
+        void CreateShaders()
+        {
+            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            shaderManager.SetUniforms(
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
+            );
+        }
+        #endregion
+
+        #region Create VBOs
+        void CreateVBOs()
+        {
+            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
+
+            positionVboHandle = BufferManager.SetupBuffer(
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            normalVboHandle = BufferManager.SetupBuffer(
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = BufferManager.SetupBuffer(
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+        }
+        #endregion
+
+        #region Create VAOs
+        void CreateVAOs()
+        {
+            #region ---
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
+            vaoHandle = BufferManager.GenerateVaoBuffer();
+
+            #region add matrix transform uniforms
+
+            BufferManager.SetupVaoBuffer(positionVboHandle,
+
+                shaderManager.ProgramHandle, 0, 3, "in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+            BufferManager.SetupVaoBuffer(normalVboHandle,
+
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+
+            #endregion
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        }
+        #endregion 
+        #endregion
+
+        #region MAIN LOOP
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            MoveCamera();
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
+                //PrimitiveType.Lines, cube.Indices.Length,
+                //DrawElementsType.UnsignedInt, IntPtr.Zero
+                //);
+
+            SwapBuffers();
+        } 
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            base.Dispose();
+            shaderManager.Dispose();
+        } 
+        #endregion
+
+        #region Input Control
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        #endregion
+
+    }
+}
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
deleted file mode 100644
index db9d5b1..0000000
--- a/AWGL/AWLogger.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    /// <summary>
-    /// AWLogger
-    /// </summary>
-    internal static class AWLogger
-    {
-       
-        internal static void WriteLine(string output)
-        {
-            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
-        }
-
-        internal static void PlatformInfo()
-        {
-            WriteLine("Starting Logger. . .");
-            WriteLine("Getting Platform Information. . .");
-            WriteLine(GL.GetString(StringName.Vendor));
-            WriteLine(GL.GetString(StringName.Renderer));
-            WriteLine(GL.GetString(StringName.Version));
-            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
-        }
-
-        internal static void ShaderInfo(int shaderHandle)
-        {
-            String infoLog;
-            GL.GetShaderInfoLog(shaderHandle, out infoLog);
-            WriteLine(infoLog);
-        }
-
-        internal static void ProgramInfo(int programHandle)
-        {
-            String infoLog;
-            GL.GetProgramInfoLog(programHandle, out infoLog);
-            WriteLine(infoLog);
-            ShadersAttached(programHandle);
-        }
-
-        internal static void ShadersAttached(int programHandle)
-        {
-            int attachedShaders;
-            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
-            WriteLine(attachedShaders + temp + " Attached");
-        }
-    }
-
-}
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
index a67acb8..51cd98d 100644
--- a/AWGL/AWOldScene.cs
+++ b/AWGL/AWOldScene.cs
@@ -1,3 +1,5 @@
-﻿using AWGL.Nodes;
+﻿using AWGL.Managers;
+using AWGL.Nodes;
 using AWGL.Shapes;
+using AWGL.Utilities;
 using OpenTK;
@@ -28,3 +30,3 @@ namespace AWGL
             //create player camera
-            playerView = new AWCamera();
+            playerView = new Camera();
 
@@ -64,3 +66,3 @@ namespace AWGL
 
-        protected AWCamera playerView;
+        protected Camera playerView;
 
@@ -80,3 +82,3 @@ namespace AWGL
 
-        private AWShaderManager shaderManager;
+        private ShaderManager shaderManager;
 
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
deleted file mode 100644
index a9b78dd..0000000
--- a/AWGL/AWScene.cs
+++ /dev/null
@@ -1,266 +0,0 @@
-﻿using AWGL.Nodes;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-
-namespace AWGL
-{
-    public class AWScene : GameWindow, IDisposable
-    {
-        #region Members
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        AWShaderManager shaderManager;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-        AWGraphLines graph;
-        AWCamera camera;
-        List<Key> keyList;
-        #endregion
-
-        public AWScene()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        { }
-
-        #region OpenGL Setup
-        protected override void OnLoad(System.EventArgs e)
-        {
-            VSync = VSyncMode.On;
-            
-            camera = new AWCamera();
-            keyList = new List<Key>();
-
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-            
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-            graph = new AWGraphLines(20);
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.CornflowerBlue);
-
-#if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif
-        }
-
-        #region Create Shaders
-        void CreateShaders()
-        {
-            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            );
-        }
-        #endregion
-
-        #region Create VBOs
-        void CreateVBOs()
-        {
-            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
-
-            positionVboHandle = AWBufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            normalVboHandle = AWBufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            eboHandle = AWBufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
-        #endregion
-
-        #region Create VAOs
-        void CreateVAOs()
-        {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = AWBufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            AWBufferManager.SetupVaoBuffer(positionVboHandle,
-
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            AWBufferManager.SetupVaoBuffer(normalVboHandle,
-
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-
-            #endregion
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        }
-        #endregion 
-        #endregion
-
-        #region MAIN LOOP
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            MoveCamera();
-
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            GL.Viewport(0, 0, Width, Height);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-                //PrimitiveType.Lines, cube.Indices.Length,
-                //DrawElementsType.UnsignedInt, IntPtr.Zero
-                //);
-
-            SwapBuffers();
-        } 
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            base.Dispose();
-            shaderManager.Dispose();
-        } 
-        #endregion
-
-        #region Input Control
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
-                }
-            }
-        }
-
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        #endregion
-
-    }
-}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
deleted file mode 100644
index 2918c1c..0000000
--- a/AWGL/AWShaderManager.cs
+++ /dev/null
@@ -1,145 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.IO;
-using OpenTK.Graphics.OpenGL;
-using System.Diagnostics;
-using OpenTK;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    class AWShaderManager : IDisposable
-    {
-        #region Private Members
-        // Handles
-        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
-
-        private string defaultDataPath = "Data/Shaders/";
-        private string m_vertexShaderPath = "Simple_VS";
-        private string m_fragmentShaderPath = "Simple_FS";
-        #endregion
-
-        #region Contructors
-        public AWShaderManager() 
-        { 
-            m_programHandle = BuildProgram(); 
-        }
-
-        public AWShaderManager(string vertexShaderPath, string fragmentShaderPath)
-        {
-            m_vertexShaderPath = vertexShaderPath;
-            m_fragmentShaderPath = fragmentShaderPath;
-            m_programHandle = BuildProgram();
-        }
-        #endregion
-
-        #region Shader and Program Contruction Methods
-        internal string LoadShader(string shaderSourcePath)
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-
-        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            AWLogger.ShaderInfo(shaderHandle);
-
-            return shaderHandle;
-        }
-
-        internal int BuildProgram()
-        {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
-
-            int programHandle = GL.CreateProgram();
-
-            GL.AttachShader(programHandle, m_vertexShaderHandle);
-            GL.AttachShader(programHandle, m_fragmentShaderHandle);
-
-            GL.LinkProgram(programHandle);
-
-            #region Check linker success
-
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
-            }
-
-            #endregion
-
-            #region Validate Program
-
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
-            }
-            #endregion
-
-            // Delete the shaders as the program has them now
-            GL.DeleteShader(m_vertexShaderHandle);
-            GL.DeleteShader(m_fragmentShaderHandle);
-
-            return programHandle;
-        }
-        #endregion
-
-        #region IDisposable
-        public void Dispose()
-        {
-            GL.DeleteProgram(m_programHandle);
-        }
-        #endregion
-
-        #region Public Methods
-
-        public int ProgramHandle
-        {
-            get
-            {
-                return m_programHandle;
-            }
-        }
-
-        public void SetUniforms(
-            out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, Matrix4 mvMatrix,
-            Size dimensions, ref AWCamera camera)
-        {
-            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        } 
-        #endregion
-
-    }
-}
diff --git a/AWGL/Managers/BufferManager.cs b/AWGL/Managers/BufferManager.cs
new file mode 100644
index 0000000..f3719c4
--- /dev/null
+++ b/AWGL/Managers/BufferManager.cs
@@ -0,0 +1,118 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL.Managers
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    public sealed class BufferManager : IDisposable
+    {
+        #region Singleton Pattern - Thread Safe
+        private static volatile BufferManager instance = new BufferManager();
+        private static object syncRoot = new Object();
+
+        private BufferManager() { }
+
+        public static BufferManager Instance
+        {
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new BufferManager();
+                    }
+                }
+
+                return instance;
+            }
+        } 
+        #endregion
+
+        #region Set up Vertex Buffer Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
+        internal static int SetupBuffer(
+            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            int handle;
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+            return handle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
+        internal static int SetupBuffer(
+            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            int handle;
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+            return handle;
+        } 
+        #endregion
+
+        #region Set up Vertex Array Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="bufferHandle"></param>
+        /// <param name="ProgramHandle"></param>
+        /// <param name="index"></param>
+        /// <param name="size"></param>
+        /// <param name="attributeName"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="vertexAttribPointerType"></param>
+        internal static void SetupVaoBuffer(
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
+            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, bufferHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType,
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal static int GenerateVaoBuffer()
+        {
+            int handle;
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+            return handle;
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
new file mode 100644
index 0000000..72b7fdd
--- /dev/null
+++ b/AWGL/Managers/ShaderManager.cs
@@ -0,0 +1,146 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
+using OpenTK;
+using System.Drawing;
+using AWGL.Utilities;
+
+namespace AWGL.Managers
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class ShaderManager : IDisposable
+    {
+        #region Private Members
+        // Handles
+        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+
+        private string defaultDataPath = "Data/Shaders/";
+        private string m_vertexShaderPath = "Simple_VS";
+        private string m_fragmentShaderPath = "Simple_FS";
+        #endregion
+
+        #region Contructors
+        public ShaderManager() 
+        { 
+            m_programHandle = BuildProgram(); 
+        }
+
+        public ShaderManager(string vertexShaderPath, string fragmentShaderPath)
+        {
+            m_vertexShaderPath = vertexShaderPath;
+            m_fragmentShaderPath = fragmentShaderPath;
+            m_programHandle = BuildProgram();
+        }
+        #endregion
+
+        #region Shader and Program Contruction Methods
+        internal string LoadShader(string shaderSourcePath)
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+
+        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            Logger.ShaderInfo(shaderHandle);
+
+            return shaderHandle;
+        }
+
+        internal int BuildProgram()
+        {
+            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
+
+            int programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
+
+            int linkSuccess;
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Debug.WriteLine("Program link failed: " + message);
+            }
+
+            #endregion
+
+            #region Validate Program
+
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Debug.WriteLine("Program validation failed", message);
+            }
+            #endregion
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
+        }
+        #endregion
+
+        #region IDisposable
+        public void Dispose()
+        {
+            GL.DeleteProgram(m_programHandle);
+        }
+        #endregion
+
+        #region Public Methods
+
+        public int ProgramHandle
+        {
+            get
+            {
+                return m_programHandle;
+            }
+        }
+
+        public void SetUniforms(
+            out int projMatrixHandle, out int mvMatrixHandle,
+            out Matrix4 projMatrix, Matrix4 mvMatrix,
+            Size dimensions, ref Camera camera)
+        {
+            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+
+            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        } 
+        #endregion
+
+    }
+}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index 6d64581..ca93718 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using AWGL.Managers;
+using System;
 using System.Collections.Generic;
@@ -10,3 +11,3 @@ namespace AWGL.Nodes
     {
-        protected AWBufferManager m_BufferManager;
+        protected BufferManager m_BufferManager;
 
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
index 9d9b423..6d0c8ca 100644
--- a/AWGL/Nodes/AWParticles.cs
+++ b/AWGL/Nodes/AWParticles.cs
@@ -12,2 +12,10 @@ namespace AWGL.Nodes
     {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+}
+/*
         #region Private Members
@@ -112 +120,2 @@ namespace AWGL.Nodes
 }
+        */
\ No newline at end of file
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
new file mode 100644
index 0000000..f806424
--- /dev/null
+++ b/AWGL/Utilities/Camera.cs
@@ -0,0 +1,64 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    /// <summary>
+    /// Camera
+    /// </summary>
+    public class Camera
+    {
+        public Vector3 Position = new Vector3(2, 2, 2);
+        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public float MoveSpeed = 0.2f;
+        public float MouseSensitivity = 0.01f;
+
+        public Matrix4 LookAtMatrix
+        {
+            get
+            {
+                return GetViewMatrix();
+            }
+        }
+        public Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+        }
+
+        public void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
new file mode 100644
index 0000000..5b1701d
--- /dev/null
+++ b/AWGL/Utilities/Logger.cs
@@ -0,0 +1,55 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    /// <summary>
+    /// AWLogger
+    /// </summary>
+    internal static class Logger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c3e3e539e5430f5e0abeb47c10459f530105f749">More Refactoring. Added some class stubs.</a>  -  c3e3e53</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 8 files changed, 306 insertions(+), 310 deletions(-)

diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
deleted file mode 100644
index 85bb98f..0000000
--- a/AWGL/AWEngine.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// AWEngine Main Entry Piont
-    /// </summary>
-    public sealed class AWEngine
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile AWEngine instance = new AWEngine();
-        private static object syncRoot = new Object();
-
-        private AWEngine() { }
-
-        public static AWEngine Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new AWEngine();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        [STAThread]
-        public static void Main()
-        {
-            using (AWEngineWindow game = new AWEngineWindow())
-            {
-                game.Run(30,0);
-            }
-        }
-
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
-            
-        }
-    }
-}
diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 5482d11..9256ae5 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -42,3 +42,3 @@ namespace AWGL
         public AWEngineWindow()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -168,3 +168,3 @@ namespace AWGL
         {
-            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             GL.Viewport(0, 0, Width, Height);
@@ -266,2 +266,19 @@ namespace AWGL
 
+        [STAThread]
+        public static void Main()
+        {
+            using (AWEngineWindow window = new AWEngineWindow())
+            {
+                window.Run();
+            }
+        }
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+
+        }
     }
diff --git a/AWGL/AWOldEngineWindow.cs b/AWGL/AWOldEngineWindow.cs
new file mode 100644
index 0000000..8b85c34
--- /dev/null
+++ b/AWGL/AWOldEngineWindow.cs
@@ -0,0 +1,253 @@
+﻿using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class AWOldEngineWindow : GameWindow
+    {
+        #region Constructor
+
+        public AWOldEngineWindow() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
+        {
+            //set context
+            //this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new Camera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(20); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
+
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected Camera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private ShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            //Title = AWUtils.PrintOpenGLInfo();
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
deleted file mode 100644
index 51cd98d..0000000
--- a/AWGL/AWOldScene.cs
+++ /dev/null
@@ -1,253 +0,0 @@
-﻿using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Shapes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class AWOldScene : GameWindow
-    {
-        #region Constructor
-
-        public AWOldScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new Camera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(20); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected Camera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private ShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
new file mode 100644
index 0000000..d2f066d
--- /dev/null
+++ b/AWGL/Managers/InputManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class InputManager
+    {
+    }
+}
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
new file mode 100644
index 0000000..0ad1daa
--- /dev/null
+++ b/AWGL/Managers/ModelManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class ModelManager
+    {
+    }
+}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
new file mode 100644
index 0000000..687a689
--- /dev/null
+++ b/AWGL/Managers/TextureManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class TextureManager
+    {
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 5b1701d..2a71e55 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -17,3 +17,3 @@ namespace AWGL.Utilities
         {
-            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+            Debug.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1ec030b90150c26c05f7f8457d40fe9837aa8443">~</a>  -  1ec030b</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 9256ae5..068b970 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -21,2 +21,11 @@ namespace AWGL
         #region Members
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+
+        }
         int modelviewMatrixLocation,
@@ -275,10 +284,2 @@ namespace AWGL
 
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
-
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/53c8ece7f02fb44a36b41dc914bc173c525ac703">Precise Timer.</a>  -  53c8ece</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 2 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 068b970..efc1b52 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -50,2 +50,5 @@ namespace AWGL
 
+        PreciseTimer m_Timer = new PreciseTimer();
+        public delegate void OnRenderFrame(double elapsedTime);
+
         public AWEngineWindow()
@@ -280,3 +283,3 @@ namespace AWGL
             {
-                window.Run();
+                window.Run(30, 60);
             }
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
new file mode 100644
index 0000000..b5f8c46
--- /dev/null
+++ b/AWGL/Utilities/PreciseTimer.cs
@@ -0,0 +1,38 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class PreciseTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public PreciseTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public double GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+            double elapsedTime = (double)(time - m_previouslyElapsedTime) / (double)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6966da4527604eab92bed9932d317363f3077cff">added external-game</a>  -  6966da4</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 4 files changed, 102 insertions(+), 18 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index efc1b52..ba0d1a8 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -18,3 +18,6 @@ namespace AWGL
 {
-    public class AWEngineWindow : GameWindow, IDisposable
+    /// <summary>
+    /// Inherit me
+    /// </summary>
+    public abstract class AWEngineWindow : GameWindow, IDisposable
     {
@@ -49,8 +52,10 @@ namespace AWGL
         #endregion
+        
+        protected PreciseTimer m_Timer = new PreciseTimer();
 
-        PreciseTimer m_Timer = new PreciseTimer();
-        public delegate void OnRenderFrame(double elapsedTime);
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
 
-        public AWEngineWindow()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+        public AWEngineWindow(int height, int width)
+            : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -163,2 +168,3 @@ namespace AWGL
         {
+            #region Input
             if (Focused)
@@ -172,3 +178,4 @@ namespace AWGL
 
-            MoveCamera();
+            MoveCamera(); 
+            #endregion
 
@@ -176,6 +183,11 @@ namespace AWGL
             GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+
+            UpdateFrame(m_Timer.GetElapsedTime());
         }
 
+        new public abstract void UpdateFrame(double elapsedTime);
+
         protected override void OnRenderFrame(FrameEventArgs e)
         {
+            base.OnRenderFrame(e);
             this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
@@ -191,5 +203,13 @@ namespace AWGL
                 //);
-
             SwapBuffers();
-        } 
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, Width, Height);
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+        }
         #endregion
@@ -277,12 +297,2 @@ namespace AWGL
         #endregion
-
-        [STAThread]
-        public static void Main()
-        {
-            using (AWEngineWindow window = new AWEngineWindow())
-            {
-                window.Run(30, 60);
-            }
-        }
-
     }
diff --git a/Game/Program.cs b/Game/Program.cs
new file mode 100644
index 0000000..fa3b2ec
--- /dev/null
+++ b/Game/Program.cs
@@ -0,0 +1,17 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Game
+{
+    static class Program
+    {
+        [STAThread]
+        static void Main()
+        {
+            using (Window game = new Window(1024, 600)) { game.Run(); }
+        }
+    }
+}
new file mode 100644
index 0000000..2ff6e9a
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Game")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("Game")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("4eace48b-4870-46ff-b611-f513a0f075d3")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/Game/Window.cs b/Game/Window.cs
new file mode 100644
index 0000000..c590d7e
--- /dev/null
+++ b/Game/Window.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using AWGL;
+
+namespace Game
+{
+    class Window : AWEngineWindow
+    {
+        public Window(int width, int height) : base(width, height) { }
+
+        public override void UpdateFrame(double elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+    }
+
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7bf73e3f9a8dedc0e90a9b5ca119e557bc188d70">Squashed commit of the following:</a>  -  7bf73e3</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 16 files changed, 508 insertions(+), 111 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index ba0d1a8..4e2185f 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -23,4 +23,3 @@ namespace AWGL
     {
-        #region Members
-
+        #region Old code
         public static string AppName
@@ -49,7 +48,7 @@ namespace AWGL
         AWGraphLines graph;
-        Camera camera;
-        List<Key> keyList;
         #endregion
-        
-        protected PreciseTimer m_Timer = new PreciseTimer();
+
+        protected PreciseTimer m_Timer;
+        protected Camera camera;
+        protected List<Key> keyList;
 
@@ -63,24 +62,28 @@ namespace AWGL
 
-        #region OpenGL Setup
+        #region Load everything here
         protected override void OnLoad(System.EventArgs e)
         {
-            VSync = VSyncMode.On;
-            
+            m_Timer = new PreciseTimer();
+
+            //CameraManager
             camera = new Camera();
+            
+            // InputManager
             keyList = new List<Key>();
-
             Keyboard.KeyDown += HandleKeyDown;
             Keyboard.KeyUp += HandleKeyUp;
-            
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-            graph = new AWGraphLines(20);
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.CornflowerBlue);
+
+            #region Old Code
+            //root = new AWGroupNode();
+            //group = new AWGroupNode();
+            //cube = new AWCube();
+            //graph = new AWGraphLines(20);
+            //CreateShaders();
+            //CreateVBOs();
+            //CreateVAOs();
+
+            //// Other state
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.ClearColor(Color.CornflowerBlue); 
+            #endregion
 
@@ -88,5 +91,10 @@ namespace AWGL
             AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif
+#endif      
+            Initialise();
         }
 
+        public abstract void Initialise();
+        #endregion
+
+        #region Old Code
         #region Create Shaders
@@ -94,10 +102,10 @@ namespace AWGL
         {
-            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+            //shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
 
-            GL.UseProgram(shaderManager.ProgramHandle);
+            //GL.UseProgram(shaderManager.ProgramHandle);
 
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            );
+            //shaderManager.SetUniforms(
+            //    out projectionMatrixLocation, out modelviewMatrixLocation,
+            //    out projectionMatrix, modelviewMatrix, ClientSize, ref camera
+            //);
         }
@@ -108,20 +116,20 @@ namespace AWGL
         {
-            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
+            //Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            //System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            //System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
 
-            positionVboHandle = BufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //positionVboHandle = BufferManager.SetupBuffer(
+            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            normalVboHandle = BufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //normalVboHandle = BufferManager.SetupBuffer(
+            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            eboHandle = BufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //eboHandle = BufferManager.SetupBuffer(
+            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
@@ -145,12 +153,12 @@ namespace AWGL
 
-            BufferManager.SetupVaoBuffer(positionVboHandle,
+            //BufferManager.SetupVaoBuffer(positionVboHandle,
 
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            BufferManager.SetupVaoBuffer(normalVboHandle,
+            //    shaderManager.ProgramHandle, 0, 3, "in_position",
+            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+            //    );
+            //BufferManager.SetupVaoBuffer(normalVboHandle,
 
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
+            //    shaderManager.ProgramHandle, 1, 3, "in_normal",
+            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+            //    );
 
@@ -158,10 +166,10 @@ namespace AWGL
 
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
-            GL.BindVertexArray(0);
+            //GL.BindVertexArray(0);
         }
-        #endregion 
+        #endregion  
         #endregion
 
-        #region MAIN LOOP
+        #region Game Loop
         protected override void OnUpdateFrame(FrameEventArgs e)
@@ -169,10 +177,10 @@ namespace AWGL
             #region Input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            //if (Focused)
+            //{
+            //    Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            //    Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
+            //    camera.AddRotation(delta.X, delta.Y);
+            //    ResetCursor();
+            //}
 
@@ -181,9 +189,9 @@ namespace AWGL
 
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
-
-            UpdateFrame(m_Timer.GetElapsedTime());
+            #region Old Code
+            //Matrix4 lookat = camera.GetViewMatrix();
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            #endregion
         }
 
-        new public abstract void UpdateFrame(double elapsedTime);
+        new public abstract void UpdateFrame(float elapsedTime);
 
@@ -192,13 +200,19 @@ namespace AWGL
             base.OnRenderFrame(e);
-            this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            GL.Viewport(0, 0, Width, Height);
 
+            Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-                //PrimitiveType.Lines, cube.Indices.Length,
-                //DrawElementsType.UnsignedInt, IntPtr.Zero
-                //);
+            #region Old Code
+            //GL.BindVertexArray(vaoHandle);
+            //GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+            //GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
+            //PrimitiveType.Lines, cube.Indices.Length,
+            //DrawElementsType.UnsignedInt, IntPtr.Zero
+            //); 
+            #endregion
+
+            // Single call to StateRenderer to take place here.
+            RenderFrame(m_Timer.GetElapsedTime());
+
             SwapBuffers();
@@ -206,2 +220,4 @@ namespace AWGL
 
+        new public abstract void RenderFrame(float elapsedTime);
+
         protected override void OnResize(EventArgs e)
@@ -209,6 +225,8 @@ namespace AWGL
             base.OnResize(e);
-            GL.Viewport(0, 0, Width, Height);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
 
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+            #region Old Code
+            //Matrix4 lookat = camera.GetViewMatrix();
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            #endregion
         }
@@ -220,3 +238,3 @@ namespace AWGL
             base.Dispose();
-            shaderManager.Dispose();
+            //shaderManager.Dispose();
         } 
@@ -248,3 +266,3 @@ namespace AWGL
                 {
-                    case OpenTK.Input.Key.Escape:
+                    case Key.Escape:
                         Exit();
@@ -291,6 +309,6 @@ namespace AWGL
 
-            if (Focused)
-            {
-                ResetCursor();
-            }
+            //if (Focused)
+            //{
+            //    ResetCursor();
+            //}
         } 
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..f0656a9
--- /dev/null
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index d2f066d..3cecb80 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -7,3 +7,3 @@ namespace AWGL.Managers
 {
-    class InputManager
+    public static class InputManager
     {
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
new file mode 100644
index 0000000..f839772
--- /dev/null
+++ b/AWGL/Managers/StateManager.cs
@@ -0,0 +1,46 @@
+﻿using AWGL.Interfaces;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    public class StateManager
+    {
+        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        IGameObject currentState = null;
+
+        public void Update(float elapsedTime)
+        {
+            if (currentState == null)
+                return;
+            currentState.Update(elapsedTime);
+        }
+
+        public void Render()
+        {
+            if (currentState == null)
+                return;
+            currentState.Render();
+        }
+
+        public void AddState(string stateName, IGameObject state)
+        {
+            Debug.Assert( Exists(stateName) == false );
+            stateStore.Add(stateName, state);
+        }
+
+        public void ChangeState(string stateName)
+        {
+            Debug.Assert( Exists(stateName) );
+            currentState = stateStore[stateName];
+        }
+
+        public bool Exists(string stateName)
+        {
+            return stateStore.ContainsKey(stateName);
+        }
+    }
+}
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
new file mode 100644
index 0000000..b5ee17a
--- /dev/null
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -0,0 +1,23 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+using NUnit.Framework;
+using AWGL.States;
+
+namespace AWGL.Managers.Tests
+{
+    [TestFixture]
+    public class StateManagerTest
+    {
+        [Test]
+        public void TestAddStateExists()
+        {
+            StateManager stateManager = new StateManager();
+            stateManager.AddState("test-state", new SplashScreenState(stateManager));
+
+            Assert.IsTrue(stateManager.Exists("test-state"));
+        }
+    }
+}
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
new file mode 100644
index 0000000..9533adb
--- /dev/null
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers.Tests
+{
+    class TextureManagerTest
+    {
+    }
+}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 687a689..f6b9687 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -1,3 +1,7 @@
-﻿using System;
+﻿using AWGL.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
 using System.Linq;
@@ -7,4 +11,48 @@ namespace AWGL.Managers
 {
-    class TextureManager
+    public class TextureManager : IDisposable
     {
+        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+
+        public Texture Get(string textureId)
+        {
+            return m_textureDatabase[textureId];
+        }
+
+        private Bitmap bitmap;
+        private int textureGpuHandle;
+
+        public void LoadTexture(string textureId, string path)
+        {
+            new Bitmap("Data/Textures/logo.jpg");
+            bitmap = new Bitmap(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height);
+        }
+
+        #region MyRegion
+        
+        #endregion
+
+
+        public void Dispose()
+        {
+            foreach (Texture t in m_textureDatabase.Values)
+            {
+                GL.DeleteTextures(1, new int[] { t.ID });
+            }
+            bitmap.Dispose();
+        }
     }
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
new file mode 100644
index 0000000..70930e5
--- /dev/null
+++ b/AWGL/States/DefaultState.cs
@@ -0,0 +1,48 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class DefaultState : IGameObject
+    {
+        double currentRotation = 0;
+
+        StateManager m_stateManager;
+        public DefaultState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.PointSize(5f);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.TriangleStrip);
+
+            GL.Color4(new Color4(1f, 0f, 0f, .5f));
+            GL.Vertex3(new Vector3(-50f, 0f, 0f));
+            GL.Color3(new Vector3(0f, 1f, 0f));
+            GL.Vertex3(new Vector3(50f, 0, 0));
+            GL.Color3(new Vector3(0f, 0f, 1f));
+            GL.Vertex3(new Vector3(0f, 50f, 0));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
new file mode 100644
index 0000000..f905683
--- /dev/null
+++ b/AWGL/States/DrawSpriteState.cs
@@ -0,0 +1,58 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class DrawSpriteState : IGameObject
+    {
+        private ShaderManager m_shaderManager;
+        private StateManager m_stateManager;
+
+        double height, width, halfHeight, halfWidth, x, y, z;
+
+        #region IGameObject States
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+
+            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+
+            GL.End();
+
+        } 
+        #endregion
+        public DrawSpriteState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+            this.height = 200;
+            this.width = 200;
+
+            this.halfHeight = this.height / 2;
+            this.halfWidth = this.width / 2;
+
+            this.x = 0;
+            this.y = 0;
+            this.z = 2;
+        }
+    }
+}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
new file mode 100644
index 0000000..7477640
--- /dev/null
+++ b/AWGL/States/SplashScreenState.cs
@@ -0,0 +1,51 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Timers;
+
+namespace AWGL.States
+{
+    public class SplashScreenState : IGameObject
+    {
+        double currentRotation = 0;
+        double delay = 300;
+
+        StateManager m_stateManager;
+        public SplashScreenState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            delay--;
+            if (delay <= 0){
+                delay = 3;
+                m_stateManager.ChangeState("Default");
+            }
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
index b5f8c46..6fe09fc 100644
--- a/AWGL/Utilities/PreciseTimer.cs
+++ b/AWGL/Utilities/PreciseTimer.cs
@@ -27,3 +27,3 @@ namespace AWGL.Utilities
 
-        public double GetElapsedTime()
+        public float GetElapsedTime()
         {
@@ -31,3 +31,4 @@ namespace AWGL.Utilities
             QueryPerformanceCounter(ref time);
-            double elapsedTime = (double)(time - m_previouslyElapsedTime) / (double)m_ticksPerSecond;
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
 
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
new file mode 100644
index 0000000..41e0f76
--- /dev/null
+++ b/AWGL/Utilities/Renderer.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    static class Renderer
+    {
+
+        public static void DrawSkyBox()
+        {
+
+        }
+    }
+}
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
new file mode 100644
index 0000000..604d0d5
--- /dev/null
+++ b/AWGL/Utilities/Texture.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct Texture
+    {
+        public int ID { get; set; }
+        public int Width { get; set; }
+        public int Height { get; set; }
+
+        public Texture(int id, int width, int height) :this()
+        {
+            ID = id;
+            Width = width;
+            Height = Height;
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
new file mode 100644
index 0000000..dc84871
--- /dev/null
+++ b/Game/Game.cs
@@ -0,0 +1,64 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+using AWGL;
+
+using OpenTK.Graphics.OpenGL;
+using AWGL.Managers;
+using AWGL.States;
+
+namespace Game
+{
+    class Game : AWEngineWindow
+    {
+        public StateManager stateManager;
+
+        public Game(int width, int height) : base(width, height) { }
+
+        private void Setup2DGraphics(double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -100, 100);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            Setup2DGraphics(ScreenWidth, ScreenHeight);
+        }
+
+        public override void Initialise()
+        {
+            Setup2DGraphics(ScreenWidth, ScreenHeight);
+
+            stateManager = new StateManager();
+            stateManager.AddState("Splash", new SplashScreenState(stateManager));
+            stateManager.AddState("Default", new DefaultState(stateManager));
+            stateManager.AddState("Drawing", new DrawSpriteState(stateManager));
+
+            stateManager.ChangeState("Drawing");
+        }
+
+        public override void UpdateFrame(float elapsedTime)
+        {
+            
+        }
+
+        public override void RenderFrame(float elapsedTime)
+        {
+            stateManager.Update(elapsedTime);
+            stateManager.Render();
+        }
+
+    }
+
+
+}
diff --git a/Game/Program.cs b/Game/Program.cs
index fa3b2ec..8d228e5 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Window game = new Window(1024, 600)) { game.Run(); }
+            using (Game game = new Game(1024, 600)) { game.Run(30, 60); }
         }
diff --git a/Game/Window.cs b/Game/Window.cs
deleted file mode 100644
index c590d7e..0000000
--- a/Game/Window.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using AWGL;
-
-namespace Game
-{
-    class Window : AWEngineWindow
-    {
-        public Window(int width, int height) : base(width, height) { }
-
-        public override void UpdateFrame(double elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-
-
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eac1948d6ffe6cc3e9ef68c35a8174bf35ccc073">missing parentheses</a>  -  eac1948</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index f6b9687..29ec82f 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -41,3 +41,3 @@ namespace AWGL.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height);
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height));
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8fabcf8fa8919b98156e277547472e24b1de530c">Sprites.</a>  -  8fabcf8</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 4 files changed, 71 insertions(+), 15 deletions(-)

diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 9533adb..83a2473 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -5,6 +5,20 @@ using System.Text;
 
+using NUnit.Framework;
+using AWGL.Utilities;
+
 namespace AWGL.Managers.Tests
 {
-    class TextureManagerTest
+    [TestFixture]
+    public class TextureManagerTest
     {
+        [Test]
+        public void TestLoadTexture()
+        {
+            //string textureid = "test-texture";
+            //Texture t = new Texture();
+            //TextureManager manager = new TextureManager();
+            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
+
+            Assert.IsTrue(true);
+        }
     }
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 29ec82f..73c4e82 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -21,2 +21,4 @@ namespace AWGL.Managers
         private Bitmap bitmap;
+        private BitmapData bitmapData;
+
         private int textureGpuHandle;
@@ -25,4 +27,4 @@ namespace AWGL.Managers
         {
-            new Bitmap("Data/Textures/logo.jpg");
-            bitmap = new Bitmap(path);
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
 
@@ -30,14 +32,25 @@ namespace AWGL.Managers
             GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            
+            try
+            {
+                bitmap = new Bitmap(path);
+                bitmap.Save("test.bmp", ImageFormat.Bmp);
+                bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            }
+            catch (Exception e)
+            {
+                Logger.WriteLine("Error loading texture.");
+            }
 
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
 
-            bitmap.UnlockBits(data);
+            bitmap.UnlockBits(bitmapData);
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height));
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
         }
@@ -45,3 +58,3 @@ namespace AWGL.Managers
         #region MyRegion
-        
+
         #endregion
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index f905683..7c2c9e1 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -2,2 +2,3 @@
 using AWGL.Managers;
+using AWGL.Utilities;
 using OpenTK;
@@ -14,6 +15,7 @@ namespace AWGL.States
     {
-        private ShaderManager m_shaderManager;
         private StateManager m_stateManager;
+        private TextureManager m_textureManager;
 
         double height, width, halfHeight, halfWidth, x, y, z;
+        float topUV, bottomUV, leftUV, rightUV;
 
@@ -28,2 +30,7 @@ namespace AWGL.States
         {
+            Texture texture = m_textureManager.Get("test");
+            GL.Enable(EnableCap.Texture2D);
+            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
             GL.ClearColor(Color.Black);
@@ -31,8 +38,14 @@ namespace AWGL.States
 
+            GL.TexCoord2(new Vector2d(leftUV, topUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
 
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
@@ -43,5 +56,11 @@ namespace AWGL.States
         #endregion
-        public DrawSpriteState(StateManager stateManager)
+        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
         {
             m_stateManager = stateManager;
+            m_textureManager = texturManager;
+            Initialise();
+        }
+
+        private void Initialise()
+        {
             this.height = 200;
@@ -55,2 +74,7 @@ namespace AWGL.States
             this.z = 2;
+
+            this.topUV = 0;
+            this.bottomUV = 1;
+            this.leftUV = 0;
+            this.rightUV = 1;
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index dc84871..15f2687 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -17,2 +17,3 @@ namespace Game
         public StateManager stateManager;
+        public TextureManager texManager;
 
@@ -41,2 +42,6 @@ namespace Game
 
+            texManager = new TextureManager();
+
+            texManager.LoadTexture("test", "Data/Textures/logo.jpg");
+
             stateManager = new StateManager();
@@ -44,3 +49,3 @@ namespace Game
             stateManager.AddState("Default", new DefaultState(stateManager));
-            stateManager.AddState("Drawing", new DrawSpriteState(stateManager));
+            stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a923f153be3b9e117e85a1a3a814c2440be0feda">Incomplete work on Sprite and Renderer classes.</a>  -  a923f15</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 6 files changed, 214 insertions(+), 12 deletions(-)

diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 7c2c9e1..3233424 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
         {
-            Texture texture = m_textureManager.Get("test");
+            Texture texture = m_textureManager.Get("sprite1");
             GL.Enable(EnableCap.Texture2D);
@@ -39,14 +39,14 @@ namespace AWGL.States
             GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
             GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
             GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
 
             GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
             GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
             GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
 
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
new file mode 100644
index 0000000..a23de30
--- /dev/null
+++ b/AWGL/States/TestSpriteClassState.cs
@@ -0,0 +1,45 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class TestSpriteClassState : IGameObject
+    {
+        Renderer m_renderer = new Renderer();
+        TextureManager m_textureManager = new TextureManager();
+        Sprite sprite1 = new Sprite();
+        Sprite sprite2 = new Sprite();
+
+        public TestSpriteClassState(TextureManager textureManager)
+        {
+            m_textureManager = textureManager;
+            sprite1.Texture = m_textureManager.Get("sprite1");
+            //sprite1.SetHeight(256 * 0.5f);
+
+            sprite2.Texture = m_textureManager.Get("sprite2");
+            sprite2.SetPosition(new Vector3d(-2, -2, 0));
+            //sprite2.SetColour(new Color4(1, 0, 0, 1));
+        }
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(0f, 0f, 0f, 1f);
+            m_renderer.DrawSprite(sprite1);
+            m_renderer.DrawSprite(sprite2);
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/Utilities/Point.cs b/AWGL/Utilities/Point.cs
new file mode 100644
index 0000000..5f28270
--- /dev/null
+++ b/AWGL/Utilities/Point.cs
@@ -0,0 +1 @@
+﻿
\ No newline at end of file
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 41e0f76..5022a5d 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,5 @@
-﻿using System;
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
@@ -7,6 +10,34 @@ namespace AWGL.Utilities
 {
-    static class Renderer
+    class Renderer
     {
+        public Renderer()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
+        }
+
+        public void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        {
+            GL.Color4(color);
+            GL.TexCoord2(uvs);
+            GL.Vertex3(position);
+        }
+
+        public void DrawSprite(Sprite sprite)
+        {
+            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
+            GL.Begin(PrimitiveType.Triangles);
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                DrawImmediateModeVertex(
+                    sprite.VertexPositions[i],
+                    sprite.VertexColours[i],
+                    sprite.VertexUVs[i]);
+
+            }
+            GL.End();
+        }
 
-        public static void DrawSkyBox()
+        public void DrawSkyBox()
         {
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
new file mode 100644
index 0000000..ecaf2ad
--- /dev/null
+++ b/AWGL/Utilities/Sprite.cs
@@ -0,0 +1,123 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class Sprite
+    {
+        internal const int VertexAmount = 6;
+        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
+        Color4[] vertexColours = new Color4[VertexAmount];
+        Vector2[] vertexUVs = new Vector2[VertexAmount];
+        Texture texture = new Texture();
+
+        public Texture Texture
+        {
+            get { return texture; }
+            set
+            {
+                texture = value;
+
+                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
+            }
+        }
+        public Vector3d[] VertexPositions { get { return vertexPositions; } }
+
+        public Color4[] VertexColours { get { return vertexColours; } }
+
+        public Vector2[] VertexUVs { get { return vertexUVs; } }
+
+        public Sprite()
+        {
+            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
+            SetColour(new Color4(1, 1, 1, 1));
+            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
+        }
+
+        private Vector3d GetCentre()
+        {
+            double halfWidth = GetWidth() / 2;
+            double halfHeight = GetHeight() / 2;
+
+            return new Vector3d(
+                vertexPositions[0].X + halfWidth,
+                vertexPositions[0].Y - halfHeight,
+                vertexPositions[0].Z);
+        }
+
+        private void InitVertexPositions(Vector3d position, double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+
+            //GL.TexCoord2(new Vector2d(leftUV, topUV));
+            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
+            //GL.TexCoord2(new Vector2d(rightUV, topUV));
+            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+
+            //GL.TexCoord2(new Vector2d(rightUV, topUV));
+            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            //GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
+            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+        }
+
+        public double GetWidth()
+        {
+            //top right -> top left
+            return vertexPositions[1].X - vertexPositions[0].X;
+        }
+
+        public double GetHeight()
+        {
+            //top left -> bottom left
+            return vertexPositions[0].Y - vertexPositions[2].Y;
+        }
+
+        public void SetWidth(double width)
+        {
+            InitVertexPositions(GetCentre(), width, GetHeight());
+        }
+
+        public void SetHeight(double height)
+        {
+            InitVertexPositions(GetCentre(), GetWidth(), height);
+        }
+
+        public void SetPosition(double x, double y)
+        {
+            SetPosition(new Vector3d(x, y, 0));
+        }
+
+        public void SetPosition(Vector3d position)
+        {
+            InitVertexPositions(position, GetWidth(), GetHeight());
+        }
+
+        public void SetColour(Color4 color4)
+        {
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                vertexColours[i] = color4;
+            }
+        }
+
+        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
+        {
+            vertexUVs[0] = topLeft;
+            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
+
+            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[4] = bottomRight;
+            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 15f2687..59528f3 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -44,3 +44,4 @@ namespace Game
 
-            texManager.LoadTexture("test", "Data/Textures/logo.jpg");
+            texManager.LoadTexture("sprite1", "Data/Textures/metal.jpg");
+            texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
 
@@ -50,4 +51,5 @@ namespace Game
             stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
+            stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
 
-            stateManager.ChangeState("Drawing");
+            stateManager.ChangeState("TestTexture");
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/07607047892e5e246634a238485ab91a5e5a1e7d">working after a bit of a hitch</a>  -  0760704</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 5 files changed, 13 insertions(+), 14 deletions(-)

diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 3233424..3588115 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -56,2 +56,3 @@ namespace AWGL.States
         #endregion
+
         public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
index a23de30..814b797 100644
--- a/AWGL/States/TestSpriteClassState.cs
+++ b/AWGL/States/TestSpriteClassState.cs
@@ -24,7 +24,10 @@ namespace AWGL.States
             sprite1.Texture = m_textureManager.Get("sprite1");
-            //sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetPosition(new Vector3d(100, 100, 0));
+            sprite1.SetColour(new Color4(256, 256, 256, 1));
 
             sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetPosition(new Vector3d(-2, -2, 0));
-            //sprite2.SetColour(new Color4(1, 0, 0, 1));
+            sprite2.SetHeight(256 * .5f);
+            sprite2.SetPosition(new Vector3d(-100, -100, 0));
+            sprite2.SetColour(new Color4(256, 256, 256, 1));
         }
@@ -38,3 +41,3 @@ namespace AWGL.States
         {
-            GL.ClearColor(0f, 0f, 0f, 1f);
+            GL.ClearColor(1f, 1f, 1f, 1f);
             m_renderer.DrawSprite(sprite1);
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 5022a5d..22d380d 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -15,4 +15,4 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.Texture2D);
-            GL.Enable(EnableCap.Blend);
-            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
+            //GL.Enable(EnableCap.Blend);
+            //GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
         }
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
index ecaf2ad..6cf4b1f 100644
--- a/AWGL/Utilities/Sprite.cs
+++ b/AWGL/Utilities/Sprite.cs
@@ -36,3 +36,3 @@ namespace AWGL.Utilities
             InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            SetColour(new Color4(1, 1, 1, 1));
+            //SetColour(new Color4(1, 1, 1, 1));
             SetUVs(new Vector2(0, 0), new Vector2(1, 1));
@@ -56,14 +56,8 @@ namespace AWGL.Utilities
 
-            //GL.TexCoord2(new Vector2d(leftUV, topUV));
             vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            //GL.TexCoord2(new Vector2d(rightUV, topUV));
             vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
 
-            //GL.TexCoord2(new Vector2d(rightUV, topUV));
             vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            //GL.TexCoord2(new Vector2d(rightUV, bottomUV));
             vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
diff --git a/Game/Game.cs b/Game/Game.cs
index 59528f3..610b1cf 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -44,3 +44,3 @@ namespace Game
 
-            texManager.LoadTexture("sprite1", "Data/Textures/metal.jpg");
+            texManager.LoadTexture("sprite1", "Data/Textures/logo.jpg");
             texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
@@ -53,2 +53,3 @@ namespace Game
 
+            //stateManager.ChangeState("Drawing");
             stateManager.ChangeState("TestTexture");

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/4003e2a9ab743d98ef1fdad4a1ba182ecea62042">Squashed commit of the following:</a>  -  4003e2a</p><p>authored by Anthony Woodward, 4 weeks ago</p></div><pre>
 15 files changed, 305 insertions(+), 54 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 4e2185f..803587e 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,6 +39,2 @@ namespace AWGL
 
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        ShaderManager shaderManager;
-
         AWNode m_sceneGraph;
@@ -53,2 +49,4 @@ namespace AWGL
         protected List<Key> keyList;
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected ShaderManager shaderManager;
 
@@ -57,5 +55,5 @@ namespace AWGL
 
-        public AWEngineWindow(int height, int width)
+        public AWEngineWindow(int height, int width, int major, int minor)
             : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
@@ -75,2 +73,4 @@ namespace AWGL
 
+            CreateShaders();
+            
             #region Old Code
@@ -80,3 +80,3 @@ namespace AWGL
             //graph = new AWGraphLines(20);
-            //CreateShaders();
+            
             //CreateVBOs();
@@ -98,17 +98,20 @@ namespace AWGL
 
-        #region Old Code
-        #region Create Shaders
-        void CreateShaders()
+        private void CreateShaders()
         {
-            //shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
 
-            //GL.UseProgram(shaderManager.ProgramHandle);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
-            //shaderManager.SetUniforms(
-            //    out projectionMatrixLocation, out modelviewMatrixLocation,
-            //    out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            //);
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = ScreenWidth / (float)(ScreenHeight);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));//camera.GetViewMatrix();
+
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
         }
-        #endregion
 
+        #region Old Code
         #region Create VBOs
@@ -177,10 +180,10 @@ namespace AWGL
             #region Input
-            //if (Focused)
-            //{
-            //    Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-            //    Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-            //    camera.AddRotation(delta.X, delta.Y);
-            //    ResetCursor();
-            //}
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
 
@@ -190,5 +193,7 @@ namespace AWGL
             #region Old Code
-            //Matrix4 lookat = camera.GetViewMatrix();
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
             #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
         }
@@ -200,4 +205,10 @@ namespace AWGL
             base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = AWEngineWindow.AppName +
 
-            Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             
@@ -228,4 +239,4 @@ namespace AWGL
             #region Old Code
-            //Matrix4 lookat = camera.GetViewMatrix();
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
             #endregion
@@ -309,6 +320,6 @@ namespace AWGL
 
-            //if (Focused)
-            //{
-            //    ResetCursor();
-            //}
+            if (Focused)
+            {
+                ResetCursor();
+            }
         } 
diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
index 410ba8d..dff573e 100644
--- a/AWGL/Data/Shaders/CH02_FS.glsl
+++ b/AWGL/Data/Shaders/CH02_FS.glsl
@@ -1,2 +1,2 @@
-#version 330 core
+#version 140 core
 
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
index 4513442..6a17ae4 100644
--- a/AWGL/Data/Shaders/CH02_VS.glsl
+++ b/AWGL/Data/Shaders/CH02_VS.glsl
@@ -1,2 +1,2 @@
-﻿#version 330 core
+﻿#version 140 core
 
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index 46f2251..6b8e738 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 130
+﻿#version 140
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 3975262..98fde5b 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 130
+﻿#version 140
 
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
new file mode 100644
index 0000000..497ce1e
--- /dev/null
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -0,0 +1,95 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using AWGL.Utilities;
+using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Graphics;
+using System.Runtime.InteropServices;
+
+namespace AWGL.Managers
+{
+    public class BufferObjectManager
+    {
+        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
+
+        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        {
+            int bufferHandle;
+
+            #region Get sizes of buffer stores
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
+            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
+            IntPtr noOffset = new IntPtr(0);
+            #endregion
+
+            // Generate Vertex Buffer Object and bind it so it is current.
+            GL.GenBuffers(1, out bufferHandle);         
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
+
+            #region Save pointers generated by OpenGL here so i dont forget.
+            bufferObject.VboID = bufferHandle; 
+            #endregion
+            
+            #region Send all data to the Vertex Buffer
+            // Initialise storage space for the Vertex Buffer.
+            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
+            // Send Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            // Send Normals data, offset by size of Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            
+            GL.GenBuffers(1, out bufferHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, 
+                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
+                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+
+            bufferObject.IboID = bufferHandle;
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+            #endregion
+
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            // Generate Vertex Array Object and bind it so it is current.
+            GL.GenVertexArrays(1, out bufferHandle);
+            GL.BindVertexArray(bufferHandle);
+
+            bufferObject.VaoID = bufferHandle;
+
+            bufferHandle = GL.GetAttribLocation(program, "in_position");
+            GL.EnableVertexAttribArray(bufferHandle); 
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(program, bufferHandle, "in_position");
+
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            GL.EnableVertexAttribArray(bufferHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.BindAttribLocation(program, bufferHandle, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+
+            GL.BindVertexArray(bufferObject.VaoID);
+
+            m_bufferStore.Add(name, bufferObject);
+        }
+
+        public BufferObject GetBuffer(string name)
+        {
+            return m_bufferStore[name];
+        }
+    }
+}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 72b7fdd..7899c0e 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -17,3 +17,3 @@ namespace AWGL.Managers
     /// </summary>
-    class ShaderManager : IDisposable
+    public class ShaderManager : IDisposable
     {
@@ -85,3 +85,3 @@ namespace AWGL.Managers
                 GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
+                Logger.WriteLine("Program link failed: " + message);
             }
@@ -99,3 +99,3 @@ namespace AWGL.Managers
                 GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
+                Logger.WriteLine("Program validation failed" + message);
             }
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 73c4e82..22add0d 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -42,3 +42,3 @@ namespace AWGL.Managers
             {
-                Logger.WriteLine("Error loading texture.");
+                Logger.WriteLine("Error loading texture. " + e.Message);
             }
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index 7988a3f..a83299f 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using System.Runtime.InteropServices;
 
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
new file mode 100644
index 0000000..5d4d2b6
--- /dev/null
+++ b/AWGL/States/VboState.cs
@@ -0,0 +1,68 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using System.Drawing;
+using System.Diagnostics;
+
+namespace AWGL.States
+{
+    public class VboState : IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        ShaderManager m_shaderManager;
+        Cube cube;
+
+        public VboState(StateManager stateManager, ShaderManager shaderManager)
+        {
+            m_stateManager = stateManager;
+            this.m_stateManager = stateManager;
+            this.m_shaderManager = shaderManager;
+
+            cube = new Cube();
+
+            CreateVBOs();
+
+            //// Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.MidnightBlue);
+        }
+
+        private void CreateVBOs()
+        {
+            // this buffer object will take care of VAO generation temporarily - stored in bufferObject.VaoId
+            BufferObject tempVBO = new BufferObject();
+            tempVBO.PositionData = cube.Vertices;//new Vector3[cube.Vertices.Length];
+            tempVBO.NormalsData = cube.Normals; // Vector3[cube.Normals.Length];
+            tempVBO.IndicesData = cube.Indices;
+            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, m_shaderManager.ProgramHandle);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+
+        public void Render()
+        {
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType,
+                            m_bufferObject.IndicesData.Length,
+                            DrawElementsType.UnsignedInt,
+                            IntPtr.Zero);
+        }
+    }
+}
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
new file mode 100644
index 0000000..7b917da
--- /dev/null
+++ b/AWGL/Utilities/BufferObject.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct BufferObject
+    {
+        public int VaoID { get; set; }
+
+        public int VboID { get; set; }
+
+        public int IboID { get; set; }
+
+        public PrimitiveType PrimitiveType { get; set; }
+
+        public Vector3[] PositionData { get; set; }
+
+        public Vector3[] NormalsData { get; set; }
+
+        public Color4[] ColorData { get; set; }
+
+        public int[] IndicesData { get; set; }
+
+        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+        {
+            #region Buffer Pointer IDs
+            VaoID = vaoId;
+            VboID = vboId;
+            IboID = iboId;
+            #endregion
+            
+            PositionData = vPositionData;
+            NormalsData = vNormalsData;
+            ColorData = vColorData;
+            IndicesData = indicesData;
+        }
+
+    }
+}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index f806424..e454405 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -52,2 +52,4 @@ namespace AWGL.Utilities
             Position += offset;
+
+            Logger.WriteLine("Camera Position = " + Position);
         }
@@ -61,2 +63,4 @@ namespace AWGL.Utilities
             Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+
+            Logger.WriteLine("Camera Orientation = " + Orientation);
         }
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
new file mode 100644
index 0000000..2876ecc
--- /dev/null
+++ b/AWGL/Utilities/CustomVertexStruct.cs
@@ -0,0 +1,35 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.InteropServices;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct AWVertex
+    {
+        /// <summary>
+        /// Defines the size of the AWVertex struct in bytes.
+        /// </summary>
+        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
+        private Vector3[] vector31;
+        private Vector3[] vector32;
+        private int[] p;
+
+        public Vector3[] Postions { get; set; }
+
+        public Vector3[] Normals {get; set;}
+
+        public int[] Colors {get; set;}
+
+        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
+        {
+            Postions = positions;
+            Normals = nomarls;
+            Colors = colors;
+        }
+
+            
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 610b1cf..12bfbbe 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -19,3 +19,3 @@ namespace Game
 
-        public Game(int width, int height) : base(width, height) { }
+        public Game(int width, int height, int major, int minor) : base(width, height, major, minor) { }
 
@@ -32,11 +32,4 @@ namespace Game
 
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            Setup2DGraphics(ScreenWidth, ScreenHeight);
-        }
-
         public override void Initialise()
         {
-            Setup2DGraphics(ScreenWidth, ScreenHeight);
 
@@ -52,5 +45,5 @@ namespace Game
             stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
+            stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
 
-            //stateManager.ChangeState("Drawing");
-            stateManager.ChangeState("TestTexture");
+            stateManager.ChangeState("VboState");
         }
@@ -59,3 +52,3 @@ namespace Game
         {
-            
+            stateManager.Update(elapsedTime);
         }
@@ -64,3 +57,2 @@ namespace Game
         {
-            stateManager.Update(elapsedTime);
             stateManager.Render();
diff --git a/Game/Program.cs b/Game/Program.cs
index 8d228e5..c87f0aa 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600)) { game.Run(30, 60); }
+            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(30, 60); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/625d8b35abbdc497ffcb713e1a3ffc3704d319ee">Conflicts: 	AWGL/OpenTK/OpenTK.GLControl.dll 	AWGL/OpenTK/OpenTK.dll</a>  -  625d8b3</p><p>authored by Anthony Woodward, 3 weeks ago</p></div><pre>
 9 files changed, 433 insertions(+), 168 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 803587e..8529615 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -1,2 +1,4 @@
-﻿using AWGL.Managers;
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
 using AWGL.Nodes;
@@ -11,3 +13,6 @@ using System.Diagnostics;
 using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Text;
@@ -19,3 +24,4 @@ namespace AWGL
     /// <summary>
-    /// Inherit me
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
     /// </summary>
@@ -23,30 +29,4 @@ namespace AWGL
     {
-        #region Old code
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
 
-        }
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-        AWGraphLines graph;
-        #endregion
-
-        protected PreciseTimer m_Timer;
-        protected Camera camera;
-        protected List<Key> keyList;
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected ShaderManager shaderManager;
+        public static string AppName { get { return "AWEngine"; } }
 
@@ -54,6 +34,20 @@ namespace AWGL
         public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
 
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected ShaderManager shaderManager;
+        protected PreciseTimer m_Timer;
+        protected AWGL.Utilities.Camera camera;
+        protected List<Key> keyList;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(height, width, new GraphicsMode(32, 24, 8, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
@@ -66,3 +60,3 @@ namespace AWGL
             //CameraManager
-            camera = new Camera();
+            camera = new AWGL.Utilities.Camera();
             
@@ -73,17 +67,15 @@ namespace AWGL
 
-            CreateShaders();
-            
-            #region Old Code
-            //root = new AWGroupNode();
-            //group = new AWGroupNode();
-            //cube = new AWCube();
-            //graph = new AWGraphLines(20);
-            
-            //CreateVBOs();
-            //CreateVAOs();
+            //CreateShaders();
+
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+
+            AssimpContext importer = new AssimpContext();
+            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
+            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
+            ComputeBoundingBox();
 
             //// Other state
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.ClearColor(Color.CornflowerBlue); 
-            #endregion
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.Black); 
+           
 
@@ -96,3 +88,3 @@ namespace AWGL
         public abstract void Initialise();
-        #endregion
+        
 
@@ -103,73 +95,27 @@ namespace AWGL
             GL.UseProgram(shaderManager.ProgramHandle);
-
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            QueryMatrixLocations();
 
             float aspectRatio = ScreenWidth / (float)(ScreenHeight);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
-            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));//camera.GetViewMatrix();
-
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
+            SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
         }
 
-        #region Old Code
-        #region Create VBOs
-        void CreateVBOs()
+        protected void QueryMatrixLocations()
         {
-            //Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            //System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            //System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
-
-            //positionVboHandle = BufferManager.SetupBuffer(
-            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //normalVboHandle = BufferManager.SetupBuffer(
-            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //eboHandle = BufferManager.SetupBuffer(
-            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
         }
-        #endregion
 
-        #region Create VAOs
-        void CreateVAOs()
+        public void SetModelviewMatrix(Matrix4 matrix)
         {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = BufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            //BufferManager.SetupVaoBuffer(positionVboHandle,
-
-            //    shaderManager.ProgramHandle, 0, 3, "in_position",
-            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-            //    );
-            //BufferManager.SetupVaoBuffer(normalVboHandle,
-
-            //    shaderManager.ProgramHandle, 1, 3, "in_normal",
-            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-            //    );
-
-            #endregion
-
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            modelviewMatrix = matrix;
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        }
 
-            //GL.BindVertexArray(0);
+        protected void SetProjectionMatrix(Matrix4 matrix)
+        {
+            projectionMatrix = matrix;
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
         }
-        #endregion  
+
         #endregion
@@ -179,20 +125,23 @@ namespace AWGL
         {
-            #region Input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            #region input
+            //if (focused)
+            //{
+            //    point center = new point(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2);
+            //    point delta = new point(center.x - system.windows.forms.cursor.position.x, center.y - system.windows.forms.cursor.position.y);
 
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
+            //    camera.addrotation(delta.x, delta.y);
+            //    resetcursor();
+            //}
 
-            MoveCamera(); 
-            #endregion
+            //movecamera();
 
-            #region Old Code
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
             #endregion
 
+            m_angle += 25f * (float)e.Time;
+            if (m_angle > 360)
+            {
+                m_angle = 0.0f;
+            }
+
             UpdateFrame(m_Timer.GetElapsedTime());
@@ -215,13 +164,36 @@ namespace AWGL
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            // Single call to StateRenderer to take place here.
+            
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
 
-            #region Old Code
-            //GL.BindVertexArray(vaoHandle);
-            //GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            //GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-            //PrimitiveType.Lines, cube.Indices.Length,
-            //DrawElementsType.UnsignedInt, IntPtr.Zero
-            //); 
-            #endregion
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
 
-            // Single call to StateRenderer to take place here.
             RenderFrame(m_Timer.GetElapsedTime());
@@ -238,7 +210,8 @@ namespace AWGL
 
-            #region Old Code
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
-            #endregion
+            float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
         }
+
         #endregion
@@ -326,3 +299,258 @@ namespace AWGL
         #endregion
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index 6b8e738..f80f0ec 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -6,3 +6,3 @@ const vec3 ambient = vec3(0.1, 0.1, 0.1);
 const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(0.9, 0.9, 0.7);
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 98fde5b..8c9d031 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -4,8 +4,15 @@ precision highp float;
 
-uniform mat4 projection_matrix;
+// object space to camera space transformation
 uniform mat4 modelview_matrix;
-
+ 
+// camera space to clip coordinates
+uniform mat4 projection_matrix;
+ 
+// incoming vertex position
 in vec3 in_position;
+ 
+// incoming vertex normal
 in vec3 in_normal;
-
+ 
+// transformed vertex normal
 out vec3 normal;
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 497ce1e..885620e 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -76,3 +76,3 @@ namespace AWGL.Managers
 
-            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+                bufferHandle = GL.GetAttribLocation(program, "in_normal");
             GL.EnableVertexAttribArray(bufferHandle);
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
new file mode 100644
index 0000000..9005258
--- /dev/null
+++ b/AWGL/States/AssimpImportedState.cs
@@ -0,0 +1,46 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Assimp.Configs;
+using Assimp;
+using System.IO;
+using System.Reflection;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.States
+{
+    public class AssimpImportedState :IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        ShaderManager m_shaderManager;
+
+        
+
+        public AssimpImportedState(StateManager stateManager, ShaderManager shaderManager)
+        {
+            m_stateManager = stateManager;
+            m_shaderManager = shaderManager;
+        }
+
+        public void Render()
+        {
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+    }
+}
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index 5d4d2b6..6b2ac74 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -33,6 +33,2 @@ namespace AWGL.States
             CreateVBOs();
-
-            //// Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.MidnightBlue);
         }
@@ -43,4 +39,4 @@ namespace AWGL.States
             BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;//new Vector3[cube.Vertices.Length];
-            tempVBO.NormalsData = cube.Normals; // Vector3[cube.Normals.Length];
+            tempVBO.PositionData = cube.Vertices;
+            tempVBO.NormalsData = cube.Normals;
             tempVBO.IndicesData = cube.Indices;
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index e454405..014da3d 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -14,4 +14,4 @@ namespace AWGL.Utilities
     {
-        public Vector3 Position = new Vector3(2, 2, 2);
-        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public Vector3 Position = new Vector3(0f, 5f, 5f);
+        public Vector3 Orientation = new Vector3(0f, 0f, 0f);
         public float MoveSpeed = 0.2f;
diff --git a/Game/Game.cs b/Game/Game.cs
index 12bfbbe..3fac302 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -1,2 +1,5 @@
-﻿using System;
+﻿using AWGL;
+using AWGL.Managers;
+using AWGL.States;
+using System;
 using System.Collections.Generic;
@@ -6,8 +9,2 @@ using System.Threading.Tasks;
 
-using AWGL;
-
-using OpenTK.Graphics.OpenGL;
-using AWGL.Managers;
-using AWGL.States;
-
 namespace Game
@@ -21,13 +18,2 @@ namespace Game
 
-        private void Setup2DGraphics(double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -100, 100);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-        }
-
         public override void Initialise()
@@ -45,5 +31,7 @@ namespace Game
             stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
-            stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
+            //stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
+            stateManager.AddState("Assimp-state", new AssimpImportedState(stateManager, shaderManager));
 
-            stateManager.ChangeState("VboState");
+            stateManager.ChangeState("Assimp-state");
+            //stateManager.ChangeState("VboState");
         }
diff --git a/Game/Program.cs b/Game/Program.cs
index c87f0aa..a9832fc 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(30, 60); }
+            using (Game game = new Game(1024, 600, 3, 2)) { game.Run(60, 0); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e40d399153d51e446e709b684bf4ea65aba2a4b8">Adding 3D models for testing purposes.</a>  -  e40d399</p><p>authored by Anthony Woodward, 3 weeks ago</p></div><pre>
 1 file changed, 59 insertions(+), 55 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 8529615..bf69ca1 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -3,3 +3,2 @@ using Assimp.Configs;
 using AWGL.Managers;
-using AWGL.Nodes;
 using AWGL.Utilities;
@@ -11,3 +10,2 @@ using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Drawing;
@@ -15,7 +13,4 @@ using System.Drawing.Imaging;
 using System.IO;
-using System.Linq;
 using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
+using System.Windows.Forms;
 
@@ -50,3 +45,3 @@ namespace AWGL
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 8, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            : base(height, width, new GraphicsMode(32, 24, 8, 8), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -68,4 +63,4 @@ namespace AWGL
             //CreateShaders();
-
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+                                                                                                            //"Content/Models/Characters/bunny/reconstruction/bun_zipper.ply"
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");
 
@@ -78,3 +73,3 @@ namespace AWGL
             GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.Black); 
+            GL.ClearColor(.1f, 0f, .1f, 0f);
            
@@ -99,3 +94,3 @@ namespace AWGL
             SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
-            SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+            SetModelviewMatrix(Matrix4.CreateTranslation(0, 0, 5));
         }
@@ -126,12 +121,12 @@ namespace AWGL
             #region input
-            //if (focused)
-            //{
-            //    point center = new point(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2);
-            //    point delta = new point(center.x - system.windows.forms.cursor.position.x, center.y - system.windows.forms.cursor.position.y);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
 
-            //    camera.addrotation(delta.x, delta.y);
-            //    resetcursor();
-            //}
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
 
-            //movecamera();
+            MoveCamera();
 
@@ -175,6 +170,6 @@ namespace AWGL
             GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = camera.GetViewMatrix();
             GL.LoadMatrix(ref lookat);
 
-            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
 
@@ -184,3 +179,3 @@ namespace AWGL
             tmp = 1.0f / tmp;
-            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+            GL.Scale(tmp * 20, tmp * 20, tmp * 20);
 
@@ -245,37 +240,46 @@ namespace AWGL
         {
-            foreach (Key key in keyList)
+            if (keyList.Count > 0) 
             {
-
-                switch (key)
+                foreach (Key key in keyList)
                 {
-                    case Key.Escape:
-                        Exit();
-                        break;
-
-                    case Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
 
-                    case Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
+                    switch (key)
+                    {
+                        case Key.Escape:
+                            Exit();
+                            break;
+
+                        case Key.W:
+                            camera.Move(0f, 0.1f, 0f);
+                            break;
+
+                        case Key.A:
+                            camera.Move(-0.1f, 0f, 0f);
+                            break;
+
+                        case Key.S:
+                            camera.Move(0f, -0.1f, 0f);
+                            break;
+
+                        case Key.D:
+                            camera.Move(0.1f, 0f, 0f);
+                            break;
+
+                        case Key.Q:
+                            camera.Move(0f, 0f, 0.1f);
+                            break;
+
+                        case Key.E:
+                            camera.Move(0f, 0f, -0.1f);
+                            break;
+
+                        case Key.F11:
+                            if (this.WindowState == OpenTK.WindowState.Normal)
+                                this.WindowState = OpenTK.WindowState.Fullscreen;
+                            else
+                                this.WindowState = OpenTK.WindowState.Normal;
+                            break;
+                        default:
+                            break;
+                    }
                 }
@@ -469,3 +473,3 @@ namespace AWGL
             {
-                // color = FromColor(mat.ColorDiffuse);
+                color = FromColor(mat.ColorDiffuse);
             }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/56b219d6513cada51642a3698baa468e4ead0b3f">More resources.</a>  -  56b219d</p><p>authored by Anthony Woodward, 3 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index bf69ca1..62f659c 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -63,3 +63,3 @@ namespace AWGL
             //CreateShaders();
-                                                                                                            //"Content/Models/Characters/bunny/reconstruction/bun_zipper.ply"
+                                                                                                            //"Content/Models/Vehicles/Jupiter2/jupe2/Jupiter 2 Plus.obj"
             String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/219a36c845c2058bda2f48385dcecf8c59a1caa8">disabled full screen switching for now. too buggy.</a>  -  219a36c</p><p>authored by Anthony Woodward, 3 weeks ago</p></div><pre>
 1 file changed, 6 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 62f659c..7bcc546 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -275,8 +275,2 @@ namespace AWGL
 
-                        case Key.F11:
-                            if (this.WindowState == OpenTK.WindowState.Normal)
-                                this.WindowState = OpenTK.WindowState.Fullscreen;
-                            else
-                                this.WindowState = OpenTK.WindowState.Normal;
-                            break;
                         default:

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/75a695d4fd593d49cc65fb401a15604bbcfe0c96">Squashed commit of the following:</a>  -  75a695d</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 32 files changed, 905 insertions(+), 1055 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 7bcc546..ee38827 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -3,2 +3,3 @@ using Assimp.Configs;
 using AWGL.Managers;
+using AWGL.Nodes;
 using AWGL.Utilities;
@@ -10,2 +11,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Drawing;
@@ -13,3 +15,7 @@ using System.Drawing.Imaging;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
 using System.Windows.Forms;
@@ -33,6 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected ShaderManager shaderManager;
         protected PreciseTimer m_Timer;
-        protected AWGL.Utilities.Camera camera;
-        protected List<Key> keyList;
 
@@ -45,4 +48,4 @@ namespace AWGL
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 8, 8), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
         { }
@@ -52,29 +55,3 @@ namespace AWGL
         {
-            m_Timer = new PreciseTimer();
-
-            //CameraManager
-            camera = new AWGL.Utilities.Camera();
-            
-            // InputManager
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //CreateShaders();
-                                                                                                            //"Content/Models/Vehicles/Jupiter2/jupe2/Jupiter 2 Plus.obj"
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");
-
-            AssimpContext importer = new AssimpContext();
-            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
-            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
-            ComputeBoundingBox();
-
-            //// Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(.1f, 0f, .1f, 0f);
-           
-
-#if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif      
+            BaseInitialisation();
             Initialise();
@@ -82,35 +59,57 @@ namespace AWGL
 
-        public abstract void Initialise();
-        
-
-        private void CreateShaders()
+        private void BaseInitialisation()
         {
-            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-            QueryMatrixLocations();
-
-            float aspectRatio = ScreenWidth / (float)(ScreenHeight);
-            SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
-            SetModelviewMatrix(Matrix4.CreateTranslation(0, 0, 5));
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
         }
 
-        protected void QueryMatrixLocations()
+        private void InitialiseInput()
         {
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
         }
 
-        public void SetModelviewMatrix(Matrix4 matrix)
+        private void InitialiseTimer()
         {
-            modelviewMatrix = matrix;
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            m_Timer = new PreciseTimer();
         }
 
-        protected void SetProjectionMatrix(Matrix4 matrix)
+        private void InitialiseStockShaders()
         {
-            projectionMatrix = matrix;
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            ShaderManager.LoadDefaultShaderProgram();
         }
 
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
         #endregion
@@ -126,3 +125,3 @@ namespace AWGL
 
-                camera.AddRotation(delta.X, delta.Y);
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
                 ResetCursor();
@@ -130,4 +129,2 @@ namespace AWGL
 
-            MoveCamera();
-
             //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
@@ -135,8 +132,2 @@ namespace AWGL
 
-            m_angle += 25f * (float)e.Time;
-            if (m_angle > 360)
-            {
-                m_angle = 0.0f;
-            }
-
             UpdateFrame(m_Timer.GetElapsedTime());
@@ -157,17 +148,22 @@ namespace AWGL
                 " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
             // Single call to StateRenderer to take place here.
-            
-            GL.Enable(EnableCap.Texture2D);
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.Normalize);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.LoadMatrix(ref lookat);
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
 
@@ -175,19 +171,20 @@ namespace AWGL
 
-            float tmp = m_sceneMax.X - m_sceneMin.X;
-            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            tmp = 1.0f / tmp;
-            GL.Scale(tmp * 20, tmp * 20, tmp * 20);
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
 
-            GL.Translate(-m_sceneCenter);
+            //GL.Translate(-m_sceneCenter);
 
-            if (m_displayList == 0)
-            {
-                m_displayList = GL.GenLists(1);
-                GL.NewList(m_displayList, ListMode.Compile);
-                RecursiveRender(m_model, m_model.RootNode);
-                GL.EndList();
-            }
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
 
-            GL.CallList(m_displayList);
+            //GL.CallList(m_displayList); 
+            #endregion
 
@@ -205,8 +202,12 @@ namespace AWGL
 
-            float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-        }
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
 
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
         #endregion
@@ -216,4 +217,3 @@ namespace AWGL
         {
-            base.Dispose();
-            //shaderManager.Dispose();
+            
         } 
@@ -222,5 +222,8 @@ namespace AWGL
         #region Input Control
+        
         private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
         {
-            keyList.Add(e.Key);
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
         }
@@ -229,7 +232,7 @@ namespace AWGL
         {
-            for (int count = 0; count < keyList.Count; count++)
+            for (int count = 0; count < InputManager.keyList.Count; count++)
             {
-                if (keyList[count] == e.Key)
+                if (InputManager.keyList[count] == e.Key)
                 {
-                    keyList.Remove(keyList[count]);
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
                 }
@@ -238,47 +241,3 @@ namespace AWGL
 
-        private void MoveCamera()
-        {
-            if (keyList.Count > 0) 
-            {
-                foreach (Key key in keyList)
-                {
-
-                    switch (key)
-                    {
-                        case Key.Escape:
-                            Exit();
-                            break;
-
-                        case Key.W:
-                            camera.Move(0f, 0.1f, 0f);
-                            break;
-
-                        case Key.A:
-                            camera.Move(-0.1f, 0f, 0f);
-                            break;
-
-                        case Key.S:
-                            camera.Move(0f, -0.1f, 0f);
-                            break;
-
-                        case Key.D:
-                            camera.Move(0.1f, 0f, 0f);
-                            break;
-
-                        case Key.Q:
-                            camera.Move(0f, 0f, 0.1f);
-                            break;
-
-                        case Key.E:
-                            camera.Move(0f, 0f, -0.1f);
-                            break;
-
-                        default:
-                            break;
-                    }
-                }
-            }
-        }
-
-        private void ResetCursor()
+        public void ResetCursor()
         {
@@ -296,4 +255,7 @@ namespace AWGL
         } 
+        
         #endregion
 
+        #region Assimp example code
+
         private void ComputeBoundingBox()
@@ -467,3 +429,3 @@ namespace AWGL
             {
-                color = FromColor(mat.ColorDiffuse);
+                // color = FromColor(mat.ColorDiffuse);
             }
@@ -547,2 +509,4 @@ namespace AWGL
 
+        #endregion
+
         protected override void OnUnload(EventArgs e)
diff --git a/AWGL/AWOldEngineWindow.cs b/AWGL/AWOldEngineWindow.cs
deleted file mode 100644
index 8b85c34..0000000
--- a/AWGL/AWOldEngineWindow.cs
+++ /dev/null
@@ -1,253 +0,0 @@
-﻿using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Shapes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class AWOldEngineWindow : GameWindow
-    {
-        #region Constructor
-
-        public AWOldEngineWindow() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new Camera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(20); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected Camera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private ShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
deleted file mode 100644
index adf29da..0000000
--- a/AWGL/AWSceneManager.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class AWSceneManager
-    {
-
-    }
-}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
deleted file mode 100644
index 66624c7..0000000
--- a/AWGL/AWUtils.cs
+++ /dev/null
@@ -1,192 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.IO;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Utility functions
-    /// </summary>
-    public class AWUtils
-    {
-        /// <summary>
-        /// Helper Funtion for loading shaders. Returns Shader Source from file.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <returns>Shader Source Code</returns>
-        public static string LoadShader(String filename)
-        {
-            string dataPath = "Data/Shaders/";
-            string shaderSource;
-
-            using (StreamReader sr = new StreamReader(dataPath + filename))
-            {
-                shaderSource = sr.ReadToEnd();
-            }
-
-            return shaderSource;
-        }     
-        
-        /// <summary>
-        /// Load the shader file, creates an OpenGL shader object, compiles the 
-        /// source code and returns the handle to the internal shader object. 
-        /// If the compilation fails, the application will exit.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <returns>Shader Handle</returns>
-        public static int BuildShader(string filename, ShaderType shaderType)
-        {
-            string shaderSource = LoadShader(filename);
-
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, shaderSource);
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        /// <summary>
-        /// Creates a program object, attaches the shaders, links them and 
-        /// returns the OpenGL handle of the program.
-        /// </summary>
-        /// <param name="vertexShaderId">Shader Handle</param>
-        /// <param name="fragmentShaderId">Shader Handle</param>
-        /// <returns>Shader Program Handle</returns>
-        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
-        {
-            int programHandle = GL.CreateProgram();
-            GL.AttachShader(programHandle, vertexShaderId);
-            GL.AttachShader(programHandle, fragmentShaderId);
-            GL.LinkProgram(programHandle);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess);
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess);
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
-            }
-
-            return programHandle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <typeparam name="TVertex"></typeparam>
-        /// <param name="vertices"></param>
-        /// <param name="elements"></param>
-        /// <param name="elementSize"></param>
-        /// <param name="typeSize"></param>
-        /// <param name="bufferUsageTypeGL"></param>
-        /// <returns></returns>
-        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements, 
-                                           int elementSize, 
-                                           int typeSize, 
-                                           BufferUsageHint bufferUsageTypeGL) 
-            where TVertex : struct
-        {
-            Vbo vboHandle = new Vbo();
-
-            vboHandle.NumElements = elements.Length;
-
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            #region
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-            #endregion
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != vbo_Size)
-                throw new Exception("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != ebo_Size)
-                throw new Exception("Element data not uploaded correctly");
-
-            return vboHandle;
-        }
-
-        #region TestOpenGLVersion
-        /// <summary>
-        /// Get OpenGL Version Information and check system meets requirements
-        /// </summary>
-        public static void TestOpenGLVersion()
-        {
-            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 0);
-            Version m_TargetHigh = new Version(4, 1);
-            if (m_Version < m_TargetLow)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
-            }
-            else if (m_Version > m_TargetHigh)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
-            }
-        }
-        #endregion
-
-        public static string PrintOpenGLInfo()
-        {
-            
-            TestOpenGLVersion();
-
-            return "AWGL Engine Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index f80f0ec..f890462 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 140
+#version 410 core
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 8c9d031..1cd8777 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 140
+#version 410 core
 
@@ -22,3 +22,3 @@ void main(void)
   //works only for orthogonal modelview
-  normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
   
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
new file mode 100644
index 0000000..fa93cee
--- /dev/null
+++ b/AWGL/Data/Shaders/render-fs.glsl
@@ -0,0 +1,21 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} fs_in;
+
+out vec4 color;
+
+void main(void)
+{
+    // Reflect view vector about the plane defined by the normal
+    // at the fragment
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+
+    // Sample from scaled using reflection vector
+     color = texture(tex_cubemap, r);
+}
diff --git a/AWGL/Data/Shaders/render-vs.glsl b/AWGL/Data/Shaders/render-vs.glsl
new file mode 100644
index 0000000..4f89dba
--- /dev/null
+++ b/AWGL/Data/Shaders/render-vs.glsl
@@ -0,0 +1,23 @@
+#version 410 core
+
+uniform mat4 mv_matrix;
+uniform mat4 proj_matrix;
+
+layout (location = 0) in vec4 in_position;
+layout (location = 1) in vec3 in_normal;
+
+out VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} vs_out;
+
+void main(void)
+{
+    vec4 pos_vs = mv_matrix * in_position;
+
+    vs_out.normal = mat3(mv_matrix) * in_normal;
+    vs_out.view = pos_vs.xyz;
+
+    gl_Position = proj_matrix * pos_vs;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-fs.glsl b/AWGL/Data/Shaders/skybox-fs.glsl
new file mode 100644
index 0000000..f996bf4
--- /dev/null
+++ b/AWGL/Data/Shaders/skybox-fs.glsl
@@ -0,0 +1,15 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+	vec3 tc;
+}fs_in;
+
+layout(location = 0) out vec4 color;
+
+void main(void)
+{
+	color = texture(tex_cubemap, fs_in.tc);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
new file mode 100644
index 0000000..6ef7af2
--- /dev/null
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -0,0 +1,18 @@
+﻿#version 410 core
+ 
+ out VS_OUT
+ {
+	vec3 tc;
+ }vs_out;
+
+uniform vec3 eye_position;
+uniform mat4 mv_matrix;
+uniform mat4 mvp_matrix;
+
+in lowp vec3 in_position;
+
+ void main(void)
+ {
+	vs_out.tc = in_position;
+	gl_Position = mvp_matrix * vec4(in_position, 1.0);
+ }
\ No newline at end of file
diff --git a/AWGL/Managers/BufferManager.cs b/AWGL/Managers/BufferManager.cs
deleted file mode 100644
index f3719c4..0000000
--- a/AWGL/Managers/BufferManager.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL.Managers
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    public sealed class BufferManager : IDisposable
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile BufferManager instance = new BufferManager();
-        private static object syncRoot = new Object();
-
-        private BufferManager() { }
-
-        public static BufferManager Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new BufferManager();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        #region Set up Vertex Buffer Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-            return handle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-            return handle;
-        } 
-        #endregion
-
-        #region Set up Vertex Array Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="bufferHandle"></param>
-        /// <param name="ProgramHandle"></param>
-        /// <param name="index"></param>
-        /// <param name="size"></param>
-        /// <param name="attributeName"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="vertexAttribPointerType"></param>
-        internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
-            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, bufferHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType,
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal static int GenerateVaoBuffer()
-        {
-            int handle;
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-            return handle;
-        } 
-        #endregion
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 885620e..497ce1e 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -76,3 +76,3 @@ namespace AWGL.Managers
 
-                bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
             GL.EnableVertexAttribArray(bufferHandle);
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 3cecb80..4985b5d 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK.Input;
+using System;
 using System.Collections.Generic;
@@ -9,2 +10,5 @@ namespace AWGL.Managers
     {
+        public static List<Key> keyList = new List<Key>();
+
+
     }
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 7899c0e..1de11cf 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -17,29 +17,45 @@ namespace AWGL.Managers
     /// </summary>
-    public class ShaderManager : IDisposable
+    public static class ShaderManager
     {
-        #region Private Members
+        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+
         // Handles
-        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
 
-        private string defaultDataPath = "Data/Shaders/";
-        private string m_vertexShaderPath = "Simple_VS";
-        private string m_fragmentShaderPath = "Simple_FS";
-        #endregion
+        private static string defaultDataPath = "Data/Shaders/";
+        private static string m_vertexShaderFile = "opentk-vs";
+        private static string m_fragmentShaderFile = "opentk-fs";
 
-        #region Contructors
-        public ShaderManager() 
-        { 
-            m_programHandle = BuildProgram(); 
+        internal static void LoadDefaultShaderProgram()
+        {
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("default", new Shader(m_programHandle));
         }
 
-        public ShaderManager(string vertexShaderPath, string fragmentShaderPath)
+        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
         {
-            m_vertexShaderPath = vertexShaderPath;
-            m_fragmentShaderPath = fragmentShaderPath;
+            m_vertexShaderFile = vertexShaderPath;
+            m_fragmentShaderFile = fragmentShaderPath;
             m_programHandle = BuildProgram();
+
+            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
+        }
+
+        public static Shader DefaultShader
+        {
+            get
+            {
+                return m_shaderStorage["default"];
+            }
+        }
+
+        public static Shader Get(string shaderID)
+        {
+            return m_shaderStorage[shaderID];
         }
-        #endregion
 
         #region Shader and Program Contruction Methods
-        internal string LoadShader(string shaderSourcePath)
+        internal static string LoadShader(string shaderSourcePath)
         {
@@ -51,3 +67,3 @@ namespace AWGL.Managers
 
-        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
         {
@@ -65,6 +81,6 @@ namespace AWGL.Managers
 
-        internal int BuildProgram()
+        internal static int BuildProgram()
         {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
+            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
 
@@ -78,12 +94,5 @@ namespace AWGL.Managers
             #region Check linker success
-
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Logger.WriteLine("Program link failed: " + message);
-            }
-
+            int[] temp = new int[1];
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
+            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
             #endregion
@@ -91,12 +100,18 @@ namespace AWGL.Managers
             #region Validate Program
-
-            int validateSuccess;
             GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Logger.WriteLine("Program validation failed" + message);
-            }
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
+            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            //if (validateSuccess == 0)
+            //{
+            //    String message;
+            //    GL.GetProgramInfoLog(programHandle, out message);
+            //    Logger.WriteLine("Program validation failed" + message);
+            //}
+            #endregion
+
+            #region Registered Attributes
+            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
+            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
+
+            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
             #endregion
@@ -111,33 +126,18 @@ namespace AWGL.Managers
 
-        #region IDisposable
-        public void Dispose()
-        {
-            GL.DeleteProgram(m_programHandle);
-        }
-        #endregion
-
         #region Public Methods
 
-        public int ProgramHandle
-        {
-            get
-            {
-                return m_programHandle;
-            }
-        }
-
-        public void SetUniforms(
-            out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, Matrix4 mvMatrix,
-            Size dimensions, ref Camera camera)
-        {
-            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+        //public void SetUniforms(
+        //    out int projMatrixHandle, out int mvMatrixHandle,
+        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
+        //    Size dimensions, ref Camera camera)
+        //{
+        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
 
-            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
 
-            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        } 
+        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        //} 
         #endregion
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index f839772..81cdad1 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -34,3 +34,3 @@ namespace AWGL.Managers
 
-        public void ChangeState(string stateName)
+        public void SetState(string stateName)
         {
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 22add0d..f58a674 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -20,2 +20,3 @@ namespace AWGL.Managers
 
+        private int textureGpuHandle;
         private Bitmap bitmap;
@@ -23,4 +24,2 @@ namespace AWGL.Managers
 
-        private int textureGpuHandle;
-
         public void LoadTexture(string textureId, string path)
@@ -32,20 +31,10 @@ namespace AWGL.Managers
             GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-            
-            try
-            {
-                bitmap = new Bitmap(path);
-                bitmap.Save("test.bmp", ImageFormat.Bmp);
-                bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            }
-            catch (Exception e)
-            {
-                Logger.WriteLine("Error loading texture. " + e.Message);
-            }
 
+            OpenImageFile(path);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+            GL.TexImage2D(TextureTarget.Texture2D, 
+                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
                 OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
 
-            bitmap.UnlockBits(bitmapData);
+            CloseImageFile();
 
@@ -53,3 +42,3 @@ namespace AWGL.Managers
             GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            
+
             m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
@@ -57,5 +46,48 @@ namespace AWGL.Managers
 
-        #region MyRegion
+        public void LoadSkyTexture(string textureId, string[] path)
+        {
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
+
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+
+            for (int face = 0; face < 6; face++)
+            {
+                OpenImageFile(path[face]);
+                bitmap.Save(face + ".bmp");
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
+                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+                GL.Finish();
+                CloseImageFile();
+            }
 
-        #endregion
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        private void OpenImageFile(string path)
+        {
+            bitmap = new Bitmap(path);
+
+            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+        }
+
+        private void CloseImageFile()
+        {
+            bitmap.UnlockBits(bitmapData);
+
+            CleanUp();
+        }
+
+        private void CleanUp()
+        {
+            bitmap.Dispose();
+        }
 
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index ca93718..ebd2cf8 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -11,3 +11,3 @@ namespace AWGL.Nodes
     {
-        protected BufferManager m_BufferManager;
+        protected BufferObjectManager m_BufferManager;
 
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index d9fb493..da559ff 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -13,3 +13,4 @@ namespace AWGL.Shapes
     {
-        public Cube()
+
+        public Cube(int x, int y, int z)
         {
@@ -17,10 +18,10 @@ namespace AWGL.Shapes
             {
-                new Vector3(-1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f, -1.0f, -1.0f), 
-                new Vector3( 1.0f,  1.0f, -1.0f),
-                new Vector3(-1.0f,  1.0f, -1.0f)
+                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f, y-1.0f, z-1.0f),
+                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
+                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
+                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
             };
@@ -68,2 +69,3 @@ namespace AWGL.Shapes
 
+
         /// <summary>
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index 9005258..b93645e 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -25,10 +25,6 @@ namespace AWGL.States
         StateManager m_stateManager;
-        ShaderManager m_shaderManager;
 
-        
-
-        public AssimpImportedState(StateManager stateManager, ShaderManager shaderManager)
+        public AssimpImportedState(StateManager stateManager)
         {
             m_stateManager = stateManager;
-            m_shaderManager = shaderManager;
         }
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
new file mode 100644
index 0000000..a35e38b
--- /dev/null
+++ b/AWGL/States/Skyboxstate.cs
@@ -0,0 +1,218 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.States
+{
+    public class Skyboxstate : IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        Cube cube;
+        BufferObject cubeObject;
+
+        // Data layout for each line below is:
+        // position{XYZ},			    normal{XYZ},
+        float[] vertexData = new float[] {
+            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
+  
+            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
+  
+            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
+  
+            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
+  
+            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
+  
+            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
+        };
+
+        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        Matrix3 modelMatrix3, normalMatrix;
+        Vector3 eyeObjectSpace;
+        Vector3 trans;
+
+        
+        int eye_handle, skybox_vao;
+
+        float aspect = 1024 / (float)600;
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            LoadCubeMap();
+            CreateShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+            trans = new Vector3(0f, 0f, -10f);
+
+            LoadTestObject();
+        }
+
+        private void CreateShaders()
+        {
+            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
+
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
+            eye_handle = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+            GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            GL.GenVertexArrays(1, out skybox_vao);
+            GL.BindVertexArray(skybox_vao);
+
+            GL.DepthFunc(DepthFunction.Lequal);
+            //GL.GenBuffers(1, out cubevbo);
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, cubevbo);
+            //GL.BufferData(BufferTarget.ArrayBuffer, new IntPtr(sizeof(float) * vertexData.Length), vertexData, BufferUsageHint.StaticDraw);
+
+            //GL.EnableVertexAttribArray(vertexAttribPosition);
+            //GL.VertexAttribPointer(vertexAttribPosition, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(0));
+            //GL.EnableVertexAttribArray(vertexAttribNormal);
+            //GL.VertexAttribPointer(vertexAttribNormal, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(12));
+
+            //cubeindexCount = 36;
+        }
+
+        private void LoadTestObject()
+        {
+            cube = new Cube(0, 0, 0);
+            cubeObject = new BufferObject();
+            cubeObject.PositionData = cube.Vertices;
+            cubeObject.NormalsData = cube.Normals;
+            cubeObject.IndicesData = cube.Indices;
+            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
+
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Skybox").ID);
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            MoveCamera();
+            _rotation += elapsedTime * 0.1f;
+
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
+            Renderer.modelViewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            eyeObjectSpace = new Vector3(0.0f, 0.0f, 1.0f);
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Camera.GetViewMatrix());
+        }
+
+        public void Render()
+        {
+            Renderer.DrawSkyBox(m_textureManager, cubeObject);
+        }
+
+        #region Input Control
+        private void MoveCamera()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+
+            }
+        #endregion
+        }
+    }
+}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index 7477640..8507938 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
                 delay = 3;
-                m_stateManager.ChangeState("Default");
+                m_stateManager.SetState("Voxels");
             }
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index 6b2ac74..daf98d4 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -19,14 +19,10 @@ namespace AWGL.States
         BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
         BufferObject m_bufferObject;
         StateManager m_stateManager;
-        ShaderManager m_shaderManager;
-        Cube cube;
+        Cube cube = new Cube(0, 0, 0);
 
-        public VboState(StateManager stateManager, ShaderManager shaderManager)
+        public VboState(StateManager stateManager)
         {
             m_stateManager = stateManager;
-            this.m_stateManager = stateManager;
-            this.m_shaderManager = shaderManager;
-
-            cube = new Cube();
 
@@ -37,3 +33,2 @@ namespace AWGL.States
         {
-            // this buffer object will take care of VAO generation temporarily - stored in bufferObject.VaoId
             BufferObject tempVBO = new BufferObject();
@@ -44,5 +39,4 @@ namespace AWGL.States
 
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, m_shaderManager.ProgramHandle);
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
             m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-
         }
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
new file mode 100644
index 0000000..bc8d310
--- /dev/null
+++ b/AWGL/States/VoxelState.cs
@@ -0,0 +1,108 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace AWGL.States
+{
+    public class VoxelState : IGameObject
+    {
+        double currentRotation = 0;
+        public float length = 1f, height = 1f, width = 1f;
+
+        StateManager m_stateManager = new StateManager();
+
+        BufferObjectManager m_bufferObjectManager;
+        BufferObject m_bufferObject;
+
+        TextureManager m_textureManager = new TextureManager();
+
+        Cube[][][] m_blocks;
+
+        public VoxelState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            m_bufferObjectManager = new BufferObjectManager();
+
+            //LoadSkyBox();
+
+            GenerateChunk();
+        }
+
+        private void LoadSkyBox()
+        {
+            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+            m_textureManager.LoadSkyTexture("skybox", 
+                new string[] 
+                {
+                    skyboxTexturePath + "jajlands1_ft.jpg",
+                    skyboxTexturePath + "jajlands1_bk.jpg",
+                    skyboxTexturePath + "jajlands1_lf.jpg",
+                    skyboxTexturePath + "jajlands1_rt.jpg",
+                    skyboxTexturePath + "jajlands1_up.jpg",
+                    skyboxTexturePath + "jajlands1_dn.jpg"
+                }
+            );
+
+        }
+
+        private void GenerateChunk()
+        {
+            BufferObject tmpVBO = new BufferObject();
+            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+            
+            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+            {
+                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+                {
+                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+                    {
+                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+                        if (x == 0 && y == 0 && z == 0) 
+                        { 
+                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+                        }
+                        else
+                        { 
+                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+                        }
+                    }
+                }
+            }
+
+            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 100 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+        }
+    }
+}
diff --git a/AWGL/TextRenderer.cs b/AWGL/TextRenderer.cs
deleted file mode 100644
index cc94917..0000000
--- a/AWGL/TextRenderer.cs
+++ /dev/null
@@ -1,155 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using OpenTK;
-using System.Drawing;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Uses System.Drawing for 2d text rendering.
-    /// </summary>
-    public class TextRenderer : IDisposable
-    {
-        Bitmap bmp;
-        Graphics gfx;
-        int texture;
-        Rectangle dirty_region;
-        bool disposed;
-
-        #region Constructors
-
-        /// <summary>
-        /// Constructs a new instance.
-        /// </summary>
-        /// <param name="width">The width of the backing store in pixels.</param>
-        /// <param name="height">The height of the backing store in pixels.</param>
-        public TextRenderer(int width, int height)
-        {
-            if (width <= 0)
-                throw new ArgumentOutOfRangeException("width");
-            if (height <= 0)
-                throw new ArgumentOutOfRangeException("height ");
-            if (GraphicsContext.CurrentContext == null)
-                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
-
-            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            gfx = Graphics.FromImage(bmp);
-            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
-
-            texture = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
-                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-        }
-
-        #endregion
-
-        #region Public Members
-
-        /// <summary>
-        /// Clears the backing store to the specified color.
-        /// </summary>
-        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
-        public void Clear(Color color)
-        {
-            gfx.Clear(color);
-            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
-        }
-
-        /// <summary>
-        /// Draws the specified string to the backing store.
-        /// </summary>
-        /// <param name="text">The <see cref="System.String"/> to draw.</param>
-        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
-        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
-        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
-        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
-        public void DrawString(string text, Font font, Brush brush, PointF point)
-        {
-            gfx.DrawString(text, font, brush, point);
-
-            SizeF size = gfx.MeasureString(text, font);
-            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
-            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
-        }
-
-        /// <summary>
-        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
-        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
-        /// in order to render the drawn text on screen.
-        /// </summary>
-        public int Texture
-        {
-            get
-            {
-                UploadBitmap();
-                return texture;
-            }
-        }
-
-        #endregion
-
-        #region Private Members
-
-        // Uploads the dirty regions of the backing store to the OpenGL texture.
-        void UploadBitmap()
-        {
-            if (dirty_region != RectangleF.Empty)
-            {
-                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
-                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-                GL.BindTexture(TextureTarget.Texture2D, texture);
-                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
-                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
-                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-                bmp.UnlockBits(data);
-
-                dirty_region = Rectangle.Empty;
-            }
-        }
-
-        #endregion
-
-        #region IDisposable Members
-
-        void Dispose(bool manual)
-        {
-            if (!disposed)
-            {
-                if (manual)
-                {
-                    bmp.Dispose();
-                    gfx.Dispose();
-                    if (GraphicsContext.CurrentContext != null)
-                        GL.DeleteTexture(texture);
-                }
-
-                disposed = true;
-            }
-        }
-
-        public void Dispose()
-        {
-            Dispose(true);
-            GC.SuppressFinalize(this);
-        }
-
-        ~TextRenderer()
-        {
-            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
-        }
-
-        #endregion
-    }
-
-}
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
new file mode 100644
index 0000000..80a21e8
--- /dev/null
+++ b/AWGL/Utilities/Block.cs
@@ -0,0 +1,29 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public class Block
+    {
+        enum BlockType
+        {
+            BlockType_Default = 0,
+
+            BlockType_Grass,
+            BlockType_Dirt,
+            BlockType_Water,
+            BlockType_Stone,
+            BlockType_Wood,
+            BlockType_Sand,
+
+            BlockType_NumTypes,
+        };
+
+        public bool IsActive { get; set; }
+        private bool m_active;
+        private BlockType type;
+    }
+}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index 014da3d..be2ebfc 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -12,10 +12,10 @@ namespace AWGL.Utilities
     /// </summary>
-    public class Camera
+    public static class Camera
     {
-        public Vector3 Position = new Vector3(0f, 5f, 5f);
-        public Vector3 Orientation = new Vector3(0f, 0f, 0f);
-        public float MoveSpeed = 0.2f;
-        public float MouseSensitivity = 0.01f;
+        public static Vector3 Position = new Vector3(0f, 0f, 0f);
+        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static float MoveSpeed = 0.2f;
+        public static float MouseSensitivity = 0.01f;
 
-        public Matrix4 LookAtMatrix
+        public static Matrix4 LookAtMatrix
         {
@@ -26,3 +26,4 @@ namespace AWGL.Utilities
         }
-        public Matrix4 GetViewMatrix()
+
+        public static Matrix4 GetViewMatrix()
         {
@@ -37,3 +38,3 @@ namespace AWGL.Utilities
 
-        public void Move(float x, float y, float z)
+        public static void Move(float x, float y, float z)
         {
@@ -56,3 +57,3 @@ namespace AWGL.Utilities
 
-        public void AddRotation(float x, float y)
+        public static void AddRotation(float x, float y)
         {
@@ -63,4 +64,2 @@ namespace AWGL.Utilities
             Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-
-            Logger.WriteLine("Camera Orientation = " + Orientation);
         }
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
new file mode 100644
index 0000000..1daf90b
--- /dev/null
+++ b/AWGL/Utilities/Chunk.cs
@@ -0,0 +1,91 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+namespace AWGL.Utilities
+{
+    public class Chunk : IDisposable
+    {
+        public const int CHUNK_SIZE = 16;
+        private Block[][][] m_blocks;
+        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+
+        public Chunk()
+        {
+            //Create Blocks
+            m_blocks = new Block[CHUNK_SIZE][][];
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                m_blocks[i] = new Block[CHUNK_SIZE][];
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+                }
+            }
+        }
+
+        public void Update(float dt) { }
+
+        public void Render() { }
+
+        public void Dispose()
+        {
+            // Delete blocks
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = null;
+                }
+                m_blocks[i] = null;
+            }
+            m_blocks = null;
+        }
+
+        public void CreateMesh()
+        {
+            for (int x = 0; x < CHUNK_SIZE; x++)
+            {
+                for (int y = 0; y < CHUNK_SIZE; y++)
+                {
+                    for (int z = 0; z < CHUNK_SIZE; z++)
+                    {
+                        if (m_blocks[x][y][z].IsActive == false)
+                        {
+                            // Don't create triangle data for inactive blocks
+                            continue;
+                        }
+
+                        CreateCube(x, y, z);
+                    }
+                }
+            }
+        }
+
+        private void CreateCube(int x, int y, int z)
+        {
+            float blockSize = 1f;
+
+            
+            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+
+            Vector3 n1;
+
+
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
new file mode 100644
index 0000000..bc2853d
--- /dev/null
+++ b/AWGL/Utilities/Extensions.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public static class Extensions
+    {
+        // http://stackoverflow.com/a/1547282/1090268
+        public static T[] Concat<T>(this T[] x, T[] y)
+        {
+            if (x == null) throw new ArgumentNullException("x");
+            if (y == null) throw new ArgumentNullException("y");
+            int oldLen = x.Length;
+            Array.Resize<T>(ref x, x.Length + y.Length);
+            Array.Copy(y, 0, x, oldLen, y.Length);
+            return x;
+        }
+    }
+}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 22d380d..780768e 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿using AWGL.Managers;
+using OpenTK;
 using OpenTK.Graphics;
@@ -10,12 +11,8 @@ namespace AWGL.Utilities
 {
-    class Renderer
+    public static class Renderer
     {
-        public Renderer()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            //GL.Enable(EnableCap.Blend);
-            //GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
-        }
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix;
 
-        public void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
         {
@@ -26,3 +23,3 @@ namespace AWGL.Utilities
 
-        public void DrawSprite(Sprite sprite)
+        public static void DrawSprite(Sprite sprite)
         {
@@ -36,3 +33,2 @@ namespace AWGL.Utilities
                     sprite.VertexUVs[i]);
-
             }
@@ -41,5 +37,43 @@ namespace AWGL.Utilities
 
-        public void DrawSkyBox()
+        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        {
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+
+            GL.Disable(EnableCap.DepthTest);
+            int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
+            GL.Uniform1(temploc, 0);
+
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            //GL.Uniform3(eye_handle, ref eyeObjectSpace);
+            GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);
+
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public static void DrawWireframeVoxel(float length, float height, float width)
+        {
+            
+        }
+
+        public static void DrawChunk(Chunk chunk)
+        {
+
+        }
+
+        internal static void ToggleWireframeOn()
         {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
 
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
         }
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
new file mode 100644
index 0000000..fe0bd98
--- /dev/null
+++ b/AWGL/Utilities/Shader.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public struct Shader
+    {
+        public int ID { get; set; }
+
+        public Shader(int id)
+            : this()
+        {
+            ID = id;
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 3fac302..ff2e880 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -13,4 +13,3 @@ namespace Game
     {
-        public StateManager stateManager;
-        public TextureManager texManager;
+        public StateManager stateManager = new StateManager();
 
@@ -20,18 +19,15 @@ namespace Game
         {
+            SetupStates();
+            stateManager.SetState("skybox");
+        }
 
-            texManager = new TextureManager();
-
-            texManager.LoadTexture("sprite1", "Data/Textures/logo.jpg");
-            texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
-
-            stateManager = new StateManager();
-            stateManager.AddState("Splash", new SplashScreenState(stateManager));
-            stateManager.AddState("Default", new DefaultState(stateManager));
-            stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
-            stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
-            //stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
-            stateManager.AddState("Assimp-state", new AssimpImportedState(stateManager, shaderManager));
+        private void SetupStates()
+        {
+            stateManager.AddState("skybox", new Skyboxstate(stateManager));
+            stateManager.AddState("vbo", new VboState(stateManager));
+        }
 
-            stateManager.ChangeState("Assimp-state");
-            //stateManager.ChangeState("VboState");
+        private void SetState(string stateToLoad)
+        {
+            stateManager.SetState(stateToLoad);
         }
diff --git a/Game/Program.cs b/Game/Program.cs
index a9832fc..0e40c51 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -1,17 +1,17 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace Game
-{
-    static class Program
-    {
-        [STAThread]
-        static void Main()
-        {
-            using (Game game = new Game(1024, 600, 3, 2)) { game.Run(60, 0); }
-        }
-    }
-}
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Game
+{
+    static class Program
+    {
+        [STAThread]
+        static void Main()
+        {
+            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(60, 0); }
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5b2e825fc4418672a624382e08ebde5dae4f6903">Clean Out #1</a>  -  5b2e825</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 22 files changed, 56 insertions(+), 144 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index ee38827..cac9e9d 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,3 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
+        protected AnimationTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace AWGL
         {
-            m_Timer = new PreciseTimer();
+            m_Timer = new AnimationTimer();
         }
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
index f0656a9..4ae5676 100644
--- a/AWGL/Interfaces/IGameObject.cs
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -1,6 +1,2 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 namespace AWGL.Interfaces
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 497ce1e..6c22cee 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -1,11 +1,6 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using AWGL.Utilities;
-using AWGL.Shapes;
+﻿using AWGL.Utilities;
 using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Graphics;
-using System.Runtime.InteropServices;
+using System;
+using System.Collections.Generic;
 
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 4985b5d..033aac7 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -1,6 +1,3 @@
 ﻿using OpenTK.Input;
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
index 0ad1daa..379e697 100644
--- a/AWGL/Managers/ModelManager.cs
+++ b/AWGL/Managers/ModelManager.cs
@@ -1,6 +1,2 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 namespace AWGL.Managers
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 1de11cf..d7ed991 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -1,12 +1,5 @@
-﻿using System;
+﻿using AWGL.Utilities;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL;
-using System.Diagnostics;
-using OpenTK;
-using System.Drawing;
-using AWGL.Utilities;
 
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index 81cdad1..2e7bffb 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -1,7 +1,4 @@
 ﻿using AWGL.Interfaces;
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 
@@ -34,3 +31,3 @@ namespace AWGL.Managers
 
-        public void SetState(string stateName)
+        public void ChangeState(string stateName)
         {
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
index b5ee17a..cd2b473 100644
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -1,8 +1,4 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-using NUnit.Framework;
+﻿
 using AWGL.States;
+using NUnit.Framework;
 
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 83a2473..91135bd 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -1,8 +1,3 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 using NUnit.Framework;
-using AWGL.Utilities;
 
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index f58a674..ca2af2d 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -6,4 +6,2 @@ using System.Drawing;
 using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index b93645e..cee39bb 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -3,16 +3,2 @@ using AWGL.Managers;
 using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Assimp.Configs;
-using Assimp;
-using System.IO;
-using System.Reflection;
-using System.Drawing;
-using System.Drawing.Imaging;
 
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
index 70930e5..2c2bc68 100644
--- a/AWGL/States/DefaultState.cs
+++ b/AWGL/States/DefaultState.cs
@@ -5,7 +5,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 3588115..d806653 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -5,7 +5,3 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index a35e38b..31502dc 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -5,3 +5,2 @@ using AWGL.Utilities;
 using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
@@ -9,8 +8,2 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index 8507938..d1d3fcc 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
                 delay = 3;
-                m_stateManager.SetState("Voxels");
+                m_stateManager.ChangeState("Voxels");
             }
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index daf98d4..bb1b9f0 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -1,14 +1,7 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using AWGL.Interfaces;
+﻿using AWGL.Interfaces;
 using AWGL.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
 using AWGL.Shapes;
 using AWGL.Utilities;
-using System.Drawing;
-using System.Diagnostics;
+using OpenTK.Graphics.OpenGL;
+using System;
 
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
index bc8d310..7f887b8 100644
--- a/AWGL/States/VoxelState.cs
+++ b/AWGL/States/VoxelState.cs
@@ -4,12 +4,4 @@ using AWGL.Shapes;
 using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
new file mode 100644
index 0000000..99ffa7a
--- /dev/null
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -0,0 +1,39 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class AnimationTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public AnimationTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public float GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 2a71e55..892f8fd 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -2,6 +2,3 @@
 using System;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/Utilities/Point.cs b/AWGL/Utilities/Point.cs
deleted file mode 100644
index 5f28270..0000000
--- a/AWGL/Utilities/Point.cs
+++ /dev/null
@@ -1 +0,0 @@
-﻿
\ No newline at end of file
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
deleted file mode 100644
index 6fe09fc..0000000
--- a/AWGL/Utilities/PreciseTimer.cs
+++ /dev/null
@@ -1,39 +0,0 @@
-﻿
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.Utilities
-{
-    public class PreciseTimer
-    {
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
-
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
-
-        long m_ticksPerSecond = 0;
-        long m_previouslyElapsedTime = 0;
-
-        public PreciseTimer()
-        {
-            QueryPerformanceFrequency(ref m_ticksPerSecond);
-            GetElapsedTime();
-        }
-
-        public float GetElapsedTime()
-        {
-            long time = 0;
-            QueryPerformanceCounter(ref time);
-
-            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
-
-            return elapsedTime;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 780768e..5a6fa86 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -5,5 +5,2 @@ using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8d1a2af6e728f7092fcfd3d1c2313b3dcc0499ee">sorting out dependencies after todays fiasco on the lab machines. .Net4.5.1->.Net4.5</a>  -  8d1a2af</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index ff2e880..8eda708 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -20,3 +20,3 @@ namespace Game
             SetupStates();
-            stateManager.SetState("skybox");
+            stateManager.ChangeState("skybox");
         }
@@ -26,3 +26,2 @@ namespace Game
             stateManager.AddState("skybox", new Skyboxstate(stateManager));
-            stateManager.AddState("vbo", new VboState(stateManager));
         }
@@ -31,3 +30,3 @@ namespace Game
         {
-            stateManager.SetState(stateToLoad);
+            stateManager.ChangeState(stateToLoad);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/96d5be68daa6d803b5c170bbc58faa22ea28844a">Dependency change again, Nuget didn't act as trouble free as it first seemed to be. .</a>  -  96d5be6</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 22 files changed, 504 insertions(+)

diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/22c79083a6f717525e2dda4372c728aa635534f1">Refactor</a>  -  22c7908</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
index 99ffa7a..6fe09fc 100644
--- a/AWGL/Utilities/AnimationTimer.cs
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -8,3 +8,3 @@ namespace AWGL.Utilities
 {
-    public class AnimationTimer
+    public class PreciseTimer
     {
@@ -21,3 +21,3 @@ namespace AWGL.Utilities
 
-        public AnimationTimer()
+        public PreciseTimer()
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c48b6c163f867044b460ca6d433c593cdf10fefd">Refactor.</a>  -  c48b6c1</p><p>authored by Anthony Woodward, 13 days ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index cac9e9d..ee38827 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,3 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected AnimationTimer m_Timer;
+        protected PreciseTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace AWGL
         {
-            m_Timer = new AnimationTimer();
+            m_Timer = new PreciseTimer();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/4fcfdc865df36a6b5dd9022a99d806ac42d5f6b5">Sticking with 3.3 Core Profile.</a>  -  4fcfdc8</p><p>authored by Anthony Woodward, 6 days ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Game/Program.cs b/Game/Program.cs
index 0e40c51..c1a111c 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(60, 0); }
+            using (Game game = new Game(1024, 600, 3, 3)) { game.Run(60, 0); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/89c0d8a67a723abc4cebadd0db0d5bed869c2e3f">Switching logger to output to the console.</a>  -  89c0d8a</p><p>authored by Anthony Woodward, 6 days ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 892f8fd..3e4bbb7 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Debug.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fc5b094184cf8456bc085c27715341d4c8fee528">Hooked up eye_position in the shader. Definately just made some progress.</a>  -  fc5b094</p><p>authored by Anthony Woodward, 5 days ago</p></div><pre>
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index 6ef7af2..b5d3304 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -15,4 +15,4 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = in_position;
-	gl_Position = mvp_matrix * vec4(in_position, 1.0);
+	vs_out.tc = in_position.xyz;
+	gl_Position = mvp_matrix * vec4(in_position.xyz - eye_position, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index 31502dc..c56ad6c 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -106,5 +106,5 @@ namespace AWGL.States
 
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
             Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
-            eye_handle = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
         }
@@ -151,5 +151,5 @@ namespace AWGL.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
-            Renderer.modelViewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
-            eyeObjectSpace = new Vector3(0.0f, 0.0f, 1.0f);
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Camera.GetViewMatrix());
+            Renderer.modelViewMatrix = Matrix4.Identity;
+            Renderer.eyePosition = Camera.Position;
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 5a6fa86..ffca12c 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -11,3 +11,4 @@ namespace AWGL.Utilities
         internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix;
+        internal static Vector3 eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition;
 
@@ -48,3 +49,3 @@ namespace AWGL.Utilities
             GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
-            //GL.Uniform3(eye_handle, ref eyeObjectSpace);
+            GL.Uniform3(handle_eyePosition, ref eyePosition);
             GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d205aa68f1f58037be852ae9ea7363801e58a120">slight mods, nothing major</a>  -  d205aa6</p><p>authored by Anthony Woodward, 5 days ago</p></div><pre>
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index c56ad6c..19187da 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -150,6 +150,6 @@ namespace AWGL.States
 
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
             Renderer.modelViewMatrix = Matrix4.Identity;
             Renderer.eyePosition = Camera.Position;
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index ffca12c..a932714 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -48,3 +48,3 @@ namespace AWGL.Utilities
 
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            
             GL.Uniform3(handle_eyePosition, ref eyePosition);
@@ -56,2 +56,5 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.DepthTest);
+
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/afb87106e17f139803c3a0363d73fcb37b7bc510">KAOS name change, needs a clean eye checkover.</a>  -  afb8710</p><p>authored by Anthony Woodward, 5 days ago</p></div><pre>
 4 files changed, 439 insertions(+), 520 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
deleted file mode 100644
index ee38827..0000000
--- a/AWGL/AWEngineWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class AWEngineWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = AWEngineWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/KAOSEngine.cs b/AWGL/KAOSEngine.cs
new file mode 100644
index 0000000..9465ea2
--- /dev/null
+++ b/AWGL/KAOSEngine.cs
@@ -0,0 +1,437 @@
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+
+        /// Loop Area
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 3e4bbb7..dfdaff8 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index 8eda708..6ec5f44 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : AWEngineWindow
+    class Game : KAOSEngine
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8a3fada5f1891333c5afec1487ea67cb0a15fb29">Skybox rotation now works. Movement not so much.</a>  -  8a3fada</p><p>authored by Anthony Woodward, 5 days ago</p></div><pre>
 4 files changed, 25 insertions(+), 21 deletions(-)

diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index b5d3304..f341e57 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -8,4 +8,3 @@
 uniform vec3 eye_position;
-uniform mat4 mv_matrix;
-uniform mat4 mvp_matrix;
+uniform mat4 view_matrix;
 
@@ -15,4 +14,4 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = in_position.xyz;
-	gl_Position = mvp_matrix * vec4(in_position.xyz - eye_position, 1.0);
+	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	gl_Position = vec4(in_position.xyz - eye_position, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index 19187da..eb36378 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -107,4 +107,9 @@ namespace AWGL.States
             Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
+
+            Logger.WriteLine("Render Shader");
+            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
         }
@@ -151,3 +156,6 @@ namespace AWGL.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            Renderer.modelViewMatrix = Matrix4.Identity;
+            
+            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(new Vector3(0f, -4f, 0f)));
             Renderer.eyePosition = Camera.Position;
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index be2ebfc..3cb02fc 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -19,10 +19,2 @@ namespace AWGL.Utilities
 
-        public static Matrix4 LookAtMatrix
-        {
-            get
-            {
-                return GetViewMatrix();
-            }
-        }
-
         public static Matrix4 GetViewMatrix()
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index a932714..4101369 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -10,5 +10,5 @@ namespace AWGL.Utilities
     {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
         internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
 
@@ -44,3 +44,2 @@ namespace AWGL.Utilities
 
-            GL.Disable(EnableCap.DepthTest);
             int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
@@ -48,7 +47,10 @@ namespace AWGL.Utilities
 
-            
+            eyePosition = Camera.Position;
             GL.Uniform3(handle_eyePosition, ref eyePosition);
-            GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);
 
             GL.BindVertexArray(cubeObject.VaoID);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+
             GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
@@ -57,4 +59,7 @@ namespace AWGL.Utilities
 
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            //Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
             GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7273c137d69cf891f6a7601f14a8a3133d464916">Tidying everything up.</a>  -  7273c13</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 6 files changed, 31 insertions(+), 38 deletions(-)

diff --git a/AWGL/Data/Interfaces/IGameObject.cs b/AWGL/Data/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..4ae5676
--- /dev/null
+++ b/AWGL/Data/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
index fa93cee..b9c351c 100644
--- a/AWGL/Data/Shaders/render-fs.glsl
+++ b/AWGL/Data/Shaders/render-fs.glsl
@@ -4,2 +4,6 @@ uniform samplerCube tex_cubemap;
 
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
 in VS_OUT
@@ -20,2 +24,6 @@ void main(void)
      color = texture(tex_cubemap, r);
+
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
 }
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index f341e57..c433716 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -7,3 +7,2 @@
 
-uniform vec3 eye_position;
 uniform mat4 view_matrix;
@@ -15,3 +14,3 @@ in lowp vec3 in_position;
 	vs_out.tc = mat3(view_matrix) * in_position.xyz;
-	gl_Position = vec4(in_position.xyz - eye_position, 1.0);
+	gl_Position = vec4(in_position.xyz, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
deleted file mode 100644
index 4ae5676..0000000
--- a/AWGL/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace AWGL.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index eb36378..b07d87f 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -125,12 +125,2 @@ namespace AWGL.States
             GL.DepthFunc(DepthFunction.Lequal);
-            //GL.GenBuffers(1, out cubevbo);
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, cubevbo);
-            //GL.BufferData(BufferTarget.ArrayBuffer, new IntPtr(sizeof(float) * vertexData.Length), vertexData, BufferUsageHint.StaticDraw);
-
-            //GL.EnableVertexAttribArray(vertexAttribPosition);
-            //GL.VertexAttribPointer(vertexAttribPosition, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(0));
-            //GL.EnableVertexAttribArray(vertexAttribNormal);
-            //GL.VertexAttribPointer(vertexAttribNormal, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(12));
-
-            //cubeindexCount = 36;
         }
@@ -146,4 +136,4 @@ namespace AWGL.States
 
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Skybox").ID);
-            cubeObject = m_bufferManager.GetBuffer("Cube");
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
         }
@@ -153,3 +143,2 @@ namespace AWGL.States
             MoveCamera();
-            _rotation += elapsedTime * 0.1f;
 
@@ -159,5 +148,4 @@ namespace AWGL.States
 
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(new Vector3(0f, -4f, 0f)));
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
-            
         }
@@ -166,3 +154,13 @@ namespace AWGL.States
         {
+            cubeObject = m_bufferManager.GetBuffer("SkyCube");
             Renderer.DrawSkyBox(m_textureManager, cubeObject);
+            
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 4101369..4067c1a 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -44,8 +44,2 @@ namespace AWGL.Utilities
 
-            int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
-            GL.Uniform1(temploc, 0);
-
-            eyePosition = Camera.Position;
-            GL.Uniform3(handle_eyePosition, ref eyePosition);
-
             GL.BindVertexArray(cubeObject.VaoID);
@@ -58,8 +52,2 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.DepthTest);
-
-            GL.UseProgram(ShaderManager.Get("Render").ID);
-
-            //Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
-            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/949673c06a50ae435abcc33c1b05e27f8fe1a9f3">Revert "KAOS name change, needs a clean eye checkover."</a>  -  949673c</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 4 files changed, 520 insertions(+), 439 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
new file mode 100644
index 0000000..ee38827
--- /dev/null
+++ b/AWGL/AWEngineWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class AWEngineWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public AWEngineWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = AWEngineWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/KAOSEngine.cs b/AWGL/KAOSEngine.cs
deleted file mode 100644
index 9465ea2..0000000
--- a/AWGL/KAOSEngine.cs
+++ /dev/null
@@ -1,437 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSEngine : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "KAOS"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public KAOSEngine(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-
-        /// Loop Area
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSEngine.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index dfdaff8..3e4bbb7 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index 6ec5f44..8eda708 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : KAOSEngine
+    class Game : AWEngineWindow
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/efa5e8c11eb765f83d8bcdfdc88d58a76fcf126a">Fixing Project</a>  -  efa5e8c</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/AWGL/Data/Interfaces/IGameObject.cs b/AWGL/Data/Interfaces/IGameObject.cs
deleted file mode 100644
index 4ae5676..0000000
--- a/AWGL/Data/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace AWGL.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..4ae5676
--- /dev/null
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/aeb7175143d35b3534776ad7ed1c34df589c483d">Renaming project.</a>  -  aeb7175</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 59 files changed, 611 insertions(+), 611 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
deleted file mode 100644
index ee38827..0000000
--- a/AWGL/AWEngineWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class AWEngineWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = AWEngineWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
index 4ae5676..b2da157 100644
--- a/AWGL/Interfaces/IGameObject.cs
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -1,3 +1,3 @@
 ﻿
-namespace AWGL.Interfaces
+namespace KAOS.Interfaces
 {
diff --git a/AWGL/KAOSWindow.cs b/AWGL/KAOSWindow.cs
new file mode 100644
index 0000000..8751f33
--- /dev/null
+++ b/AWGL/KAOSWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Managers;
+using KAOS.Nodes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 6c22cee..5ad5904 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK;
@@ -6,3 +6,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 033aac7..83ddedd 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
index 379e697..c118589 100644
--- a/AWGL/Managers/ModelManager.cs
+++ b/AWGL/Managers/ModelManager.cs
@@ -1,3 +1,3 @@
 ﻿
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index d7ed991..ab00068 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -5,3 +5,3 @@ using System.IO;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index 2e7bffb..8a00128 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Interfaces;
+﻿using KAOS.Interfaces;
 using System.Collections.Generic;
@@ -4,3 +4,3 @@ using System.Diagnostics;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
index cd2b473..fc92063 100644
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -1,6 +1,6 @@
 ﻿
-using AWGL.States;
+using KAOS.States;
 using NUnit.Framework;
 
-namespace AWGL.Managers.Tests
+namespace KAOS.Managers.Tests
 {
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 91135bd..007e120 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -3,3 +3,3 @@ using NUnit.Framework;
 
-namespace AWGL.Managers.Tests
+namespace KAOS.Managers.Tests
 {
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index ca2af2d..0970750 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System.Drawing.Imaging;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
index 536eeeb..58875a5 100644
--- a/AWGL/Nodes/AWCube.cs
+++ b/AWGL/Nodes/AWCube.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
+﻿using KAOS.Shapes;
+using KAOS.Tutorial;
 using OpenTK;
@@ -11,3 +11,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index e9d9de0..1e65c18 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -10,3 +10,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
index 2190c34..0fb12d0 100644
--- a/AWGL/Nodes/AWGroupNode.cs
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -8,3 +8,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
index 6c266a2..d5f77a0 100644
--- a/AWGL/Nodes/AWMesh.cs
+++ b/AWGL/Nodes/AWMesh.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index ebd2cf8..d0dddca 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Managers;
+﻿using KAOS.Managers;
 using System;
@@ -7,3 +7,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
index 6d0c8ca..44911f9 100644
--- a/AWGL/Nodes/AWParticles.cs
+++ b/AWGL/Nodes/AWParticles.cs
@@ -8,3 +8,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
index fddd1ad..85afb1d 100644
--- a/AWGL/Nodes/AWPolygon.cs
+++ b/AWGL/Nodes/AWPolygon.cs
@@ -9,3 +9,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
index abfbd48..888793f 100644
--- a/AWGL/Nodes/IGroupNode.cs
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -5,3 +5,3 @@ using System.Text;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
index b1e3f51..0924346 100644
--- a/AWGL/Nodes/ISceneNode.cs
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -6,3 +6,3 @@ using System.Text;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index 908685b..0f9cd8a 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -10,3 +10,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index a83299f..0f64155 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -3,3 +3,3 @@ using System.Runtime.InteropServices;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
index be7248a..cd6f7e6 100644
--- a/AWGL/Shapes/Capsule.cs
+++ b/AWGL/Shapes/Capsule.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
index e72266a..1c340a1 100644
--- a/AWGL/Shapes/ChamferCube.cs
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
index 1d029c9..ebac329 100644
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -2,3 +2,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
index 96d04a5..2dc56fc 100644
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -4,3 +4,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
index b6dd18e..5b4e4cc 100644
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -2,3 +2,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
index 935452e..62d5462 100644
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -1,2 +1,2 @@
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
index b83ee64..a662cfe 100644
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -2,3 +2,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
index a7821e3..c1d54c6 100644
--- a/AWGL/Shapes/MengerSponge.cs
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -4,3 +4,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index da559ff..99c2d1b 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -9,3 +9,3 @@ using System.Drawing;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
index dea9734..4b2ae9f 100644
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -9,3 +9,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
index 6c4801c..df9a78e 100644
--- a/AWGL/Shapes/Old/Plane.cs
+++ b/AWGL/Shapes/Old/Plane.cs
@@ -12,3 +12,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
index 18ba007..c5315af 100644
--- a/AWGL/Shapes/Old/Shape.cs
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -10,3 +10,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
index 4d7db8e..fcb493d 100644
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -3,3 +3,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
index 3718073..8a744ca 100644
--- a/AWGL/Shapes/SlicedHose.cs
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -2,3 +2,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
index 0562c49..7c5ee4f 100644
--- a/AWGL/Shapes/SlicedSphere.cs
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
index e8953f0..898c314 100644
--- a/AWGL/Shapes/TorusKnot.cs
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -3,3 +3,3 @@ using System.Diagnostics;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
index e194506..2576afe 100644
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -31,3 +31,3 @@ using System.Runtime.InteropServices;
 
-namespace AWGL.Tutorial
+namespace KAOS.Tutorial
 {
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index cee39bb..40dbc84 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -1,6 +1,6 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
index 2c2bc68..e26345e 100644
--- a/AWGL/States/DefaultState.cs
+++ b/AWGL/States/DefaultState.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Drawing;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index d806653..f83dcda 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -1,4 +1,4 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Drawing;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index b07d87f..59095f9 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK;
@@ -9,3 +9,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index d1d3fcc..c18d9ec 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
 using OpenTK;
@@ -12,3 +12,3 @@ using System.Timers;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index bb1b9f0..917dae0 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
index 7f887b8..e8b82e2 100644
--- a/AWGL/States/VoxelState.cs
+++ b/AWGL/States/VoxelState.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
index 6fe09fc..9d28a68 100644
--- a/AWGL/Utilities/AnimationTimer.cs
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -6,3 +6,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
index 80a21e8..4d80ab9 100644
--- a/AWGL/Utilities/Block.cs
+++ b/AWGL/Utilities/Block.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
index 7b917da..18a1ea1 100644
--- a/AWGL/Utilities/BufferObject.cs
+++ b/AWGL/Utilities/BufferObject.cs
@@ -8,3 +8,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index 3cb02fc..59ace7e 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -7,3 +7,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
index 1daf90b..26681e0 100644
--- a/AWGL/Utilities/Chunk.cs
+++ b/AWGL/Utilities/Chunk.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Shapes;
+﻿using KAOS.Shapes;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Text;
 using System.Threading.Tasks;
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
index 2876ecc..e3d3585 100644
--- a/AWGL/Utilities/CustomVertexStruct.cs
+++ b/AWGL/Utilities/CustomVertexStruct.cs
@@ -7,3 +7,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
index bc2853d..759ed2a 100644
--- a/AWGL/Utilities/Extensions.cs
+++ b/AWGL/Utilities/Extensions.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 3e4bbb7..6e15e05 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -4,3 +4,3 @@ using System.Diagnostics;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 4067c1a..903fe15 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Managers;
+﻿using KAOS.Managers;
 using OpenTK;
@@ -6,3 +6,3 @@ using System;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
index fe0bd98..2b5cda0 100644
--- a/AWGL/Utilities/Shader.cs
+++ b/AWGL/Utilities/Shader.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
index 6cf4b1f..8ce0c32 100644
--- a/AWGL/Utilities/Sprite.cs
+++ b/AWGL/Utilities/Sprite.cs
@@ -7,3 +7,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
index 604d0d5..fffdeb7 100644
--- a/AWGL/Utilities/Texture.cs
+++ b/AWGL/Utilities/Texture.cs
@@ -5,3 +5,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/Game/Game.cs b/Game/Game.cs
index 8eda708..e284cc0 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -1,4 +1,4 @@
-﻿using AWGL;
-using AWGL.Managers;
-using AWGL.States;
+﻿using KAOS;
+using KAOS.Managers;
+using KAOS.States;
 using System;
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : AWEngineWindow
+    class Game : KAOSWindow
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0191c42c4f400843f35291d0a3366b203c4864f5">RENAMING PROJECT</a>  -  0191c42</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 174 files changed, 6653 insertions(+), 6653 deletions(-)

diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
deleted file mode 100644
index dff573e..0000000
--- a/AWGL/Data/Shaders/CH02_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-#version 140 core
-
-out vec4 color;
-
-void main(void)
-{
-	color = vec4(0.0, 0.8, 0.0, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
deleted file mode 100644
index 6a17ae4..0000000
--- a/AWGL/Data/Shaders/CH02_VS.glsl
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿#version 140 core
-
-void main(void)
-{
-	const vec4 vertices[3] = vec4[3](
-		vec4(0.25, -0.25, 0.5, 1.0),
-		vec4(-0.25, 0.25, 0.5, 1.0),
-		vec4(0.25, 0.25, 0.5, 1.0)
-		);
-	// Index into our array using gl_VertexID
-	gl_Position = vertices[gl_VertexID];
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_FS.glsl b/AWGL/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/AWGL/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_VS.glsl b/AWGL/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/AWGL/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/FS.glsl b/AWGL/Data/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/AWGL/Data/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_VS.glsl b/AWGL/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/AWGL/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_FS.glsl b/AWGL/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/AWGL/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_VS.glsl b/AWGL/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/AWGL/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_FS.glsl b/AWGL/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/AWGL/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_VS.glsl b/AWGL/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/AWGL/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_FS.glsl b/AWGL/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/AWGL/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_VS.glsl b/AWGL/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/AWGL/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/VS.glsl b/AWGL/Data/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/AWGL/Data/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
deleted file mode 100644
index f890462..0000000
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in vec3 normal;
-
-out vec4 out_frag_color;
-
-void main(void)
-{
-  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
-  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
deleted file mode 100644
index 1cd8777..0000000
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ /dev/null
@@ -1,26 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-// object space to camera space transformation
-uniform mat4 modelview_matrix;
- 
-// camera space to clip coordinates
-uniform mat4 projection_matrix;
- 
-// incoming vertex position
-in vec3 in_position;
- 
-// incoming vertex normal
-in vec3 in_normal;
- 
-// transformed vertex normal
-out vec3 normal;
-
-void main(void)
-{
-  //works only for orthogonal modelview
-  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
-  
-  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
deleted file mode 100644
index b9c351c..0000000
--- a/AWGL/Data/Shaders/render-fs.glsl
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿#version 410 core
-
-uniform samplerCube tex_cubemap;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in VS_OUT
-{
-    vec3 normal;
-    vec3 view;
-} fs_in;
-
-out vec4 color;
-
-void main(void)
-{
-    // Reflect view vector about the plane defined by the normal
-    // at the fragment
-    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
-
-    // Sample from scaled using reflection vector
-     color = texture(tex_cubemap, r);
-
-	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
-
-	color = color * vec4(ambient + diffuse * lightColor, 1.0);
-}
diff --git a/AWGL/Data/Shaders/render-vs.glsl b/AWGL/Data/Shaders/render-vs.glsl
deleted file mode 100644
index 4f89dba..0000000
--- a/AWGL/Data/Shaders/render-vs.glsl
+++ /dev/null
@@ -1,23 +0,0 @@
-#version 410 core
-
-uniform mat4 mv_matrix;
-uniform mat4 proj_matrix;
-
-layout (location = 0) in vec4 in_position;
-layout (location = 1) in vec3 in_normal;
-
-out VS_OUT
-{
-    vec3 normal;
-    vec3 view;
-} vs_out;
-
-void main(void)
-{
-    vec4 pos_vs = mv_matrix * in_position;
-
-    vs_out.normal = mat3(mv_matrix) * in_normal;
-    vs_out.view = pos_vs.xyz;
-
-    gl_Position = proj_matrix * pos_vs;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-fs.glsl b/AWGL/Data/Shaders/skybox-fs.glsl
deleted file mode 100644
index f996bf4..0000000
--- a/AWGL/Data/Shaders/skybox-fs.glsl
+++ /dev/null
@@ -1,15 +0,0 @@
-﻿#version 410 core
-
-uniform samplerCube tex_cubemap;
-
-in VS_OUT
-{
-	vec3 tc;
-}fs_in;
-
-layout(location = 0) out vec4 color;
-
-void main(void)
-{
-	color = texture(tex_cubemap, fs_in.tc);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
deleted file mode 100644
index c433716..0000000
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿#version 410 core
- 
- out VS_OUT
- {
-	vec3 tc;
- }vs_out;
-
-uniform mat4 view_matrix;
-
-in lowp vec3 in_position;
-
- void main(void)
- {
-	vs_out.tc = mat3(view_matrix) * in_position.xyz;
-	gl_Position = vec4(in_position.xyz, 1.0);
- }
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-fs.glsl b/AWGL/Data/Shaders/spincube-fs.glsl
deleted file mode 100644
index a8d60b9..0000000
--- a/AWGL/Data/Shaders/spincube-fs.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-#version 330 core                                                  
-                                                                               
-out vec4 color;                                                    
-                                                                               
-in VS_OUT                                                          
-{                                                                  
-    vec4 color;                                                    
-} fs_in;                                                           
-                                                                               
-void main(void)                                                    
-{                                                                  
-    color = fs_in.color;                                           
-}    
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-vs.glsl b/AWGL/Data/Shaders/spincube-vs.glsl
deleted file mode 100644
index 9de1ae1..0000000
--- a/AWGL/Data/Shaders/spincube-vs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 330 core                                                   
-                                                                                
-in vec4 position;                                                   
-                                                                                
-out VS_OUT                                                          
-{                                                                   
-    vec4 color;                                                     
-} vs_out;                                                           
-                                                                                
-uniform mat4 mv_matrix;                                             
-uniform mat4 proj_matrix;                                           
-                                                                                
-void main(void)                                                     
-{                                                                   
-    gl_Position = proj_matrix * mv_matrix * position;               
-    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
-}   
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
deleted file mode 100644
index b2da157..0000000
--- a/AWGL/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace KAOS.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/KAOSWindow.cs b/AWGL/KAOSWindow.cs
deleted file mode 100644
index 8751f33..0000000
--- a/AWGL/KAOSWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using KAOS.Managers;
-using KAOS.Nodes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public KAOSWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
deleted file mode 100644
index 5ad5904..0000000
--- a/AWGL/Managers/BufferObjectManager.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    public class BufferObjectManager
-    {
-        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
-
-        public void AddBufferObject(string name, BufferObject bufferObject, int program)
-        {
-            int bufferHandle;
-
-            #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
-            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
-            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
-            IntPtr noOffset = new IntPtr(0);
-            #endregion
-
-            // Generate Vertex Buffer Object and bind it so it is current.
-            GL.GenBuffers(1, out bufferHandle);         
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
-
-            #region Save pointers generated by OpenGL here so i dont forget.
-            bufferObject.VboID = bufferHandle; 
-            #endregion
-            
-            #region Send all data to the Vertex Buffer
-            // Initialise storage space for the Vertex Buffer.
-            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
-            // Send Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
-                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
-            // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
-            
-            GL.GenBuffers(1, out bufferHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, 
-                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
-                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
-
-            bufferObject.IboID = bufferHandle;
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
-            #endregion
-
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            // Generate Vertex Array Object and bind it so it is current.
-            GL.GenVertexArrays(1, out bufferHandle);
-            GL.BindVertexArray(bufferHandle);
-
-            bufferObject.VaoID = bufferHandle;
-
-            bufferHandle = GL.GetAttribLocation(program, "in_position");
-            GL.EnableVertexAttribArray(bufferHandle); 
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(program, bufferHandle, "in_position");
-
-            bufferHandle = GL.GetAttribLocation(program, "in_normal");
-            GL.EnableVertexAttribArray(bufferHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
-            GL.BindAttribLocation(program, bufferHandle, "in_normal");
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
-
-            GL.BindVertexArray(bufferObject.VaoID);
-
-            m_bufferStore.Add(name, bufferObject);
-        }
-
-        public BufferObject GetBuffer(string name)
-        {
-            return m_bufferStore[name];
-        }
-    }
-}
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
deleted file mode 100644
index 83ddedd..0000000
--- a/AWGL/Managers/InputManager.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using OpenTK.Input;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    public static class InputManager
-    {
-        public static List<Key> keyList = new List<Key>();
-
-
-    }
-}
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
deleted file mode 100644
index c118589..0000000
--- a/AWGL/Managers/ModelManager.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿
-namespace KAOS.Managers
-{
-    class ModelManager
-    {
-    }
-}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
deleted file mode 100644
index ab00068..0000000
--- a/AWGL/Managers/ShaderManager.cs
+++ /dev/null
@@ -1,139 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System.Collections.Generic;
-using System.IO;
-
-namespace KAOS.Managers
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    public static class ShaderManager
-    {
-        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
-
-        // Handles
-        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
-
-        private static string defaultDataPath = "Data/Shaders/";
-        private static string m_vertexShaderFile = "opentk-vs";
-        private static string m_fragmentShaderFile = "opentk-fs";
-
-        internal static void LoadDefaultShaderProgram()
-        {
-            if (m_shaderStorage == null)
-                m_shaderStorage = new Dictionary<string, Shader>();
-            m_programHandle = BuildProgram();
-            m_shaderStorage.Add("default", new Shader(m_programHandle));
-        }
-
-        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
-        {
-            m_vertexShaderFile = vertexShaderPath;
-            m_fragmentShaderFile = fragmentShaderPath;
-            m_programHandle = BuildProgram();
-
-            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
-        }
-
-        public static Shader DefaultShader
-        {
-            get
-            {
-                return m_shaderStorage["default"];
-            }
-        }
-
-        public static Shader Get(string shaderID)
-        {
-            return m_shaderStorage[shaderID];
-        }
-
-        #region Shader and Program Contruction Methods
-        internal static string LoadShader(string shaderSourcePath)
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-
-        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            Logger.ShaderInfo(shaderHandle);
-
-            return shaderHandle;
-        }
-
-        internal static int BuildProgram()
-        {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
-
-            int programHandle = GL.CreateProgram();
-
-            GL.AttachShader(programHandle, m_vertexShaderHandle);
-            GL.AttachShader(programHandle, m_fragmentShaderHandle);
-
-            GL.LinkProgram(programHandle);
-
-            #region Check linker success
-            int[] temp = new int[1];
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
-            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
-            #endregion
-
-            #region Validate Program
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
-            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
-            //if (validateSuccess == 0)
-            //{
-            //    String message;
-            //    GL.GetProgramInfoLog(programHandle, out message);
-            //    Logger.WriteLine("Program validation failed" + message);
-            //}
-            #endregion
-
-            #region Registered Attributes
-            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
-            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
-
-            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
-            #endregion
-
-            // Delete the shaders as the program has them now
-            GL.DeleteShader(m_vertexShaderHandle);
-            GL.DeleteShader(m_fragmentShaderHandle);
-
-            return programHandle;
-        }
-        #endregion
-
-        #region Public Methods
-
-        //public void SetUniforms(
-        //    out int projMatrixHandle, out int mvMatrixHandle,
-        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
-        //    Size dimensions, ref Camera camera)
-        //{
-        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        //} 
-        #endregion
-
-    }
-}
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
deleted file mode 100644
index 8a00128..0000000
--- a/AWGL/Managers/StateManager.cs
+++ /dev/null
@@ -1,43 +0,0 @@
-﻿using KAOS.Interfaces;
-using System.Collections.Generic;
-using System.Diagnostics;
-
-namespace KAOS.Managers
-{
-    public class StateManager
-    {
-        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
-        IGameObject currentState = null;
-
-        public void Update(float elapsedTime)
-        {
-            if (currentState == null)
-                return;
-            currentState.Update(elapsedTime);
-        }
-
-        public void Render()
-        {
-            if (currentState == null)
-                return;
-            currentState.Render();
-        }
-
-        public void AddState(string stateName, IGameObject state)
-        {
-            Debug.Assert( Exists(stateName) == false );
-            stateStore.Add(stateName, state);
-        }
-
-        public void ChangeState(string stateName)
-        {
-            Debug.Assert( Exists(stateName) );
-            currentState = stateStore[stateName];
-        }
-
-        public bool Exists(string stateName)
-        {
-            return stateStore.ContainsKey(stateName);
-        }
-    }
-}
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
deleted file mode 100644
index fc92063..0000000
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿
-using KAOS.States;
-using NUnit.Framework;
-
-namespace KAOS.Managers.Tests
-{
-    [TestFixture]
-    public class StateManagerTest
-    {
-        [Test]
-        public void TestAddStateExists()
-        {
-            StateManager stateManager = new StateManager();
-            stateManager.AddState("test-state", new SplashScreenState(stateManager));
-
-            Assert.IsTrue(stateManager.Exists("test-state"));
-        }
-    }
-}
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
deleted file mode 100644
index 007e120..0000000
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-﻿
-using NUnit.Framework;
-
-namespace KAOS.Managers.Tests
-{
-    [TestFixture]
-    public class TextureManagerTest
-    {
-        [Test]
-        public void TestLoadTexture()
-        {
-            //string textureid = "test-texture";
-            //Texture t = new Texture();
-            //TextureManager manager = new TextureManager();
-            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
-
-            Assert.IsTrue(true);
-        }
-    }
-}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
deleted file mode 100644
index 0970750..0000000
--- a/AWGL/Managers/TextureManager.cs
+++ /dev/null
@@ -1,102 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace KAOS.Managers
-{
-    public class TextureManager : IDisposable
-    {
-        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
-
-        public Texture Get(string textureId)
-        {
-            return m_textureDatabase[textureId];
-        }
-
-        private int textureGpuHandle;
-        private Bitmap bitmap;
-        private BitmapData bitmapData;
-
-        public void LoadTexture(string textureId, string path)
-        {
-            if (string.IsNullOrEmpty(path))
-                throw new ArgumentException(path);
-
-            GL.GenTextures(1, out textureGpuHandle);
-            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-
-            OpenImageFile(path);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 
-                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
-
-            CloseImageFile();
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
-        }
-
-        public void LoadSkyTexture(string textureId, string[] path)
-        {
-            GL.ActiveTexture(TextureUnit.Texture0);
-            GL.GenTextures(1, out textureGpuHandle);
-            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
-
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-
-            for (int face = 0; face < 6; face++)
-            {
-                OpenImageFile(path[face]);
-                bitmap.Save(face + ".bmp");
-                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
-                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
-
-                GL.Finish();
-                CloseImageFile();
-            }
-
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
-        }
-
-        private void OpenImageFile(string path)
-        {
-            bitmap = new Bitmap(path);
-
-            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-        }
-
-        private void CloseImageFile()
-        {
-            bitmap.UnlockBits(bitmapData);
-
-            CleanUp();
-        }
-
-        private void CleanUp()
-        {
-            bitmap.Dispose();
-        }
-
-
-        public void Dispose()
-        {
-            foreach (Texture t in m_textureDatabase.Values)
-            {
-                GL.DeleteTextures(1, new int[] { t.ID });
-            }
-            bitmap.Dispose();
-        }
-    }
-}
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
deleted file mode 100644
index 58875a5..0000000
--- a/AWGL/Nodes/AWCube.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿using KAOS.Shapes;
-using KAOS.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    public class AWCube : AWNode, ISceneNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public Vector3[] Vertices
-        {
-            get { return CubeVertices; }
-        }
-
-        public int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
deleted file mode 100644
index 1e65c18..0000000
--- a/AWGL/Nodes/AWGraphLines.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWGraphLines : AWNode, ISceneNode
-    {
-        private int m_gridSize = 20;
-
-        public Vector3[] Vertices
-        {
-            get { return m_vertices; }
-        }
-
-        private static Vector3[] m_vertices;
-
-        public AWGraphLines(int gridSize)
-        {
-            m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize * 2];
-            BuildVertices();
-        }
-
-        private void BuildVertices()
-        {
-            for (int i = 0; i < m_gridSize *2; i += 4)
-            {
-                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
-                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
-                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
-                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
-            }
-        }
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
deleted file mode 100644
index 0fb12d0..0000000
--- a/AWGL/Nodes/AWGroupNode.cs
+++ /dev/null
@@ -1,99 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-
-        public OpenTK.Vector3[] Vertices
-        {
-            get { throw new NotImplementedException(); }
-        }
-
-        public int[] Indices
-        {
-            get { throw new NotImplementedException(); }
-        }
-    } 
-}
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
deleted file mode 100644
index d5f77a0..0000000
--- a/AWGL/Nodes/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
deleted file mode 100644
index d0dddca..0000000
--- a/AWGL/Nodes/AWNode.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using KAOS.Managers;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public abstract class AWNode
-    {
-        protected BufferObjectManager m_BufferManager;
-
-        protected AWNode()
-        {
-            //m_BufferManager = new AWBufferManager();
-        }
-
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
deleted file mode 100644
index 44911f9..0000000
--- a/AWGL/Nodes/AWParticles.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWParticles : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-
-}
-/*
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
-        */
\ No newline at end of file
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
deleted file mode 100644
index 85afb1d..0000000
--- a/AWGL/Nodes/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
deleted file mode 100644
index 888793f..0000000
--- a/AWGL/Nodes/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface IGroupNode : IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
deleted file mode 100644
index 0924346..0000000
--- a/AWGL/Nodes/ISceneNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
deleted file mode 100644
index 9623e06..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("AWGL")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("AWGL")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
deleted file mode 100644
index ee33056..0000000
--- a/AWGL/Scene/FBOScene.cs
+++ /dev/null
@@ -1,246 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class FBOScene : DefaultScene
-    {
-        #region Private Member Variables
-        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
-
-        private uint ColorTexture;
-        private uint DepthTexture;
-        private uint FBOHandle;
-
-        private const int TextureSize = 512;
-
-        private DrawableShape Object;
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
-            {
-                throw new NotSupportedException(
-                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
-                Exit();
-            }
-
-            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearDepth(1.0);
-            GL.DepthFunc(DepthFunction.Lequal);
-
-            GL.Enable(EnableCap.CullFace);
-
-            // Create Color Tex
-            GL.GenTextures(1, out ColorTexture);
-            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create Depth Tex
-            GL.GenTextures(1, out DepthTexture);
-            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
-            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create a FBO and attach the textures
-            GL.Ext.GenFramebuffers(1, out FBOHandle);
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
-
-            #region Test for Error
-
-            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
-            {
-                case FramebufferErrorCode.FramebufferCompleteExt:
-                    {
-                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: There are no attachments.");
-                        break;
-                    }
-                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
-                     {
-                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
-                         break;
-                     }*/
-                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
-                    {
-                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
-                    {
-                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
-                    {
-                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
-                    {
-                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferUnsupportedExt:
-                    {
-                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
-                        break;
-                    }
-                default:
-                    {
-                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
-                        break;
-                    }
-            }
-
-            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
-            int[] queryinfo = new int[6];
-            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
-            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
-            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
-            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
-            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
-            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
-            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
-                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
-
-            Console.WriteLine("Last GL Error: " + GL.GetError());
-
-            #endregion Test for Error
-
-            GL.PushAttrib(AttribMask.ViewportBit);
-            {
-                GL.Viewport(0, 0, TextureSize, TextureSize);
-
-                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
-                GL.ClearColor(1f, 0f, 0f, 0f);
-                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
-                GL.MatrixMode(MatrixMode.Projection);
-                GL.LoadMatrix(ref perspective);
-
-                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
-                GL.MatrixMode(MatrixMode.Modelview);
-                GL.LoadMatrix(ref lookat);
-
-                // draw some complex object into the FBO's textures
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.Light0);
-                GL.Enable(EnableCap.ColorMaterial);
-                GL.Color3(0f, 1f, 0f);
-                Object.Draw();
-                GL.Disable(EnableCap.ColorMaterial);
-                GL.Disable(EnableCap.Light0);
-                GL.Disable(EnableCap.Lighting);
-
-            }
-            GL.PopAttrib();
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
-
-            GL.ClearColor(.1f, .2f, .3f, 0f);
-            GL.Color3(1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
-            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            double aspect_ratio = Width / (double)Height;
-
-            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-        }
-    }
-}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
deleted file mode 100644
index 3aca921..0000000
--- a/AWGL/Scene/PickerScene.cs
+++ /dev/null
@@ -1,204 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
-    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
-    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
-    /// </summary>
-    public class PickerScene : DefaultScene
-    {
-        public PickerScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Member variable
-        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
-        private float angle;
-        private BeginMode VBO_PrimMode;
-        private Vertex[] VBO_Array;
-        uint VBO_Handle;
-
-        private uint SelectedTriangle;
-
-        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
-        #endregion
-
-        #region OnLoad
-        /// <summary>Load resources here.</summary>
-        /// <param name="e">Not used.</param>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.CullFace);
-
-            #region prepare data for VBO from procedural object
-            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
-            VertexT2fN3fV3f[] temp_VBO;
-            uint[] temp_IBO;
-            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
-            temp_obj.Dispose();
-            if (temp_IBO != null)
-                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
-
-            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
-            VBO_Array = new Vertex[temp_VBO.Length];
-            int TriangleCounter = -1;
-            for (int i = 0; i < temp_VBO.Length; i++)
-            {
-                // Position
-                VBO_Array[i].Position = temp_VBO[i].Position;
-
-                // Index
-                if (i % 3 == 0)
-                    TriangleCounter++;
-                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
-            }
-            #endregion prepare data for VBO from procedural object
-
-            #region Setup VBO for drawing
-            GL.GenBuffers(1, out VBO_Handle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
-            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
-            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
-            #endregion Setup VBO for drawing
-
-            #region Shader
-
-            //create and compile shaders
-            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
-
-            //create program object, attach shaders and link
-            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
-
-            // flag ShaderObjects for delete when not used anymore
-            GL.DeleteShader(VertexShaderObject);
-            GL.DeleteShader(FragmentShaderObject);
-
-            GL.UseProgram(0);
-
-            #endregion Shader
-
-        }
-        #endregion
-
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.DeleteBuffers(1, ref VBO_Handle);
-
-            base.OnUnload(e);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Called when your window is resized. Set your viewport here. It is also
-        /// a good place to set up your projection matrix (which probably changes
-        /// along when the aspect ratio of your window).
-        /// </summary>
-        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref projection);
-        }
-        #endregion
-
-        #region OnRenderFrame
-        /// <summary>
-        /// Called when it is time to render the next frame. Add your rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Color3(Color.White);
-            GL.EnableClientState(EnableCap.ColorArray);
-
-            #region Pass 1: Draw Object and pick Triangle
-            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref modelview);
-            GL.Translate(0f, 0f, -3f);
-            GL.Rotate(angle, Vector3.UnitX);
-            GL.Rotate(angle, Vector3.UnitY);
-            angle += (float)e.Time * 3.0f;
-
-            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
-             GL.UseProgram(ProgramObject);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            // GL.UseProgram(0);
-
-            // Read Pixel under mouse cursor
-            Byte4 Pixel = new Byte4();
-            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
-            SelectedTriangle = Pixel.ToUInt32();
-            #endregion Pass 1: Draw Object and pick Triangle
-
-            GL.Color3(Color.White);
-            GL.DisableClientState(EnableCap.ColorArray);
-
-            #region Pass 2: Draw Shape
-            if (SelectedTriangle == uint.MaxValue)
-                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
-            else
-                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.Color3(1f, 1f, 1f);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-            GL.Color3(Color.Red);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-
-            if (SelectedTriangle != uint.MaxValue)
-            {
-                GL.Disable(EnableCap.DepthTest);
-                GL.Color3(Color.Green);
-                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
-                GL.Enable(EnableCap.DepthTest);
-            }
-            #endregion Pass 2: Draw Shape
-
-            this.SwapBuffers();
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Error at Swapbuffers: " + err);
-        }
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
deleted file mode 100644
index 8acb843..0000000
--- a/AWGL/Scene/StencilCSGScene.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class StencilCSGScene : DefaultScene
-    {
-        #region Model Related
-        private DrawableShape OperandB;
-        private DrawableShape OperandA;
-        private float MySphereZOffset = 0f;
-        private float MySphereXOffset = 0f;
-
-        private int Texture;
-        #endregion Model Related
-
-        private bool ShowDebugWireFrame = true;
-
-        private float CameraZoom;
-        private float CameraRotX;
-        private float CameraRotY;
-        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
-
-        #region Window
-        public StencilCSGScene()
-        {
-            base.VSync = VSyncMode.Off;
-            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
-            {
-                switch (e.Key)
-                {
-                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
-                }
-            };
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
-            GL.LoadMatrix(ref p);
-        }
-        #endregion Window
-
-        public override void Setup(EventArgs e)
-        {
-            #region Abort on platforms which will not be able to execute the ops properly
-            /*
-            if (!GL.SupportsExtension("VERSION_1_2"))
-            {
-                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
-                this.Exit();
-            }
-
-            int[] t = new int[2];
-            GL.GetInteger(GetPName.MajorVersion, out t[0]);
-            GL.GetInteger(GetPName.MinorVersion, out t[1]);
-            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
-
-            GL.GetInteger(GetPName.DepthBits, out t[0]);
-            Trace.WriteLine("Depth Bits: " + t[0]);
-            GL.GetInteger(GetPName.StencilBits, out t[1]);
-            Trace.WriteLine("Stencil Bits: " + t[1]);
-
-            if (t[0] < 16)
-            {
-                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
-                this.Exit();
-            }
-
-            if (t[1] < 1)
-            {
-                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
-                this.Exit();
-            }
-            */
-            #endregion Abort on platforms which will not be able to execute the ops properly
-
-            #region GL States
-            GL.ClearColor(.08f, .12f, .16f, 1f);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Less);
-            GL.ClearDepth(1.0);
-
-            GL.Enable(EnableCap.StencilTest);
-            GL.ClearStencil(0);
-            GL.StencilMask(0xFFFFFFFF); // read&write
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-            GL.CullFace(CullFaceMode.Back);
-
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-
-            GL.Color4(1f, 1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.ShadeModel(ShadingModel.Smooth);
-
-            #endregion GL States
-
-            #region Load Texture
-            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
-            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
-
-            GL.GenTextures(1, out Texture);
-            GL.BindTexture(TextureTarget.Texture2D, Texture);
-
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.Finish();
-            bitmap.UnlockBits(data);
-            #endregion Load Texture
-
-            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
-            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
-                                           SlicedSphere.eSubdivisions.Three,
-                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
-                                           true);
-
-            #region Invert Operand B's Normals
-            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
-            BeginMode tempPrimMode;
-            VertexT2dN3dV3d[] tempVertices;
-            uint[] tempIndices;
-
-            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
-            OperandB.Dispose();
-
-            for (int i = 0; i < tempVertices.Length; i++)
-            {
-                tempVertices[i].Normal *= -1.0;
-                tempVertices[i].Normal.Normalize();
-            }
-
-            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
-            #endregion Invert Operand B's Normals
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref Texture);
-
-            OperandA.Dispose();
-            OperandB.Dispose();
-
-            base.OnUnload(e);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Magic numbers for camera
-            CameraRotX = -Mouse.X * .5f;
-            CameraRotY = Mouse.Y * .5f;
-            CameraZoom = Mouse.Wheel * .2f;
-            #endregion Magic numbers for camera
-        }
-
-        public void DrawOperandB()
-        {
-            GL.PushMatrix();
-            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
-            OperandB.Draw();
-            GL.PopMatrix();
-        }
-
-        public void DrawOperandA()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            OperandA.Draw();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        public void RenderCsg()
-        {
-            // first pass
-            GL.Disable(EnableCap.StencilTest);
-
-            GL.ColorMask(false, false, false, false);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB();// draw front-faces into depth buffer
-
-            // use stencil plane to find parts of b in a 
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // increment the stencil where the front face of a is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
-            DrawOperandB(); // draw the part of b that's in a
-
-            // fix depth
-            GL.ColorMask(false, false, false, false);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Disable(EnableCap.StencilTest);
-            GL.DepthFunc(DepthFunction.Always);
-            DrawOperandA();
-            GL.DepthFunc(DepthFunction.Less);
-
-            // second pass
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA();
-
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            DrawOperandB(); // increment the stencil where the front face of b is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Equal, 0, 1);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // draw the part of a that's in b
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
-
-            MySphereZOffset += (float)(e.Time * 3.1);
-            MySphereXOffset += (float)(e.Time * 4.2);
-
-            #region Transform setup
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
-
-            // Camera
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-
-            GL.Translate(0f, 0f, CameraZoom);
-            GL.Rotate(CameraRotX, Vector3.UnitY);
-            GL.Rotate(CameraRotY, Vector3.UnitX);
-            #endregion Transform setup
-
-            RenderCsg();
-
-            // ---------------------------------
-
-            if (ShowDebugWireFrame)
-            {
-                GL.Color3(System.Drawing.Color.LightGray);
-                GL.Disable(EnableCap.StencilTest);
-                GL.Disable(EnableCap.Lighting);
-                //GL.Disable( EnableCap.DepthTest );
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-                DrawOperandB();
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-                GL.Enable(EnableCap.DepthTest);
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.StencilTest);
-            }
-            SwapBuffers();
-        }
-
-    }
-}
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
deleted file mode 100644
index 2b84210..0000000
--- a/AWGL/Scene/StereoVisionScene.cs
+++ /dev/null
@@ -1,164 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVisionScene : DefaultScene
-    {
-        public StereoVisionScene()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            Angle += (float)(e.Time * 20.0);
-
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    
-    }
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
deleted file mode 100644
index ec53ee7..0000000
--- a/AWGL/Scene/Texture2DScene.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class Texture2DScene : DefaultScene
-    {
-        #region Private Members
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.Texture2D);
-
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            bitmap.UnlockBits(data);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
-        }
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref texture);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.Begin(BeginMode.Quads);
-
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            GL.End();
-
-            SwapBuffers();
-        }
-        #endregion
-
-    }
-}
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
deleted file mode 100644
index 0f9cd8a..0000000
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ /dev/null
@@ -1,182 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.Shapes
-{
-    // Abstract base class for procedurally generated geometry
-    // 
-    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
-    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
-    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
-    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
-    // Can use a Display List to prevent repeated immediate mode draws.
-    //
-
-    public abstract class DrawableShape: IDisposable
-    {
-        protected BeginMode PrimitiveMode;
-        protected VertexT2dN3dV3d[] VertexArray;
-        protected uint[] IndexArray;
-
-        public int GetTriangleCount
-        {
-            get
-            {
-                switch ( PrimitiveMode )
-                { 
-                case BeginMode.Triangles:
-                    if ( IndexArray != null )
-                    {
-                        return IndexArray.Length / 3;
-                    } else
-                    {
-                        return VertexArray.Length / 3;
-                    }
-                  //  break;
-                default: throw new NotImplementedException("Unknown primitive type.");
-                }
-            }
-        }
-
-        #region Display List
-
-        private bool UseDisplayList;
-        private int DisplayListHandle = 0;
-
-        #endregion Display List
-
-        public DrawableShape( bool useDisplayList )
-        {
-            UseDisplayList = useDisplayList;
-            PrimitiveMode = BeginMode.Triangles;
-            VertexArray = null;
-            IndexArray = null;
-        }
-
-        #region Convert to VBO
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2dN3dV3d[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = VertexArray[i].TexCoord;
-                vertices[i].Normal = VertexArray[i].Normal;
-                vertices[i].Position = VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2fN3fV3f[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
-                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
-                vertices[i].Position = (Vector3)VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2hN3hV3h[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
-                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
-                vertices[i].Position = (Vector3h)VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        #endregion Convert to VBO
-
-        private void DrawImmediateMode()
-        {
-            GL.Begin( PrimitiveMode );
-            {
-                if ( IndexArray == null )
-                    foreach ( VertexT2dN3dV3d v in VertexArray )
-                    {
-                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
-                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
-                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
-                    } else
-                {
-                    for ( uint i = 0; i < IndexArray.Length; i++ )
-                    {
-                        uint index = IndexArray[i];
-                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
-                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
-                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
-                    }
-                }
-            }
-            GL.End();
-        }
-
-        /// <summary>
-        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
-        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
-        /// </summary>
-        public void Draw()
-        {
-            if ( !UseDisplayList )
-                DrawImmediateMode();
-            else
-                if ( DisplayListHandle == 0 )
-                {
-                    if ( VertexArray == null )
-                        throw new Exception("Cannot draw null Vertex Array.");
-                    DisplayListHandle = GL.GenLists( 1 );
-                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
-                    DrawImmediateMode();
-                    GL.EndList();
-                } else
-                    GL.CallList( DisplayListHandle );
-        }
-
-        
-
-        #region IDisposable Members
-
-        /// <summary>
-        /// Removes reference to VertexArray and IndexArray.
-        /// Deletes the Display List, so it requires an OpenGL context.
-        /// The instance is effectively destroyed.
-        /// </summary>
-        public void Dispose()
-        {
-            if ( VertexArray != null )
-                VertexArray = null;
-            if ( IndexArray != null )
-                IndexArray = null;
-            if ( DisplayListHandle != 0 )
-            {
-                GL.DeleteLists( DisplayListHandle, 1 );
-                DisplayListHandle = 0;
-            }
-        }
-
-        #endregion
-    }
-
-}
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
deleted file mode 100644
index 0f64155..0000000
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-using OpenTK;
-using System.Runtime.InteropServices;
-
-namespace KAOS.Shapes
-{
-    public struct VertexT2dN3dV3d
-    {
-        public Vector2d TexCoord;
-        public Vector3d Normal;
-        public Vector3d Position;
-
-        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
-        {
-            TexCoord = texcoord;
-            Normal = normal;
-            Position = position;
-        }
-    }
-
-    public struct VertexT2fN3fV3f
-    {
-        public Vector2 TexCoord;
-        public Vector3 Normal;
-        public Vector3 Position;
-    }
-
-    public struct VertexT2hN3hV3h
-    {
-        public Vector2h TexCoord;
-        public Vector3h Normal;
-        public Vector3h Position;
-    }
-
-   
-}
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
deleted file mode 100644
index cd6f7e6..0000000
--- a/AWGL/Shapes/Capsule.cs
+++ /dev/null
@@ -1,108 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class Capsule: DrawableShape
-    {
-        public enum eSubdivisions
-        {
-            None = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-        }
-
-
-        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            uint HoseSubDivs = 0;
-            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.None:
-                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
-                HoseSubDivs = 0;
-                break;
-            case eSubdivisions.One:
-                spheresubdivs = SlicedSphere.eSubdivisions.One;
-                HoseSubDivs = 1;
-                break;
-            case eSubdivisions.Two:
-                spheresubdivs = SlicedSphere.eSubdivisions.Two;
-                HoseSubDivs = 3;
-                break;
-            case eSubdivisions.Three:
-                spheresubdivs = SlicedSphere.eSubdivisions.Three;
-                HoseSubDivs = 7;
-                break;
-            case eSubdivisions.Four:
-                spheresubdivs = SlicedSphere.eSubdivisions.Four;
-                HoseSubDivs = 15;
-                break;
-            }
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
-            VertexT2dN3dV3d[] TemporaryVBO;
-            uint[] TemporaryIBO;
-
-            List<Chunk> AllChunks = new List<Chunk>();
-            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
-                     offset2 = new Vector3d( 0.0, 0.0, -height );
-            for ( int i = 0; i < 4; i++ )
-            {
-                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
-                switch ( i )
-                {
-                case 0:
-                    tempSide = SlicedHose.eSide.FrontBottom;
-                    break;
-                case 1:
-                    tempSide = SlicedHose.eSide.BackBottom;
-                    break;
-                case 2:
-                    tempSide = SlicedHose.eSide.BackTop;
-                    break;
-                case 3:
-                    tempSide = SlicedHose.eSide.FrontTop;
-                    break;
-                }
-                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
-                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempHose.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-
-            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
-                                                       new SlicedSphere.eDir[] {
-                                                           SlicedSphere.eDir.BackBottomRight,
-                                                           SlicedSphere.eDir.FrontTopRight,
-                                                           SlicedSphere.eDir.BackTopRight,
-                                                           SlicedSphere.eDir.FrontBottomRight, 
-                                                          },
-                                                       false );
-
-            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            front.Dispose();
-
-            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
-                                                      new SlicedSphere.eDir[] { 
-                                                          SlicedSphere.eDir.FrontBottomLeft,
-                                                          SlicedSphere.eDir.FrontTopLeft, 
-                                                          SlicedSphere.eDir.BackTopLeft,
-                                                          SlicedSphere.eDir.BackBottomLeft },
-                                                      false );
-            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            back.Dispose();
-
-            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-            AllChunks.Clear();
-        }
-    }
-}
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
deleted file mode 100644
index 1c340a1..0000000
--- a/AWGL/Shapes/ChamferCube.cs
+++ /dev/null
@@ -1,278 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class ChamferCube: DrawableShape
-    {
-
-        public enum SubDivs: byte
-        {
-            Zero,
-            One,
-            Two,
-            Three,
-            Four,
-        }
-
-        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
-            : base( useDL )
-        {   
-            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
-            uint hoseSubDivs = 0;
-
-            switch ( subdivs )
-            {
-            case SubDivs.Zero:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
-                hoseSubDivs = 0;
-                break;
-            case SubDivs.One:
-                sphereSubDivs = SlicedSphere.eSubdivisions.One;
-                hoseSubDivs = 1;
-                break;
-            case SubDivs.Two:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
-                hoseSubDivs = 3;
-                break;
-            case SubDivs.Three:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
-                hoseSubDivs = 7;
-                break;
-            case SubDivs.Four:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
-                hoseSubDivs = 15;
-                break;
-            }
-
-            #region Temporary Storage
-
-            List<Chunk> AllChunks = new List<Chunk>();
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
-            VertexT2dN3dV3d[] TemporaryVBO;
-            uint[] TemporaryIBO;
-
-            #endregion Temporary Storage
-
-            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
-            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
-            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
-            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
-            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
-            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
-            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
-            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
-
-            #region 8 sliced Spheres
-            SlicedSphere tempSphere;
-            Vector3d tempVector = Vector3d.Zero;
-            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
-
-            for ( int i = 0; i < 8; i++ )
-            {
-                switch ( i )
-                {
-                case 0:
-                    tempVector = FrontTopRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
-                    break;
-                case 1:
-                    tempVector = FrontTopLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
-                    break;
-                case 2:
-                    tempVector = FrontBottomRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
-                    break;
-                case 3:
-                    tempVector = FrontBottomLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
-                    break;
-                case 4:
-                    tempVector = BackBottomRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
-                    break;
-                case 5:
-                    tempVector = BackBottomLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
-                    break;
-                case 6:
-                    tempVector = BackTopRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
-                    break;
-                case 7:
-                    tempVector = BackTopLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
-                    break;
-                }
-                tempSphere = new SlicedSphere( radius,
-                                                 tempVector,
-                                                 sphereSubDivs,
-                                                 tempEdge,
-                                                 false );
-                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempSphere.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-            #endregion 8 sliced Spheres
-
-            #region 12 sliced Hoses
-
-            SlicedHose tempHose;
-            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
-            Vector3d tempHoseStart = Vector3d.Zero;
-            Vector3d tempHoseEnd = Vector3d.Zero;
-
-            for ( int i = 0; i < 12; i++ )
-            {
-                switch ( i )
-                {
-                #region Around X Axis
-                case 0:
-                    tempSide = SlicedHose.eSide.BottomRight;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = FrontBottomRightEdge;
-                    break;
-                case 1:
-                    tempSide = SlicedHose.eSide.TopRight;
-                    tempHoseStart = BackTopRightEdge;
-                    tempHoseEnd = FrontTopRightEdge;
-                    break;
-                case 2:
-                    tempSide = SlicedHose.eSide.TopLeft;
-                    tempHoseStart = BackTopLeftEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                case 3:
-                    tempSide = SlicedHose.eSide.BottomLeft;
-                    tempHoseStart = BackBottomLeftEdge;
-                    tempHoseEnd = FrontBottomLeftEdge;
-                    break;
-                #endregion Around X Axis
-                #region Around Y Axis
-                case 4:
-                    tempSide = SlicedHose.eSide.FrontRight;
-                    tempHoseStart = FrontBottomRightEdge;
-                    tempHoseEnd = FrontTopRightEdge;
-                    break;
-                case 5:
-                    tempSide = SlicedHose.eSide.BackRight;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = BackTopRightEdge;
-                    break;
-                case 6:
-                    tempSide = SlicedHose.eSide.BackLeft;
-                    tempHoseStart = BackBottomLeftEdge;
-                    tempHoseEnd = BackTopLeftEdge;
-                    break;
-                case 7:
-                    tempSide = SlicedHose.eSide.FrontLeft;
-                    tempHoseStart = FrontBottomLeftEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                #endregion Around Y Axis
-                #region Around Z Axis
-                case 8:
-                    tempSide = SlicedHose.eSide.FrontTop;
-                    tempHoseStart = FrontTopRightEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                case 9:
-                    tempSide = SlicedHose.eSide.BackTop;
-                    tempHoseStart = BackTopRightEdge;
-                    tempHoseEnd = BackTopLeftEdge;
-                    break;
-                case 10:
-                    tempSide = SlicedHose.eSide.BackBottom;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = BackBottomLeftEdge;
-                    break;
-                case 11:
-                    tempSide = SlicedHose.eSide.FrontBottom;
-                    tempHoseStart = FrontBottomRightEdge;
-                    tempHoseEnd = FrontBottomLeftEdge;
-                    break;
-                #endregion Around Z Axis
-                }
-                tempHose = new SlicedHose( tempSide,
-                                             hoseSubDivs,
-                                             radius,
-                                             tempHoseStart,
-                                             tempHoseEnd,
-                                             false );
-                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempHose.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-            #endregion 12 sliced Hoses
-
-            #region 6 quads for the sides
-
-            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
-            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
-
-            // all quads use the same texcoords
-            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
-            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
-            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
-            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
-
-            // front face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
-            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // back face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
-            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // top face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
-            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // bottom face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
-            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // right face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
-            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // left face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
-            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-
-            #endregion 6 quads for the sides
-
-            #region Final Assembly of Chunks
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-            AllChunks.Clear();
-            #endregion Final Assembly of Chunks
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
deleted file mode 100644
index ebac329..0000000
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ /dev/null
@@ -1,80 +0,0 @@
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public class Chunk
-    {
-        public VertexT2dN3dV3d[] Vertices;
-        public uint[] Indices;
-
-        public uint VertexCount
-        {
-            get
-            {
-                return (uint)Vertices.Length;
-            }
-        }
-        public uint IndexCount
-        {
-            get
-            {
-                return (uint)Indices.Length;
-            }
-        }
-
-        public Chunk( uint vertexcount, uint indexcount )
-        {
-            Vertices = new VertexT2dN3dV3d[vertexcount];
-            Indices = new uint[indexcount];
-        }
-
-        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
-        {
-            Vertices = new VertexT2dN3dV3d[vbo.Length];
-            for ( int i = 0; i < Vertices.Length; i++ )
-            {
-                Vertices[i] = vbo[i];
-            } 
-            Indices = new uint[ibo.Length];
-            for ( int i = 0; i < Indices.Length; i++ )
-            {
-                Indices[i] = ibo[i];
-            }
-        }
-
-        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
-        {
-
-            uint VertexCounter = 0;
-            uint IndexCounter = 0;
-
-            foreach ( Chunk ch in c )
-            {
-                VertexCounter += ch.VertexCount;
-                IndexCounter += ch.IndexCount;
-            }
-
-            vbo = new VertexT2dN3dV3d[VertexCounter];
-            ibo = new uint[IndexCounter];
-
-            VertexCounter = 0;
-            IndexCounter = 0;
-
-            foreach ( Chunk ch in c )
-            {
-                for ( int i = 0; i < ch.Vertices.Length; i++ )
-                {
-                    vbo[VertexCounter + i] = ch.Vertices[i];
-                }
-
-                for ( int i = 0; i < ch.Indices.Length; i++ )
-                {
-                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
-                }
-
-                VertexCounter += (uint)ch.VertexCount;
-                IndexCounter += (uint)ch.IndexCount;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
deleted file mode 100644
index 2dc56fc..0000000
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ /dev/null
@@ -1,421 +0,0 @@
-using OpenTK;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class MengerSponge
-    {
-        private struct MengerCube
-        {
-            private Vector3d Center;
-            private double SideLength;
-            private eSides[] VisibleSides;
-            private eSides[] VisibilityToInherit;
-
-            public void GetArraySizes( out uint vertexcount, out uint indexcount )
-            {
-                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
-                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
-            }
-
-            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
-            {
-                Center = center;
-                SideLength = sidelength;
-
-                /*  List<eSides> Sides = new List<eSides>();
-                  foreach ( eSides s in visibleSides )
-                  {
-                      bool isVisible = false;
-                      foreach ( eSides p in parentsVisibility )
-                      {
-                          if ( (int)p == (int)s )
-                          {
-                              isVisible = true;
-                              break;
-                          }
-                      }
-                      if ( isVisible )
-                      {
-                          Sides.Add( s );
-                      }
-                  }
-                  VisibleSides = Sides.ToArray();*/
-                VisibleSides = visibleSides;
-                VisibilityToInherit = visibleSides;
-            }
-
-            public void Subdivide( out MengerCube[] cubes )
-            {
-                cubes = new MengerCube[20]; // 8 + 4 + 8
-
-                double NewLength = this.SideLength / 3.0;
-                double six = this.SideLength * 2.0 / 3.0;
-                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
-
-                // front
-                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
-                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
-                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
-
-                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
-                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
-                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
-
-                // center
-                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                // back
-                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
-                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
-
-                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
-                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
-
-                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
-                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
-                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
-
-            }
-
-            public enum eSides: byte
-            {
-                Front,
-                Back,
-                Right,
-                Left,
-                Top,
-                Bottom
-            }
-
-            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
-
-            public void GetVboAndIbo( ref List<Chunk> chunks )
-            {
-                foreach ( eSides s in AllSides )
-                {
-                    DrawSide( s, ref chunks );
-                }
-            }
-
-            private void DrawSide( eSides side, ref List<Chunk> chunks )
-            {
-                #region Setup constants for current direction
-
-                double _Zero = 0.0; // 0/3
-                double _Three = 0.3333333333333; // 1/3
-                double _Six = 0.66666666666666; // 2/3
-                double _One = 1.0; // 3/3 
-
-                double ThirdLength = SideLength / 3f;
-
-                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
-                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
-                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
-                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
-
-                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
-                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
-                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
-                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
-
-                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
-
-                switch ( side )
-                {
-                case eSides.Front:
-                    P0 = C0;
-                    P1 = C1;
-                    P2 = C2;
-                    P3 = C3;
-
-                    P4 = C4;
-                    P5 = C5;
-                    P6 = C6;
-                    P7 = C7;
-                    break;
-                case eSides.Back:
-                    P0 = C5;
-                    P1 = C4;
-                    P2 = C7;
-                    P3 = C6;
-
-                    P4 = C1;
-                    P5 = C0;
-                    P6 = C3;
-                    P7 = C2;
-                    break;
-                case eSides.Right:
-                    P0 = C1;
-                    P1 = C5;
-                    P2 = C6;
-                    P3 = C2;
-
-                    P4 = C0;
-                    P5 = C4;
-                    P6 = C7;
-                    P7 = C3;
-                    break;
-                case eSides.Left:
-                    P0 = C4;
-                    P1 = C0;
-                    P2 = C3;
-                    P3 = C7;
-
-                    P4 = C5;
-                    P5 = C1;
-                    P6 = C2;
-                    P7 = C6;
-                    break;
-                case eSides.Top:
-                    P0 = C3;
-                    P1 = C2;
-                    P2 = C6;
-                    P3 = C7;
-
-                    P4 = C0;
-                    P5 = C1;
-                    P6 = C5;
-                    P7 = C4;
-                    break;
-                case eSides.Bottom:
-                    P0 = C1;
-                    P1 = C0;
-                    P2 = C4;
-                    P3 = C5;
-
-                    P4 = C2;
-                    P5 = C3;
-                    P6 = C7;
-                    P7 = C6;
-                    break;
-                default:
-                    throw new NotImplementedException( "Unknown enum value: " + side );
-                }
-
-                #endregion Setup constants for current direction
-
-                #region Set Normal
-
-                Vector3d FaceNormal;
-
-                switch ( side )
-                {
-                case eSides.Front:
-                    FaceNormal = Vector3d.UnitZ;
-                    break;
-                case eSides.Back:
-                    FaceNormal = -Vector3d.UnitZ;
-                    break;
-                case eSides.Right:
-                    FaceNormal = Vector3d.UnitX;
-                    break;
-                case eSides.Left:
-                    FaceNormal = -Vector3d.UnitX;
-                    break;
-                case eSides.Top:
-                    FaceNormal = Vector3d.UnitY;
-                    break;
-                case eSides.Bottom:
-                    FaceNormal = -Vector3d.UnitY;
-                    break;
-                default:
-                    throw new NotImplementedException( "Unknown enum value: " + side );
-                }
-                #endregion Set Normal
-
-                bool FaceIsVisible = false;
-                foreach ( eSides s in VisibleSides )
-                {
-                    if ( s == side )
-                    {
-                        FaceIsVisible = true;
-                        break;
-                    }
-                }
-
-                if ( FaceIsVisible )
-                {
-                    #region Define Layer1 Vertices
-                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
-
-                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
-                    Layer1.Vertices[0].Normal = FaceNormal;
-                    Layer1.Vertices[0].Position = P0;
-
-                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
-                    Layer1.Vertices[1].Normal = FaceNormal;
-                    Layer1.Vertices[1].Position = P1;
-
-                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
-                    Layer1.Vertices[2].Normal = FaceNormal;
-                    Layer1.Vertices[2].Position = P2;
-
-                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
-                    Layer1.Vertices[3].Normal = FaceNormal;
-                    Layer1.Vertices[3].Position = P3;
-
-                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
-                    Layer1.Vertices[4].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
-
-                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
-                    Layer1.Vertices[5].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
-
-                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
-                    Layer1.Vertices[6].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
-
-                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
-                    Layer1.Vertices[7].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
-                    #endregion Define Layer1 Vertices
-
-                    #region Define Layer1 Indices
-                    Layer1.Indices[0] = 0;
-                    Layer1.Indices[1] = 5;
-                    Layer1.Indices[2] = 4;
-
-                    Layer1.Indices[3] = 0;
-                    Layer1.Indices[4] = 1;
-                    Layer1.Indices[5] = 5;
-
-                    Layer1.Indices[6] = 5;
-                    Layer1.Indices[7] = 1;
-                    Layer1.Indices[8] = 2;
-
-                    Layer1.Indices[9] = 6;
-                    Layer1.Indices[10] = 5;
-                    Layer1.Indices[11] = 2;
-
-                    Layer1.Indices[12] = 7;
-                    Layer1.Indices[13] = 6;
-                    Layer1.Indices[14] = 2;
-
-                    Layer1.Indices[15] = 3;
-                    Layer1.Indices[16] = 7;
-                    Layer1.Indices[17] = 2;
-
-                    Layer1.Indices[18] = 0;
-                    Layer1.Indices[19] = 7;
-                    Layer1.Indices[20] = 3;
-
-                    Layer1.Indices[21] = 0;
-                    Layer1.Indices[22] = 4;
-                    Layer1.Indices[23] = 7;
-
-                    chunks.Add( Layer1 );
-                    #endregion Define Layer1 Indices
-                }
-
-                #region Define Layer2 Vertices
-                Chunk Layer2 = new Chunk( 12, 8 * 3 );
-
-                Vector3d T0, T1, T2, T3;
-                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
-                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
-                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
-                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
-
-                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
-                Layer2.Vertices[0].Normal = FaceNormal;
-                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
-
-                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
-                Layer2.Vertices[1].Normal = FaceNormal;
-                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
-
-                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
-                Layer2.Vertices[3].Normal = FaceNormal;
-                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
-
-                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
-                Layer2.Vertices[4].Normal = FaceNormal;
-                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
-
-                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
-                Layer2.Vertices[6].Normal = FaceNormal;
-                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
-
-                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
-                Layer2.Vertices[7].Normal = FaceNormal;
-                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
-
-                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
-                Layer2.Vertices[9].Normal = FaceNormal;
-                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
-
-                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
-                Layer2.Vertices[10].Normal = FaceNormal;
-                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
-
-                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
-                Layer2.Vertices[2].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
-
-                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
-                Layer2.Vertices[5].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
-
-                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
-                Layer2.Vertices[8].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
-
-                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
-                Layer2.Vertices[11].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
-                #endregion Define Layer2 Vertices
-
-                #region Define Layer2 Indices
-                Layer2.Indices[0] = 0;
-                Layer2.Indices[1] = 2;
-                Layer2.Indices[2] = 11;
-
-                Layer2.Indices[3] = 0;
-                Layer2.Indices[4] = 1;
-                Layer2.Indices[5] = 2;
-
-                Layer2.Indices[6] = 2;
-                Layer2.Indices[7] = 3;
-                Layer2.Indices[8] = 4;
-
-                Layer2.Indices[9] = 2;
-                Layer2.Indices[10] = 4;
-                Layer2.Indices[11] = 5;
-
-                Layer2.Indices[12] = 5;
-                Layer2.Indices[13] = 6;
-                Layer2.Indices[14] = 8;
-
-                Layer2.Indices[15] = 8;
-                Layer2.Indices[16] = 6;
-                Layer2.Indices[17] = 7;
-
-                Layer2.Indices[18] = 11;
-                Layer2.Indices[19] = 8;
-                Layer2.Indices[20] = 10;
-
-                Layer2.Indices[21] = 10;
-                Layer2.Indices[22] = 8;
-                Layer2.Indices[23] = 9;
-
-                chunks.Add( Layer2 );
-                #endregion Define Layer2 Indices
-            }
-        }
-    }
-
-   
-}
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
deleted file mode 100644
index 5b4e4cc..0000000
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ /dev/null
@@ -1,228 +0,0 @@
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-
-    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
-    internal struct TetrahedronFace
-    {
-        private Vector3d APosition, BPosition, CPosition;
-        private Vector3d DPosition, Normal;
-        private Vector2d ATexCoord, BTexCoord, CTexCoord;
-
-        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
-                                   ref Vector3d bpos, ref Vector2d btc,
-                                   ref Vector3d cpos, ref Vector2d ctc,
-                                   ref Vector3d dpos,
-                                   ref Vector3d normal )
-        {
-            APosition = apos; ATexCoord = atc;
-            BPosition = bpos; BTexCoord = btc;
-            CPosition = cpos; CTexCoord = ctc;
-            DPosition = dpos;
-            Normal = normal;
-        }
-
-        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
-        /// <param name="first">1st output Triangle</param>
-        /// <param name="second">2nd output Triangle</param>
-        /// <param name="third">3rd output Triangle</param>
-        /// <param name="fourth">4th output Triangle</param>
-        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
-        {
-            Vector3d temp;
-
-            // find the 3 points AB, BC, CA 
-            Vector3d CenterAB;
-            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
-
-            Vector3d CenterBC;
-            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
-
-            Vector3d CenterCA;
-            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
-
-            // find the 3 points AD, BD, CD 
-            Vector3d CenterAD;
-            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
-
-            Vector3d CenterBD;
-            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
-
-            Vector3d CenterCD;
-            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
-
-            // emit 4 new CCW triangles
-            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
-                              ref CenterAB, ref this.BTexCoord,
-                              ref CenterCA, ref this.CTexCoord,
-                              ref CenterAD,
-                              ref this.Normal );
-
-            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
-                               ref this.BPosition, ref this.BTexCoord,
-                               ref CenterBC, ref this.CTexCoord,
-                               ref CenterBD,
-                               ref this.Normal );
-
-            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
-                              ref CenterBC, ref this.BTexCoord,
-                              ref this.CPosition, ref this.CTexCoord,
-                              ref CenterCD,
-                              ref this.Normal );
-
-            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
-                               ref CenterBD, ref this.BTexCoord,
-                               ref CenterCD, ref this.CTexCoord,
-                               ref this.DPosition,
-                               ref this.Normal );
-        }
-
-
-        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
-        {
-            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
-            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
-
-            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
-            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
-            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
-            CenterD = CenterAB;
-            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
-            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
-            CenterD /= 3.0;
-            Vector3d E = CenterD + ( this.Normal * 0.5 );
-            Vector3d temp = this.Normal;
-            temp *= height;
-            Vector3d.Add(ref CenterD, ref temp, out CenterD);
-
-            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
-            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
-            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
-            TexCoordD = TexCoordAB;
-            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
-            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
-            TexCoordD /= 3.0;
-            #region 1
-            first.APosition = this.APosition;
-            first.ATexCoord = this.ATexCoord;
-
-            first.BPosition = CenterAB;
-            first.BTexCoord = TexCoordAB;
-
-            first.CPosition = CenterCA;
-            first.CTexCoord = TexCoordCA;
-
-            first.Normal = this.Normal;
-            temp = ( this.APosition + CenterAB + CenterCA );
-            temp /= 3.0;
-            temp += this.Normal * -1.0;
-            first.DPosition = temp;
-            #endregion 1
-            #region 2
-            second.APosition = CenterAB;
-            second.ATexCoord = TexCoordAB;
-
-            second.BPosition = this.BPosition;
-            second.BTexCoord = this.BTexCoord;
-
-            second.CPosition = CenterBC;
-            second.CTexCoord = TexCoordBC;
-
-            second.Normal = this.Normal;
-
-            temp = CenterAB + this.BPosition + CenterBC;
-            temp /=  3.0;
-            temp += this.Normal * -1.0;
-            second.DPosition = temp;
-
-            #endregion 2
-            #region 3
-            third.APosition = CenterBC;
-            third.ATexCoord = TexCoordBC;
-
-            third.BPosition = this.CPosition;
-            third.BTexCoord = this.CTexCoord;
-
-            third.CPosition = CenterCA;
-            third.CTexCoord = TexCoordCA;
-
-            third.Normal = this.Normal;
-            temp = CenterBC + this.CPosition + CenterCA;
-            temp /= 3.0;
-            temp += this.Normal * -1.0;
-            third.DPosition = temp;
-            #endregion 3
-            #region 4
-            fourth.APosition = CenterAB;
-            fourth.ATexCoord = TexCoordAB;
-
-            fourth.BPosition = CenterD;
-            fourth.BTexCoord = TexCoordD;
-
-            fourth.CPosition = CenterCA;
-            fourth.CTexCoord = TexCoordCA;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
-            fourth.DPosition = E;
-            #endregion 4
-            #region 5
-            fifth.APosition = CenterAB;
-            fifth.ATexCoord = TexCoordAB;
-
-            fifth.BPosition = CenterBC;
-            fifth.BTexCoord = TexCoordBC;
-
-            fifth.CPosition = CenterD;
-            fifth.CTexCoord = TexCoordD;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
-            fifth.DPosition = E;
-
-            #endregion 5
-            #region 6
-            sixth.APosition = CenterBC;
-            sixth.ATexCoord = TexCoordBC;
-
-            sixth.BPosition = CenterCA;
-            sixth.BTexCoord = TexCoordCA;
-
-            sixth.CPosition = CenterD;
-            sixth.CTexCoord = TexCoordD;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
-            sixth.DPosition = E;
-            #endregion 6
-        }
-
-        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
-        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
-        {
-            first.TexCoord = this.ATexCoord;
-            first.Normal = this.Normal;
-            first.Position = this.APosition;
-
-            second.TexCoord = this.BTexCoord;
-            second.Normal = this.Normal;
-            second.Position = this.BPosition;
-
-            third.TexCoord = this.CTexCoord;
-            third.Normal = this.Normal;
-            third.Position = this.CPosition;
-        }
-
-        /// <summary>Debugging Aid, no real purpose</summary>
-        public override string ToString()
-        {
-            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "Normal= " + this.Normal.ToString();
-        }
-    }
-
-
-}
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
deleted file mode 100644
index 62d5462..0000000
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-namespace KAOS.Shapes
-{
-    public sealed class VboShape: DrawableShape
-    {
-        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
-            : base( useDL )
-        {
-            PrimitiveMode = primitives;
-
-            VertexArray = new VertexT2dN3dV3d[vertices.Length];
-            for ( uint i = 0; i < vertices.Length; i++ )
-            {
-                VertexArray[i] = vertices[i];
-            }
-
-            IndexArray = new uint[indices.Length];
-            for ( uint i = 0; i < indices.Length; i++ )
-            {
-                IndexArray[i] = indices[i];
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
deleted file mode 100644
index a662cfe..0000000
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ /dev/null
@@ -1,70 +0,0 @@
-using System;
-
-namespace KAOS.Shapes
-{
-    public sealed class KochTetrahedron: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            Zero = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-            Five=5,
-            Six=6,
-            Seven=7,
-            Eight=8,
-        }
-
-        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            TetrahedronFace[] Triangles;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.Zero:
-                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-            case eSubdivisions.Four:
-            case eSubdivisions.Five:
-            case eSubdivisions.Six:
-            case eSubdivisions.Seven:
-            case eSubdivisions.Eight:
-                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    TetrahedronFace[] temp;
-                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
-                    Triangles = temp;
-                    extrusionHeight *= extrusionMultiplier;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
-            IndexArray = null;
-        }
-
-        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
-        {
-            output = new TetrahedronFace[input.Length * 6];
-
-            int counter = 0;
-            for ( int i = 0; i < input.Length; i++ )
-            {
-                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
-                counter += 6; // every source triangle emits 6 new triangles
-            }
-
-        }
-    }
-}
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
deleted file mode 100644
index c1d54c6..0000000
--- a/AWGL/Shapes/MengerSponge.cs
+++ /dev/null
@@ -1,115 +0,0 @@
-using OpenTK;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class MengerSponge: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            None = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-        }
-
-        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            List<MengerCube> Cubes;
-            switch ( subdivs )
-            {
-            case eSubdivisions.None:
-                CreateDefaultMengerSponge( scale, out Cubes );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-                CreateDefaultMengerSponge( scale, out Cubes );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    List<MengerCube> temp;
-                    SubdivideMengerSponge( ref Cubes, out temp );
-                    Cubes = temp;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            #region Get Array Dimensions
-            uint
-                VertexCount = 0,
-                IndexCount = 0;
-
-            foreach ( MengerCube c in Cubes )
-            {
-                uint t1, t2;
-                c.GetArraySizes( out t1, out t2 );
-                VertexCount += t1;
-                IndexCount += t2;
-            }
-
-            VertexArray = new VertexT2dN3dV3d[VertexCount];
-            IndexArray = new uint[IndexCount];
-            #endregion Get Array Dimensions
-
-            List<Chunk> AllChunks = new List<Chunk>();
-
-            #region Build a temporary List of all loose pieces
-            foreach ( MengerCube c in Cubes )
-            {
-                c.GetVboAndIbo( ref AllChunks );
-            }
-            #endregion Build a temporary List of all loose pieces
-
-            #region Assemble pieces into a single VBO and IBO
-            VertexCount = 0;
-            IndexCount = 0;
-
-            foreach ( Chunk ch in AllChunks )
-            {
-                for ( int i = 0; i < ch.Vertices.Length; i++ )
-                {
-                    VertexArray[VertexCount + i] = ch.Vertices[i];
-                }
-
-                for ( int i = 0; i < ch.Indices.Length; i++ )
-                {
-                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
-                }
-
-                VertexCount += (uint)ch.Vertices.Length;
-                IndexCount += (uint)ch.Indices.Length;
-            }
-
-            #endregion Assemble pieces into a single VBO and IBO
-
-            AllChunks.Clear();
-        }
-
-        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
-        {
-            output = new List<MengerCube>( 1 );
-            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
-        }
-
-        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
-        {
-            output = new List<MengerCube>( input.Count * 20 );
-            foreach ( MengerCube InputCube in input )
-            {
-                MengerCube[] SubdividedCubes;
-                InputCube.Subdivide( out SubdividedCubes );
-                for ( int i = 0; i < SubdividedCubes.Length; i++ )
-                {
-                    output.Add( SubdividedCubes[i] );
-                }
-            }
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
deleted file mode 100644
index 99c2d1b..0000000
--- a/AWGL/Shapes/Old/Cube.cs
+++ /dev/null
@@ -1,85 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using System.Drawing;
-
-namespace KAOS.Shapes
-{
-    public class Cube : Shape
-    {
-
-        public Cube(int x, int y, int z)
-        {
-            Vertices = new Vector3[]
-            {
-                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
-                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
-                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
-                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
-                new Vector3(x-1.0f, y-1.0f, z-1.0f),
-                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
-                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
-                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
-            };
-
-            Indices = new int[]
-            {
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1,
-            };
-
-            Normals = new Vector3[]
-            {
-                new Vector3(-1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f,  1.0f, -1.0f),
-                new Vector3(-1.0f,  1.0f, -1.0f),
-            };
-
-            Colors = new int[]
-            {
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.Gold),
-            };
-        }
-
-
-        /// <summary>
-        /// Converts a Color instance into an int representation
-        /// </summary>
-        /// <param name="c">
-        /// A <see cref="Color"/> instance to be converted
-        /// </param>
-        /// <returns>
-        /// A <see cref="System.Int32"/>
-        /// </returns>
-        public static int ColorToRgba32(Color c)
-        {
-            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
deleted file mode 100644
index 4b2ae9f..0000000
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using System;
-
-namespace KAOS.Shapes
-{
-    class IsoSphere : Shape
-    {
-        const double DoublePI = System.Math.PI * 2.0;
-
-        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
-        {
-            int count = 4 * s_steps * t_steps ;
-            
-            Vertices = new Vector3[count];
-            Normals = new Vector3[count];
-            Texcoords = new Vector2[count];
-            Indices = new int[6 * count / 4];
-
-            int i = 0;
-            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
-            {
-                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
-                {
-                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
-                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
-                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
-                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
-                    Normals[i] = Vector3.Normalize(Vertices[i]);
-
-                    ++i;
-                }
-            }
-            
-            for (i = 0; i < 6*count/4; i+=6)
-            {
-                Indices[i] = i;
-                Indices[i + 1] = i + 1;
-                Indices[i + 2] = i + 2 * s_steps + 1;
-                Indices[i + 3] = i + 2 * s_steps;
-                Indices[i + 4] = i;
-                Indices[i + 5] = i + 2 * s_steps + 1;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
deleted file mode 100644
index df9a78e..0000000
--- a/AWGL/Shapes/Old/Plane.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-    public class Plane : Shape
-    {
-        public Plane(int x_res, int y_res, float x_scale, float y_scale)
-        {
-            Vertices = new Vector3[x_res * y_res];
-            Normals = new Vector3[x_res * y_res];
-            Indices = new int[6 * x_res * y_res];
-            Texcoords = new Vector2[x_res * y_res];
-
-            int i = 0;
-            for (int y = -y_res / 2; y < y_res / 2; y++)
-            {
-                for (int x = -x_res / 2; x < x_res / 2; x++)
-                {
-                    Vertices[i].X = x_scale * (float)x / (float)x_res;
-                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
-                    Vertices[i].Z = 0;
-                    Normals[i].X = Normals[i].Y = 0;
-                    Normals[i].Z = 1;
-                    i++;
-                }
-            }
-
-            i = 0;
-            for (int y = 0; y < y_res - 1; y++)
-            {
-                for (int x = 0; x < x_res - 1; x++)
-                {
-                    Indices[i++] = (y + 0) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x + 1;
-                }
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
deleted file mode 100644
index c5315af..0000000
--- a/AWGL/Shapes/Old/Shape.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-
-
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-    public abstract class Shape
-    {
-        private Vector3[] vertices, normals;
-        private Vector2[] texcoords;
-        private int[] indices;
-        private int[] colors;
-
-        public Vector3[] Vertices
-        {
-            get { return vertices; }
-            protected set
-            {
-                vertices = value;
-            }
-        }
-
-        public Vector3[] Normals
-        {
-            get { return normals; }
-            protected set
-            {
-                normals = value;
-            }
-        }
-
-        public Vector2[] Texcoords
-        {
-            get { return texcoords; }
-            protected set
-            {
-                texcoords = value;
-            }
-        }
-
-        public int[] Indices
-        {
-            get { return indices; }
-            protected set
-            {
-                indices = value;
-            }
-        }
-
-        public int[] Colors
-        {
-            get { return colors; }
-            protected set
-            {
-                colors = value;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
deleted file mode 100644
index fcb493d..0000000
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ /dev/null
@@ -1,171 +0,0 @@
-using OpenTK;
-using System;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class SierpinskiTetrahedron: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
-            Zero = 0,
-            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
-            One = 1,
-            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
-            Two = 2,
-            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
-            Three = 3,
-            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
-            Four = 4,
-            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
-            Five = 5,
-            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
-            Six = 6,
-            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
-            Seven = 7,
-            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
-            Eight = 8,
-            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
-            Nine = 9,
-        }
-
-        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
-        /// <param name="scale">Default: 1f.</param>
-        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
-        /// <param name="useDL"></param>
-        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            TetrahedronFace[] Triangles;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.Zero:
-                CreateDefaultTetrahedron( scale, out Triangles );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-            case eSubdivisions.Four:
-            case eSubdivisions.Five:
-            case eSubdivisions.Six:
-            case eSubdivisions.Seven:
-            case eSubdivisions.Eight:
-            case eSubdivisions.Nine:
-                CreateDefaultTetrahedron( scale, out Triangles );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    TetrahedronFace[] temp;
-                    SubdivideTetrahedron( ref Triangles, out temp );
-                    Triangles = temp;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
-            IndexArray = null;
-        }
-
-        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
-        {
-            output = new VertexT2dN3dV3d[input.Length * 3];
-            int counter = 0;
-            for ( int i = 0; i < input.Length; i++ )
-            {
-                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
-                counter += 3;
-            }
-        }
-
-        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
-        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
-        {
-            Vector3d[] Points = new Vector3d[4];
-            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
-            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
-            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
-            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
-
-            Vector2d[] TexCoords = new Vector2d[4];
-            TexCoords[0] = new Vector2d( 0.0, 0.0 );
-            TexCoords[1] = new Vector2d( 1.0, 0.0 );
-            TexCoords[2] = new Vector2d( 0.0, 1.0 );
-            TexCoords[3] = new Vector2d( 1.0, 1.0 );
-
-            Vector3d Normal;
-            array = new TetrahedronFace[4];
-
-            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
-            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
-                                                   ref Points[2], ref TexCoords[0],
-                                                   ref Points[1], ref TexCoords[1],
-                                                   ref Points[3],
-                                                   ref Normal );
-
-            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
-            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
-                                                   ref Points[3], ref TexCoords[1],
-                                                   ref Points[2], ref TexCoords[2],
-                                                   ref Points[1],
-                                                   ref Normal );
-
-            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
-            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
-                                                   ref Points[1], ref TexCoords[1],
-                                                   ref Points[3], ref TexCoords[3],
-                                                   ref Points[2],
-                                                   ref Normal );
-
-            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
-            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
-                                                   ref Points[2], ref TexCoords[2],
-                                                   ref Points[3], ref TexCoords[1],
-                                                   ref Points[0],
-                                                   ref Normal );
-        }
-
-        /// <summary>Subdivides each triangle into 4 new ones.</summary>
-        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
-        {
-
-            output = new TetrahedronFace[source.Length * 4];
-
-            int counter = 0;
-            for ( int i = 0; i < source.Length; i++ )
-            {
-                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
-                counter += 4; // every source triangle emits 4 new triangles
-            }
-        }
-
-        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
-        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
-        {
-            Vector3d temp1, temp2, temp3;
-
-            Vector3d.Subtract( ref A, ref D, out temp1 );
-            Vector3d.Subtract( ref B, ref D, out temp2 );
-            Vector3d.Subtract( ref C, ref D, out temp3 );
-
-            Vector3d.Add( ref temp1, ref temp2, out result );
-            Vector3d.Add(ref result, ref temp3, out result);
-            result.Normalize();
-        }
-
-        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
-        {
-            Vector3d temp1, temp2;
-            Vector3d.Subtract( ref A, ref B, out temp1 );
-            temp1.Normalize();
-            Vector3d.Subtract(ref C, ref B, out temp2);
-            temp2.Normalize();
-            Vector3d.Cross( ref temp1, ref temp2, out result );
-            result *=  -1.0;
-            result.Normalize();
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
deleted file mode 100644
index 8a744ca..0000000
--- a/AWGL/Shapes/SlicedHose.cs
+++ /dev/null
@@ -1,192 +0,0 @@
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-	public sealed class SlicedHose : DrawableShape
-	{
-
-        public enum eSide:byte
-        {
-            // Around X Axis
-            BottomRight,
-            TopRight,
-            TopLeft,
-            BottomLeft,
-
-            // Around Y Axis
-
-            FrontRight,
-            BackRight,
-            BackLeft,
-            FrontLeft,
-
-            // Around Z Axis
-            FrontBottom,
-            BackBottom,
-            BackTop,
-            FrontTop,
-        }
-
-        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
-            : base( useDL )
-        {
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            Vector3d start = Vector3d.Zero,
-                     end = Vector3d.Zero;
-            double TexCoordStart=0f, TexCoordEnd=0f;
-
-            switch ( side )
-            {
-            #region Around X Axis
-            case eSide.BottomRight:
-                start = -Vector3d.UnitY;
-                end = Vector3d.UnitZ;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.TopRight:
-                start = Vector3d.UnitZ;
-                end = Vector3d.UnitY;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.TopLeft:
-                start = Vector3d.UnitY;
-                end = -Vector3d.UnitZ;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.BottomLeft:
-                start = -Vector3d.UnitZ;
-                end = -Vector3d.UnitY;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-            #endregion Around X Axis
-            #region Around Y Axis
-            case eSide.FrontRight:
-                start = Vector3d.UnitX;
-                end = Vector3d.UnitZ;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.BackRight:
-                start = Vector3d.UnitZ;
-                end = -Vector3d.UnitX;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.BackLeft:
-                start = -Vector3d.UnitX;
-                end = -Vector3d.UnitZ;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.FrontLeft:
-                start = -Vector3d.UnitZ;
-                end = Vector3d.UnitX;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-#endregion Around Y Axis
-            #region Around Z Axis
-            case eSide.FrontBottom:
-                start = -Vector3d.UnitY;
-                end = Vector3d.UnitX;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.BackBottom:
-                start = -Vector3d.UnitX;
-                end = -Vector3d.UnitY;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.BackTop:
-                start = Vector3d.UnitY;
-                end = -Vector3d.UnitX;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.FrontTop:
-                start = Vector3d.UnitX;
-                end = Vector3d.UnitY;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-#endregion Around Z Axis
-
-            }
-
-            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
-
-            double divisor = 1.0/ ((double)temp.Length-1.0);
-            for ( int i = 0; i < temp.Length; i++ )
-            {
-                float Multiplier = (float)( i * divisor );
-
-                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
-
-                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
-                temp[i].Normal.Normalize();
-                temp[i].Position = temp[i].Normal;
-                temp[i].Position *= scale;
-            }
-
-            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
-            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
-
-            uint VertexCounter = 0,
-                 IndexCounter = 0,
-                 QuadCounter = 0;
-
-            for ( int i = 0; i < temp.Length; i++ )
-            {
-                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
-                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
-                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
-                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
-
-
-                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
-                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
-                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
-                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
-                VertexCounter += 2;
-
-                if ( i < temp.Length - 1 )
-                {
-                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
-                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
-                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
-
-                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
-                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
-                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
-
-                    IndexCounter += 6;
-                    QuadCounter += 2;
-                }
-            }
-
-        }
- 
-    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
-    {
-        double t1;
-        Vector3d.Dot( ref a, ref b, out t1 );
-        double theta = System.Math.Acos( t1 );
-
-        double temp = 1.0 / System.Math.Sin( theta );
-        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
-        double t3 = System.Math.Sin( factor * theta ) * temp;
-
-        Vector3d v1 = Vector3d.Multiply( a, t2);
-        Vector3d v2 = Vector3d.Multiply( b, t3 );
-        result = Vector3d.Add( v1, v2 );
-    }
-
-
-    }
-}
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
deleted file mode 100644
index 7c5ee4f..0000000
--- a/AWGL/Shapes/SlicedSphere.cs
+++ /dev/null
@@ -1,193 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class SlicedSphere: DrawableShape
-    {
-        public enum eSubdivisions
-        {
-            Zero = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-            Five=5,
-            Six=6,
-            Seven=7,
-            Eight=8,
-        }
-
-        public enum eDir
-        {
-            All,
-            FrontTopRight,
-            FrontBottomRight,
-            FrontBottomLeft,
-            FrontTopLeft,
-            BackTopRight,
-            BackBottomRight,
-            BackBottomLeft,
-            BackTopLeft,
-
-        }
-
-        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
-            : base( useDL )
-        {
-            double Diameter = radius;
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            if ( sides[0] == eDir.All )
-            {
-                sides = new eDir[] {  eDir.FrontTopRight,
-            eDir.FrontBottomRight,
-            eDir.FrontBottomLeft,
-            eDir.FrontTopLeft,
-            eDir.BackTopRight,
-            eDir.BackBottomRight,
-            eDir.BackBottomLeft,
-            eDir.BackTopLeft,};
-            }
-
-            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
-            IndexArray = new uint[sides.Length * 3];
-
-            uint counter = 0;
-            foreach ( eDir s in sides )
-            {
-                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
-                IndexArray[counter + 0] = counter + 0;
-                IndexArray[counter + 1] = counter + 1;
-                IndexArray[counter + 2] = counter + 2;
-                counter += 3;
-            }
-
-            if ( subdivs != eSubdivisions.Zero )
-            {
-
-                for ( int s = 0; s < (int)subdivs; s++ )
-                {
-                    #region Assemble Chunks and convert to Arrays
-                    List<Chunk> AllChunks = new List<Chunk>();
-                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
-                    {
-                        Chunk chu;
-                        Subdivide( Diameter,
-                                   ref VertexArray[IndexArray[i + 0]],
-                                   ref VertexArray[IndexArray[i + 1]],
-                                   ref VertexArray[IndexArray[i + 2]],
-                                   out chu );
-                        AllChunks.Add( chu );
-                    }
-
-                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-                    AllChunks.Clear();
-                    #endregion Assemble Chunks and convert to Arrays
-                }
-            }
-
-            for (int i=0; i<VertexArray.Length;i++)
-            {
-                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
-            }
-        }
-
-        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
-        {
-            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
-                            t2 = new VertexT2dN3dV3d(),
-                            t3 = new VertexT2dN3dV3d();
-            switch ( s )
-            {
-            case eDir.FrontTopRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                break;
-            case eDir.FrontBottomRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                break;
-            case eDir.FrontBottomLeft: 
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                break;
-            case eDir.FrontTopLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                break;
-            case eDir.BackTopRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                break;
-            case eDir.BackBottomRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                break;
-            case eDir.BackBottomLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                break;
-            case eDir.BackTopLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                break;
-            }
-            first = t1;
-            second = t2;
-            third = t3;
-        }
-
-
-        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
-        {
-            c = new Chunk(6, 12);
-
-            c.Vertices[0] = first;
-            
-            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
-            c.Vertices[1].Normal.Normalize();
-            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
-            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
-
-            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
-            c.Vertices[2].Normal.Normalize();
-            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
-            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
-
-            c.Vertices[3] = second;
-    
-            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
-            c.Vertices[4].Normal.Normalize();
-            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
-            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
-
-            c.Vertices[5] = third;
-
-            #region Indices
-            c.Indices[0]=0;
-            c.Indices[1]=1;
-            c.Indices[2]=2;
-            c.Indices[3]=2;
-            c.Indices[4]=1;
-            c.Indices[5]=4;
-            c.Indices[6]=1;
-            c.Indices[7]=3;
-            c.Indices[8]=4;
-            c.Indices[9]=2;
-            c.Indices[10]=4;
-            c.Indices[11]=5;
-            #endregion Indices
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
deleted file mode 100644
index 898c314..0000000
--- a/AWGL/Shapes/TorusKnot.cs
+++ /dev/null
@@ -1,126 +0,0 @@
-﻿using OpenTK;
-using System.Diagnostics;
-
-namespace KAOS.Shapes
-{
-    public sealed class TorusKnot: DrawableShape
-    {
-        #region Constants
-        // hard minimums to make sure the created Torusknot is 3D
-        private const int MINShapeVertices = 3;
-        private const int MINPathSteps = 32;
-        private const double TwoPi = ( 2.0 * System.Math.PI );
-        #endregion Constants
-
-        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
-            : base( useDL )
-        {
-            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
-            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
-            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
-
-            Vector3d[] PathPositions = new Vector3d[pathsteps];
-
-            #region Find the center Points for each step on the path
-
-            for ( int i = 0; i < pathsteps; i++ )
-            {
-                double Angle = ( i / (double)pathsteps ) * TwoPi;
-                double AngleTimesP = Angle * p;
-                double AngleTimesQ = Angle * q;
-                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
-
-                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
-                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
-                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
-
-            }
-            #endregion Find the center Points for each step on the path
-
-            #region Find the Torus length
-            Vector3d result;
-            double[] Lengths = new double[pathsteps];
-            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
-            Lengths[0] = result.Length;
-            double TotalLength = result.Length;
-            for ( int i = 1; i < pathsteps; i++ ) // skipping 
-            {
-                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
-                Lengths[i] = result.Length;
-                TotalLength += result.Length;
-            }
-            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
-            #endregion Find the Torus length
-
-            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
-
-            #region Loft a circle Shape along the path
-            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
-            for ( uint i = 0; i < pathsteps; i++ )
-            {
-                Vector3d last, next, normal, tangent;
-                if ( i == pathsteps - 1 )
-                    next = PathPositions[0];
-                else
-                    next = PathPositions[i + 1];
-                if ( i == 0 )
-                    last = PathPositions[pathsteps - 1];
-                else
-                    last = PathPositions[i - 1];
-
-                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
-                tangent.Normalize();
-
-                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
-                normal.Normalize();
-                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
-
-                for ( uint j = 0; j < shapevertices; j++ )
-                {
-                    uint index = i * (uint)shapevertices + j;
-
-                    // Create a point on the plane and rotate it
-                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
-                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
-                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
-                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
-                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
-                    VertexArray[index].Normal.Normalize();
-                    // just generate some semi-useful UVs to fill blanks
-                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
-                }
-            }
-            #endregion Loft a circle Shape along the path
-
-            PathPositions = null; // not needed anymore
-
-            uint currentindex = 0;
-
-            #region Build a Triangle strip from the Vertices
-            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
-            for ( uint i = 0; i < pathsteps; i++ )
-            {
-                uint RowCurrent = i * (uint)shapevertices;
-                uint RowBelow;
-                if ( i == pathsteps - 1 )
-                    RowBelow = 0; // for the last row, the first row is the following
-                else
-                    RowBelow = ( i + 1 ) * (uint)shapevertices;
-
-                // new ring begins here
-                for ( uint j = 0; j < shapevertices; j++ )
-                {
-                    IndexArray[currentindex++] = RowCurrent + j;
-                    IndexArray[currentindex++] = RowBelow + j;
-                }
-                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
-                IndexArray[currentindex++] = RowCurrent;
-                IndexArray[currentindex++] = RowBelow;
-            }
-            #endregion Build a Triangle strip from the Vertices
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
deleted file mode 100644
index 2576afe..0000000
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿#region License
-//
-// The Open Toolkit Library License
-//
-// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights to 
-// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-// the Software, and to permit persons to whom the Software is furnished to do
-// so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in all
-// copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-// OTHER DEALINGS IN THE SOFTWARE.
-//
-#endregion
-
-using OpenTK;
-using System.Drawing;
-using System.Runtime.InteropServices;
-
-namespace KAOS.Tutorial
-{
-    [StructLayout(LayoutKind.Sequential, Pack = 1)]
-    struct VertexPositionColor
-    {
-        public Vector3 Position;
-        public uint Color;
-
-        public VertexPositionColor(float x, float y, float z, Color color)
-        {
-            Position = new Vector3(x, y, z);
-            Color = ToRgba(color);
-        }
-
-        static uint ToRgba(Color color)
-        {
-            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
-        }
-    }
-}
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
deleted file mode 100644
index 40dbc84..0000000
--- a/AWGL/States/AssimpImportedState.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-
-namespace KAOS.States
-{
-    public class AssimpImportedState :IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-
-        public AssimpImportedState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Render()
-        {
-
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-    }
-}
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
deleted file mode 100644
index e26345e..0000000
--- a/AWGL/States/DefaultState.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DefaultState : IGameObject
-    {
-        double currentRotation = 0;
-
-        StateManager m_stateManager;
-        public DefaultState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.Black);
-            GL.PointSize(5f);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.TriangleStrip);
-
-            GL.Color4(new Color4(1f, 0f, 0f, .5f));
-            GL.Vertex3(new Vector3(-50f, 0f, 0f));
-            GL.Color3(new Vector3(0f, 1f, 0f));
-            GL.Vertex3(new Vector3(50f, 0, 0));
-            GL.Color3(new Vector3(0f, 0f, 1f));
-            GL.Vertex3(new Vector3(0f, 50f, 0));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
deleted file mode 100644
index f83dcda..0000000
--- a/AWGL/States/DrawSpriteState.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DrawSpriteState : IGameObject
-    {
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        double height, width, halfHeight, halfWidth, x, y, z;
-        float topUV, bottomUV, leftUV, rightUV;
-
-        #region IGameObject States
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            Texture texture = m_textureManager.Get("sprite1");
-            GL.Enable(EnableCap.Texture2D);
-            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-            GL.ClearColor(Color.Black);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.End();
-
-        } 
-        #endregion
-
-        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-        {
-            m_stateManager = stateManager;
-            m_textureManager = texturManager;
-            Initialise();
-        }
-
-        private void Initialise()
-        {
-            this.height = 200;
-            this.width = 200;
-
-            this.halfHeight = this.height / 2;
-            this.halfWidth = this.width / 2;
-
-            this.x = 0;
-            this.y = 0;
-            this.z = 2;
-
-            this.topUV = 0;
-            this.bottomUV = 1;
-            this.leftUV = 0;
-            this.rightUV = 1;
-        }
-    }
-}
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
deleted file mode 100644
index 59095f9..0000000
--- a/AWGL/States/Skyboxstate.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-
-namespace KAOS.States
-{
-    public class Skyboxstate : IGameObject
-    {
-        private BufferObjectManager m_bufferManager;
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        Cube cube;
-        BufferObject cubeObject;
-
-        // Data layout for each line below is:
-        // position{XYZ},			    normal{XYZ},
-        float[] vertexData = new float[] {
-            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
-  
-            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
-  
-            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
-  
-            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
-  
-            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
-  
-            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
-        };
-
-        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
-        string[] skyboxFaces = new String[]
-        {
-            defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
-            defaultSkyboxPath + "pos_y.bmp",
-            defaultSkyboxPath + "neg_y.bmp",
-            defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
-        };
-
-        Matrix3 modelMatrix3, normalMatrix;
-        Vector3 eyeObjectSpace;
-        Vector3 trans;
-
-        
-        int eye_handle, skybox_vao;
-
-        float aspect = 1024 / (float)600;
-        float _rotation;
-
-        public Skyboxstate(StateManager stateManager)
-        {
-            m_bufferManager = new BufferObjectManager();
-            m_stateManager = stateManager;
-            m_textureManager = new TextureManager();
-
-            LoadCubeMap();
-            CreateShaders();
-
-            _rotation = MathHelper.DegreesToRadians(90);
-            trans = new Vector3(0f, 0f, -10f);
-
-            LoadTestObject();
-        }
-
-        private void CreateShaders()
-        {
-            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
-
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
-
-            Logger.WriteLine("Render Shader");
-            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
-
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
-        }
-
-        private void LoadCubeMap()
-        {
-            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-            GL.Enable(EnableCap.TextureCubeMapSeamless);
-
-            GL.GenVertexArrays(1, out skybox_vao);
-            GL.BindVertexArray(skybox_vao);
-
-            GL.DepthFunc(DepthFunction.Lequal);
-        }
-
-        private void LoadTestObject()
-        {
-            cube = new Cube(0, 0, 0);
-            cubeObject = new BufferObject();
-            cubeObject.PositionData = cube.Vertices;
-            cubeObject.NormalsData = cube.Normals;
-            cubeObject.IndicesData = cube.Indices;
-            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
-
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
-        }
-
-        public void Update(float elapsedTime)
-        {
-            MoveCamera();
-
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            
-            Renderer.viewMatrix = Camera.GetViewMatrix();
-
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
-            Renderer.eyePosition = Camera.Position;
-        }
-
-        public void Render()
-        {
-            cubeObject = m_bufferManager.GetBuffer("SkyCube");
-            Renderer.DrawSkyBox(m_textureManager, cubeObject);
-            
-            cubeObject = m_bufferManager.GetBuffer("Cube");
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Get("Render").ID);
-
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
-
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
-        }
-
-        #region Input Control
-        private void MoveCamera()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-
-            }
-        #endregion
-        }
-    }
-}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
deleted file mode 100644
index c18d9ec..0000000
--- a/AWGL/States/SplashScreenState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Timers;
-
-namespace KAOS.States
-{
-    public class SplashScreenState : IGameObject
-    {
-        double currentRotation = 0;
-        double delay = 300;
-
-        StateManager m_stateManager;
-        public SplashScreenState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            delay--;
-            if (delay <= 0){
-                delay = 3;
-                m_stateManager.ChangeState("Voxels");
-            }
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.MidnightBlue);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
-            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
-            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
deleted file mode 100644
index 814b797..0000000
--- a/AWGL/States/TestSpriteClassState.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.States
-{
-    public class TestSpriteClassState : IGameObject
-    {
-        Renderer m_renderer = new Renderer();
-        TextureManager m_textureManager = new TextureManager();
-        Sprite sprite1 = new Sprite();
-        Sprite sprite2 = new Sprite();
-
-        public TestSpriteClassState(TextureManager textureManager)
-        {
-            m_textureManager = textureManager;
-            sprite1.Texture = m_textureManager.Get("sprite1");
-            sprite1.SetHeight(256 * 0.5f);
-            sprite1.SetPosition(new Vector3d(100, 100, 0));
-            sprite1.SetColour(new Color4(256, 256, 256, 1));
-
-            sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetHeight(256 * .5f);
-            sprite2.SetPosition(new Vector3d(-100, -100, 0));
-            sprite2.SetColour(new Color4(256, 256, 256, 1));
-        }
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(1f, 1f, 1f, 1f);
-            m_renderer.DrawSprite(sprite1);
-            m_renderer.DrawSprite(sprite2);
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
deleted file mode 100644
index 917dae0..0000000
--- a/AWGL/States/VboState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VboState : IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-        Cube cube = new Cube(0, 0, 0);
-
-        public VboState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            CreateVBOs();
-        }
-
-        private void CreateVBOs()
-        {
-            BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;
-            tempVBO.NormalsData = cube.Normals;
-            tempVBO.IndicesData = cube.Indices;
-            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-
-        public void Render()
-        {
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType,
-                            m_bufferObject.IndicesData.Length,
-                            DrawElementsType.UnsignedInt,
-                            IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
deleted file mode 100644
index e8b82e2..0000000
--- a/AWGL/States/VoxelState.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VoxelState : IGameObject
-    {
-        double currentRotation = 0;
-        public float length = 1f, height = 1f, width = 1f;
-
-        StateManager m_stateManager = new StateManager();
-
-        BufferObjectManager m_bufferObjectManager;
-        BufferObject m_bufferObject;
-
-        TextureManager m_textureManager = new TextureManager();
-
-        Cube[][][] m_blocks;
-
-        public VoxelState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            m_bufferObjectManager = new BufferObjectManager();
-
-            //LoadSkyBox();
-
-            GenerateChunk();
-        }
-
-        private void LoadSkyBox()
-        {
-            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-            m_textureManager.LoadSkyTexture("skybox", 
-                new string[] 
-                {
-                    skyboxTexturePath + "jajlands1_ft.jpg",
-                    skyboxTexturePath + "jajlands1_bk.jpg",
-                    skyboxTexturePath + "jajlands1_lf.jpg",
-                    skyboxTexturePath + "jajlands1_rt.jpg",
-                    skyboxTexturePath + "jajlands1_up.jpg",
-                    skyboxTexturePath + "jajlands1_dn.jpg"
-                }
-            );
-
-        }
-
-        private void GenerateChunk()
-        {
-            BufferObject tmpVBO = new BufferObject();
-            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
-            
-            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-            {
-                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-                {
-                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-                    {
-                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-                        if (x == 0 && y == 0 && z == 0) 
-                        { 
-                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-                        }
-                        else
-                        { 
-                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-                        }
-                    }
-                }
-            }
-
-            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 100 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-        }
-    }
-}
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
deleted file mode 100644
index 9d28a68..0000000
--- a/AWGL/Utilities/AnimationTimer.cs
+++ /dev/null
@@ -1,39 +0,0 @@
-﻿
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class PreciseTimer
-    {
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
-
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
-
-        long m_ticksPerSecond = 0;
-        long m_previouslyElapsedTime = 0;
-
-        public PreciseTimer()
-        {
-            QueryPerformanceFrequency(ref m_ticksPerSecond);
-            GetElapsedTime();
-        }
-
-        public float GetElapsedTime()
-        {
-            long time = 0;
-            QueryPerformanceCounter(ref time);
-
-            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
-
-            return elapsedTime;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
deleted file mode 100644
index 4d80ab9..0000000
--- a/AWGL/Utilities/Block.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public class Block
-    {
-        enum BlockType
-        {
-            BlockType_Default = 0,
-
-            BlockType_Grass,
-            BlockType_Dirt,
-            BlockType_Water,
-            BlockType_Stone,
-            BlockType_Wood,
-            BlockType_Sand,
-
-            BlockType_NumTypes,
-        };
-
-        public bool IsActive { get; set; }
-        private bool m_active;
-        private BlockType type;
-    }
-}
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
deleted file mode 100644
index 18a1ea1..0000000
--- a/AWGL/Utilities/BufferObject.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct BufferObject
-    {
-        public int VaoID { get; set; }
-
-        public int VboID { get; set; }
-
-        public int IboID { get; set; }
-
-        public PrimitiveType PrimitiveType { get; set; }
-
-        public Vector3[] PositionData { get; set; }
-
-        public Vector3[] NormalsData { get; set; }
-
-        public Color4[] ColorData { get; set; }
-
-        public int[] IndicesData { get; set; }
-
-        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
-        {
-            #region Buffer Pointer IDs
-            VaoID = vaoId;
-            VboID = vboId;
-            IboID = iboId;
-            #endregion
-            
-            PositionData = vPositionData;
-            NormalsData = vNormalsData;
-            ColorData = vColorData;
-            IndicesData = indicesData;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
deleted file mode 100644
index 59ace7e..0000000
--- a/AWGL/Utilities/Camera.cs
+++ /dev/null
@@ -1,59 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    /// <summary>
-    /// Camera
-    /// </summary>
-    public static class Camera
-    {
-        public static Vector3 Position = new Vector3(0f, 0f, 0f);
-        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
-        public static float MoveSpeed = 0.2f;
-        public static float MouseSensitivity = 0.01f;
-
-        public static Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
-            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
-        }
-
-        public static void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
-            Position += offset;
-
-            Logger.WriteLine("Camera Position = " + Position);
-        }
-
-        public static void AddRotation(float x, float y)
-        {
-            x = x * MouseSensitivity;
-            y = y * MouseSensitivity;
-
-            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
-            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
deleted file mode 100644
index 26681e0..0000000
--- a/AWGL/Utilities/Chunk.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿using KAOS.Shapes;
-using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-namespace KAOS.Utilities
-{
-    public class Chunk : IDisposable
-    {
-        public const int CHUNK_SIZE = 16;
-        private Block[][][] m_blocks;
-        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
-
-        public Chunk()
-        {
-            //Create Blocks
-            m_blocks = new Block[CHUNK_SIZE][][];
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                m_blocks[i] = new Block[CHUNK_SIZE][];
-
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-                }
-            }
-        }
-
-        public void Update(float dt) { }
-
-        public void Render() { }
-
-        public void Dispose()
-        {
-            // Delete blocks
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                
-
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = null;
-                }
-                m_blocks[i] = null;
-            }
-            m_blocks = null;
-        }
-
-        public void CreateMesh()
-        {
-            for (int x = 0; x < CHUNK_SIZE; x++)
-            {
-                for (int y = 0; y < CHUNK_SIZE; y++)
-                {
-                    for (int z = 0; z < CHUNK_SIZE; z++)
-                    {
-                        if (m_blocks[x][y][z].IsActive == false)
-                        {
-                            // Don't create triangle data for inactive blocks
-                            continue;
-                        }
-
-                        CreateCube(x, y, z);
-                    }
-                }
-            }
-        }
-
-        private void CreateCube(int x, int y, int z)
-        {
-            float blockSize = 1f;
-
-            
-            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
-
-            Vector3 n1;
-
-
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
deleted file mode 100644
index e3d3585..0000000
--- a/AWGL/Utilities/CustomVertexStruct.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.InteropServices;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct AWVertex
-    {
-        /// <summary>
-        /// Defines the size of the AWVertex struct in bytes.
-        /// </summary>
-        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
-        private Vector3[] vector31;
-        private Vector3[] vector32;
-        private int[] p;
-
-        public Vector3[] Postions { get; set; }
-
-        public Vector3[] Normals {get; set;}
-
-        public int[] Colors {get; set;}
-
-        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
-        {
-            Postions = positions;
-            Normals = nomarls;
-            Colors = colors;
-        }
-
-            
-    }
-}
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
deleted file mode 100644
index 759ed2a..0000000
--- a/AWGL/Utilities/Extensions.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public static class Extensions
-    {
-        // http://stackoverflow.com/a/1547282/1090268
-        public static T[] Concat<T>(this T[] x, T[] y)
-        {
-            if (x == null) throw new ArgumentNullException("x");
-            if (y == null) throw new ArgumentNullException("y");
-            int oldLen = x.Length;
-            Array.Resize<T>(ref x, x.Length + y.Length);
-            Array.Copy(y, 0, x, oldLen, y.Length);
-            return x;
-        }
-    }
-}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
deleted file mode 100644
index 6e15e05..0000000
--- a/AWGL/Utilities/Logger.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-
-namespace KAOS.Utilities
-{
-    /// <summary>
-    /// AWLogger
-    /// </summary>
-    internal static class Logger
-    {
-       
-        internal static void WriteLine(string output)
-        {
-            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
-        }
-
-        internal static void PlatformInfo()
-        {
-            WriteLine("Starting Logger. . .");
-            WriteLine("Getting Platform Information. . .");
-            WriteLine(GL.GetString(StringName.Vendor));
-            WriteLine(GL.GetString(StringName.Renderer));
-            WriteLine(GL.GetString(StringName.Version));
-            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
-        }
-
-        internal static void ShaderInfo(int shaderHandle)
-        {
-            String infoLog;
-            GL.GetShaderInfoLog(shaderHandle, out infoLog);
-            WriteLine(infoLog);
-        }
-
-        internal static void ProgramInfo(int programHandle)
-        {
-            String infoLog;
-            GL.GetProgramInfoLog(programHandle, out infoLog);
-            WriteLine(infoLog);
-            ShadersAttached(programHandle);
-        }
-
-        internal static void ShadersAttached(int programHandle)
-        {
-            int attachedShaders;
-            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
-            WriteLine(attachedShaders + temp + " Attached");
-        }
-    }
-
-}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
deleted file mode 100644
index 903fe15..0000000
--- a/AWGL/Utilities/Renderer.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-﻿using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.Utilities
-{
-    public static class Renderer
-    {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
-
-        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
-        {
-            GL.Color4(color);
-            GL.TexCoord2(uvs);
-            GL.Vertex3(position);
-        }
-
-        public static void DrawSprite(Sprite sprite)
-        {
-            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(PrimitiveType.Triangles);
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                DrawImmediateModeVertex(
-                    sprite.VertexPositions[i],
-                    sprite.VertexColours[i],
-                    sprite.VertexUVs[i]);
-            }
-            GL.End();
-        }
-
-        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
-        {
-            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
-            GL.UseProgram(ShaderManager.Get("Skybox").ID);
-            GL.ActiveTexture(TextureUnit.Texture0);
-            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
-
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
-
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        public static void DrawWireframeVoxel(float length, float height, float width)
-        {
-            
-        }
-
-        public static void DrawChunk(Chunk chunk)
-        {
-
-        }
-
-        internal static void ToggleWireframeOn()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-        }
-
-        internal static void ToggleWireframeOff()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
deleted file mode 100644
index 2b5cda0..0000000
--- a/AWGL/Utilities/Shader.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public struct Shader
-    {
-        public int ID { get; set; }
-
-        public Shader(int id)
-            : this()
-        {
-            ID = id;
-        }
-    }
-}
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
deleted file mode 100644
index 8ce0c32..0000000
--- a/AWGL/Utilities/Sprite.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class Sprite
-    {
-        internal const int VertexAmount = 6;
-        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
-        Color4[] vertexColours = new Color4[VertexAmount];
-        Vector2[] vertexUVs = new Vector2[VertexAmount];
-        Texture texture = new Texture();
-
-        public Texture Texture
-        {
-            get { return texture; }
-            set
-            {
-                texture = value;
-
-                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
-            }
-        }
-        public Vector3d[] VertexPositions { get { return vertexPositions; } }
-
-        public Color4[] VertexColours { get { return vertexColours; } }
-
-        public Vector2[] VertexUVs { get { return vertexUVs; } }
-
-        public Sprite()
-        {
-            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            //SetColour(new Color4(1, 1, 1, 1));
-            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
-        }
-
-        private Vector3d GetCentre()
-        {
-            double halfWidth = GetWidth() / 2;
-            double halfHeight = GetHeight() / 2;
-
-            return new Vector3d(
-                vertexPositions[0].X + halfWidth,
-                vertexPositions[0].Y - halfHeight,
-                vertexPositions[0].Z);
-        }
-
-        private void InitVertexPositions(Vector3d position, double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-
-            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-
-            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-        }
-
-        public double GetWidth()
-        {
-            //top right -> top left
-            return vertexPositions[1].X - vertexPositions[0].X;
-        }
-
-        public double GetHeight()
-        {
-            //top left -> bottom left
-            return vertexPositions[0].Y - vertexPositions[2].Y;
-        }
-
-        public void SetWidth(double width)
-        {
-            InitVertexPositions(GetCentre(), width, GetHeight());
-        }
-
-        public void SetHeight(double height)
-        {
-            InitVertexPositions(GetCentre(), GetWidth(), height);
-        }
-
-        public void SetPosition(double x, double y)
-        {
-            SetPosition(new Vector3d(x, y, 0));
-        }
-
-        public void SetPosition(Vector3d position)
-        {
-            InitVertexPositions(position, GetWidth(), GetHeight());
-        }
-
-        public void SetColour(Color4 color4)
-        {
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                vertexColours[i] = color4;
-            }
-        }
-
-        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
-        {
-            vertexUVs[0] = topLeft;
-            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
-
-            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[4] = bottomRight;
-            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
deleted file mode 100644
index fffdeb7..0000000
--- a/AWGL/Utilities/Texture.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct Texture
-    {
-        public int ID { get; set; }
-        public int Width { get; set; }
-        public int Height { get; set; }
-
-        public Texture(int id, int width, int height) :this()
-        {
-            ID = id;
-            Width = width;
-            Height = Height;
-        }
-    }
-}
diff --git a/KAOS/Data/Shaders/CH02_FS.glsl b/KAOS/Data/Shaders/CH02_FS.glsl
new file mode 100644
index 0000000..dff573e
--- /dev/null
+++ b/KAOS/Data/Shaders/CH02_FS.glsl
@@ -0,0 +1,8 @@
+#version 140 core
+
+out vec4 color;
+
+void main(void)
+{
+	color = vec4(0.0, 0.8, 0.0, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CH02_VS.glsl b/KAOS/Data/Shaders/CH02_VS.glsl
new file mode 100644
index 0000000..6a17ae4
--- /dev/null
+++ b/KAOS/Data/Shaders/CH02_VS.glsl
@@ -0,0 +1,12 @@
+﻿#version 140 core
+
+void main(void)
+{
+	const vec4 vertices[3] = vec4[3](
+		vec4(0.25, -0.25, 0.5, 1.0),
+		vec4(-0.25, 0.25, 0.5, 1.0),
+		vec4(0.25, 0.25, 0.5, 1.0)
+		);
+	// Index into our array using gl_VertexID
+	gl_Position = vertices[gl_VertexID];
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_FS.glsl b/KAOS/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/KAOS/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_VS.glsl b/KAOS/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/KAOS/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/FS.glsl b/KAOS/Data/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/KAOS/Data/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_VS.glsl b/KAOS/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_FS.glsl b/KAOS/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/KAOS/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_VS.glsl b/KAOS/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/KAOS/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_FS.glsl b/KAOS/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/KAOS/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_VS.glsl b/KAOS/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/KAOS/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_FS.glsl b/KAOS/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/KAOS/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_VS.glsl b/KAOS/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/KAOS/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/VS.glsl b/KAOS/Data/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/KAOS/Data/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-fs.glsl b/KAOS/Data/Shaders/opentk-fs.glsl
new file mode 100644
index 0000000..f890462
--- /dev/null
+++ b/KAOS/Data/Shaders/opentk-fs.glsl
@@ -0,0 +1,17 @@
+#version 410 core
+
+precision highp float;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
+in vec3 normal;
+
+out vec4 out_frag_color;
+
+void main(void)
+{
+  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
+  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-vs.glsl b/KAOS/Data/Shaders/opentk-vs.glsl
new file mode 100644
index 0000000..1cd8777
--- /dev/null
+++ b/KAOS/Data/Shaders/opentk-vs.glsl
@@ -0,0 +1,26 @@
+#version 410 core
+
+precision highp float;
+
+// object space to camera space transformation
+uniform mat4 modelview_matrix;
+ 
+// camera space to clip coordinates
+uniform mat4 projection_matrix;
+ 
+// incoming vertex position
+in vec3 in_position;
+ 
+// incoming vertex normal
+in vec3 in_normal;
+ 
+// transformed vertex normal
+out vec3 normal;
+
+void main(void)
+{
+  //works only for orthogonal modelview
+  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  
+  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
new file mode 100644
index 0000000..b9c351c
--- /dev/null
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -0,0 +1,29 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
+in VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} fs_in;
+
+out vec4 color;
+
+void main(void)
+{
+    // Reflect view vector about the plane defined by the normal
+    // at the fragment
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+
+    // Sample from scaled using reflection vector
+     color = texture(tex_cubemap, r);
+
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
+}
diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
new file mode 100644
index 0000000..4f89dba
--- /dev/null
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -0,0 +1,23 @@
+#version 410 core
+
+uniform mat4 mv_matrix;
+uniform mat4 proj_matrix;
+
+layout (location = 0) in vec4 in_position;
+layout (location = 1) in vec3 in_normal;
+
+out VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} vs_out;
+
+void main(void)
+{
+    vec4 pos_vs = mv_matrix * in_position;
+
+    vs_out.normal = mat3(mv_matrix) * in_normal;
+    vs_out.view = pos_vs.xyz;
+
+    gl_Position = proj_matrix * pos_vs;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/skybox-fs.glsl b/KAOS/Data/Shaders/skybox-fs.glsl
new file mode 100644
index 0000000..f996bf4
--- /dev/null
+++ b/KAOS/Data/Shaders/skybox-fs.glsl
@@ -0,0 +1,15 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+	vec3 tc;
+}fs_in;
+
+layout(location = 0) out vec4 color;
+
+void main(void)
+{
+	color = texture(tex_cubemap, fs_in.tc);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
new file mode 100644
index 0000000..c433716
--- /dev/null
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -0,0 +1,16 @@
+﻿#version 410 core
+ 
+ out VS_OUT
+ {
+	vec3 tc;
+ }vs_out;
+
+uniform mat4 view_matrix;
+
+in lowp vec3 in_position;
+
+ void main(void)
+ {
+	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	gl_Position = vec4(in_position.xyz, 1.0);
+ }
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-fs.glsl b/KAOS/Data/Shaders/spincube-fs.glsl
new file mode 100644
index 0000000..a8d60b9
--- /dev/null
+++ b/KAOS/Data/Shaders/spincube-fs.glsl
@@ -0,0 +1,13 @@
+#version 330 core                                                  
+                                                                               
+out vec4 color;                                                    
+                                                                               
+in VS_OUT                                                          
+{                                                                  
+    vec4 color;                                                    
+} fs_in;                                                           
+                                                                               
+void main(void)                                                    
+{                                                                  
+    color = fs_in.color;                                           
+}    
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-vs.glsl b/KAOS/Data/Shaders/spincube-vs.glsl
new file mode 100644
index 0000000..9de1ae1
--- /dev/null
+++ b/KAOS/Data/Shaders/spincube-vs.glsl
@@ -0,0 +1,17 @@
+#version 330 core                                                   
+                                                                                
+in vec4 position;                                                   
+                                                                                
+out VS_OUT                                                          
+{                                                                   
+    vec4 color;                                                     
+} vs_out;                                                           
+                                                                                
+uniform mat4 mv_matrix;                                             
+uniform mat4 proj_matrix;                                           
+                                                                                
+void main(void)                                                     
+{                                                                   
+    gl_Position = proj_matrix * mv_matrix * position;               
+    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
+}   
\ No newline at end of file
diff --git a/KAOS/Interfaces/IGameObject.cs b/KAOS/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..b2da157
--- /dev/null
+++ b/KAOS/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace KAOS.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
new file mode 100644
index 0000000..8751f33
--- /dev/null
+++ b/KAOS/KAOSWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Managers;
+using KAOS.Nodes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
new file mode 100644
index 0000000..5ad5904
--- /dev/null
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -0,0 +1,90 @@
+﻿using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    public class BufferObjectManager
+    {
+        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
+
+        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        {
+            int bufferHandle;
+
+            #region Get sizes of buffer stores
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
+            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
+            IntPtr noOffset = new IntPtr(0);
+            #endregion
+
+            // Generate Vertex Buffer Object and bind it so it is current.
+            GL.GenBuffers(1, out bufferHandle);         
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
+
+            #region Save pointers generated by OpenGL here so i dont forget.
+            bufferObject.VboID = bufferHandle; 
+            #endregion
+            
+            #region Send all data to the Vertex Buffer
+            // Initialise storage space for the Vertex Buffer.
+            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
+            // Send Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            // Send Normals data, offset by size of Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            
+            GL.GenBuffers(1, out bufferHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, 
+                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
+                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+
+            bufferObject.IboID = bufferHandle;
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+            #endregion
+
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            // Generate Vertex Array Object and bind it so it is current.
+            GL.GenVertexArrays(1, out bufferHandle);
+            GL.BindVertexArray(bufferHandle);
+
+            bufferObject.VaoID = bufferHandle;
+
+            bufferHandle = GL.GetAttribLocation(program, "in_position");
+            GL.EnableVertexAttribArray(bufferHandle); 
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(program, bufferHandle, "in_position");
+
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            GL.EnableVertexAttribArray(bufferHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.BindAttribLocation(program, bufferHandle, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+
+            GL.BindVertexArray(bufferObject.VaoID);
+
+            m_bufferStore.Add(name, bufferObject);
+        }
+
+        public BufferObject GetBuffer(string name)
+        {
+            return m_bufferStore[name];
+        }
+    }
+}
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
new file mode 100644
index 0000000..83ddedd
--- /dev/null
+++ b/KAOS/Managers/InputManager.cs
@@ -0,0 +1,12 @@
+﻿using OpenTK.Input;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    public static class InputManager
+    {
+        public static List<Key> keyList = new List<Key>();
+
+
+    }
+}
diff --git a/KAOS/Managers/ModelManager.cs b/KAOS/Managers/ModelManager.cs
new file mode 100644
index 0000000..c118589
--- /dev/null
+++ b/KAOS/Managers/ModelManager.cs
@@ -0,0 +1,7 @@
+﻿
+namespace KAOS.Managers
+{
+    class ModelManager
+    {
+    }
+}
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
new file mode 100644
index 0000000..ab00068
--- /dev/null
+++ b/KAOS/Managers/ShaderManager.cs
@@ -0,0 +1,139 @@
+﻿using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System.Collections.Generic;
+using System.IO;
+
+namespace KAOS.Managers
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    public static class ShaderManager
+    {
+        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+
+        // Handles
+        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+
+        private static string defaultDataPath = "Data/Shaders/";
+        private static string m_vertexShaderFile = "opentk-vs";
+        private static string m_fragmentShaderFile = "opentk-fs";
+
+        internal static void LoadDefaultShaderProgram()
+        {
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("default", new Shader(m_programHandle));
+        }
+
+        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
+        {
+            m_vertexShaderFile = vertexShaderPath;
+            m_fragmentShaderFile = fragmentShaderPath;
+            m_programHandle = BuildProgram();
+
+            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
+        }
+
+        public static Shader DefaultShader
+        {
+            get
+            {
+                return m_shaderStorage["default"];
+            }
+        }
+
+        public static Shader Get(string shaderID)
+        {
+            return m_shaderStorage[shaderID];
+        }
+
+        #region Shader and Program Contruction Methods
+        internal static string LoadShader(string shaderSourcePath)
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+
+        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            Logger.ShaderInfo(shaderHandle);
+
+            return shaderHandle;
+        }
+
+        internal static int BuildProgram()
+        {
+            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
+
+            int programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
+            int[] temp = new int[1];
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
+            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            #endregion
+
+            #region Validate Program
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
+            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            //if (validateSuccess == 0)
+            //{
+            //    String message;
+            //    GL.GetProgramInfoLog(programHandle, out message);
+            //    Logger.WriteLine("Program validation failed" + message);
+            //}
+            #endregion
+
+            #region Registered Attributes
+            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
+            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
+
+            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
+            #endregion
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
+        }
+        #endregion
+
+        #region Public Methods
+
+        //public void SetUniforms(
+        //    out int projMatrixHandle, out int mvMatrixHandle,
+        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
+        //    Size dimensions, ref Camera camera)
+        //{
+        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+
+        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+
+        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        //} 
+        #endregion
+
+    }
+}
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
new file mode 100644
index 0000000..8a00128
--- /dev/null
+++ b/KAOS/Managers/StateManager.cs
@@ -0,0 +1,43 @@
+﻿using KAOS.Interfaces;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace KAOS.Managers
+{
+    public class StateManager
+    {
+        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        IGameObject currentState = null;
+
+        public void Update(float elapsedTime)
+        {
+            if (currentState == null)
+                return;
+            currentState.Update(elapsedTime);
+        }
+
+        public void Render()
+        {
+            if (currentState == null)
+                return;
+            currentState.Render();
+        }
+
+        public void AddState(string stateName, IGameObject state)
+        {
+            Debug.Assert( Exists(stateName) == false );
+            stateStore.Add(stateName, state);
+        }
+
+        public void ChangeState(string stateName)
+        {
+            Debug.Assert( Exists(stateName) );
+            currentState = stateStore[stateName];
+        }
+
+        public bool Exists(string stateName)
+        {
+            return stateStore.ContainsKey(stateName);
+        }
+    }
+}
diff --git a/KAOS/Managers/Tests/StateManagerTest.cs b/KAOS/Managers/Tests/StateManagerTest.cs
new file mode 100644
index 0000000..fc92063
--- /dev/null
+++ b/KAOS/Managers/Tests/StateManagerTest.cs
@@ -0,0 +1,19 @@
+﻿
+using KAOS.States;
+using NUnit.Framework;
+
+namespace KAOS.Managers.Tests
+{
+    [TestFixture]
+    public class StateManagerTest
+    {
+        [Test]
+        public void TestAddStateExists()
+        {
+            StateManager stateManager = new StateManager();
+            stateManager.AddState("test-state", new SplashScreenState(stateManager));
+
+            Assert.IsTrue(stateManager.Exists("test-state"));
+        }
+    }
+}
diff --git a/KAOS/Managers/Tests/TextureManagerTest.cs b/KAOS/Managers/Tests/TextureManagerTest.cs
new file mode 100644
index 0000000..007e120
--- /dev/null
+++ b/KAOS/Managers/Tests/TextureManagerTest.cs
@@ -0,0 +1,20 @@
+﻿
+using NUnit.Framework;
+
+namespace KAOS.Managers.Tests
+{
+    [TestFixture]
+    public class TextureManagerTest
+    {
+        [Test]
+        public void TestLoadTexture()
+        {
+            //string textureid = "test-texture";
+            //Texture t = new Texture();
+            //TextureManager manager = new TextureManager();
+            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
+
+            Assert.IsTrue(true);
+        }
+    }
+}
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
new file mode 100644
index 0000000..0970750
--- /dev/null
+++ b/KAOS/Managers/TextureManager.cs
@@ -0,0 +1,102 @@
+﻿using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace KAOS.Managers
+{
+    public class TextureManager : IDisposable
+    {
+        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+
+        public Texture Get(string textureId)
+        {
+            return m_textureDatabase[textureId];
+        }
+
+        private int textureGpuHandle;
+        private Bitmap bitmap;
+        private BitmapData bitmapData;
+
+        public void LoadTexture(string textureId, string path)
+        {
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
+
+            OpenImageFile(path);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 
+                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+            CloseImageFile();
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        public void LoadSkyTexture(string textureId, string[] path)
+        {
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
+
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+
+            for (int face = 0; face < 6; face++)
+            {
+                OpenImageFile(path[face]);
+                bitmap.Save(face + ".bmp");
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
+                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+                GL.Finish();
+                CloseImageFile();
+            }
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        private void OpenImageFile(string path)
+        {
+            bitmap = new Bitmap(path);
+
+            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+        }
+
+        private void CloseImageFile()
+        {
+            bitmap.UnlockBits(bitmapData);
+
+            CleanUp();
+        }
+
+        private void CleanUp()
+        {
+            bitmap.Dispose();
+        }
+
+
+        public void Dispose()
+        {
+            foreach (Texture t in m_textureDatabase.Values)
+            {
+                GL.DeleteTextures(1, new int[] { t.ID });
+            }
+            bitmap.Dispose();
+        }
+    }
+}
diff --git a/KAOS/Nodes/AWCube.cs b/KAOS/Nodes/AWCube.cs
new file mode 100644
index 0000000..58875a5
--- /dev/null
+++ b/KAOS/Nodes/AWCube.cs
@@ -0,0 +1,69 @@
+﻿using KAOS.Shapes;
+using KAOS.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    /// <summary>
+    /// Cube Node
+    /// </summary>
+    public class AWCube : AWNode, ISceneNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public Vector3[] Vertices
+        {
+            get { return CubeVertices; }
+        }
+
+        public int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/AWGraphLines.cs b/KAOS/Nodes/AWGraphLines.cs
new file mode 100644
index 0000000..1e65c18
--- /dev/null
+++ b/KAOS/Nodes/AWGraphLines.cs
@@ -0,0 +1,58 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWGraphLines : AWNode, ISceneNode
+    {
+        private int m_gridSize = 20;
+
+        public Vector3[] Vertices
+        {
+            get { return m_vertices; }
+        }
+
+        private static Vector3[] m_vertices;
+
+        public AWGraphLines(int gridSize)
+        {
+            m_gridSize = gridSize;
+            m_vertices = new Vector3[m_gridSize * 2];
+            BuildVertices();
+        }
+
+        private void BuildVertices()
+        {
+            for (int i = 0; i < m_gridSize *2; i += 4)
+            {
+                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
+                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
+                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
+                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
+            }
+        }
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/AWGroupNode.cs b/KAOS/Nodes/AWGroupNode.cs
new file mode 100644
index 0000000..0fb12d0
--- /dev/null
+++ b/KAOS/Nodes/AWGroupNode.cs
@@ -0,0 +1,99 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+
+        public OpenTK.Vector3[] Vertices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
+    } 
+}
diff --git a/KAOS/Nodes/AWMesh.cs b/KAOS/Nodes/AWMesh.cs
new file mode 100644
index 0000000..d5f77a0
--- /dev/null
+++ b/KAOS/Nodes/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Nodes/AWNode.cs b/KAOS/Nodes/AWNode.cs
new file mode 100644
index 0000000..d0dddca
--- /dev/null
+++ b/KAOS/Nodes/AWNode.cs
@@ -0,0 +1,22 @@
+﻿using KAOS.Managers;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public abstract class AWNode
+    {
+        protected BufferObjectManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
+        public abstract void Render();
+    }
+
+}
diff --git a/KAOS/Nodes/AWParticles.cs b/KAOS/Nodes/AWParticles.cs
new file mode 100644
index 0000000..44911f9
--- /dev/null
+++ b/KAOS/Nodes/AWParticles.cs
@@ -0,0 +1,121 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWParticles : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+}
+/*
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
+        */
\ No newline at end of file
diff --git a/KAOS/Nodes/AWPolygon.cs b/KAOS/Nodes/AWPolygon.cs
new file mode 100644
index 0000000..85afb1d
--- /dev/null
+++ b/KAOS/Nodes/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/IGroupNode.cs b/KAOS/Nodes/IGroupNode.cs
new file mode 100644
index 0000000..888793f
--- /dev/null
+++ b/KAOS/Nodes/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Nodes
+{
+    public interface IGroupNode : IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Nodes/ISceneNode.cs b/KAOS/Nodes/ISceneNode.cs
new file mode 100644
index 0000000..0924346
--- /dev/null
+++ b/KAOS/Nodes/ISceneNode.cs
@@ -0,0 +1,13 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Nodes
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
new file mode 100644
index 0000000..9623e06
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("AWGL")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("AWGL")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/KAOS/Scene/FBOScene.cs b/KAOS/Scene/FBOScene.cs
new file mode 100644
index 0000000..ee33056
--- /dev/null
+++ b/KAOS/Scene/FBOScene.cs
@@ -0,0 +1,246 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    public class FBOScene : DefaultScene
+    {
+        #region Private Member Variables
+        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
+
+        private uint ColorTexture;
+        private uint DepthTexture;
+        private uint FBOHandle;
+
+        private const int TextureSize = 512;
+
+        private DrawableShape Object;
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+
+        public override void Setup(EventArgs e)
+        {
+            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
+            {
+                throw new NotSupportedException(
+                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
+                Exit();
+            }
+
+            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearDepth(1.0);
+            GL.DepthFunc(DepthFunction.Lequal);
+
+            GL.Enable(EnableCap.CullFace);
+
+            // Create Color Tex
+            GL.GenTextures(1, out ColorTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create Depth Tex
+            GL.GenTextures(1, out DepthTexture);
+            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
+            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create a FBO and attach the textures
+            GL.Ext.GenFramebuffers(1, out FBOHandle);
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
+
+            #region Test for Error
+
+            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
+            {
+                case FramebufferErrorCode.FramebufferCompleteExt:
+                    {
+                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: There are no attachments.");
+                        break;
+                    }
+                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
+                     {
+                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
+                         break;
+                     }*/
+                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
+                    {
+                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
+                    {
+                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
+                    {
+                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
+                    {
+                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferUnsupportedExt:
+                    {
+                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
+                        break;
+                    }
+                default:
+                    {
+                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
+                        break;
+                    }
+            }
+
+            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
+            int[] queryinfo = new int[6];
+            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
+            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
+            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
+            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
+            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
+            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
+            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
+                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
+
+            Console.WriteLine("Last GL Error: " + GL.GetError());
+
+            #endregion Test for Error
+
+            GL.PushAttrib(AttribMask.ViewportBit);
+            {
+                GL.Viewport(0, 0, TextureSize, TextureSize);
+
+                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
+                GL.ClearColor(1f, 0f, 0f, 0f);
+                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
+                GL.MatrixMode(MatrixMode.Projection);
+                GL.LoadMatrix(ref perspective);
+
+                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
+                GL.MatrixMode(MatrixMode.Modelview);
+                GL.LoadMatrix(ref lookat);
+
+                // draw some complex object into the FBO's textures
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.Light0);
+                GL.Enable(EnableCap.ColorMaterial);
+                GL.Color3(0f, 1f, 0f);
+                Object.Draw();
+                GL.Disable(EnableCap.ColorMaterial);
+                GL.Disable(EnableCap.Light0);
+                GL.Disable(EnableCap.Lighting);
+
+            }
+            GL.PopAttrib();
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
+
+            GL.ClearColor(.1f, .2f, .3f, 0f);
+            GL.Color3(1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
+            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            double aspect_ratio = Width / (double)Height;
+
+            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+        }
+    }
+}
diff --git a/KAOS/Scene/PickerScene.cs b/KAOS/Scene/PickerScene.cs
new file mode 100644
index 0000000..3aca921
--- /dev/null
+++ b/KAOS/Scene/PickerScene.cs
@@ -0,0 +1,204 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Diagnostics;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
+    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
+    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
+    /// </summary>
+    public class PickerScene : DefaultScene
+    {
+        public PickerScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Member variable
+        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
+        private float angle;
+        private BeginMode VBO_PrimMode;
+        private Vertex[] VBO_Array;
+        uint VBO_Handle;
+
+        private uint SelectedTriangle;
+
+        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
+        #endregion
+
+        #region OnLoad
+        /// <summary>Load resources here.</summary>
+        /// <param name="e">Not used.</param>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.CullFace);
+
+            #region prepare data for VBO from procedural object
+            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
+            VertexT2fN3fV3f[] temp_VBO;
+            uint[] temp_IBO;
+            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
+            temp_obj.Dispose();
+            if (temp_IBO != null)
+                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
+
+            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
+            VBO_Array = new Vertex[temp_VBO.Length];
+            int TriangleCounter = -1;
+            for (int i = 0; i < temp_VBO.Length; i++)
+            {
+                // Position
+                VBO_Array[i].Position = temp_VBO[i].Position;
+
+                // Index
+                if (i % 3 == 0)
+                    TriangleCounter++;
+                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
+            }
+            #endregion prepare data for VBO from procedural object
+
+            #region Setup VBO for drawing
+            GL.GenBuffers(1, out VBO_Handle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
+            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
+            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
+            #endregion Setup VBO for drawing
+
+            #region Shader
+
+            //create and compile shaders
+            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
+
+            //create program object, attach shaders and link
+            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
+
+            // flag ShaderObjects for delete when not used anymore
+            GL.DeleteShader(VertexShaderObject);
+            GL.DeleteShader(FragmentShaderObject);
+
+            GL.UseProgram(0);
+
+            #endregion Shader
+
+        }
+        #endregion
+
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DeleteBuffers(1, ref VBO_Handle);
+
+            base.OnUnload(e);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Called when your window is resized. Set your viewport here. It is also
+        /// a good place to set up your projection matrix (which probably changes
+        /// along when the aspect ratio of your window).
+        /// </summary>
+        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref projection);
+        }
+        #endregion
+
+        #region OnRenderFrame
+        /// <summary>
+        /// Called when it is time to render the next frame. Add your rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Color3(Color.White);
+            GL.EnableClientState(EnableCap.ColorArray);
+
+            #region Pass 1: Draw Object and pick Triangle
+            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref modelview);
+            GL.Translate(0f, 0f, -3f);
+            GL.Rotate(angle, Vector3.UnitX);
+            GL.Rotate(angle, Vector3.UnitY);
+            angle += (float)e.Time * 3.0f;
+
+            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
+             GL.UseProgram(ProgramObject);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            // GL.UseProgram(0);
+
+            // Read Pixel under mouse cursor
+            Byte4 Pixel = new Byte4();
+            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
+            SelectedTriangle = Pixel.ToUInt32();
+            #endregion Pass 1: Draw Object and pick Triangle
+
+            GL.Color3(Color.White);
+            GL.DisableClientState(EnableCap.ColorArray);
+
+            #region Pass 2: Draw Shape
+            if (SelectedTriangle == uint.MaxValue)
+                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
+            else
+                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.Color3(1f, 1f, 1f);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+            GL.Color3(Color.Red);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+
+            if (SelectedTriangle != uint.MaxValue)
+            {
+                GL.Disable(EnableCap.DepthTest);
+                GL.Color3(Color.Green);
+                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
+                GL.Enable(EnableCap.DepthTest);
+            }
+            #endregion Pass 2: Draw Shape
+
+            this.SwapBuffers();
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Error at Swapbuffers: " + err);
+        }
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Scene/StencilCSGScene.cs b/KAOS/Scene/StencilCSGScene.cs
new file mode 100644
index 0000000..8acb843
--- /dev/null
+++ b/KAOS/Scene/StencilCSGScene.cs
@@ -0,0 +1,293 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class StencilCSGScene : DefaultScene
+    {
+        #region Model Related
+        private DrawableShape OperandB;
+        private DrawableShape OperandA;
+        private float MySphereZOffset = 0f;
+        private float MySphereXOffset = 0f;
+
+        private int Texture;
+        #endregion Model Related
+
+        private bool ShowDebugWireFrame = true;
+
+        private float CameraZoom;
+        private float CameraRotX;
+        private float CameraRotY;
+        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
+
+        #region Window
+        public StencilCSGScene()
+        {
+            base.VSync = VSyncMode.Off;
+            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
+            {
+                switch (e.Key)
+                {
+                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
+                }
+            };
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
+            GL.LoadMatrix(ref p);
+        }
+        #endregion Window
+
+        public override void Setup(EventArgs e)
+        {
+            #region Abort on platforms which will not be able to execute the ops properly
+            /*
+            if (!GL.SupportsExtension("VERSION_1_2"))
+            {
+                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
+                this.Exit();
+            }
+
+            int[] t = new int[2];
+            GL.GetInteger(GetPName.MajorVersion, out t[0]);
+            GL.GetInteger(GetPName.MinorVersion, out t[1]);
+            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
+
+            GL.GetInteger(GetPName.DepthBits, out t[0]);
+            Trace.WriteLine("Depth Bits: " + t[0]);
+            GL.GetInteger(GetPName.StencilBits, out t[1]);
+            Trace.WriteLine("Stencil Bits: " + t[1]);
+
+            if (t[0] < 16)
+            {
+                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
+                this.Exit();
+            }
+
+            if (t[1] < 1)
+            {
+                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
+                this.Exit();
+            }
+            */
+            #endregion Abort on platforms which will not be able to execute the ops properly
+
+            #region GL States
+            GL.ClearColor(.08f, .12f, .16f, 1f);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Less);
+            GL.ClearDepth(1.0);
+
+            GL.Enable(EnableCap.StencilTest);
+            GL.ClearStencil(0);
+            GL.StencilMask(0xFFFFFFFF); // read&write
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+            GL.CullFace(CullFaceMode.Back);
+
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+
+            GL.Color4(1f, 1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.ShadeModel(ShadingModel.Smooth);
+
+            #endregion GL States
+
+            #region Load Texture
+            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
+            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
+
+            GL.GenTextures(1, out Texture);
+            GL.BindTexture(TextureTarget.Texture2D, Texture);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.Finish();
+            bitmap.UnlockBits(data);
+            #endregion Load Texture
+
+            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
+            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
+                                           SlicedSphere.eSubdivisions.Three,
+                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
+                                           true);
+
+            #region Invert Operand B's Normals
+            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
+            BeginMode tempPrimMode;
+            VertexT2dN3dV3d[] tempVertices;
+            uint[] tempIndices;
+
+            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
+            OperandB.Dispose();
+
+            for (int i = 0; i < tempVertices.Length; i++)
+            {
+                tempVertices[i].Normal *= -1.0;
+                tempVertices[i].Normal.Normalize();
+            }
+
+            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
+            #endregion Invert Operand B's Normals
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref Texture);
+
+            OperandA.Dispose();
+            OperandB.Dispose();
+
+            base.OnUnload(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Magic numbers for camera
+            CameraRotX = -Mouse.X * .5f;
+            CameraRotY = Mouse.Y * .5f;
+            CameraZoom = Mouse.Wheel * .2f;
+            #endregion Magic numbers for camera
+        }
+
+        public void DrawOperandB()
+        {
+            GL.PushMatrix();
+            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
+            OperandB.Draw();
+            GL.PopMatrix();
+        }
+
+        public void DrawOperandA()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            OperandA.Draw();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        public void RenderCsg()
+        {
+            // first pass
+            GL.Disable(EnableCap.StencilTest);
+
+            GL.ColorMask(false, false, false, false);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB();// draw front-faces into depth buffer
+
+            // use stencil plane to find parts of b in a 
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // increment the stencil where the front face of a is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
+            DrawOperandB(); // draw the part of b that's in a
+
+            // fix depth
+            GL.ColorMask(false, false, false, false);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Disable(EnableCap.StencilTest);
+            GL.DepthFunc(DepthFunction.Always);
+            DrawOperandA();
+            GL.DepthFunc(DepthFunction.Less);
+
+            // second pass
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA();
+
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            DrawOperandB(); // increment the stencil where the front face of b is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Equal, 0, 1);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // draw the part of a that's in b
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
+
+            MySphereZOffset += (float)(e.Time * 3.1);
+            MySphereXOffset += (float)(e.Time * 4.2);
+
+            #region Transform setup
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
+
+            // Camera
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+
+            GL.Translate(0f, 0f, CameraZoom);
+            GL.Rotate(CameraRotX, Vector3.UnitY);
+            GL.Rotate(CameraRotY, Vector3.UnitX);
+            #endregion Transform setup
+
+            RenderCsg();
+
+            // ---------------------------------
+
+            if (ShowDebugWireFrame)
+            {
+                GL.Color3(System.Drawing.Color.LightGray);
+                GL.Disable(EnableCap.StencilTest);
+                GL.Disable(EnableCap.Lighting);
+                //GL.Disable( EnableCap.DepthTest );
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+                DrawOperandB();
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+                GL.Enable(EnableCap.DepthTest);
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.StencilTest);
+            }
+            SwapBuffers();
+        }
+
+    }
+}
diff --git a/KAOS/Scene/StereoVisionScene.cs b/KAOS/Scene/StereoVisionScene.cs
new file mode 100644
index 0000000..2b84210
--- /dev/null
+++ b/KAOS/Scene/StereoVisionScene.cs
@@ -0,0 +1,164 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVisionScene : DefaultScene
+    {
+        public StereoVisionScene()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            Angle += (float)(e.Time * 20.0);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    
+    }
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}
diff --git a/KAOS/Scene/Texture2DScene.cs b/KAOS/Scene/Texture2DScene.cs
new file mode 100644
index 0000000..ec53ee7
--- /dev/null
+++ b/KAOS/Scene/Texture2DScene.cs
@@ -0,0 +1,86 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class Texture2DScene : DefaultScene
+    {
+        #region Private Members
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.Texture2D);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+        }
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref texture);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.Begin(BeginMode.Quads);
+
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            GL.End();
+
+            SwapBuffers();
+        }
+        #endregion
+
+    }
+}
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
new file mode 100644
index 0000000..0f9cd8a
--- /dev/null
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -0,0 +1,182 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.Shapes
+{
+    // Abstract base class for procedurally generated geometry
+    // 
+    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
+    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
+    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
+    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
+    // Can use a Display List to prevent repeated immediate mode draws.
+    //
+
+    public abstract class DrawableShape: IDisposable
+    {
+        protected BeginMode PrimitiveMode;
+        protected VertexT2dN3dV3d[] VertexArray;
+        protected uint[] IndexArray;
+
+        public int GetTriangleCount
+        {
+            get
+            {
+                switch ( PrimitiveMode )
+                { 
+                case BeginMode.Triangles:
+                    if ( IndexArray != null )
+                    {
+                        return IndexArray.Length / 3;
+                    } else
+                    {
+                        return VertexArray.Length / 3;
+                    }
+                  //  break;
+                default: throw new NotImplementedException("Unknown primitive type.");
+                }
+            }
+        }
+
+        #region Display List
+
+        private bool UseDisplayList;
+        private int DisplayListHandle = 0;
+
+        #endregion Display List
+
+        public DrawableShape( bool useDisplayList )
+        {
+            UseDisplayList = useDisplayList;
+            PrimitiveMode = BeginMode.Triangles;
+            VertexArray = null;
+            IndexArray = null;
+        }
+
+        #region Convert to VBO
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2dN3dV3d[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = VertexArray[i].TexCoord;
+                vertices[i].Normal = VertexArray[i].Normal;
+                vertices[i].Position = VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2fN3fV3f[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2hN3hV3h[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3h)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        #endregion Convert to VBO
+
+        private void DrawImmediateMode()
+        {
+            GL.Begin( PrimitiveMode );
+            {
+                if ( IndexArray == null )
+                    foreach ( VertexT2dN3dV3d v in VertexArray )
+                    {
+                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
+                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
+                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
+                    } else
+                {
+                    for ( uint i = 0; i < IndexArray.Length; i++ )
+                    {
+                        uint index = IndexArray[i];
+                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
+                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
+                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
+                    }
+                }
+            }
+            GL.End();
+        }
+
+        /// <summary>
+        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
+        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
+        /// </summary>
+        public void Draw()
+        {
+            if ( !UseDisplayList )
+                DrawImmediateMode();
+            else
+                if ( DisplayListHandle == 0 )
+                {
+                    if ( VertexArray == null )
+                        throw new Exception("Cannot draw null Vertex Array.");
+                    DisplayListHandle = GL.GenLists( 1 );
+                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
+                    DrawImmediateMode();
+                    GL.EndList();
+                } else
+                    GL.CallList( DisplayListHandle );
+        }
+
+        
+
+        #region IDisposable Members
+
+        /// <summary>
+        /// Removes reference to VertexArray and IndexArray.
+        /// Deletes the Display List, so it requires an OpenGL context.
+        /// The instance is effectively destroyed.
+        /// </summary>
+        public void Dispose()
+        {
+            if ( VertexArray != null )
+                VertexArray = null;
+            if ( IndexArray != null )
+                IndexArray = null;
+            if ( DisplayListHandle != 0 )
+            {
+                GL.DeleteLists( DisplayListHandle, 1 );
+                DisplayListHandle = 0;
+            }
+        }
+
+        #endregion
+    }
+
+}
diff --git a/KAOS/Shapes/Base/VertexStructs.cs b/KAOS/Shapes/Base/VertexStructs.cs
new file mode 100644
index 0000000..0f64155
--- /dev/null
+++ b/KAOS/Shapes/Base/VertexStructs.cs
@@ -0,0 +1,35 @@
+using OpenTK;
+using System.Runtime.InteropServices;
+
+namespace KAOS.Shapes
+{
+    public struct VertexT2dN3dV3d
+    {
+        public Vector2d TexCoord;
+        public Vector3d Normal;
+        public Vector3d Position;
+
+        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        {
+            TexCoord = texcoord;
+            Normal = normal;
+            Position = position;
+        }
+    }
+
+    public struct VertexT2fN3fV3f
+    {
+        public Vector2 TexCoord;
+        public Vector3 Normal;
+        public Vector3 Position;
+    }
+
+    public struct VertexT2hN3hV3h
+    {
+        public Vector2h TexCoord;
+        public Vector3h Normal;
+        public Vector3h Position;
+    }
+
+   
+}
diff --git a/KAOS/Shapes/Capsule.cs b/KAOS/Shapes/Capsule.cs
new file mode 100644
index 0000000..cd6f7e6
--- /dev/null
+++ b/KAOS/Shapes/Capsule.cs
@@ -0,0 +1,108 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class Capsule: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+        }
+
+
+        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            uint HoseSubDivs = 0;
+            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+                HoseSubDivs = 0;
+                break;
+            case eSubdivisions.One:
+                spheresubdivs = SlicedSphere.eSubdivisions.One;
+                HoseSubDivs = 1;
+                break;
+            case eSubdivisions.Two:
+                spheresubdivs = SlicedSphere.eSubdivisions.Two;
+                HoseSubDivs = 3;
+                break;
+            case eSubdivisions.Three:
+                spheresubdivs = SlicedSphere.eSubdivisions.Three;
+                HoseSubDivs = 7;
+                break;
+            case eSubdivisions.Four:
+                spheresubdivs = SlicedSphere.eSubdivisions.Four;
+                HoseSubDivs = 15;
+                break;
+            }
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
+                     offset2 = new Vector3d( 0.0, 0.0, -height );
+            for ( int i = 0; i < 4; i++ )
+            {
+                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
+                switch ( i )
+                {
+                case 0:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    break;
+                }
+                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+
+            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
+                                                       new SlicedSphere.eDir[] {
+                                                           SlicedSphere.eDir.BackBottomRight,
+                                                           SlicedSphere.eDir.FrontTopRight,
+                                                           SlicedSphere.eDir.BackTopRight,
+                                                           SlicedSphere.eDir.FrontBottomRight, 
+                                                          },
+                                                       false );
+
+            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            front.Dispose();
+
+            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
+                                                      new SlicedSphere.eDir[] { 
+                                                          SlicedSphere.eDir.FrontBottomLeft,
+                                                          SlicedSphere.eDir.FrontTopLeft, 
+                                                          SlicedSphere.eDir.BackTopLeft,
+                                                          SlicedSphere.eDir.BackBottomLeft },
+                                                      false );
+            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            back.Dispose();
+
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+        }
+    }
+}
diff --git a/KAOS/Shapes/ChamferCube.cs b/KAOS/Shapes/ChamferCube.cs
new file mode 100644
index 0000000..1c340a1
--- /dev/null
+++ b/KAOS/Shapes/ChamferCube.cs
@@ -0,0 +1,278 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class ChamferCube: DrawableShape
+    {
+
+        public enum SubDivs: byte
+        {
+            Zero,
+            One,
+            Two,
+            Three,
+            Four,
+        }
+
+        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
+            : base( useDL )
+        {   
+            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+            uint hoseSubDivs = 0;
+
+            switch ( subdivs )
+            {
+            case SubDivs.Zero:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+                hoseSubDivs = 0;
+                break;
+            case SubDivs.One:
+                sphereSubDivs = SlicedSphere.eSubdivisions.One;
+                hoseSubDivs = 1;
+                break;
+            case SubDivs.Two:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
+                hoseSubDivs = 3;
+                break;
+            case SubDivs.Three:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
+                hoseSubDivs = 7;
+                break;
+            case SubDivs.Four:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
+                hoseSubDivs = 15;
+                break;
+            }
+
+            #region Temporary Storage
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            #endregion Temporary Storage
+
+            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
+            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
+            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
+            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
+            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
+            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
+            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
+            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
+
+            #region 8 sliced Spheres
+            SlicedSphere tempSphere;
+            Vector3d tempVector = Vector3d.Zero;
+            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
+
+            for ( int i = 0; i < 8; i++ )
+            {
+                switch ( i )
+                {
+                case 0:
+                    tempVector = FrontTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
+                    break;
+                case 1:
+                    tempVector = FrontTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
+                    break;
+                case 2:
+                    tempVector = FrontBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
+                    break;
+                case 3:
+                    tempVector = FrontBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
+                    break;
+                case 4:
+                    tempVector = BackBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
+                    break;
+                case 5:
+                    tempVector = BackBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
+                    break;
+                case 6:
+                    tempVector = BackTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
+                    break;
+                case 7:
+                    tempVector = BackTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
+                    break;
+                }
+                tempSphere = new SlicedSphere( radius,
+                                                 tempVector,
+                                                 sphereSubDivs,
+                                                 tempEdge,
+                                                 false );
+                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempSphere.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 8 sliced Spheres
+
+            #region 12 sliced Hoses
+
+            SlicedHose tempHose;
+            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
+            Vector3d tempHoseStart = Vector3d.Zero;
+            Vector3d tempHoseEnd = Vector3d.Zero;
+
+            for ( int i = 0; i < 12; i++ )
+            {
+                switch ( i )
+                {
+                #region Around X Axis
+                case 0:
+                    tempSide = SlicedHose.eSide.BottomRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = FrontBottomRightEdge;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.TopRight;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.TopLeft;
+                    tempHoseStart = BackTopLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.BottomLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around X Axis
+                #region Around Y Axis
+                case 4:
+                    tempSide = SlicedHose.eSide.FrontRight;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 5:
+                    tempSide = SlicedHose.eSide.BackRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackTopRightEdge;
+                    break;
+                case 6:
+                    tempSide = SlicedHose.eSide.BackLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 7:
+                    tempSide = SlicedHose.eSide.FrontLeft;
+                    tempHoseStart = FrontBottomLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                #endregion Around Y Axis
+                #region Around Z Axis
+                case 8:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    tempHoseStart = FrontTopRightEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 9:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 10:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackBottomLeftEdge;
+                    break;
+                case 11:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around Z Axis
+                }
+                tempHose = new SlicedHose( tempSide,
+                                             hoseSubDivs,
+                                             radius,
+                                             tempHoseStart,
+                                             tempHoseEnd,
+                                             false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 12 sliced Hoses
+
+            #region 6 quads for the sides
+
+            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
+            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
+
+            // all quads use the same texcoords
+            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
+            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
+            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
+            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
+
+            // front face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
+            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // back face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
+            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // top face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // bottom face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
+            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // right face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // left face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
+            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+
+            #endregion 6 quads for the sides
+
+            #region Final Assembly of Chunks
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+            #endregion Final Assembly of Chunks
+        }
+    }
+}
diff --git a/KAOS/Shapes/Helpers/Chunk.cs b/KAOS/Shapes/Helpers/Chunk.cs
new file mode 100644
index 0000000..ebac329
--- /dev/null
+++ b/KAOS/Shapes/Helpers/Chunk.cs
@@ -0,0 +1,80 @@
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public class Chunk
+    {
+        public VertexT2dN3dV3d[] Vertices;
+        public uint[] Indices;
+
+        public uint VertexCount
+        {
+            get
+            {
+                return (uint)Vertices.Length;
+            }
+        }
+        public uint IndexCount
+        {
+            get
+            {
+                return (uint)Indices.Length;
+            }
+        }
+
+        public Chunk( uint vertexcount, uint indexcount )
+        {
+            Vertices = new VertexT2dN3dV3d[vertexcount];
+            Indices = new uint[indexcount];
+        }
+
+        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
+        {
+            Vertices = new VertexT2dN3dV3d[vbo.Length];
+            for ( int i = 0; i < Vertices.Length; i++ )
+            {
+                Vertices[i] = vbo[i];
+            } 
+            Indices = new uint[ibo.Length];
+            for ( int i = 0; i < Indices.Length; i++ )
+            {
+                Indices[i] = ibo[i];
+            }
+        }
+
+        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
+        {
+
+            uint VertexCounter = 0;
+            uint IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                VertexCounter += ch.VertexCount;
+                IndexCounter += ch.IndexCount;
+            }
+
+            vbo = new VertexT2dN3dV3d[VertexCounter];
+            ibo = new uint[IndexCounter];
+
+            VertexCounter = 0;
+            IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    vbo[VertexCounter + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
+                }
+
+                VertexCounter += (uint)ch.VertexCount;
+                IndexCounter += (uint)ch.IndexCount;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Helpers/MengerCube.cs b/KAOS/Shapes/Helpers/MengerCube.cs
new file mode 100644
index 0000000..2dc56fc
--- /dev/null
+++ b/KAOS/Shapes/Helpers/MengerCube.cs
@@ -0,0 +1,421 @@
+using OpenTK;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class MengerSponge
+    {
+        private struct MengerCube
+        {
+            private Vector3d Center;
+            private double SideLength;
+            private eSides[] VisibleSides;
+            private eSides[] VisibilityToInherit;
+
+            public void GetArraySizes( out uint vertexcount, out uint indexcount )
+            {
+                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
+                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
+            }
+
+            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
+            {
+                Center = center;
+                SideLength = sidelength;
+
+                /*  List<eSides> Sides = new List<eSides>();
+                  foreach ( eSides s in visibleSides )
+                  {
+                      bool isVisible = false;
+                      foreach ( eSides p in parentsVisibility )
+                      {
+                          if ( (int)p == (int)s )
+                          {
+                              isVisible = true;
+                              break;
+                          }
+                      }
+                      if ( isVisible )
+                      {
+                          Sides.Add( s );
+                      }
+                  }
+                  VisibleSides = Sides.ToArray();*/
+                VisibleSides = visibleSides;
+                VisibilityToInherit = visibleSides;
+            }
+
+            public void Subdivide( out MengerCube[] cubes )
+            {
+                cubes = new MengerCube[20]; // 8 + 4 + 8
+
+                double NewLength = this.SideLength / 3.0;
+                double six = this.SideLength * 2.0 / 3.0;
+                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
+
+                // front
+                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
+                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
+                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
+
+                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
+                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
+                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
+
+                // center
+                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                // back
+                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
+
+                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+
+                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
+                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
+
+            }
+
+            public enum eSides: byte
+            {
+                Front,
+                Back,
+                Right,
+                Left,
+                Top,
+                Bottom
+            }
+
+            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
+
+            public void GetVboAndIbo( ref List<Chunk> chunks )
+            {
+                foreach ( eSides s in AllSides )
+                {
+                    DrawSide( s, ref chunks );
+                }
+            }
+
+            private void DrawSide( eSides side, ref List<Chunk> chunks )
+            {
+                #region Setup constants for current direction
+
+                double _Zero = 0.0; // 0/3
+                double _Three = 0.3333333333333; // 1/3
+                double _Six = 0.66666666666666; // 2/3
+                double _One = 1.0; // 3/3 
+
+                double ThirdLength = SideLength / 3f;
+
+                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
+                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
+                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
+                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
+
+                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
+                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
+                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
+                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
+
+                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    P0 = C0;
+                    P1 = C1;
+                    P2 = C2;
+                    P3 = C3;
+
+                    P4 = C4;
+                    P5 = C5;
+                    P6 = C6;
+                    P7 = C7;
+                    break;
+                case eSides.Back:
+                    P0 = C5;
+                    P1 = C4;
+                    P2 = C7;
+                    P3 = C6;
+
+                    P4 = C1;
+                    P5 = C0;
+                    P6 = C3;
+                    P7 = C2;
+                    break;
+                case eSides.Right:
+                    P0 = C1;
+                    P1 = C5;
+                    P2 = C6;
+                    P3 = C2;
+
+                    P4 = C0;
+                    P5 = C4;
+                    P6 = C7;
+                    P7 = C3;
+                    break;
+                case eSides.Left:
+                    P0 = C4;
+                    P1 = C0;
+                    P2 = C3;
+                    P3 = C7;
+
+                    P4 = C5;
+                    P5 = C1;
+                    P6 = C2;
+                    P7 = C6;
+                    break;
+                case eSides.Top:
+                    P0 = C3;
+                    P1 = C2;
+                    P2 = C6;
+                    P3 = C7;
+
+                    P4 = C0;
+                    P5 = C1;
+                    P6 = C5;
+                    P7 = C4;
+                    break;
+                case eSides.Bottom:
+                    P0 = C1;
+                    P1 = C0;
+                    P2 = C4;
+                    P3 = C5;
+
+                    P4 = C2;
+                    P5 = C3;
+                    P6 = C7;
+                    P7 = C6;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+
+                #endregion Setup constants for current direction
+
+                #region Set Normal
+
+                Vector3d FaceNormal;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    FaceNormal = Vector3d.UnitZ;
+                    break;
+                case eSides.Back:
+                    FaceNormal = -Vector3d.UnitZ;
+                    break;
+                case eSides.Right:
+                    FaceNormal = Vector3d.UnitX;
+                    break;
+                case eSides.Left:
+                    FaceNormal = -Vector3d.UnitX;
+                    break;
+                case eSides.Top:
+                    FaceNormal = Vector3d.UnitY;
+                    break;
+                case eSides.Bottom:
+                    FaceNormal = -Vector3d.UnitY;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+                #endregion Set Normal
+
+                bool FaceIsVisible = false;
+                foreach ( eSides s in VisibleSides )
+                {
+                    if ( s == side )
+                    {
+                        FaceIsVisible = true;
+                        break;
+                    }
+                }
+
+                if ( FaceIsVisible )
+                {
+                    #region Define Layer1 Vertices
+                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
+
+                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
+                    Layer1.Vertices[0].Normal = FaceNormal;
+                    Layer1.Vertices[0].Position = P0;
+
+                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
+                    Layer1.Vertices[1].Normal = FaceNormal;
+                    Layer1.Vertices[1].Position = P1;
+
+                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
+                    Layer1.Vertices[2].Normal = FaceNormal;
+                    Layer1.Vertices[2].Position = P2;
+
+                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
+                    Layer1.Vertices[3].Normal = FaceNormal;
+                    Layer1.Vertices[3].Position = P3;
+
+                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
+                    Layer1.Vertices[4].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
+
+                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
+                    Layer1.Vertices[5].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
+
+                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
+                    Layer1.Vertices[6].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
+
+                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
+                    Layer1.Vertices[7].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
+                    #endregion Define Layer1 Vertices
+
+                    #region Define Layer1 Indices
+                    Layer1.Indices[0] = 0;
+                    Layer1.Indices[1] = 5;
+                    Layer1.Indices[2] = 4;
+
+                    Layer1.Indices[3] = 0;
+                    Layer1.Indices[4] = 1;
+                    Layer1.Indices[5] = 5;
+
+                    Layer1.Indices[6] = 5;
+                    Layer1.Indices[7] = 1;
+                    Layer1.Indices[8] = 2;
+
+                    Layer1.Indices[9] = 6;
+                    Layer1.Indices[10] = 5;
+                    Layer1.Indices[11] = 2;
+
+                    Layer1.Indices[12] = 7;
+                    Layer1.Indices[13] = 6;
+                    Layer1.Indices[14] = 2;
+
+                    Layer1.Indices[15] = 3;
+                    Layer1.Indices[16] = 7;
+                    Layer1.Indices[17] = 2;
+
+                    Layer1.Indices[18] = 0;
+                    Layer1.Indices[19] = 7;
+                    Layer1.Indices[20] = 3;
+
+                    Layer1.Indices[21] = 0;
+                    Layer1.Indices[22] = 4;
+                    Layer1.Indices[23] = 7;
+
+                    chunks.Add( Layer1 );
+                    #endregion Define Layer1 Indices
+                }
+
+                #region Define Layer2 Vertices
+                Chunk Layer2 = new Chunk( 12, 8 * 3 );
+
+                Vector3d T0, T1, T2, T3;
+                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
+                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
+                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
+                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
+
+                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
+                Layer2.Vertices[0].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
+
+                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
+                Layer2.Vertices[1].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
+
+                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
+                Layer2.Vertices[3].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
+
+                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
+                Layer2.Vertices[4].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
+
+                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
+                Layer2.Vertices[6].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
+
+                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
+                Layer2.Vertices[7].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
+
+                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
+                Layer2.Vertices[9].Normal = FaceNormal;
+                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
+
+                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
+                Layer2.Vertices[10].Normal = FaceNormal;
+                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
+
+                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
+                Layer2.Vertices[2].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
+
+                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
+                Layer2.Vertices[5].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
+
+                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
+                Layer2.Vertices[8].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
+
+                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
+                Layer2.Vertices[11].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
+                #endregion Define Layer2 Vertices
+
+                #region Define Layer2 Indices
+                Layer2.Indices[0] = 0;
+                Layer2.Indices[1] = 2;
+                Layer2.Indices[2] = 11;
+
+                Layer2.Indices[3] = 0;
+                Layer2.Indices[4] = 1;
+                Layer2.Indices[5] = 2;
+
+                Layer2.Indices[6] = 2;
+                Layer2.Indices[7] = 3;
+                Layer2.Indices[8] = 4;
+
+                Layer2.Indices[9] = 2;
+                Layer2.Indices[10] = 4;
+                Layer2.Indices[11] = 5;
+
+                Layer2.Indices[12] = 5;
+                Layer2.Indices[13] = 6;
+                Layer2.Indices[14] = 8;
+
+                Layer2.Indices[15] = 8;
+                Layer2.Indices[16] = 6;
+                Layer2.Indices[17] = 7;
+
+                Layer2.Indices[18] = 11;
+                Layer2.Indices[19] = 8;
+                Layer2.Indices[20] = 10;
+
+                Layer2.Indices[21] = 10;
+                Layer2.Indices[22] = 8;
+                Layer2.Indices[23] = 9;
+
+                chunks.Add( Layer2 );
+                #endregion Define Layer2 Indices
+            }
+        }
+    }
+
+   
+}
diff --git a/KAOS/Shapes/Helpers/TetrahedronFace.cs b/KAOS/Shapes/Helpers/TetrahedronFace.cs
new file mode 100644
index 0000000..5b4e4cc
--- /dev/null
+++ b/KAOS/Shapes/Helpers/TetrahedronFace.cs
@@ -0,0 +1,228 @@
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+
+    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
+    internal struct TetrahedronFace
+    {
+        private Vector3d APosition, BPosition, CPosition;
+        private Vector3d DPosition, Normal;
+        private Vector2d ATexCoord, BTexCoord, CTexCoord;
+
+        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
+                                   ref Vector3d bpos, ref Vector2d btc,
+                                   ref Vector3d cpos, ref Vector2d ctc,
+                                   ref Vector3d dpos,
+                                   ref Vector3d normal )
+        {
+            APosition = apos; ATexCoord = atc;
+            BPosition = bpos; BTexCoord = btc;
+            CPosition = cpos; CTexCoord = ctc;
+            DPosition = dpos;
+            Normal = normal;
+        }
+
+        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
+        /// <param name="first">1st output Triangle</param>
+        /// <param name="second">2nd output Triangle</param>
+        /// <param name="third">3rd output Triangle</param>
+        /// <param name="fourth">4th output Triangle</param>
+        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
+        {
+            Vector3d temp;
+
+            // find the 3 points AB, BC, CA 
+            Vector3d CenterAB;
+            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
+
+            Vector3d CenterBC;
+            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
+
+            Vector3d CenterCA;
+            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
+
+            // find the 3 points AD, BD, CD 
+            Vector3d CenterAD;
+            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
+
+            Vector3d CenterBD;
+            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
+
+            Vector3d CenterCD;
+            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
+
+            // emit 4 new CCW triangles
+            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
+                              ref CenterAB, ref this.BTexCoord,
+                              ref CenterCA, ref this.CTexCoord,
+                              ref CenterAD,
+                              ref this.Normal );
+
+            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
+                               ref this.BPosition, ref this.BTexCoord,
+                               ref CenterBC, ref this.CTexCoord,
+                               ref CenterBD,
+                               ref this.Normal );
+
+            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
+                              ref CenterBC, ref this.BTexCoord,
+                              ref this.CPosition, ref this.CTexCoord,
+                              ref CenterCD,
+                              ref this.Normal );
+
+            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
+                               ref CenterBD, ref this.BTexCoord,
+                               ref CenterCD, ref this.CTexCoord,
+                               ref this.DPosition,
+                               ref this.Normal );
+        }
+
+
+        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
+        {
+            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
+            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
+
+            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
+            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
+            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
+            CenterD = CenterAB;
+            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
+            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
+            CenterD /= 3.0;
+            Vector3d E = CenterD + ( this.Normal * 0.5 );
+            Vector3d temp = this.Normal;
+            temp *= height;
+            Vector3d.Add(ref CenterD, ref temp, out CenterD);
+
+            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
+            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
+            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
+            TexCoordD = TexCoordAB;
+            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
+            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
+            TexCoordD /= 3.0;
+            #region 1
+            first.APosition = this.APosition;
+            first.ATexCoord = this.ATexCoord;
+
+            first.BPosition = CenterAB;
+            first.BTexCoord = TexCoordAB;
+
+            first.CPosition = CenterCA;
+            first.CTexCoord = TexCoordCA;
+
+            first.Normal = this.Normal;
+            temp = ( this.APosition + CenterAB + CenterCA );
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            first.DPosition = temp;
+            #endregion 1
+            #region 2
+            second.APosition = CenterAB;
+            second.ATexCoord = TexCoordAB;
+
+            second.BPosition = this.BPosition;
+            second.BTexCoord = this.BTexCoord;
+
+            second.CPosition = CenterBC;
+            second.CTexCoord = TexCoordBC;
+
+            second.Normal = this.Normal;
+
+            temp = CenterAB + this.BPosition + CenterBC;
+            temp /=  3.0;
+            temp += this.Normal * -1.0;
+            second.DPosition = temp;
+
+            #endregion 2
+            #region 3
+            third.APosition = CenterBC;
+            third.ATexCoord = TexCoordBC;
+
+            third.BPosition = this.CPosition;
+            third.BTexCoord = this.CTexCoord;
+
+            third.CPosition = CenterCA;
+            third.CTexCoord = TexCoordCA;
+
+            third.Normal = this.Normal;
+            temp = CenterBC + this.CPosition + CenterCA;
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            third.DPosition = temp;
+            #endregion 3
+            #region 4
+            fourth.APosition = CenterAB;
+            fourth.ATexCoord = TexCoordAB;
+
+            fourth.BPosition = CenterD;
+            fourth.BTexCoord = TexCoordD;
+
+            fourth.CPosition = CenterCA;
+            fourth.CTexCoord = TexCoordCA;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
+            fourth.DPosition = E;
+            #endregion 4
+            #region 5
+            fifth.APosition = CenterAB;
+            fifth.ATexCoord = TexCoordAB;
+
+            fifth.BPosition = CenterBC;
+            fifth.BTexCoord = TexCoordBC;
+
+            fifth.CPosition = CenterD;
+            fifth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
+            fifth.DPosition = E;
+
+            #endregion 5
+            #region 6
+            sixth.APosition = CenterBC;
+            sixth.ATexCoord = TexCoordBC;
+
+            sixth.BPosition = CenterCA;
+            sixth.BTexCoord = TexCoordCA;
+
+            sixth.CPosition = CenterD;
+            sixth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
+            sixth.DPosition = E;
+            #endregion 6
+        }
+
+        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
+        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            first.TexCoord = this.ATexCoord;
+            first.Normal = this.Normal;
+            first.Position = this.APosition;
+
+            second.TexCoord = this.BTexCoord;
+            second.Normal = this.Normal;
+            second.Position = this.BPosition;
+
+            third.TexCoord = this.CTexCoord;
+            third.Normal = this.Normal;
+            third.Position = this.CPosition;
+        }
+
+        /// <summary>Debugging Aid, no real purpose</summary>
+        public override string ToString()
+        {
+            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "Normal= " + this.Normal.ToString();
+        }
+    }
+
+
+}
diff --git a/KAOS/Shapes/Helpers/VboShape.cs b/KAOS/Shapes/Helpers/VboShape.cs
new file mode 100644
index 0000000..62d5462
--- /dev/null
+++ b/KAOS/Shapes/Helpers/VboShape.cs
@@ -0,0 +1,23 @@
+namespace KAOS.Shapes
+{
+    public sealed class VboShape: DrawableShape
+    {
+        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = primitives;
+
+            VertexArray = new VertexT2dN3dV3d[vertices.Length];
+            for ( uint i = 0; i < vertices.Length; i++ )
+            {
+                VertexArray[i] = vertices[i];
+            }
+
+            IndexArray = new uint[indices.Length];
+            for ( uint i = 0; i < indices.Length; i++ )
+            {
+                IndexArray[i] = indices[i];
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/KochTetrahedron.cs b/KAOS/Shapes/KochTetrahedron.cs
new file mode 100644
index 0000000..a662cfe
--- /dev/null
+++ b/KAOS/Shapes/KochTetrahedron.cs
@@ -0,0 +1,70 @@
+using System;
+
+namespace KAOS.Shapes
+{
+    public sealed class KochTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
+                    Triangles = temp;
+                    extrusionHeight *= extrusionMultiplier;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
+        {
+            output = new TetrahedronFace[input.Length * 6];
+
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
+                counter += 6; // every source triangle emits 6 new triangles
+            }
+
+        }
+    }
+}
diff --git a/KAOS/Shapes/MengerSponge.cs b/KAOS/Shapes/MengerSponge.cs
new file mode 100644
index 0000000..c1d54c6
--- /dev/null
+++ b/KAOS/Shapes/MengerSponge.cs
@@ -0,0 +1,115 @@
+using OpenTK;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class MengerSponge: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+        }
+
+        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            List<MengerCube> Cubes;
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    List<MengerCube> temp;
+                    SubdivideMengerSponge( ref Cubes, out temp );
+                    Cubes = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            #region Get Array Dimensions
+            uint
+                VertexCount = 0,
+                IndexCount = 0;
+
+            foreach ( MengerCube c in Cubes )
+            {
+                uint t1, t2;
+                c.GetArraySizes( out t1, out t2 );
+                VertexCount += t1;
+                IndexCount += t2;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[VertexCount];
+            IndexArray = new uint[IndexCount];
+            #endregion Get Array Dimensions
+
+            List<Chunk> AllChunks = new List<Chunk>();
+
+            #region Build a temporary List of all loose pieces
+            foreach ( MengerCube c in Cubes )
+            {
+                c.GetVboAndIbo( ref AllChunks );
+            }
+            #endregion Build a temporary List of all loose pieces
+
+            #region Assemble pieces into a single VBO and IBO
+            VertexCount = 0;
+            IndexCount = 0;
+
+            foreach ( Chunk ch in AllChunks )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    VertexArray[VertexCount + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
+                }
+
+                VertexCount += (uint)ch.Vertices.Length;
+                IndexCount += (uint)ch.Indices.Length;
+            }
+
+            #endregion Assemble pieces into a single VBO and IBO
+
+            AllChunks.Clear();
+        }
+
+        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( 1 );
+            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
+        }
+
+        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( input.Count * 20 );
+            foreach ( MengerCube InputCube in input )
+            {
+                MengerCube[] SubdividedCubes;
+                InputCube.Subdivide( out SubdividedCubes );
+                for ( int i = 0; i < SubdividedCubes.Length; i++ )
+                {
+                    output.Add( SubdividedCubes[i] );
+                }
+            }
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
new file mode 100644
index 0000000..99c2d1b
--- /dev/null
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -0,0 +1,85 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using System.Drawing;
+
+namespace KAOS.Shapes
+{
+    public class Cube : Shape
+    {
+
+        public Cube(int x, int y, int z)
+        {
+            Vertices = new Vector3[]
+            {
+                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f, y-1.0f, z-1.0f),
+                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
+                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
+                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
+            };
+
+            Indices = new int[]
+            {
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1,
+            };
+
+            Normals = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f),
+            };
+
+            Colors = new int[]
+            {
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+            };
+        }
+
+
+        /// <summary>
+        /// Converts a Color instance into an int representation
+        /// </summary>
+        /// <param name="c">
+        /// A <see cref="Color"/> instance to be converted
+        /// </param>
+        /// <returns>
+        /// A <see cref="System.Int32"/>
+        /// </returns>
+        public static int ColorToRgba32(Color c)
+        {
+            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/IsoSphere.cs b/KAOS/Shapes/Old/IsoSphere.cs
new file mode 100644
index 0000000..4b2ae9f
--- /dev/null
+++ b/KAOS/Shapes/Old/IsoSphere.cs
@@ -0,0 +1,51 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using System;
+
+namespace KAOS.Shapes
+{
+    class IsoSphere : Shape
+    {
+        const double DoublePI = System.Math.PI * 2.0;
+
+        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
+        {
+            int count = 4 * s_steps * t_steps ;
+            
+            Vertices = new Vector3[count];
+            Normals = new Vector3[count];
+            Texcoords = new Vector2[count];
+            Indices = new int[6 * count / 4];
+
+            int i = 0;
+            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
+            {
+                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
+                {
+                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
+                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
+                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
+                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
+                    Normals[i] = Vector3.Normalize(Vertices[i]);
+
+                    ++i;
+                }
+            }
+            
+            for (i = 0; i < 6*count/4; i+=6)
+            {
+                Indices[i] = i;
+                Indices[i + 1] = i + 1;
+                Indices[i + 2] = i + 2 * s_steps + 1;
+                Indices[i + 3] = i + 2 * s_steps;
+                Indices[i + 4] = i;
+                Indices[i + 5] = i + 2 * s_steps + 1;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/Plane.cs b/KAOS/Shapes/Old/Plane.cs
new file mode 100644
index 0000000..df9a78e
--- /dev/null
+++ b/KAOS/Shapes/Old/Plane.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+    public class Plane : Shape
+    {
+        public Plane(int x_res, int y_res, float x_scale, float y_scale)
+        {
+            Vertices = new Vector3[x_res * y_res];
+            Normals = new Vector3[x_res * y_res];
+            Indices = new int[6 * x_res * y_res];
+            Texcoords = new Vector2[x_res * y_res];
+
+            int i = 0;
+            for (int y = -y_res / 2; y < y_res / 2; y++)
+            {
+                for (int x = -x_res / 2; x < x_res / 2; x++)
+                {
+                    Vertices[i].X = x_scale * (float)x / (float)x_res;
+                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
+                    Vertices[i].Z = 0;
+                    Normals[i].X = Normals[i].Y = 0;
+                    Normals[i].Z = 1;
+                    i++;
+                }
+            }
+
+            i = 0;
+            for (int y = 0; y < y_res - 1; y++)
+            {
+                for (int x = 0; x < x_res - 1; x++)
+                {
+                    Indices[i++] = (y + 0) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x + 1;
+                }
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
new file mode 100644
index 0000000..c5315af
--- /dev/null
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -0,0 +1,65 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+
+
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+    public abstract class Shape
+    {
+        private Vector3[] vertices, normals;
+        private Vector2[] texcoords;
+        private int[] indices;
+        private int[] colors;
+
+        public Vector3[] Vertices
+        {
+            get { return vertices; }
+            protected set
+            {
+                vertices = value;
+            }
+        }
+
+        public Vector3[] Normals
+        {
+            get { return normals; }
+            protected set
+            {
+                normals = value;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get { return texcoords; }
+            protected set
+            {
+                texcoords = value;
+            }
+        }
+
+        public int[] Indices
+        {
+            get { return indices; }
+            protected set
+            {
+                indices = value;
+            }
+        }
+
+        public int[] Colors
+        {
+            get { return colors; }
+            protected set
+            {
+                colors = value;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
new file mode 100644
index 0000000..fcb493d
--- /dev/null
+++ b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
@@ -0,0 +1,171 @@
+using OpenTK;
+using System;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class SierpinskiTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
+            Zero = 0,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
+            One = 1,
+            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
+            Two = 2,
+            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
+            Three = 3,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
+            Four = 4,
+            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
+            Five = 5,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
+            Six = 6,
+            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
+            Seven = 7,
+            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
+            Eight = 8,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
+            Nine = 9,
+        }
+
+        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
+        /// <param name="scale">Default: 1f.</param>
+        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
+        /// <param name="useDL"></param>
+        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+            case eSubdivisions.Nine:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    SubdivideTetrahedron( ref Triangles, out temp );
+                    Triangles = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
+        {
+            output = new VertexT2dN3dV3d[input.Length * 3];
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
+                counter += 3;
+            }
+        }
+
+        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
+        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
+        {
+            Vector3d[] Points = new Vector3d[4];
+            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
+            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
+
+            Vector2d[] TexCoords = new Vector2d[4];
+            TexCoords[0] = new Vector2d( 0.0, 0.0 );
+            TexCoords[1] = new Vector2d( 1.0, 0.0 );
+            TexCoords[2] = new Vector2d( 0.0, 1.0 );
+            TexCoords[3] = new Vector2d( 1.0, 1.0 );
+
+            Vector3d Normal;
+            array = new TetrahedronFace[4];
+
+            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
+            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[2], ref TexCoords[0],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
+            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[1],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
+            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3], ref TexCoords[3],
+                                                   ref Points[2],
+                                                   ref Normal );
+
+            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
+            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[0],
+                                                   ref Normal );
+        }
+
+        /// <summary>Subdivides each triangle into 4 new ones.</summary>
+        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
+        {
+
+            output = new TetrahedronFace[source.Length * 4];
+
+            int counter = 0;
+            for ( int i = 0; i < source.Length; i++ )
+            {
+                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
+                counter += 4; // every source triangle emits 4 new triangles
+            }
+        }
+
+        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
+        {
+            Vector3d temp1, temp2, temp3;
+
+            Vector3d.Subtract( ref A, ref D, out temp1 );
+            Vector3d.Subtract( ref B, ref D, out temp2 );
+            Vector3d.Subtract( ref C, ref D, out temp3 );
+
+            Vector3d.Add( ref temp1, ref temp2, out result );
+            Vector3d.Add(ref result, ref temp3, out result);
+            result.Normalize();
+        }
+
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
+        {
+            Vector3d temp1, temp2;
+            Vector3d.Subtract( ref A, ref B, out temp1 );
+            temp1.Normalize();
+            Vector3d.Subtract(ref C, ref B, out temp2);
+            temp2.Normalize();
+            Vector3d.Cross( ref temp1, ref temp2, out result );
+            result *=  -1.0;
+            result.Normalize();
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/SlicedHose.cs b/KAOS/Shapes/SlicedHose.cs
new file mode 100644
index 0000000..8a744ca
--- /dev/null
+++ b/KAOS/Shapes/SlicedHose.cs
@@ -0,0 +1,192 @@
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+	public sealed class SlicedHose : DrawableShape
+	{
+
+        public enum eSide:byte
+        {
+            // Around X Axis
+            BottomRight,
+            TopRight,
+            TopLeft,
+            BottomLeft,
+
+            // Around Y Axis
+
+            FrontRight,
+            BackRight,
+            BackLeft,
+            FrontLeft,
+
+            // Around Z Axis
+            FrontBottom,
+            BackBottom,
+            BackTop,
+            FrontTop,
+        }
+
+        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            Vector3d start = Vector3d.Zero,
+                     end = Vector3d.Zero;
+            double TexCoordStart=0f, TexCoordEnd=0f;
+
+            switch ( side )
+            {
+            #region Around X Axis
+            case eSide.BottomRight:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.TopRight:
+                start = Vector3d.UnitZ;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.TopLeft:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.BottomLeft:
+                start = -Vector3d.UnitZ;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+            #endregion Around X Axis
+            #region Around Y Axis
+            case eSide.FrontRight:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackRight:
+                start = Vector3d.UnitZ;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackLeft:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontLeft:
+                start = -Vector3d.UnitZ;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Y Axis
+            #region Around Z Axis
+            case eSide.FrontBottom:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackBottom:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackTop:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontTop:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Z Axis
+
+            }
+
+            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
+
+            double divisor = 1.0/ ((double)temp.Length-1.0);
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                float Multiplier = (float)( i * divisor );
+
+                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
+
+                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
+                temp[i].Normal.Normalize();
+                temp[i].Position = temp[i].Normal;
+                temp[i].Position *= scale;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
+            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
+
+            uint VertexCounter = 0,
+                 IndexCounter = 0,
+                 QuadCounter = 0;
+
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
+                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
+
+
+                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
+                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
+                VertexCounter += 2;
+
+                if ( i < temp.Length - 1 )
+                {
+                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
+                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
+
+                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
+                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
+
+                    IndexCounter += 6;
+                    QuadCounter += 2;
+                }
+            }
+
+        }
+ 
+    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
+    {
+        double t1;
+        Vector3d.Dot( ref a, ref b, out t1 );
+        double theta = System.Math.Acos( t1 );
+
+        double temp = 1.0 / System.Math.Sin( theta );
+        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
+        double t3 = System.Math.Sin( factor * theta ) * temp;
+
+        Vector3d v1 = Vector3d.Multiply( a, t2);
+        Vector3d v2 = Vector3d.Multiply( b, t3 );
+        result = Vector3d.Add( v1, v2 );
+    }
+
+
+    }
+}
diff --git a/KAOS/Shapes/SlicedSphere.cs b/KAOS/Shapes/SlicedSphere.cs
new file mode 100644
index 0000000..7c5ee4f
--- /dev/null
+++ b/KAOS/Shapes/SlicedSphere.cs
@@ -0,0 +1,193 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class SlicedSphere: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public enum eDir
+        {
+            All,
+            FrontTopRight,
+            FrontBottomRight,
+            FrontBottomLeft,
+            FrontTopLeft,
+            BackTopRight,
+            BackBottomRight,
+            BackBottomLeft,
+            BackTopLeft,
+
+        }
+
+        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
+            : base( useDL )
+        {
+            double Diameter = radius;
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            if ( sides[0] == eDir.All )
+            {
+                sides = new eDir[] {  eDir.FrontTopRight,
+            eDir.FrontBottomRight,
+            eDir.FrontBottomLeft,
+            eDir.FrontTopLeft,
+            eDir.BackTopRight,
+            eDir.BackBottomRight,
+            eDir.BackBottomLeft,
+            eDir.BackTopLeft,};
+            }
+
+            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
+            IndexArray = new uint[sides.Length * 3];
+
+            uint counter = 0;
+            foreach ( eDir s in sides )
+            {
+                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
+                IndexArray[counter + 0] = counter + 0;
+                IndexArray[counter + 1] = counter + 1;
+                IndexArray[counter + 2] = counter + 2;
+                counter += 3;
+            }
+
+            if ( subdivs != eSubdivisions.Zero )
+            {
+
+                for ( int s = 0; s < (int)subdivs; s++ )
+                {
+                    #region Assemble Chunks and convert to Arrays
+                    List<Chunk> AllChunks = new List<Chunk>();
+                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
+                    {
+                        Chunk chu;
+                        Subdivide( Diameter,
+                                   ref VertexArray[IndexArray[i + 0]],
+                                   ref VertexArray[IndexArray[i + 1]],
+                                   ref VertexArray[IndexArray[i + 2]],
+                                   out chu );
+                        AllChunks.Add( chu );
+                    }
+
+                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+                    AllChunks.Clear();
+                    #endregion Assemble Chunks and convert to Arrays
+                }
+            }
+
+            for (int i=0; i<VertexArray.Length;i++)
+            {
+                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
+            }
+        }
+
+        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
+                            t2 = new VertexT2dN3dV3d(),
+                            t3 = new VertexT2dN3dV3d();
+            switch ( s )
+            {
+            case eDir.FrontTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.FrontBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                break;
+            case eDir.FrontBottomLeft: 
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.FrontTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.BackTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            case eDir.BackBottomLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            }
+            first = t1;
+            second = t2;
+            third = t3;
+        }
+
+
+        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
+        {
+            c = new Chunk(6, 12);
+
+            c.Vertices[0] = first;
+            
+            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
+            c.Vertices[1].Normal.Normalize();
+            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
+            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
+
+            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
+            c.Vertices[2].Normal.Normalize();
+            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
+            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
+
+            c.Vertices[3] = second;
+    
+            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
+            c.Vertices[4].Normal.Normalize();
+            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
+            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
+
+            c.Vertices[5] = third;
+
+            #region Indices
+            c.Indices[0]=0;
+            c.Indices[1]=1;
+            c.Indices[2]=2;
+            c.Indices[3]=2;
+            c.Indices[4]=1;
+            c.Indices[5]=4;
+            c.Indices[6]=1;
+            c.Indices[7]=3;
+            c.Indices[8]=4;
+            c.Indices[9]=2;
+            c.Indices[10]=4;
+            c.Indices[11]=5;
+            #endregion Indices
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/TorusKnot.cs b/KAOS/Shapes/TorusKnot.cs
new file mode 100644
index 0000000..898c314
--- /dev/null
+++ b/KAOS/Shapes/TorusKnot.cs
@@ -0,0 +1,126 @@
+﻿using OpenTK;
+using System.Diagnostics;
+
+namespace KAOS.Shapes
+{
+    public sealed class TorusKnot: DrawableShape
+    {
+        #region Constants
+        // hard minimums to make sure the created Torusknot is 3D
+        private const int MINShapeVertices = 3;
+        private const int MINPathSteps = 32;
+        private const double TwoPi = ( 2.0 * System.Math.PI );
+        #endregion Constants
+
+        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
+            : base( useDL )
+        {
+            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
+            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
+            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+
+            Vector3d[] PathPositions = new Vector3d[pathsteps];
+
+            #region Find the center Points for each step on the path
+
+            for ( int i = 0; i < pathsteps; i++ )
+            {
+                double Angle = ( i / (double)pathsteps ) * TwoPi;
+                double AngleTimesP = Angle * p;
+                double AngleTimesQ = Angle * q;
+                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
+
+                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
+                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
+                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
+
+            }
+            #endregion Find the center Points for each step on the path
+
+            #region Find the Torus length
+            Vector3d result;
+            double[] Lengths = new double[pathsteps];
+            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
+            Lengths[0] = result.Length;
+            double TotalLength = result.Length;
+            for ( int i = 1; i < pathsteps; i++ ) // skipping 
+            {
+                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
+                Lengths[i] = result.Length;
+                TotalLength += result.Length;
+            }
+            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
+            #endregion Find the Torus length
+
+            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
+
+            #region Loft a circle Shape along the path
+            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                Vector3d last, next, normal, tangent;
+                if ( i == pathsteps - 1 )
+                    next = PathPositions[0];
+                else
+                    next = PathPositions[i + 1];
+                if ( i == 0 )
+                    last = PathPositions[pathsteps - 1];
+                else
+                    last = PathPositions[i - 1];
+
+                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
+                tangent.Normalize();
+
+                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
+                normal.Normalize();
+                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
+
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    uint index = i * (uint)shapevertices + j;
+
+                    // Create a point on the plane and rotate it
+                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
+                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
+                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
+                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
+                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
+                    VertexArray[index].Normal.Normalize();
+                    // just generate some semi-useful UVs to fill blanks
+                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
+                }
+            }
+            #endregion Loft a circle Shape along the path
+
+            PathPositions = null; // not needed anymore
+
+            uint currentindex = 0;
+
+            #region Build a Triangle strip from the Vertices
+            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                uint RowCurrent = i * (uint)shapevertices;
+                uint RowBelow;
+                if ( i == pathsteps - 1 )
+                    RowBelow = 0; // for the last row, the first row is the following
+                else
+                    RowBelow = ( i + 1 ) * (uint)shapevertices;
+
+                // new ring begins here
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    IndexArray[currentindex++] = RowCurrent + j;
+                    IndexArray[currentindex++] = RowBelow + j;
+                }
+                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
+                IndexArray[currentindex++] = RowCurrent;
+                IndexArray[currentindex++] = RowBelow;
+            }
+            #endregion Build a Triangle strip from the Vertices
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/VertexPositionColor.cs b/KAOS/Shapes/VertexPositionColor.cs
new file mode 100644
index 0000000..2576afe
--- /dev/null
+++ b/KAOS/Shapes/VertexPositionColor.cs
@@ -0,0 +1,51 @@
+﻿#region License
+//
+// The Open Toolkit Library License
+//
+// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights to 
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+// OTHER DEALINGS IN THE SOFTWARE.
+//
+#endregion
+
+using OpenTK;
+using System.Drawing;
+using System.Runtime.InteropServices;
+
+namespace KAOS.Tutorial
+{
+    [StructLayout(LayoutKind.Sequential, Pack = 1)]
+    struct VertexPositionColor
+    {
+        public Vector3 Position;
+        public uint Color;
+
+        public VertexPositionColor(float x, float y, float z, Color color)
+        {
+            Position = new Vector3(x, y, z);
+            Color = ToRgba(color);
+        }
+
+        static uint ToRgba(Color color)
+        {
+            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
+        }
+    }
+}
diff --git a/KAOS/States/AssimpImportedState.cs b/KAOS/States/AssimpImportedState.cs
new file mode 100644
index 0000000..40dbc84
--- /dev/null
+++ b/KAOS/States/AssimpImportedState.cs
@@ -0,0 +1,28 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
+
+namespace KAOS.States
+{
+    public class AssimpImportedState :IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+
+        public AssimpImportedState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Render()
+        {
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+    }
+}
diff --git a/KAOS/States/DefaultState.cs b/KAOS/States/DefaultState.cs
new file mode 100644
index 0000000..e26345e
--- /dev/null
+++ b/KAOS/States/DefaultState.cs
@@ -0,0 +1,44 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System.Drawing;
+
+namespace KAOS.States
+{
+    public class DefaultState : IGameObject
+    {
+        double currentRotation = 0;
+
+        StateManager m_stateManager;
+        public DefaultState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.PointSize(5f);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.TriangleStrip);
+
+            GL.Color4(new Color4(1f, 0f, 0f, .5f));
+            GL.Vertex3(new Vector3(-50f, 0f, 0f));
+            GL.Color3(new Vector3(0f, 1f, 0f));
+            GL.Vertex3(new Vector3(50f, 0, 0));
+            GL.Color3(new Vector3(0f, 0f, 1f));
+            GL.Vertex3(new Vector3(0f, 50f, 0));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
new file mode 100644
index 0000000..f83dcda
--- /dev/null
+++ b/KAOS/States/DrawSpriteState.cs
@@ -0,0 +1,79 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System.Drawing;
+
+namespace KAOS.States
+{
+    public class DrawSpriteState : IGameObject
+    {
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        double height, width, halfHeight, halfWidth, x, y, z;
+        float topUV, bottomUV, leftUV, rightUV;
+
+        #region IGameObject States
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            Texture texture = m_textureManager.Get("sprite1");
+            GL.Enable(EnableCap.Texture2D);
+            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
+            GL.ClearColor(Color.Black);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.TexCoord2(new Vector2d(leftUV, topUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+            GL.End();
+
+        } 
+        #endregion
+
+        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
+        {
+            m_stateManager = stateManager;
+            m_textureManager = texturManager;
+            Initialise();
+        }
+
+        private void Initialise()
+        {
+            this.height = 200;
+            this.width = 200;
+
+            this.halfHeight = this.height / 2;
+            this.halfWidth = this.width / 2;
+
+            this.x = 0;
+            this.y = 0;
+            this.z = 2;
+
+            this.topUV = 0;
+            this.bottomUV = 1;
+            this.leftUV = 0;
+            this.rightUV = 1;
+        }
+    }
+}
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
new file mode 100644
index 0000000..59095f9
--- /dev/null
+++ b/KAOS/States/Skyboxstate.cs
@@ -0,0 +1,217 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+
+namespace KAOS.States
+{
+    public class Skyboxstate : IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        Cube cube;
+        BufferObject cubeObject;
+
+        // Data layout for each line below is:
+        // position{XYZ},			    normal{XYZ},
+        float[] vertexData = new float[] {
+            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
+  
+            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
+  
+            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
+  
+            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
+  
+            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
+  
+            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
+        };
+
+        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        Matrix3 modelMatrix3, normalMatrix;
+        Vector3 eyeObjectSpace;
+        Vector3 trans;
+
+        
+        int eye_handle, skybox_vao;
+
+        float aspect = 1024 / (float)600;
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            LoadCubeMap();
+            CreateShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+            trans = new Vector3(0f, 0f, -10f);
+
+            LoadTestObject();
+        }
+
+        private void CreateShaders()
+        {
+            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
+
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
+
+            Logger.WriteLine("Render Shader");
+            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+            GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            GL.GenVertexArrays(1, out skybox_vao);
+            GL.BindVertexArray(skybox_vao);
+
+            GL.DepthFunc(DepthFunction.Lequal);
+        }
+
+        private void LoadTestObject()
+        {
+            cube = new Cube(0, 0, 0);
+            cubeObject = new BufferObject();
+            cubeObject.PositionData = cube.Vertices;
+            cubeObject.NormalsData = cube.Normals;
+            cubeObject.IndicesData = cube.Indices;
+            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
+
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
+        }
+
+        public void Update(float elapsedTime)
+        {
+            MoveCamera();
+
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
+            
+            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
+            Renderer.eyePosition = Camera.Position;
+        }
+
+        public void Render()
+        {
+            cubeObject = m_bufferManager.GetBuffer("SkyCube");
+            Renderer.DrawSkyBox(m_textureManager, cubeObject);
+            
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+        }
+
+        #region Input Control
+        private void MoveCamera()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+
+            }
+        #endregion
+        }
+    }
+}
diff --git a/KAOS/States/SplashScreenState.cs b/KAOS/States/SplashScreenState.cs
new file mode 100644
index 0000000..c18d9ec
--- /dev/null
+++ b/KAOS/States/SplashScreenState.cs
@@ -0,0 +1,51 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Timers;
+
+namespace KAOS.States
+{
+    public class SplashScreenState : IGameObject
+    {
+        double currentRotation = 0;
+        double delay = 300;
+
+        StateManager m_stateManager;
+        public SplashScreenState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            delay--;
+            if (delay <= 0){
+                delay = 3;
+                m_stateManager.ChangeState("Voxels");
+            }
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/TestSpriteClassState.cs b/KAOS/States/TestSpriteClassState.cs
new file mode 100644
index 0000000..814b797
--- /dev/null
+++ b/KAOS/States/TestSpriteClassState.cs
@@ -0,0 +1,48 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class TestSpriteClassState : IGameObject
+    {
+        Renderer m_renderer = new Renderer();
+        TextureManager m_textureManager = new TextureManager();
+        Sprite sprite1 = new Sprite();
+        Sprite sprite2 = new Sprite();
+
+        public TestSpriteClassState(TextureManager textureManager)
+        {
+            m_textureManager = textureManager;
+            sprite1.Texture = m_textureManager.Get("sprite1");
+            sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetPosition(new Vector3d(100, 100, 0));
+            sprite1.SetColour(new Color4(256, 256, 256, 1));
+
+            sprite2.Texture = m_textureManager.Get("sprite2");
+            sprite2.SetHeight(256 * .5f);
+            sprite2.SetPosition(new Vector3d(-100, -100, 0));
+            sprite2.SetColour(new Color4(256, 256, 256, 1));
+        }
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(1f, 1f, 1f, 1f);
+            m_renderer.DrawSprite(sprite1);
+            m_renderer.DrawSprite(sprite2);
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
new file mode 100644
index 0000000..917dae0
--- /dev/null
+++ b/KAOS/States/VboState.cs
@@ -0,0 +1,51 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.States
+{
+    public class VboState : IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        Cube cube = new Cube(0, 0, 0);
+
+        public VboState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            CreateVBOs();
+        }
+
+        private void CreateVBOs()
+        {
+            BufferObject tempVBO = new BufferObject();
+            tempVBO.PositionData = cube.Vertices;
+            tempVBO.NormalsData = cube.Normals;
+            tempVBO.IndicesData = cube.Indices;
+            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+
+        public void Render()
+        {
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType,
+                            m_bufferObject.IndicesData.Length,
+                            DrawElementsType.UnsignedInt,
+                            IntPtr.Zero);
+        }
+    }
+}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
new file mode 100644
index 0000000..e8b82e2
--- /dev/null
+++ b/KAOS/States/VoxelState.cs
@@ -0,0 +1,100 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.States
+{
+    public class VoxelState : IGameObject
+    {
+        double currentRotation = 0;
+        public float length = 1f, height = 1f, width = 1f;
+
+        StateManager m_stateManager = new StateManager();
+
+        BufferObjectManager m_bufferObjectManager;
+        BufferObject m_bufferObject;
+
+        TextureManager m_textureManager = new TextureManager();
+
+        Cube[][][] m_blocks;
+
+        public VoxelState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            m_bufferObjectManager = new BufferObjectManager();
+
+            //LoadSkyBox();
+
+            GenerateChunk();
+        }
+
+        private void LoadSkyBox()
+        {
+            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+            m_textureManager.LoadSkyTexture("skybox", 
+                new string[] 
+                {
+                    skyboxTexturePath + "jajlands1_ft.jpg",
+                    skyboxTexturePath + "jajlands1_bk.jpg",
+                    skyboxTexturePath + "jajlands1_lf.jpg",
+                    skyboxTexturePath + "jajlands1_rt.jpg",
+                    skyboxTexturePath + "jajlands1_up.jpg",
+                    skyboxTexturePath + "jajlands1_dn.jpg"
+                }
+            );
+
+        }
+
+        private void GenerateChunk()
+        {
+            BufferObject tmpVBO = new BufferObject();
+            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+            
+            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+            {
+                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+                {
+                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+                    {
+                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+                        if (x == 0 && y == 0 && z == 0) 
+                        { 
+                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+                        }
+                        else
+                        { 
+                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+                        }
+                    }
+                }
+            }
+
+            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 100 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+        }
+    }
+}
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
new file mode 100644
index 0000000..9d28a68
--- /dev/null
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -0,0 +1,39 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public class PreciseTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public PreciseTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public float GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
new file mode 100644
index 0000000..4d80ab9
--- /dev/null
+++ b/KAOS/Utilities/Block.cs
@@ -0,0 +1,29 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public class Block
+    {
+        enum BlockType
+        {
+            BlockType_Default = 0,
+
+            BlockType_Grass,
+            BlockType_Dirt,
+            BlockType_Water,
+            BlockType_Stone,
+            BlockType_Wood,
+            BlockType_Sand,
+
+            BlockType_NumTypes,
+        };
+
+        public bool IsActive { get; set; }
+        private bool m_active;
+        private BlockType type;
+    }
+}
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
new file mode 100644
index 0000000..18a1ea1
--- /dev/null
+++ b/KAOS/Utilities/BufferObject.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct BufferObject
+    {
+        public int VaoID { get; set; }
+
+        public int VboID { get; set; }
+
+        public int IboID { get; set; }
+
+        public PrimitiveType PrimitiveType { get; set; }
+
+        public Vector3[] PositionData { get; set; }
+
+        public Vector3[] NormalsData { get; set; }
+
+        public Color4[] ColorData { get; set; }
+
+        public int[] IndicesData { get; set; }
+
+        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+        {
+            #region Buffer Pointer IDs
+            VaoID = vaoId;
+            VboID = vboId;
+            IboID = iboId;
+            #endregion
+            
+            PositionData = vPositionData;
+            NormalsData = vNormalsData;
+            ColorData = vColorData;
+            IndicesData = indicesData;
+        }
+
+    }
+}
diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
new file mode 100644
index 0000000..59ace7e
--- /dev/null
+++ b/KAOS/Utilities/Camera.cs
@@ -0,0 +1,59 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// Camera
+    /// </summary>
+    public static class Camera
+    {
+        public static Vector3 Position = new Vector3(0f, 0f, 0f);
+        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static float MoveSpeed = 0.2f;
+        public static float MouseSensitivity = 0.01f;
+
+        public static Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public static void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+
+            Logger.WriteLine("Camera Position = " + Position);
+        }
+
+        public static void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
new file mode 100644
index 0000000..26681e0
--- /dev/null
+++ b/KAOS/Utilities/Chunk.cs
@@ -0,0 +1,91 @@
+﻿using KAOS.Shapes;
+using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+namespace KAOS.Utilities
+{
+    public class Chunk : IDisposable
+    {
+        public const int CHUNK_SIZE = 16;
+        private Block[][][] m_blocks;
+        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+
+        public Chunk()
+        {
+            //Create Blocks
+            m_blocks = new Block[CHUNK_SIZE][][];
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                m_blocks[i] = new Block[CHUNK_SIZE][];
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+                }
+            }
+        }
+
+        public void Update(float dt) { }
+
+        public void Render() { }
+
+        public void Dispose()
+        {
+            // Delete blocks
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = null;
+                }
+                m_blocks[i] = null;
+            }
+            m_blocks = null;
+        }
+
+        public void CreateMesh()
+        {
+            for (int x = 0; x < CHUNK_SIZE; x++)
+            {
+                for (int y = 0; y < CHUNK_SIZE; y++)
+                {
+                    for (int z = 0; z < CHUNK_SIZE; z++)
+                    {
+                        if (m_blocks[x][y][z].IsActive == false)
+                        {
+                            // Don't create triangle data for inactive blocks
+                            continue;
+                        }
+
+                        CreateCube(x, y, z);
+                    }
+                }
+            }
+        }
+
+        private void CreateCube(int x, int y, int z)
+        {
+            float blockSize = 1f;
+
+            
+            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+
+            Vector3 n1;
+
+
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Utilities/CustomVertexStruct.cs b/KAOS/Utilities/CustomVertexStruct.cs
new file mode 100644
index 0000000..e3d3585
--- /dev/null
+++ b/KAOS/Utilities/CustomVertexStruct.cs
@@ -0,0 +1,35 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.InteropServices;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct AWVertex
+    {
+        /// <summary>
+        /// Defines the size of the AWVertex struct in bytes.
+        /// </summary>
+        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
+        private Vector3[] vector31;
+        private Vector3[] vector32;
+        private int[] p;
+
+        public Vector3[] Postions { get; set; }
+
+        public Vector3[] Normals {get; set;}
+
+        public int[] Colors {get; set;}
+
+        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
+        {
+            Postions = positions;
+            Normals = nomarls;
+            Colors = colors;
+        }
+
+            
+    }
+}
diff --git a/KAOS/Utilities/Extensions.cs b/KAOS/Utilities/Extensions.cs
new file mode 100644
index 0000000..759ed2a
--- /dev/null
+++ b/KAOS/Utilities/Extensions.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public static class Extensions
+    {
+        // http://stackoverflow.com/a/1547282/1090268
+        public static T[] Concat<T>(this T[] x, T[] y)
+        {
+            if (x == null) throw new ArgumentNullException("x");
+            if (y == null) throw new ArgumentNullException("y");
+            int oldLen = x.Length;
+            Array.Resize<T>(ref x, x.Length + y.Length);
+            Array.Copy(y, 0, x, oldLen, y.Length);
+            return x;
+        }
+    }
+}
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
new file mode 100644
index 0000000..6e15e05
--- /dev/null
+++ b/KAOS/Utilities/Logger.cs
@@ -0,0 +1,52 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Diagnostics;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// AWLogger
+    /// </summary>
+    internal static class Logger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
new file mode 100644
index 0000000..903fe15
--- /dev/null
+++ b/KAOS/Utilities/Renderer.cs
@@ -0,0 +1,75 @@
+﻿using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.Utilities
+{
+    public static class Renderer
+    {
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
+        internal static Vector3 eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
+
+        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        {
+            GL.Color4(color);
+            GL.TexCoord2(uvs);
+            GL.Vertex3(position);
+        }
+
+        public static void DrawSprite(Sprite sprite)
+        {
+            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
+            GL.Begin(PrimitiveType.Triangles);
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                DrawImmediateModeVertex(
+                    sprite.VertexPositions[i],
+                    sprite.VertexColours[i],
+                    sprite.VertexUVs[i]);
+            }
+            GL.End();
+        }
+
+        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        {
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public static void DrawWireframeVoxel(float length, float height, float width)
+        {
+            
+        }
+
+        public static void DrawChunk(Chunk chunk)
+        {
+
+        }
+
+        internal static void ToggleWireframeOn()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
+
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Shader.cs b/KAOS/Utilities/Shader.cs
new file mode 100644
index 0000000..2b5cda0
--- /dev/null
+++ b/KAOS/Utilities/Shader.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public struct Shader
+    {
+        public int ID { get; set; }
+
+        public Shader(int id)
+            : this()
+        {
+            ID = id;
+        }
+    }
+}
diff --git a/KAOS/Utilities/Sprite.cs b/KAOS/Utilities/Sprite.cs
new file mode 100644
index 0000000..8ce0c32
--- /dev/null
+++ b/KAOS/Utilities/Sprite.cs
@@ -0,0 +1,117 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public class Sprite
+    {
+        internal const int VertexAmount = 6;
+        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
+        Color4[] vertexColours = new Color4[VertexAmount];
+        Vector2[] vertexUVs = new Vector2[VertexAmount];
+        Texture texture = new Texture();
+
+        public Texture Texture
+        {
+            get { return texture; }
+            set
+            {
+                texture = value;
+
+                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
+            }
+        }
+        public Vector3d[] VertexPositions { get { return vertexPositions; } }
+
+        public Color4[] VertexColours { get { return vertexColours; } }
+
+        public Vector2[] VertexUVs { get { return vertexUVs; } }
+
+        public Sprite()
+        {
+            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
+            //SetColour(new Color4(1, 1, 1, 1));
+            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
+        }
+
+        private Vector3d GetCentre()
+        {
+            double halfWidth = GetWidth() / 2;
+            double halfHeight = GetHeight() / 2;
+
+            return new Vector3d(
+                vertexPositions[0].X + halfWidth,
+                vertexPositions[0].Y - halfHeight,
+                vertexPositions[0].Z);
+        }
+
+        private void InitVertexPositions(Vector3d position, double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+
+            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
+            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+
+            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
+            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+        }
+
+        public double GetWidth()
+        {
+            //top right -> top left
+            return vertexPositions[1].X - vertexPositions[0].X;
+        }
+
+        public double GetHeight()
+        {
+            //top left -> bottom left
+            return vertexPositions[0].Y - vertexPositions[2].Y;
+        }
+
+        public void SetWidth(double width)
+        {
+            InitVertexPositions(GetCentre(), width, GetHeight());
+        }
+
+        public void SetHeight(double height)
+        {
+            InitVertexPositions(GetCentre(), GetWidth(), height);
+        }
+
+        public void SetPosition(double x, double y)
+        {
+            SetPosition(new Vector3d(x, y, 0));
+        }
+
+        public void SetPosition(Vector3d position)
+        {
+            InitVertexPositions(position, GetWidth(), GetHeight());
+        }
+
+        public void SetColour(Color4 color4)
+        {
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                vertexColours[i] = color4;
+            }
+        }
+
+        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
+        {
+            vertexUVs[0] = topLeft;
+            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
+
+            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[4] = bottomRight;
+            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Texture.cs b/KAOS/Utilities/Texture.cs
new file mode 100644
index 0000000..fffdeb7
--- /dev/null
+++ b/KAOS/Utilities/Texture.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct Texture
+    {
+        public int ID { get; set; }
+        public int Width { get; set; }
+        public int Height { get; set; }
+
+        public Texture(int id, int width, int height) :this()
+        {
+            ID = id;
+            Width = width;
+            Height = Height;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b08644818f581c545f87f31066efcf8bd41b8982">Removing unnecessary files.</a>  -  b086448</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 22 files changed, 504 deletions(-)

diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d427122cbfb9b0ce19ce4b2de1676b20466c650c">Stock shaders.</a>  -  d427122</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 5 files changed, 37 insertions(+), 70 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 8751f33..c367b99 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -79,3 +79,4 @@ namespace KAOS
         {
-            ShaderManager.LoadDefaultShaderProgram();
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
         }
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
index ab00068..92525db 100644
--- a/KAOS/Managers/ShaderManager.cs
+++ b/KAOS/Managers/ShaderManager.cs
@@ -18,6 +18,6 @@ namespace KAOS.Managers
         private static string defaultDataPath = "Data/Shaders/";
-        private static string m_vertexShaderFile = "opentk-vs";
-        private static string m_fragmentShaderFile = "opentk-fs";
+        private static string m_vertexShaderFile = "skybox-vs";
+        private static string m_fragmentShaderFile = "skybox-fs";
 
-        internal static void LoadDefaultShaderProgram()
+        internal static void LoadDefaultSkyboxShader()
         {
@@ -26,3 +26,13 @@ namespace KAOS.Managers
             m_programHandle = BuildProgram();
-            m_shaderStorage.Add("default", new Shader(m_programHandle));
+            m_shaderStorage.Add("skybox", new Shader(m_programHandle));
+        }
+
+        internal static void LoadDefaultRenderShader()
+        {
+            m_vertexShaderFile = "render-vs";
+            m_fragmentShaderFile = "render-fs";
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("render", new Shader(m_programHandle));
         }
@@ -38,3 +48,11 @@ namespace KAOS.Managers
 
-        public static Shader DefaultShader
+        public static Shader Skybox
+        {
+            get
+            {
+                return Get("skybox");
+            }
+        }
+
+        public static Shader Render
         {
@@ -42,3 +60,3 @@ namespace KAOS.Managers
             {
-                return m_shaderStorage["default"];
+                return Get("render");
             }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 59095f9..f59dbb5 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -20,48 +20,2 @@ namespace KAOS.States
 
-        // Data layout for each line below is:
-        // position{XYZ},			    normal{XYZ},
-        float[] vertexData = new float[] {
-            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
-  
-            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
-  
-            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
-  
-            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
-  
-            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
-  
-            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
-        };
-
         static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
@@ -80,3 +34,2 @@ namespace KAOS.States
         Vector3 trans;
-
         
@@ -94,3 +47,3 @@ namespace KAOS.States
             LoadCubeMap();
-            CreateShaders();
+            QueryShaders();
 
@@ -102,14 +55,9 @@ namespace KAOS.States
 
-        private void CreateShaders()
+        private void QueryShaders()
         {
-            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
-
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
-
-            Logger.WriteLine("Render Shader");
-            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Skybox.ID, "eye_position");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
 
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
         }
@@ -136,4 +84,4 @@ namespace KAOS.States
 
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
         }
@@ -159,3 +107,3 @@ namespace KAOS.States
             GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Get("Render").ID);
+            GL.UseProgram(ShaderManager.Render.ID);
 
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
index 917dae0..d65f97f 100644
--- a/KAOS/States/VboState.cs
+++ b/KAOS/States/VboState.cs
@@ -32,3 +32,3 @@ namespace KAOS.States
 
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
             m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 903fe15..310a609 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -40,3 +40,3 @@ namespace KAOS.Utilities
 
-            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.UseProgram(ShaderManager.Skybox.ID);
             GL.ActiveTexture(TextureUnit.Texture0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/14826e61341ecb93925284b683c889541c1102b2">Tidying up files.</a>  -  14826e6</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 3 files changed, 4 insertions(+), 39 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index c367b99..9b52faf 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -39,3 +39,3 @@ namespace KAOS
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
+        protected AnimationTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace KAOS
         {
-            m_Timer = new PreciseTimer();
+            m_Timer = new AnimationTimer();
         }
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
index 9d28a68..8de3bf5 100644
--- a/KAOS/Utilities/AnimationTimer.cs
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -8,3 +8,3 @@ namespace KAOS.Utilities
 {
-    public class PreciseTimer
+    public class AnimationTimer
     {
@@ -21,3 +21,3 @@ namespace KAOS.Utilities
 
-        public PreciseTimer()
+        public AnimationTimer()
         {
diff --git a/KAOS/Utilities/CustomVertexStruct.cs b/KAOS/Utilities/CustomVertexStruct.cs
deleted file mode 100644
index e3d3585..0000000
--- a/KAOS/Utilities/CustomVertexStruct.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.InteropServices;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct AWVertex
-    {
-        /// <summary>
-        /// Defines the size of the AWVertex struct in bytes.
-        /// </summary>
-        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
-        private Vector3[] vector31;
-        private Vector3[] vector32;
-        private int[] p;
-
-        public Vector3[] Postions { get; set; }
-
-        public Vector3[] Normals {get; set;}
-
-        public int[] Colors {get; set;}
-
-        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
-        {
-            Postions = positions;
-            Normals = nomarls;
-            Colors = colors;
-        }
-
-            
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7ee6581c87a87eaf90bf19b0b58eabfe138bee33">moved assimp example code out of main class</a>  -  7ee6581</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 2 files changed, 303 insertions(+), 358 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 9b52faf..428ad86 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -1,5 +1,2 @@
-﻿using Assimp;
-using Assimp.Configs;
-using KAOS.Managers;
-using KAOS.Nodes;
+﻿using KAOS.Managers;
 using KAOS.Utilities;
@@ -10,12 +7,3 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
 using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
 using System.Windows.Forms;
@@ -40,8 +28,2 @@ namespace KAOS
         protected AnimationTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
         
@@ -85,32 +67,2 @@ namespace KAOS
 
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
         #endregion
@@ -130,3 +82,2 @@ namespace KAOS
 
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
             #endregion
@@ -150,42 +101,3 @@ namespace KAOS
 
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
+            
 
@@ -204,3 +116,2 @@ namespace KAOS
             float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
 
@@ -215,9 +126,2 @@ namespace KAOS
 
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
         #region Input Control
@@ -259,255 +163,2 @@ namespace KAOS
 
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
         protected override void OnUnload(EventArgs e)
@@ -515,3 +166,3 @@ namespace KAOS
             base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
+            GL.DeleteTexture(Renderer.m_texId);
         }
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 310a609..fa734d6 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -1,2 +1,3 @@
-﻿using KAOS.Managers;
+﻿using Assimp;
+using KAOS.Managers;
 using OpenTK;
@@ -5,2 +6,6 @@ using OpenTK.Graphics.OpenGL;
 using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Reflection;
 
@@ -11,4 +16,9 @@ namespace KAOS.Utilities
         internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
+        internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
+        internal static int
+            handle_projectionMatrix,
+            handle_modelViewProjectionMatrix,
+            handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, m_displayList, m_texId;
+        internal static Scene m_model;
+        internal static float m_angle;
 
@@ -24,3 +34,3 @@ namespace KAOS.Utilities
             GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(PrimitiveType.Triangles);
+            GL.Begin(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles);
             for (int i = 0; i < Sprite.VertexAmount; i++)
@@ -56,3 +66,3 @@ namespace KAOS.Utilities
         {
-            
+
         }
@@ -64,2 +74,37 @@ namespace KAOS.Utilities
 
+        public static void DrawModel()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
+        }
+
         internal static void ToggleWireframeOn()
@@ -73,3 +118,252 @@ namespace KAOS.Utilities
         }
+
+        private static void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private static void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private static void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private static void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private static void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private static Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private static Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private static Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
     }
-}
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eeaaeb9e1f786f42bdbdd1364bc4b40807d96995">credited neokabuto for the Camera of his i am using.</a>  -  eeaaeb9</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index 59ace7e..998414d 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -10,3 +10,3 @@ namespace KAOS.Utilities
     /// <summary>
-    /// Camera
+    /// Camera: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html (slightly modified)
     /// </summary>
@@ -14,4 +14,4 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, 0f);
-        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static Vector3 Position = new Vector3(0f, 0f, -4f);
+        public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
         public static float MoveSpeed = 0.2f;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e9eb9be2e2030f24b34a564ef8730a58c53fc8cf">Inverted camera view matrix, think it has helped.</a>  -  e9eb9be</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index f59dbb5..3bf13db 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -93,4 +93,4 @@ namespace KAOS.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            
-            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.viewMatrix = Matrix4.Invert(Camera.GetViewMatrix());
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0d020599038f599f302abe078654c8794f7edfe6">~</a>  -  0d02059</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index 998414d..c60cfeb 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, -4f);
+        public static Vector3 Position = new Vector3(0f, 0f, -2f);
         public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb9086974f6d6322a2f1fcdded5819e83cc7929a">Mandelbrot shader.</a>  -  bb90869</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 4 files changed, 68 insertions(+), 6 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index b9c351c..96379f0 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -2,2 +2,7 @@
 
+uniform sampler1D tex;
+uniform vec2 center;
+uniform float scale;
+uniform int iter;
+
 uniform samplerCube tex_cubemap;
@@ -6,3 +11,3 @@ const vec3 ambient = vec3(0.1, 0.1, 0.1);
 const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+const vec3 lightColor = vec3(0.8, 0.2, 0.8);
 
@@ -20,10 +25,29 @@ void main(void)
     // at the fragment
-    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+    //vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
 
     // Sample from scaled using reflection vector
-     color = texture(tex_cubemap, r);
+    // color = texture(tex_cubemap, r);
+
+	//float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	//color = color * vec4(ambient + diffuse * lightColor, 1.0);
+
+
+	vec2 z, c;
+
+    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
+    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
+
+    int i;
+    z = c;
+    for(i=0; i<iter; i++) {
+        float x = (z.x * z.x - z.y * z.y) + c.x;
+        float y = (z.y * z.x + z.x * z.y) + c.y;
 
-	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+        if((x * x + y * y) > 4.0) break;
+        z.x = x;
+        z.y = y;
+    }
 
-	color = color * vec4(ambient + diffuse * lightColor, 1.0);
-}
+    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
+}
\ No newline at end of file
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 0970750..7839198 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -44,2 +44,25 @@ namespace KAOS.Managers
 
+        public void LoadTexture1D(string textureId, string path)
+        {
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture1D, textureGpuHandle);
+
+            OpenImageFile(path);
+
+            GL.TexImage1D(TextureTarget.Texture1D,
+                0, PixelInternalFormat.Rgba, bitmapData.Width, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+            CloseImageFile();
+
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.Repeat);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
         public void LoadSkyTexture(string textureId, string[] path)
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 3bf13db..e148df0 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -46,2 +46,4 @@ namespace KAOS.States
 
+            m_textureManager.LoadTexture1D("1d", "pal.bmp");
+
             LoadCubeMap();
@@ -62,2 +64,6 @@ namespace KAOS.States
             Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
+
+            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
+            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
+            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
         }
@@ -111,2 +117,8 @@ namespace KAOS.States
             GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.Uniform1(Renderer.handle_iter, 70);
+            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
+            GL.Uniform1(Renderer.handle_scale, 2.2);
+
+
+            GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
 
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index fa734d6..63cb8b8 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -23,2 +23,5 @@ namespace KAOS.Utilities
         internal static float m_angle;
+        public static int handle_centre;
+        public static int handle_scale;
+        public static int handle_iter;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f880fee4a5a2cf3eab9bbbfdf494d4f0775559f4">credited mandelbrot shader code + screenshots</a>  -  f880fee</p><p>authored by Anthony Woodward, 4 days ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 96379f0..5e99dcd 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -34,2 +34,3 @@ void main(void)
 
+	// see: http://nuclear.mutantstargoat.com/articles/sdr_fract/
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a2963b715d1768efa5223e13d4031d6886a31209">Integrating VertexStructs with object Manager.</a>  -  a2963b7</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 12 files changed, 276 insertions(+), 193 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
new file mode 100644
index 0000000..5eee4a3
--- /dev/null
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -0,0 +1,16 @@
+﻿using KAOS.Shapes;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface IDrawableShape
+    {
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
+    }
+}
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 5ad5904..afca0fd 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -1,2 +1,4 @@
-﻿using KAOS.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK;
@@ -12,4 +14,25 @@ namespace KAOS.Managers
 
-        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        public void AddBufferObject(string name, IDrawableShape shape, int program)
         {
+            BufferObject bufferObject = new BufferObject();
+            //bufferObject.PositionData = new Vector3d[1];
+            //bufferObject.NormalsData = new Vector3d[1];
+            VertexT2dN3dV3d[] vertexData;
+            uint[] indices;
+            BeginMode type;
+
+            shape.GetArraysforVBO(out type, out vertexData, out indices);
+            for (int i = 0; i < vertexData.Length; i++)
+            {
+                if (i == 0)
+                {
+                    bufferObject.PositionData = new Vector3d[]{ vertexData[i].Position};
+                    bufferObject.NormalsData = new Vector3d[]{ vertexData[i].Normal};
+                }
+                bufferObject.PositionData = bufferObject.PositionData.Concat(new Vector3d[]{ vertexData[i].Position});
+                bufferObject.NormalsData = bufferObject.NormalsData.Concat(new Vector3d[]{ vertexData[i].Normal});
+            }
+
+            bufferObject.IndicesData = indices;
+
             int bufferHandle;
@@ -17,4 +40,4 @@ namespace KAOS.Managers
             #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            int sizeOfPositionData = Vector3d.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3d.SizeInBytes * bufferObject.NormalsData.Length;
             //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
@@ -36,6 +59,6 @@ namespace KAOS.Managers
             // Send Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer, noOffset,
                 new IntPtr(sizeOfPositionData), bufferObject.PositionData);
             // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer,
                 new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
@@ -68,3 +91,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, 0);
             GL.BindAttribLocation(program, bufferHandle, "in_position");
@@ -74,3 +97,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, sizeOfPositionData);
             GL.BindAttribLocation(program, bufferHandle, "in_normal");
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index 0f9cd8a..44029e0 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -21,3 +21,3 @@ namespace KAOS.Shapes
 
-    public abstract class DrawableShape: IDisposable
+    public abstract class DrawableShape: IDisposable, KAOS.Interfaces.IDrawableShape
     {
diff --git a/KAOS/Shapes/Base/VertexStructs.cs b/KAOS/Shapes/Base/VertexStructs.cs
index 0f64155..e98d9d7 100644
--- a/KAOS/Shapes/Base/VertexStructs.cs
+++ b/KAOS/Shapes/Base/VertexStructs.cs
@@ -11,3 +11,3 @@ namespace KAOS.Shapes
 
-        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        public VertexT2dN3dV3d(Vector2d texcoord, Vector3d normal, Vector3d position)
         {
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
index 99c2d1b..7782558 100644
--- a/KAOS/Shapes/Old/Cube.cs
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -28,3 +28,3 @@ namespace KAOS.Shapes
 
-            Indices = new int[]
+            Indices = new uint[]
             {
diff --git a/KAOS/Shapes/Old/IsoSphere.cs b/KAOS/Shapes/Old/IsoSphere.cs
index 4b2ae9f..f3fe113 100644
--- a/KAOS/Shapes/Old/IsoSphere.cs
+++ b/KAOS/Shapes/Old/IsoSphere.cs
@@ -22,3 +22,3 @@ namespace KAOS.Shapes
             Texcoords = new Vector2[count];
-            Indices = new int[6 * count / 4];
+            Indices = new uint[6 * count / 4];
 
@@ -41,8 +41,8 @@ namespace KAOS.Shapes
             {
-                Indices[i] = i;
-                Indices[i + 1] = i + 1;
-                Indices[i + 2] = i + 2 * s_steps + 1;
-                Indices[i + 3] = i + 2 * s_steps;
-                Indices[i + 4] = i;
-                Indices[i + 5] = i + 2 * s_steps + 1;
+                Indices[i] = (uint)i;
+                Indices[i + 1] = (uint)i + 1;
+                Indices[i + 2] = (uint)(i + 2 * s_steps + 1);
+                Indices[i + 3] = (uint)(i + 2 * s_steps);
+                Indices[i + 4] = (uint)i;
+                Indices[i + 5] = (uint)(i + 2 * s_steps + 1);
             }
diff --git a/KAOS/Shapes/Old/Plane.cs b/KAOS/Shapes/Old/Plane.cs
index df9a78e..e8199db 100644
--- a/KAOS/Shapes/Old/Plane.cs
+++ b/KAOS/Shapes/Old/Plane.cs
@@ -20,3 +20,3 @@ namespace KAOS.Shapes
             Normals = new Vector3[x_res * y_res];
-            Indices = new int[6 * x_res * y_res];
+            Indices = new uint[6 * x_res * y_res];
             Texcoords = new Vector2[x_res * y_res];
@@ -42,9 +42,9 @@ namespace KAOS.Shapes
                 {
-                    Indices[i++] = (y + 0) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (uint)((y + 0) * x_res + x);
+                    Indices[i++] = (uint)((y + 1) * x_res + x);
+                    Indices[i++] = (uint)((y + 0) * x_res + x + 1);
 
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x + 1;
+                    Indices[i++] = (uint)((y + 0) * x_res + x + 1);
+                    Indices[i++] = (uint)((y + 1) * x_res + x);
+                    Indices[i++] = (uint)((y + 1) * x_res + x + 1);
                 }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index c5315af..7a29b06 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -9,2 +9,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 
@@ -12,3 +13,3 @@ namespace KAOS.Shapes
 {
-    public abstract class Shape
+    public abstract class Shape : KAOS.Interfaces.IDrawableShape
     {
@@ -16,3 +17,3 @@ namespace KAOS.Shapes
         private Vector2[] texcoords;
-        private int[] indices;
+        private uint[] indices;
         private int[] colors;
@@ -46,3 +47,3 @@ namespace KAOS.Shapes
 
-        public int[] Indices
+        public uint[] Indices
         {
@@ -63,2 +64,47 @@ namespace KAOS.Shapes
         }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2dN3dV3d[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length ; i++)
+            {
+                //vertices[i].TexCoord = (Vector2d)Texcoords[i];
+                vertices[i].Normal = (Vector3d)Normals[i] ;
+                vertices[i].Position = (Vector3d)Vertices[i];
+            }
+
+            indices = Indices;
+        }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2fN3fV3f[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length; i++)
+            {
+                vertices[i].TexCoord = Texcoords[i];
+                vertices[i].Normal = Normals[i];
+                vertices[i].Position = Vertices[i];
+            }
+
+            indices = Indices;
+        }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2hN3hV3h[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)Texcoords[i];
+                vertices[i].Normal = (Vector3h)Normals[i];
+                vertices[i].Position = (Vector3h) Vertices[i];
+            }
+
+            indices = Indices;
+        }
     }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index e148df0..d663b10 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,10 +84,8 @@ namespace KAOS.States
             cube = new Cube(0, 0, 0);
-            cubeObject = new BufferObject();
-            cubeObject.PositionData = cube.Vertices;
-            cubeObject.NormalsData = cube.Normals;
-            cubeObject.IndicesData = cube.Indices;
-            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
-
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
+            //m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Torus", new TorusKnot( 256, 32, 0.1, 3, 4, 1, true ), ShaderManager.Render.ID);
+
+            //m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
+            //m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
         }
@@ -111,3 +109,3 @@ namespace KAOS.States
             
-            cubeObject = m_bufferManager.GetBuffer("Cube");
+            cubeObject = m_bufferManager.GetBuffer("Torus");
             GL.BindVertexArray(cubeObject.VaoID);
@@ -122,5 +120,5 @@ namespace KAOS.States
 
-            GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
+            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
 
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            //GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
index d65f97f..7faddb3 100644
--- a/KAOS/States/VboState.cs
+++ b/KAOS/States/VboState.cs
@@ -1,51 +1,51 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VboState : IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-        Cube cube = new Cube(0, 0, 0);
-
-        public VboState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            CreateVBOs();
-        }
-
-        private void CreateVBOs()
-        {
-            BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;
-            tempVBO.NormalsData = cube.Normals;
-            tempVBO.IndicesData = cube.Indices;
-            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-
-        public void Render()
-        {
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType,
-                            m_bufferObject.IndicesData.Length,
-                            DrawElementsType.UnsignedInt,
-                            IntPtr.Zero);
-        }
-    }
-}
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Shapes;
+//using KAOS.Utilities;
+//using OpenTK.Graphics.OpenGL;
+//using System;
+
+//namespace KAOS.States
+//{
+//    public class VboState : IGameObject
+//    {
+//        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
+//        BufferObject m_bufferObject;
+//        StateManager m_stateManager;
+//        Cube cube = new Cube(0, 0, 0);
+
+//        public VboState(StateManager stateManager)
+//        {
+//            m_stateManager = stateManager;
+
+//            CreateVBOs();
+//        }
+
+//        private void CreateVBOs()
+//        {
+//            BufferObject tempVBO = new BufferObject();
+//            tempVBO.PositionData = cube.Vertices;
+//            tempVBO.NormalsData = cube.Normals;
+//            tempVBO.IndicesData = cube.Indices;
+//            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+//            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
+//            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+//        }
+
+//        public void Update(float elapsedTime)
+//        {
+
+//        }
+
+//        public void Render()
+//        {
+//            GL.BindVertexArray(m_bufferObject.VaoID);
+//            GL.DrawElements(m_bufferObject.PrimitiveType,
+//                            m_bufferObject.IndicesData.Length,
+//                            DrawElementsType.UnsignedInt,
+//                            IntPtr.Zero);
+//        }
+//    }
+//}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
index e8b82e2..e6f0ee8 100644
--- a/KAOS/States/VoxelState.cs
+++ b/KAOS/States/VoxelState.cs
@@ -1,100 +1,100 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VoxelState : IGameObject
-    {
-        double currentRotation = 0;
-        public float length = 1f, height = 1f, width = 1f;
-
-        StateManager m_stateManager = new StateManager();
-
-        BufferObjectManager m_bufferObjectManager;
-        BufferObject m_bufferObject;
-
-        TextureManager m_textureManager = new TextureManager();
-
-        Cube[][][] m_blocks;
-
-        public VoxelState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            m_bufferObjectManager = new BufferObjectManager();
-
-            //LoadSkyBox();
-
-            GenerateChunk();
-        }
-
-        private void LoadSkyBox()
-        {
-            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-            m_textureManager.LoadSkyTexture("skybox", 
-                new string[] 
-                {
-                    skyboxTexturePath + "jajlands1_ft.jpg",
-                    skyboxTexturePath + "jajlands1_bk.jpg",
-                    skyboxTexturePath + "jajlands1_lf.jpg",
-                    skyboxTexturePath + "jajlands1_rt.jpg",
-                    skyboxTexturePath + "jajlands1_up.jpg",
-                    skyboxTexturePath + "jajlands1_dn.jpg"
-                }
-            );
-
-        }
-
-        private void GenerateChunk()
-        {
-            BufferObject tmpVBO = new BufferObject();
-            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Shapes;
+//using KAOS.Utilities;
+//using OpenTK.Graphics.OpenGL;
+//using System;
+
+//namespace KAOS.States
+//{
+//    public class VoxelState : IGameObject
+//    {
+//        double currentRotation = 0;
+//        public float length = 1f, height = 1f, width = 1f;
+
+//        StateManager m_stateManager = new StateManager();
+
+//        BufferObjectManager m_bufferObjectManager;
+//        BufferObject m_bufferObject;
+
+//        TextureManager m_textureManager = new TextureManager();
+
+//        Cube[][][] m_blocks;
+
+//        public VoxelState(StateManager stateManager)
+//        {
+//            m_stateManager = stateManager;
+
+//            m_bufferObjectManager = new BufferObjectManager();
+
+//            //LoadSkyBox();
+
+//            GenerateChunk();
+//        }
+
+//        private void LoadSkyBox()
+//        {
+//            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+//            m_textureManager.LoadSkyTexture("skybox", 
+//                new string[] 
+//                {
+//                    skyboxTexturePath + "jajlands1_ft.jpg",
+//                    skyboxTexturePath + "jajlands1_bk.jpg",
+//                    skyboxTexturePath + "jajlands1_lf.jpg",
+//                    skyboxTexturePath + "jajlands1_rt.jpg",
+//                    skyboxTexturePath + "jajlands1_up.jpg",
+//                    skyboxTexturePath + "jajlands1_dn.jpg"
+//                }
+//            );
+
+//        }
+
+//        private void GenerateChunk()
+//        {
+//            BufferObject tmpVBO = new BufferObject();
+//            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+//            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
             
-            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-            {
-                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-                {
-                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-                    {
-                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-                        if (x == 0 && y == 0 && z == 0) 
-                        { 
-                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-                        }
-                        else
-                        { 
-                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-                        }
-                    }
-                }
-            }
-
-            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 100 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-        }
-    }
-}
+//            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+//            {
+//                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+//                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+//                {
+//                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+//                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+//                    {
+//                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+//                        if (x == 0 && y == 0 && z == 0) 
+//                        { 
+//                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+//                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+//                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+//                        }
+//                        else
+//                        { 
+//                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+//                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+//                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+//                        }
+//                    }
+//                }
+//            }
+
+//            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+//            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+//        }
+
+//        public void Update(float elapsedTime)
+//        {
+//            currentRotation = 100 * elapsedTime;
+//        }
+
+//        public void Render()
+//        {
+//            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+//            GL.BindVertexArray(m_bufferObject.VaoID);
+//            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+//        }
+//    }
+//}
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
index 18a1ea1..9e616c4 100644
--- a/KAOS/Utilities/BufferObject.cs
+++ b/KAOS/Utilities/BufferObject.cs
@@ -20,5 +20,5 @@ namespace KAOS.Utilities
 
-        public Vector3[] PositionData { get; set; }
+        public Vector3d[] PositionData { get; set; }
 
-        public Vector3[] NormalsData { get; set; }
+        public Vector3d[] NormalsData { get; set; }
 
@@ -26,6 +26,6 @@ namespace KAOS.Utilities
 
-        public int[] IndicesData { get; set; }
+        public uint[] IndicesData { get; set; }
 
         public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+            Vector3d[] vPositionData, Vector3d[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/21bbf396f0d2f6a32716ff639e8cdc0b2fc94854">Removed unused methods.</a>  -  21bbf39</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 63cb8b8..d447a0a 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -62,3 +62,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -67,12 +67,2 @@ namespace KAOS.Utilities
 
-        public static void DrawWireframeVoxel(float length, float height, float width)
-        {
-
-        }
-
-        public static void DrawChunk(Chunk chunk)
-        {
-
-        }
-
         public static void DrawModel()

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/330e81cce73464af94dc1207102b3709ad596bb2">removing fractal</a>  -  330e81c</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 5e99dcd..028e794 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -25,10 +25,10 @@ void main(void)
     // at the fragment
-    //vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
 
     // Sample from scaled using reflection vector
-    // color = texture(tex_cubemap, r);
+     color = texture(tex_cubemap, r);
 
-	//float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
 
-	//color = color * vec4(ambient + diffuse * lightColor, 1.0);
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
 
@@ -52,3 +52,3 @@ void main(void)
 
-    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
+    //gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
 }
\ No newline at end of file
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d663b10..8b45f92 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -122,3 +122,3 @@ namespace KAOS.States
 
-            //GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1532475fa877dd12e93a9a639fc981eadd7b97f0">Narrowed down the issue to being caused by torus buffer conflicting with the cube buffer.</a>  -  1532475</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 7 files changed, 125 insertions(+), 100 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
index 5eee4a3..12f5eeb 100644
--- a/KAOS/Interfaces/IDrawableShape.cs
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -1,2 +1,3 @@
 ﻿using KAOS.Shapes;
+using OpenTK;
 using OpenTK.Graphics.OpenGL;
@@ -11,2 +12,7 @@ namespace KAOS.Interfaces
     {
+        Vector3[] Vertices { get; }
+        Vector3[] Normals { get; }
+        Vector2[] Texcoords { get; }
+        uint[] Indices { get; }
+
         void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index afca0fd..b045393 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -19,19 +19,11 @@ namespace KAOS.Managers
             //bufferObject.NormalsData = new Vector3d[1];
-            VertexT2dN3dV3d[] vertexData;
-            uint[] indices;
-            BeginMode type;
-
-            shape.GetArraysforVBO(out type, out vertexData, out indices);
-            for (int i = 0; i < vertexData.Length; i++)
-            {
-                if (i == 0)
-                {
-                    bufferObject.PositionData = new Vector3d[]{ vertexData[i].Position};
-                    bufferObject.NormalsData = new Vector3d[]{ vertexData[i].Normal};
-                }
-                bufferObject.PositionData = bufferObject.PositionData.Concat(new Vector3d[]{ vertexData[i].Position});
-                bufferObject.NormalsData = bufferObject.NormalsData.Concat(new Vector3d[]{ vertexData[i].Normal});
-            }
-
-            bufferObject.IndicesData = indices;
+            //VertexT2fN3fV3f[] vertexData;
+            //uint[] indices;
+            //BeginMode type;
+
+            //shape.GetArraysforVBO(out type, out vertexData, out indices);
+
+            bufferObject.PositionData = shape.Vertices;
+            bufferObject.NormalsData = shape.Normals;
+            bufferObject.IndicesData = shape.Indices;
 
@@ -40,4 +32,4 @@ namespace KAOS.Managers
             #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3d.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3d.SizeInBytes * bufferObject.NormalsData.Length;
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
             //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
@@ -59,7 +51,7 @@ namespace KAOS.Managers
             // Send Position data.
-            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer, noOffset,
-                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, noOffset, new IntPtr(sizeOfPositionData), bufferObject.PositionData);
             // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer,
-                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
             
@@ -67,5 +59,4 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, 
-                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
-                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), bufferObject.IndicesData, BufferUsageHint.StaticDraw);
 
@@ -91,3 +82,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, 0);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
             GL.BindAttribLocation(program, bufferHandle, "in_position");
@@ -97,3 +88,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, sizeOfPositionData);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
             GL.BindAttribLocation(program, bufferHandle, "in_normal");
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index 44029e0..a35c1cd 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -179,2 +179,49 @@ namespace KAOS.Shapes
         #endregion
+
+        public Vector3[] Normals
+        {
+            get
+            {
+                Vector3[] normals = new Vector3[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    normals[i] = (Vector3)VertexArray[i].Normal;
+                }
+                return normals;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get
+            {
+                Vector2[] vertices = new Vector2[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    vertices[i] = (Vector2)VertexArray[i].TexCoord;
+                }
+                return vertices;
+            }
+        }
+
+        public uint[] Indices
+        {
+            get
+            {
+                return IndexArray;
+            }
+        }
+
+        public Vector3[] Vertices
+        {
+            get
+            {
+                Vector3[] postion = new Vector3[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    postion[i] = (Vector3)VertexArray[i].Position;
+                }
+                return postion;
+            }
+        }
     }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 7a29b06..620b11f 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -23,6 +23,3 @@ namespace KAOS.Shapes
             get { return vertices; }
-            protected set
-            {
-                vertices = value;
-            }
+            set { vertices = value; }
         }
@@ -32,6 +29,3 @@ namespace KAOS.Shapes
             get { return normals; }
-            protected set
-            {
-                normals = value;
-            }
+            set { normals = value; }
         }
@@ -41,6 +35,3 @@ namespace KAOS.Shapes
             get { return texcoords; }
-            protected set
-            {
-                texcoords = value;
-            }
+            set { texcoords = value; }
         }
@@ -50,6 +41,3 @@ namespace KAOS.Shapes
             get { return indices; }
-            protected set
-            {
-                indices = value;
-            }
+            set { indices = value; }
         }
@@ -87,3 +75,3 @@ namespace KAOS.Shapes
             {
-                vertices[i].TexCoord = Texcoords[i];
+                //vertices[i].TexCoord = Texcoords[i];
                 vertices[i].Normal = Normals[i];
@@ -102,3 +90,3 @@ namespace KAOS.Shapes
             {
-                vertices[i].TexCoord = (Vector2h)Texcoords[i];
+                //vertices[i].TexCoord = (Vector2h)Texcoords[i];
                 vertices[i].Normal = (Vector3h)Normals[i];
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 8b45f92..79bb852 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -18,3 +18,2 @@ namespace KAOS.States
         Cube cube;
-        BufferObject cubeObject;
 
@@ -31,7 +30,3 @@ namespace KAOS.States
 
-        Matrix3 modelMatrix3, normalMatrix;
-        Vector3 eyeObjectSpace;
-        Vector3 trans;
-        
-        int eye_handle, skybox_vao;
+        int skybox_vao;
 
@@ -52,3 +47,2 @@ namespace KAOS.States
             _rotation = MathHelper.DegreesToRadians(90);
-            trans = new Vector3(0f, 0f, -10f);
 
@@ -85,7 +79,4 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
-            //m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
-            m_bufferManager.AddBufferObject("Torus", new TorusKnot( 256, 32, 0.1, 3, 4, 1, true ), ShaderManager.Render.ID);
-
-            //m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
-            //m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Torus", new TorusKnot(256, 32, 0.1, 3, 4, 1, false), ShaderManager.Render.ID); 
+            m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
         }
@@ -106,19 +97,4 @@ namespace KAOS.States
         {
-            cubeObject = m_bufferManager.GetBuffer("SkyCube");
-            Renderer.DrawSkyBox(m_textureManager, cubeObject);
-            
-            cubeObject = m_bufferManager.GetBuffer("Torus");
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Render.ID);
-
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
-            GL.Uniform1(Renderer.handle_iter, 70);
-            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
-            GL.Uniform1(Renderer.handle_scale, 2.2);
-
-
-            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
-
-            GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Cube"));
         }
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
index 9e616c4..0c591c0 100644
--- a/KAOS/Utilities/BufferObject.cs
+++ b/KAOS/Utilities/BufferObject.cs
@@ -20,5 +20,5 @@ namespace KAOS.Utilities
 
-        public Vector3d[] PositionData { get; set; }
+        public Vector3[] PositionData { get; set; }
 
-        public Vector3d[] NormalsData { get; set; }
+        public Vector3[] NormalsData { get; set; }
 
@@ -29,3 +29,3 @@ namespace KAOS.Utilities
         public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3d[] vPositionData, Vector3d[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
         {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index d447a0a..bf15170 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -15,13 +15,12 @@ namespace KAOS.Utilities
     {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
+        #region Members
+        internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
         internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
-        internal static int
-            handle_projectionMatrix,
-            handle_modelViewProjectionMatrix,
-            handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, m_displayList, m_texId;
+        internal static int handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
+            m_displayList, m_texId, 
+            handle_centre, handle_scale, handle_iter;
+
         internal static Scene m_model;
         internal static float m_angle;
-        public static int handle_centre;
-        public static int handle_scale;
-        public static int handle_iter;
+        #endregion
 
@@ -48,3 +47,3 @@ namespace KAOS.Utilities
 
-        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        public static void DrawSkyBox(TextureManager textureManager, BufferObject Object)
         {
@@ -55,5 +54,5 @@ namespace KAOS.Utilities
             GL.ActiveTexture(TextureUnit.Texture0);
-            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureManager.Get("skybox1").ID);
 
-            GL.BindVertexArray(cubeObject.VaoID);
+            GL.BindVertexArray(Object.VaoID);
             GL.Disable(EnableCap.DepthTest);
@@ -62,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, Object.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -67,2 +66,29 @@ namespace KAOS.Utilities
 
+        public static void DrawObject(TextureManager textureManager, BufferObject bufferObject)
+        {
+
+            GL.BindVertexArray(bufferObject.VaoID);
+            GL.UseProgram(ShaderManager.Render.ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.Uniform1(Renderer.handle_iter, 70);
+            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
+            GL.Uniform1(Renderer.handle_scale, 2.2);
+
+            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
+
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+        }
+        internal static void ToggleWireframeOn()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
+
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+        }
+
+        #region Assimp Example
         public static void DrawModel()
@@ -102,12 +128,2 @@ namespace KAOS.Utilities
 
-        internal static void ToggleWireframeOn()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-        }
-
-        internal static void ToggleWireframeOff()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-        }
-
         private static void ComputeBoundingBox()
@@ -360,2 +376,3 @@ namespace KAOS.Utilities
         }
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/262f8a35b7afc9e87eeaac3d0dfc713936edab6b">This fixes an issue I have been experiencing caused by not unbinding vao's upon completing setting it up.</a>  -  262f8a3</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 3 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index b045393..7a36acd 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -93,3 +93,4 @@ namespace KAOS.Managers
 
-            GL.BindVertexArray(bufferObject.VaoID);
+            // IMPORTANT: vertex array needs unbinding here to avoid rendering incorrectly
+            GL.BindVertexArray(0);
 
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 79bb852..1b9492f 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -41,3 +41,3 @@ namespace KAOS.States
 
-            m_textureManager.LoadTexture1D("1d", "pal.bmp");
+            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
 
@@ -79,4 +79,3 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("Torus", new TorusKnot(256, 32, 0.1, 3, 4, 1, false), ShaderManager.Render.ID); 
-            m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
         }
@@ -98,3 +97,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Cube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
         }
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index bf15170..cbb0d0b 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -47,3 +47,3 @@ namespace KAOS.Utilities
 
-        public static void DrawSkyBox(TextureManager textureManager, BufferObject Object)
+        public static void DrawSkyBox(TextureManager textureManager, BufferObject bufferObject)
         {
@@ -56,3 +56,3 @@ namespace KAOS.Utilities
 
-            GL.BindVertexArray(Object.VaoID);
+            GL.BindVertexArray(bufferObject.VaoID);
             GL.Disable(EnableCap.DepthTest);
@@ -61,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, Object.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -68,8 +68,7 @@ namespace KAOS.Utilities
         {
-
-            GL.BindVertexArray(bufferObject.VaoID);
             GL.UseProgram(ShaderManager.Render.ID);
+            GL.BindVertexArray(bufferObject.VaoID);
 
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
             GL.Uniform1(Renderer.handle_iter, 70);
@@ -80,3 +79,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/84c7766bd6c13e08423994d9146c318d6f716262">Refactoring.</a>  -  84c7766</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index a35c1cd..ea2284f 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -197,8 +197,8 @@ namespace KAOS.Shapes
             {
-                Vector2[] vertices = new Vector2[VertexArray.Length];
+                Vector2[] texCoords = new Vector2[VertexArray.Length];
                 for (uint i = 0; i < VertexArray.Length; i++)
                 {
-                    vertices[i] = (Vector2)VertexArray[i].TexCoord;
+                    texCoords[i] = (Vector2)VertexArray[i].TexCoord;
                 }
-                return vertices;
+                return texCoords;
             }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 620b11f..8660961 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -23,3 +23,3 @@ namespace KAOS.Shapes
             get { return vertices; }
-            set { vertices = value; }
+            protected set { vertices = value; }
         }
@@ -29,3 +29,3 @@ namespace KAOS.Shapes
             get { return normals; }
-            set { normals = value; }
+            protected set { normals = value; }
         }
@@ -35,3 +35,3 @@ namespace KAOS.Shapes
             get { return texcoords; }
-            set { texcoords = value; }
+            protected set { texcoords = value; }
         }
@@ -41,3 +41,3 @@ namespace KAOS.Shapes
             get { return indices; }
-            set { indices = value; }
+            protected set { indices = value; }
         }
@@ -55,3 +55,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 
@@ -70,3 +70,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 
@@ -85,3 +85,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fecf380b631287a5be804fd25701042b3cacf640">Updated mouse input.</a>  -  fecf380</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 428ad86..5fa9815 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -69,2 +69,4 @@ namespace KAOS
 
+        MouseState current, previous;
+
         #region Game Loop
@@ -72,12 +74,18 @@ namespace KAOS
         {
-            #region input
-            if (Focused)
+            #region Mouse Input
+            current = OpenTK.Input.Mouse.GetState();
+            if (current[MouseButton.Left])
             {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
                 ResetCursor();
             }
-
+            
             #endregion

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9b757d8df9393f57bf15d6cf60fc277df6f1a2d8">Updated Example.Shapes.* to use PrimitiveType.</a>  -  9b757d8</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 12 files changed, 38 insertions(+), 27 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
index 12f5eeb..99e36eb 100644
--- a/KAOS/Interfaces/IDrawableShape.cs
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -17,5 +17,5 @@ namespace KAOS.Interfaces
 
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
     }
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index ea2284f..c9489e3 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -23,3 +23,3 @@ namespace KAOS.Shapes
     {
-        protected BeginMode PrimitiveMode;
+        protected PrimitiveType PrimitiveMode;
         protected VertexT2dN3dV3d[] VertexArray;
@@ -32,4 +32,4 @@ namespace KAOS.Shapes
                 switch ( PrimitiveMode )
-                { 
-                case BeginMode.Triangles:
+                {
+                    case PrimitiveType.Triangles:
                     if ( IndexArray != null )
@@ -57,3 +57,3 @@ namespace KAOS.Shapes
             UseDisplayList = useDisplayList;
-            PrimitiveMode = BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             VertexArray = null;
@@ -64,3 +64,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
         {
@@ -79,3 +79,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
         {
@@ -94,3 +94,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
         {
diff --git a/KAOS/Shapes/Capsule.cs b/KAOS/Shapes/Capsule.cs
index cd6f7e6..56d270a 100644
--- a/KAOS/Shapes/Capsule.cs
+++ b/KAOS/Shapes/Capsule.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -46,5 +47,5 @@ namespace KAOS.Shapes
             }
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            PrimitiveType TemporaryMode;
             VertexT2dN3dV3d[] TemporaryVBO;
diff --git a/KAOS/Shapes/ChamferCube.cs b/KAOS/Shapes/ChamferCube.cs
index 1c340a1..6fa540b 100644
--- a/KAOS/Shapes/ChamferCube.cs
+++ b/KAOS/Shapes/ChamferCube.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -50,3 +51,3 @@ namespace KAOS.Shapes
             List<Chunk> AllChunks = new List<Chunk>();
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            PrimitiveType TemporaryMode;
             VertexT2dN3dV3d[] TemporaryVBO;
@@ -271,3 +272,3 @@ namespace KAOS.Shapes
             #region Final Assembly of Chunks
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
diff --git a/KAOS/Shapes/Helpers/VboShape.cs b/KAOS/Shapes/Helpers/VboShape.cs
index 62d5462..64ffdd2 100644
--- a/KAOS/Shapes/Helpers/VboShape.cs
+++ b/KAOS/Shapes/Helpers/VboShape.cs
@@ -1 +1,2 @@
+using OpenTK.Graphics.OpenGL;
 namespace KAOS.Shapes
@@ -4,3 +5,3 @@ namespace KAOS.Shapes
     {
-        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+        public VboShape( ref PrimitiveType primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
             : base( useDL )
diff --git a/KAOS/Shapes/KochTetrahedron.cs b/KAOS/Shapes/KochTetrahedron.cs
index a662cfe..07b63d9 100644
--- a/KAOS/Shapes/KochTetrahedron.cs
+++ b/KAOS/Shapes/KochTetrahedron.cs
@@ -1 +1,2 @@
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -51,3 +52,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
diff --git a/KAOS/Shapes/MengerSponge.cs b/KAOS/Shapes/MengerSponge.cs
index c1d54c6..88c7826 100644
--- a/KAOS/Shapes/MengerSponge.cs
+++ b/KAOS/Shapes/MengerSponge.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -40,3 +41,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 8660961..aeac9a0 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -15,2 +15,4 @@ namespace KAOS.Shapes
     {
+        protected PrimitiveType PrimitiveMode;
+        
         private Vector3[] vertices, normals;
@@ -53,5 +55,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
@@ -68,5 +70,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
@@ -83,5 +85,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
diff --git a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
index fcb493d..1293391 100644
--- a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -66,3 +67,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
diff --git a/KAOS/Shapes/SlicedHose.cs b/KAOS/Shapes/SlicedHose.cs
index 8a744ca..50bcc8c 100644
--- a/KAOS/Shapes/SlicedHose.cs
+++ b/KAOS/Shapes/SlicedHose.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 
@@ -32,3 +33,3 @@ namespace KAOS.Shapes
         {
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/SlicedSphere.cs b/KAOS/Shapes/SlicedSphere.cs
index 7c5ee4f..e63acfb 100644
--- a/KAOS/Shapes/SlicedSphere.cs
+++ b/KAOS/Shapes/SlicedSphere.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -39,3 +40,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/TorusKnot.cs b/KAOS/Shapes/TorusKnot.cs
index 898c314..c79b77e 100644
--- a/KAOS/Shapes/TorusKnot.cs
+++ b/KAOS/Shapes/TorusKnot.cs
@@ -1,2 +1,3 @@
 ﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Diagnostics;
@@ -21,3 +22,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+            PrimitiveMode = PrimitiveType.TriangleStrip;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/dbc18e0d5c031e5a9808c9d272c5f32064d6fecc">Removed hardcoded PrimitiveMode values.</a>  -  dbc18e0</p><p>authored by Anthony Woodward, 3 days ago</p></div><pre>
 5 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 7a36acd..97c264f 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -19,7 +19,7 @@ namespace KAOS.Managers
             //bufferObject.NormalsData = new Vector3d[1];
-            //VertexT2fN3fV3f[] vertexData;
-            //uint[] indices;
-            //BeginMode type;
+            VertexT2fN3fV3f[] vertexData;
+            uint[] indices;
+            PrimitiveType type;
 
-            //shape.GetArraysforVBO(out type, out vertexData, out indices);
+            shape.GetArraysforVBO(out type, out vertexData, out indices);
 
@@ -28,2 +28,3 @@ namespace KAOS.Managers
             bufferObject.IndicesData = shape.Indices;
+            bufferObject.PrimitiveType = type;
 
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index c9489e3..dd04c57 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -6,2 +6,3 @@
 
+using KAOS.Interfaces;
 using OpenTK;
@@ -21,3 +22,3 @@ namespace KAOS.Shapes
 
-    public abstract class DrawableShape: IDisposable, KAOS.Interfaces.IDrawableShape
+    public abstract class DrawableShape: IDisposable, IDrawableShape
     {
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
index 7782558..ae559fd 100644
--- a/KAOS/Shapes/Old/Cube.cs
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -7,2 +7,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Drawing;
@@ -67,2 +68,4 @@ namespace KAOS.Shapes
             };
+
+            PrimitiveMode = PrimitiveType.Triangles;
         }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index aeac9a0..40faf97 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -8,2 +8,3 @@
 
+using KAOS.Interfaces;
 using OpenTK;
@@ -13,3 +14,3 @@ namespace KAOS.Shapes
 {
-    public abstract class Shape : KAOS.Interfaces.IDrawableShape
+    public abstract class Shape : IDrawableShape
     {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index cbb0d0b..e1eb71c 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -61,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(bufferObject.PrimitiveType, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -79,3 +79,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(bufferObject.PrimitiveType, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fdabdd1156f919672c04051531ad2105f2b2127a">Implemented suggestion from Code Analysis.</a>  -  fdabdd1</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 2 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 7839198..1656fb4 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -105,12 +105,4 @@ namespace KAOS.Managers
             bitmap.UnlockBits(bitmapData);
-
-            CleanUp();
-        }
-
-        private void CleanUp()
-        {
-            bitmap.Dispose();
         }
 
-
         public void Dispose()
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 1b9492f..e96452b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -11,3 +11,3 @@ namespace KAOS.States
 {
-    public class Skyboxstate : IGameObject
+    public class Skyboxstate : IDisposable, IGameObject
     {
@@ -148,2 +148,7 @@ namespace KAOS.States
         }
+
+        public void Dispose()
+        {
+            m_textureManager.Dispose();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5fe170c7d3e9eb3830e1d6fc2af7269ae57f1030">Removed a whole load of old unused code to remove all build warnings.</a>  -  5fe170c</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 18 files changed, 213 insertions(+), 942 deletions(-)

diff --git a/KAOS/Interfaces/IGroupNode.cs b/KAOS/Interfaces/IGroupNode.cs
new file mode 100644
index 0000000..802144d
--- /dev/null
+++ b/KAOS/Interfaces/IGroupNode.cs
@@ -0,0 +1,14 @@
+﻿using KAOS.Interfaces;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface IGroupNode : IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Interfaces/ISceneNode.cs b/KAOS/Interfaces/ISceneNode.cs
new file mode 100644
index 0000000..a07ccb6
--- /dev/null
+++ b/KAOS/Interfaces/ISceneNode.cs
@@ -0,0 +1,13 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 5fa9815..e755aac 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -23,4 +23,2 @@ namespace KAOS
         public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
 
@@ -174,3 +172,2 @@ namespace KAOS
             base.OnUnload(e);
-            GL.DeleteTexture(Renderer.m_texId);
         }
diff --git a/KAOS/Nodes/AWCube.cs b/KAOS/Nodes/AWCube.cs
deleted file mode 100644
index 58875a5..0000000
--- a/KAOS/Nodes/AWCube.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿using KAOS.Shapes;
-using KAOS.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    public class AWCube : AWNode, ISceneNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public Vector3[] Vertices
-        {
-            get { return CubeVertices; }
-        }
-
-        public int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/AWGraphLines.cs b/KAOS/Nodes/AWGraphLines.cs
deleted file mode 100644
index 1e65c18..0000000
--- a/KAOS/Nodes/AWGraphLines.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWGraphLines : AWNode, ISceneNode
-    {
-        private int m_gridSize = 20;
-
-        public Vector3[] Vertices
-        {
-            get { return m_vertices; }
-        }
-
-        private static Vector3[] m_vertices;
-
-        public AWGraphLines(int gridSize)
-        {
-            m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize * 2];
-            BuildVertices();
-        }
-
-        private void BuildVertices()
-        {
-            for (int i = 0; i < m_gridSize *2; i += 4)
-            {
-                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
-                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
-                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
-                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
-            }
-        }
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/AWGroupNode.cs b/KAOS/Nodes/AWGroupNode.cs
index 0fb12d0..f40140e 100644
--- a/KAOS/Nodes/AWGroupNode.cs
+++ b/KAOS/Nodes/AWGroupNode.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Graphics.OpenGL;
+﻿using KAOS.Interfaces;
+using OpenTK.Graphics.OpenGL;
 using System;
diff --git a/KAOS/Nodes/AWMesh.cs b/KAOS/Nodes/AWMesh.cs
deleted file mode 100644
index d5f77a0..0000000
--- a/KAOS/Nodes/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/KAOS/Nodes/AWParticles.cs b/KAOS/Nodes/AWParticles.cs
deleted file mode 100644
index 44911f9..0000000
--- a/KAOS/Nodes/AWParticles.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWParticles : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-
-}
-/*
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
-        */
\ No newline at end of file
diff --git a/KAOS/Nodes/AWPolygon.cs b/KAOS/Nodes/AWPolygon.cs
deleted file mode 100644
index 85afb1d..0000000
--- a/KAOS/Nodes/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/IGroupNode.cs b/KAOS/Nodes/IGroupNode.cs
deleted file mode 100644
index 888793f..0000000
--- a/KAOS/Nodes/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface IGroupNode : IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/KAOS/Nodes/ISceneNode.cs b/KAOS/Nodes/ISceneNode.cs
deleted file mode 100644
index 0924346..0000000
--- a/KAOS/Nodes/ISceneNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
diff --git a/KAOS/States/AssimpImportedState.cs b/KAOS/States/AssimpImportedState.cs
deleted file mode 100644
index 40dbc84..0000000
--- a/KAOS/States/AssimpImportedState.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-
-namespace KAOS.States
-{
-    public class AssimpImportedState :IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-
-        public AssimpImportedState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Render()
-        {
-
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-    }
-}
diff --git a/KAOS/States/DefaultState.cs b/KAOS/States/DefaultState.cs
deleted file mode 100644
index e26345e..0000000
--- a/KAOS/States/DefaultState.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DefaultState : IGameObject
-    {
-        double currentRotation = 0;
-
-        StateManager m_stateManager;
-        public DefaultState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.Black);
-            GL.PointSize(5f);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.TriangleStrip);
-
-            GL.Color4(new Color4(1f, 0f, 0f, .5f));
-            GL.Vertex3(new Vector3(-50f, 0f, 0f));
-            GL.Color3(new Vector3(0f, 1f, 0f));
-            GL.Vertex3(new Vector3(50f, 0, 0));
-            GL.Color3(new Vector3(0f, 0f, 1f));
-            GL.Vertex3(new Vector3(0f, 50f, 0));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
index f83dcda..c41a56d 100644
--- a/KAOS/States/DrawSpriteState.cs
+++ b/KAOS/States/DrawSpriteState.cs
@@ -1,79 +1,79 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DrawSpriteState : IGameObject
-    {
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        double height, width, halfHeight, halfWidth, x, y, z;
-        float topUV, bottomUV, leftUV, rightUV;
-
-        #region IGameObject States
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            Texture texture = m_textureManager.Get("sprite1");
-            GL.Enable(EnableCap.Texture2D);
-            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-            GL.ClearColor(Color.Black);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.End();
-
-        } 
-        #endregion
-
-        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-        {
-            m_stateManager = stateManager;
-            m_textureManager = texturManager;
-            Initialise();
-        }
-
-        private void Initialise()
-        {
-            this.height = 200;
-            this.width = 200;
-
-            this.halfHeight = this.height / 2;
-            this.halfWidth = this.width / 2;
-
-            this.x = 0;
-            this.y = 0;
-            this.z = 2;
-
-            this.topUV = 0;
-            this.bottomUV = 1;
-            this.leftUV = 0;
-            this.rightUV = 1;
-        }
-    }
-}
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Utilities;
+//using OpenTK;
+//using OpenTK.Graphics.OpenGL;
+//using System.Drawing;
+
+//namespace KAOS.States
+//{
+//    public class DrawSpriteState : IGameObject
+//    {
+//        private StateManager m_stateManager;
+//        private TextureManager m_textureManager;
+
+//        double height, width, halfHeight, halfWidth, x, y, z;
+//        float topUV, bottomUV, leftUV, rightUV;
+
+//        #region IGameObject States
+
+//        public void Update(float elapsedTime)
+//        {
+//            //throw new NotImplementedException();
+//        }
+
+//        public void Render()
+//        {
+//            Texture texture = m_textureManager.Get("sprite1");
+//            GL.Enable(EnableCap.Texture2D);
+//            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
+//            GL.ClearColor(Color.Black);
+//            GL.Begin(PrimitiveType.Triangles);
+
+//            GL.TexCoord2(new Vector2d(leftUV, topUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
+//            GL.TexCoord2(new Vector2d(rightUV, topUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+//            GL.TexCoord2(new Vector2d(rightUV, topUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+//            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
+//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+//            GL.End();
+
+//        } 
+//        #endregion
+
+//        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
+//        {
+//            m_stateManager = stateManager;
+//            m_textureManager = texturManager;
+//            Initialise();
+//        }
+
+//        private void Initialise()
+//        {
+//            this.height = 200;
+//            this.width = 200;
+
+//            this.halfHeight = this.height / 2;
+//            this.halfWidth = this.width / 2;
+
+//            this.x = 0;
+//            this.y = 0;
+//            this.z = 2;
+
+//            this.topUV = 0;
+//            this.bottomUV = 1;
+//            this.leftUV = 0;
+//            this.rightUV = 1;
+//        }
+//    }
+//}
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
deleted file mode 100644
index 7faddb3..0000000
--- a/KAOS/States/VboState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Shapes;
-//using KAOS.Utilities;
-//using OpenTK.Graphics.OpenGL;
-//using System;
-
-//namespace KAOS.States
-//{
-//    public class VboState : IGameObject
-//    {
-//        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-//        BufferObject m_bufferObject;
-//        StateManager m_stateManager;
-//        Cube cube = new Cube(0, 0, 0);
-
-//        public VboState(StateManager stateManager)
-//        {
-//            m_stateManager = stateManager;
-
-//            CreateVBOs();
-//        }
-
-//        private void CreateVBOs()
-//        {
-//            BufferObject tempVBO = new BufferObject();
-//            tempVBO.PositionData = cube.Vertices;
-//            tempVBO.NormalsData = cube.Normals;
-//            tempVBO.IndicesData = cube.Indices;
-//            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-//            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
-//            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-//        }
-
-//        public void Update(float elapsedTime)
-//        {
-
-//        }
-
-//        public void Render()
-//        {
-//            GL.BindVertexArray(m_bufferObject.VaoID);
-//            GL.DrawElements(m_bufferObject.PrimitiveType,
-//                            m_bufferObject.IndicesData.Length,
-//                            DrawElementsType.UnsignedInt,
-//                            IntPtr.Zero);
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
index 4d80ab9..3cee9cd 100644
--- a/KAOS/Utilities/Block.cs
+++ b/KAOS/Utilities/Block.cs
@@ -1,29 +1,29 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿//using System;
+//using System.Collections.Generic;
+//using System.Linq;
+//using System.Text;
+//using System.Threading.Tasks;
 
-namespace KAOS.Utilities
-{
-    public class Block
-    {
-        enum BlockType
-        {
-            BlockType_Default = 0,
+//namespace KAOS.Utilities
+//{
+//    public class Block
+//    {
+//        enum BlockType
+//        {
+//            BlockType_Default = 0,
 
-            BlockType_Grass,
-            BlockType_Dirt,
-            BlockType_Water,
-            BlockType_Stone,
-            BlockType_Wood,
-            BlockType_Sand,
+//            BlockType_Grass,
+//            BlockType_Dirt,
+//            BlockType_Water,
+//            BlockType_Stone,
+//            BlockType_Wood,
+//            BlockType_Sand,
 
-            BlockType_NumTypes,
-        };
+//            BlockType_NumTypes,
+//        };
 
-        public bool IsActive { get; set; }
-        private bool m_active;
-        private BlockType type;
-    }
-}
+//        public bool IsActive { get; set; }
+//        private bool m_active;
+//        private BlockType type;
+//    }
+//}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
index 26681e0..0282844 100644
--- a/KAOS/Utilities/Chunk.cs
+++ b/KAOS/Utilities/Chunk.cs
@@ -1,91 +1,91 @@
-﻿using KAOS.Shapes;
-using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-namespace KAOS.Utilities
-{
-    public class Chunk : IDisposable
-    {
-        public const int CHUNK_SIZE = 16;
-        private Block[][][] m_blocks;
-        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+﻿//using KAOS.Shapes;
+//using OpenTK;
+//using System;
+//using System.Collections.Generic;
+//using System.Linq;
+//using System.Text;
+//using System.Threading.Tasks;
+//namespace KAOS.Utilities
+//{
+//    public class Chunk : IDisposable
+//    {
+//        public const int CHUNK_SIZE = 16;
+//        private Block[][][] m_blocks;
+//        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
 
-        public Chunk()
-        {
-            //Create Blocks
-            m_blocks = new Block[CHUNK_SIZE][][];
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                m_blocks[i] = new Block[CHUNK_SIZE][];
+//        public Chunk()
+//        {
+//            //Create Blocks
+//            m_blocks = new Block[CHUNK_SIZE][][];
+//            for (int i = 0; i < CHUNK_SIZE; i++)
+//            {
+//                m_blocks[i] = new Block[CHUNK_SIZE][];
 
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-                }
-            }
-        }
+//                for (int j = 0; j < CHUNK_SIZE; j++)
+//                {
+//                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+//                }
+//            }
+//        }
 
-        public void Update(float dt) { }
+//        public void Update(float dt) { }
 
-        public void Render() { }
+//        public void Render() { }
 
-        public void Dispose()
-        {
-            // Delete blocks
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
+//        public void Dispose()
+//        {
+//            // Delete blocks
+//            for (int i = 0; i < CHUNK_SIZE; i++)
+//            {
                 
 
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = null;
-                }
-                m_blocks[i] = null;
-            }
-            m_blocks = null;
-        }
+//                for (int j = 0; j < CHUNK_SIZE; j++)
+//                {
+//                    m_blocks[i][j] = null;
+//                }
+//                m_blocks[i] = null;
+//            }
+//            m_blocks = null;
+//        }
 
-        public void CreateMesh()
-        {
-            for (int x = 0; x < CHUNK_SIZE; x++)
-            {
-                for (int y = 0; y < CHUNK_SIZE; y++)
-                {
-                    for (int z = 0; z < CHUNK_SIZE; z++)
-                    {
-                        if (m_blocks[x][y][z].IsActive == false)
-                        {
-                            // Don't create triangle data for inactive blocks
-                            continue;
-                        }
+//        public void CreateMesh()
+//        {
+//            for (int x = 0; x < CHUNK_SIZE; x++)
+//            {
+//                for (int y = 0; y < CHUNK_SIZE; y++)
+//                {
+//                    for (int z = 0; z < CHUNK_SIZE; z++)
+//                    {
+//                        if (m_blocks[x][y][z].IsActive == false)
+//                        {
+//                            // Don't create triangle data for inactive blocks
+//                            continue;
+//                        }
 
-                        CreateCube(x, y, z);
-                    }
-                }
-            }
-        }
+//                        CreateCube(x, y, z);
+//                    }
+//                }
+//            }
+//        }
 
-        private void CreateCube(int x, int y, int z)
-        {
-            float blockSize = 1f;
+//        private void CreateCube(int x, int y, int z)
+//        {
+//            float blockSize = 1f;
 
             
-            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+//            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+//            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+//            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+//            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+//            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+//            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+//            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+//            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
 
-            Vector3 n1;
+//            Vector3 n1;
 
 
-            throw new NotImplementedException();
-        }
-    }
-}
+//            throw new NotImplementedException();
+//        }
+//    }
+//}
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index e1eb71c..a0a9e8e 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -17,9 +17,6 @@ namespace KAOS.Utilities
         internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
-        internal static int handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
-            m_displayList, m_texId, 
+        internal static Vector3 eyePosition;
+        internal static int 
+            handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
             handle_centre, handle_scale, handle_iter;
-
-        internal static Scene m_model;
-        internal static float m_angle;
         #endregion
@@ -81,2 +78,3 @@ namespace KAOS.Utilities
         }
+        
         internal static void ToggleWireframeOn()
@@ -91,287 +89,2 @@ namespace KAOS.Utilities
 
-        #region Assimp Example
-        public static void DrawModel()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.Normalize);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.LoadMatrix(ref lookat);
-
-            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            float tmp = m_sceneMax.X - m_sceneMin.X;
-            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            tmp = 1.0f / tmp;
-            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            GL.Translate(-m_sceneCenter);
-
-            if (m_displayList == 0)
-            {
-                m_displayList = GL.GenLists(1);
-                GL.NewList(m_displayList, ListMode.Compile);
-                RecursiveRender(m_model, m_model.RootNode);
-                GL.EndList();
-            }
-
-            GL.CallList(m_displayList);
-        }
-
-        private static void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private static void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private static void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private static void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private static void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private static Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private static Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private static Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/72361501abd6439a5fe4193882c403e3e9da03c3">Documentation updates.</a>  -  7236150</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 9 files changed, 27 insertions(+), 22 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 97c264f..e30466e 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -10,2 +10,5 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for uploading vertex data to the gpu and setting up vertex arrays.
+    /// </summary>
     public class BufferObjectManager
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index 83ddedd..c6e84e7 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -5,2 +5,5 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for polling user input, updating parameters as and when a change is detected.
+    /// </summary>
     public static class InputManager
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
index 92525db..4c8182d 100644
--- a/KAOS/Managers/ShaderManager.cs
+++ b/KAOS/Managers/ShaderManager.cs
@@ -12,3 +12,4 @@ namespace KAOS.Managers
     {
-        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+        #region Private Members
+        private static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
 
@@ -20,2 +21,3 @@ namespace KAOS.Managers
         private static string m_fragmentShaderFile = "skybox-fs";
+        #endregion
 
@@ -137,20 +139,2 @@ namespace KAOS.Managers
 
-        #region Public Methods
-
-        //public void SetUniforms(
-        //    out int projMatrixHandle, out int mvMatrixHandle,
-        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
-        //    Size dimensions, ref Camera camera)
-        //{
-        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        //} 
-        #endregion
-
     }
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
index 8a00128..f39e5e1 100644
--- a/KAOS/Managers/StateManager.cs
+++ b/KAOS/Managers/StateManager.cs
@@ -6,5 +6,8 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for managing different game states such as splash screen, menus, etc...
+    /// </summary>
     public class StateManager
     {
-        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        private Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
         IGameObject currentState = null;
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 1656fb4..f81dc83 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -9,5 +9,8 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for uploading textures to the GPU.
+    /// </summary>
     public class TextureManager : IDisposable
     {
-        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+        private Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
 
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
index 8de3bf5..7595374 100644
--- a/KAOS/Utilities/AnimationTimer.cs
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -8,2 +8,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Provides accurate timing information which may later be used for any animation.
+    /// </summary>
     public class AnimationTimer
diff --git a/KAOS/Utilities/Extensions.cs b/KAOS/Utilities/Extensions.cs
index 759ed2a..f7f6d4f 100644
--- a/KAOS/Utilities/Extensions.cs
+++ b/KAOS/Utilities/Extensions.cs
@@ -8,2 +8,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Extension methods belong here.
+    /// </summary>
     public static class Extensions
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
index 6e15e05..6ba58c9 100644
--- a/KAOS/Utilities/Logger.cs
+++ b/KAOS/Utilities/Logger.cs
@@ -7,3 +7,3 @@ namespace KAOS.Utilities
     /// <summary>
-    /// AWLogger
+    /// Responsible for displaying runtime information.
     /// </summary>
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index a0a9e8e..bd94465 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -13,2 +13,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Responsible for all rendering.
+    /// </summary>
     public static class Renderer

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6561af24985842cd648d925af0b33da0afe9429a">Slight refactoring.</a>  -  6561af2</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 4 files changed, 175 insertions(+), 177 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index e284cc0..6115a7c 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : KAOSWindow
+    class Game : KAOSEngine
     {
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
new file mode 100644
index 0000000..f4cdc0e
--- /dev/null
+++ b/KAOS/KAOSEngine.cs
@@ -0,0 +1,173 @@
+﻿using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// This is the main interface to the system. Inherit from here to get started.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS-Engine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+
+        protected AnimationTimer m_Timer;
+
+        MouseState current, previous;
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new AnimationTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
+        }
+
+        public abstract void Initialise();
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Mouse Input
+            current = OpenTK.Input.Mouse.GetState();
+            if (current[MouseButton.Left])
+            {
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
+                ResetCursor();
+            }
+            
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
deleted file mode 100644
index e755aac..0000000
--- a/KAOS/KAOSWindow.cs
+++ /dev/null
@@ -1,175 +0,0 @@
-﻿using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected AnimationTimer m_Timer;
-        
-        public KAOSWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new AnimationTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultSkyboxShader();
-            ShaderManager.LoadDefaultRenderShader();
-        }
-
-        public abstract void Initialise();
-
-        #endregion
-
-        MouseState current, previous;
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Mouse Input
-            current = OpenTK.Input.Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-                ResetCursor();
-            }
-            
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-    }
-}
\ No newline at end of file
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
index 6ba58c9..ef36cef 100644
--- a/KAOS/Utilities/Logger.cs
+++ b/KAOS/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
         {
-            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c9fd162018be4ceb0ce8bb4b51e97d700052274f">Removing redundant code.</a>  -  c9fd162</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 12 files changed, 1464 deletions(-)

diff --git a/KAOS/Managers/ModelManager.cs b/KAOS/Managers/ModelManager.cs
deleted file mode 100644
index c118589..0000000
--- a/KAOS/Managers/ModelManager.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿
-namespace KAOS.Managers
-{
-    class ModelManager
-    {
-    }
-}
diff --git a/KAOS/Scene/FBOScene.cs b/KAOS/Scene/FBOScene.cs
deleted file mode 100644
index ee33056..0000000
--- a/KAOS/Scene/FBOScene.cs
+++ /dev/null
@@ -1,246 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class FBOScene : DefaultScene
-    {
-        #region Private Member Variables
-        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
-
-        private uint ColorTexture;
-        private uint DepthTexture;
-        private uint FBOHandle;
-
-        private const int TextureSize = 512;
-
-        private DrawableShape Object;
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
-            {
-                throw new NotSupportedException(
-                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
-                Exit();
-            }
-
-            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearDepth(1.0);
-            GL.DepthFunc(DepthFunction.Lequal);
-
-            GL.Enable(EnableCap.CullFace);
-
-            // Create Color Tex
-            GL.GenTextures(1, out ColorTexture);
-            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create Depth Tex
-            GL.GenTextures(1, out DepthTexture);
-            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
-            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create a FBO and attach the textures
-            GL.Ext.GenFramebuffers(1, out FBOHandle);
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
-
-            #region Test for Error
-
-            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
-            {
-                case FramebufferErrorCode.FramebufferCompleteExt:
-                    {
-                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: There are no attachments.");
-                        break;
-                    }
-                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
-                     {
-                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
-                         break;
-                     }*/
-                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
-                    {
-                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
-                    {
-                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
-                    {
-                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
-                    {
-                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferUnsupportedExt:
-                    {
-                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
-                        break;
-                    }
-                default:
-                    {
-                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
-                        break;
-                    }
-            }
-
-            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
-            int[] queryinfo = new int[6];
-            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
-            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
-            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
-            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
-            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
-            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
-            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
-                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
-
-            Console.WriteLine("Last GL Error: " + GL.GetError());
-
-            #endregion Test for Error
-
-            GL.PushAttrib(AttribMask.ViewportBit);
-            {
-                GL.Viewport(0, 0, TextureSize, TextureSize);
-
-                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
-                GL.ClearColor(1f, 0f, 0f, 0f);
-                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
-                GL.MatrixMode(MatrixMode.Projection);
-                GL.LoadMatrix(ref perspective);
-
-                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
-                GL.MatrixMode(MatrixMode.Modelview);
-                GL.LoadMatrix(ref lookat);
-
-                // draw some complex object into the FBO's textures
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.Light0);
-                GL.Enable(EnableCap.ColorMaterial);
-                GL.Color3(0f, 1f, 0f);
-                Object.Draw();
-                GL.Disable(EnableCap.ColorMaterial);
-                GL.Disable(EnableCap.Light0);
-                GL.Disable(EnableCap.Lighting);
-
-            }
-            GL.PopAttrib();
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
-
-            GL.ClearColor(.1f, .2f, .3f, 0f);
-            GL.Color3(1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
-            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            double aspect_ratio = Width / (double)Height;
-
-            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-        }
-    }
-}
diff --git a/KAOS/Scene/PickerScene.cs b/KAOS/Scene/PickerScene.cs
deleted file mode 100644
index 3aca921..0000000
--- a/KAOS/Scene/PickerScene.cs
+++ /dev/null
@@ -1,204 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
-    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
-    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
-    /// </summary>
-    public class PickerScene : DefaultScene
-    {
-        public PickerScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Member variable
-        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
-        private float angle;
-        private BeginMode VBO_PrimMode;
-        private Vertex[] VBO_Array;
-        uint VBO_Handle;
-
-        private uint SelectedTriangle;
-
-        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
-        #endregion
-
-        #region OnLoad
-        /// <summary>Load resources here.</summary>
-        /// <param name="e">Not used.</param>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.CullFace);
-
-            #region prepare data for VBO from procedural object
-            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
-            VertexT2fN3fV3f[] temp_VBO;
-            uint[] temp_IBO;
-            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
-            temp_obj.Dispose();
-            if (temp_IBO != null)
-                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
-
-            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
-            VBO_Array = new Vertex[temp_VBO.Length];
-            int TriangleCounter = -1;
-            for (int i = 0; i < temp_VBO.Length; i++)
-            {
-                // Position
-                VBO_Array[i].Position = temp_VBO[i].Position;
-
-                // Index
-                if (i % 3 == 0)
-                    TriangleCounter++;
-                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
-            }
-            #endregion prepare data for VBO from procedural object
-
-            #region Setup VBO for drawing
-            GL.GenBuffers(1, out VBO_Handle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
-            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
-            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
-            #endregion Setup VBO for drawing
-
-            #region Shader
-
-            //create and compile shaders
-            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
-
-            //create program object, attach shaders and link
-            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
-
-            // flag ShaderObjects for delete when not used anymore
-            GL.DeleteShader(VertexShaderObject);
-            GL.DeleteShader(FragmentShaderObject);
-
-            GL.UseProgram(0);
-
-            #endregion Shader
-
-        }
-        #endregion
-
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.DeleteBuffers(1, ref VBO_Handle);
-
-            base.OnUnload(e);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Called when your window is resized. Set your viewport here. It is also
-        /// a good place to set up your projection matrix (which probably changes
-        /// along when the aspect ratio of your window).
-        /// </summary>
-        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref projection);
-        }
-        #endregion
-
-        #region OnRenderFrame
-        /// <summary>
-        /// Called when it is time to render the next frame. Add your rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Color3(Color.White);
-            GL.EnableClientState(EnableCap.ColorArray);
-
-            #region Pass 1: Draw Object and pick Triangle
-            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref modelview);
-            GL.Translate(0f, 0f, -3f);
-            GL.Rotate(angle, Vector3.UnitX);
-            GL.Rotate(angle, Vector3.UnitY);
-            angle += (float)e.Time * 3.0f;
-
-            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
-             GL.UseProgram(ProgramObject);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            // GL.UseProgram(0);
-
-            // Read Pixel under mouse cursor
-            Byte4 Pixel = new Byte4();
-            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
-            SelectedTriangle = Pixel.ToUInt32();
-            #endregion Pass 1: Draw Object and pick Triangle
-
-            GL.Color3(Color.White);
-            GL.DisableClientState(EnableCap.ColorArray);
-
-            #region Pass 2: Draw Shape
-            if (SelectedTriangle == uint.MaxValue)
-                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
-            else
-                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.Color3(1f, 1f, 1f);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-            GL.Color3(Color.Red);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-
-            if (SelectedTriangle != uint.MaxValue)
-            {
-                GL.Disable(EnableCap.DepthTest);
-                GL.Color3(Color.Green);
-                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
-                GL.Enable(EnableCap.DepthTest);
-            }
-            #endregion Pass 2: Draw Shape
-
-            this.SwapBuffers();
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Error at Swapbuffers: " + err);
-        }
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-}
diff --git a/KAOS/Scene/StencilCSGScene.cs b/KAOS/Scene/StencilCSGScene.cs
deleted file mode 100644
index 8acb843..0000000
--- a/KAOS/Scene/StencilCSGScene.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class StencilCSGScene : DefaultScene
-    {
-        #region Model Related
-        private DrawableShape OperandB;
-        private DrawableShape OperandA;
-        private float MySphereZOffset = 0f;
-        private float MySphereXOffset = 0f;
-
-        private int Texture;
-        #endregion Model Related
-
-        private bool ShowDebugWireFrame = true;
-
-        private float CameraZoom;
-        private float CameraRotX;
-        private float CameraRotY;
-        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
-
-        #region Window
-        public StencilCSGScene()
-        {
-            base.VSync = VSyncMode.Off;
-            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
-            {
-                switch (e.Key)
-                {
-                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
-                }
-            };
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
-            GL.LoadMatrix(ref p);
-        }
-        #endregion Window
-
-        public override void Setup(EventArgs e)
-        {
-            #region Abort on platforms which will not be able to execute the ops properly
-            /*
-            if (!GL.SupportsExtension("VERSION_1_2"))
-            {
-                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
-                this.Exit();
-            }
-
-            int[] t = new int[2];
-            GL.GetInteger(GetPName.MajorVersion, out t[0]);
-            GL.GetInteger(GetPName.MinorVersion, out t[1]);
-            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
-
-            GL.GetInteger(GetPName.DepthBits, out t[0]);
-            Trace.WriteLine("Depth Bits: " + t[0]);
-            GL.GetInteger(GetPName.StencilBits, out t[1]);
-            Trace.WriteLine("Stencil Bits: " + t[1]);
-
-            if (t[0] < 16)
-            {
-                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
-                this.Exit();
-            }
-
-            if (t[1] < 1)
-            {
-                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
-                this.Exit();
-            }
-            */
-            #endregion Abort on platforms which will not be able to execute the ops properly
-
-            #region GL States
-            GL.ClearColor(.08f, .12f, .16f, 1f);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Less);
-            GL.ClearDepth(1.0);
-
-            GL.Enable(EnableCap.StencilTest);
-            GL.ClearStencil(0);
-            GL.StencilMask(0xFFFFFFFF); // read&write
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-            GL.CullFace(CullFaceMode.Back);
-
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-
-            GL.Color4(1f, 1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.ShadeModel(ShadingModel.Smooth);
-
-            #endregion GL States
-
-            #region Load Texture
-            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
-            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
-
-            GL.GenTextures(1, out Texture);
-            GL.BindTexture(TextureTarget.Texture2D, Texture);
-
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.Finish();
-            bitmap.UnlockBits(data);
-            #endregion Load Texture
-
-            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
-            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
-                                           SlicedSphere.eSubdivisions.Three,
-                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
-                                           true);
-
-            #region Invert Operand B's Normals
-            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
-            BeginMode tempPrimMode;
-            VertexT2dN3dV3d[] tempVertices;
-            uint[] tempIndices;
-
-            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
-            OperandB.Dispose();
-
-            for (int i = 0; i < tempVertices.Length; i++)
-            {
-                tempVertices[i].Normal *= -1.0;
-                tempVertices[i].Normal.Normalize();
-            }
-
-            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
-            #endregion Invert Operand B's Normals
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref Texture);
-
-            OperandA.Dispose();
-            OperandB.Dispose();
-
-            base.OnUnload(e);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Magic numbers for camera
-            CameraRotX = -Mouse.X * .5f;
-            CameraRotY = Mouse.Y * .5f;
-            CameraZoom = Mouse.Wheel * .2f;
-            #endregion Magic numbers for camera
-        }
-
-        public void DrawOperandB()
-        {
-            GL.PushMatrix();
-            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
-            OperandB.Draw();
-            GL.PopMatrix();
-        }
-
-        public void DrawOperandA()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            OperandA.Draw();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        public void RenderCsg()
-        {
-            // first pass
-            GL.Disable(EnableCap.StencilTest);
-
-            GL.ColorMask(false, false, false, false);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB();// draw front-faces into depth buffer
-
-            // use stencil plane to find parts of b in a 
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // increment the stencil where the front face of a is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
-            DrawOperandB(); // draw the part of b that's in a
-
-            // fix depth
-            GL.ColorMask(false, false, false, false);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Disable(EnableCap.StencilTest);
-            GL.DepthFunc(DepthFunction.Always);
-            DrawOperandA();
-            GL.DepthFunc(DepthFunction.Less);
-
-            // second pass
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA();
-
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            DrawOperandB(); // increment the stencil where the front face of b is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Equal, 0, 1);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // draw the part of a that's in b
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
-
-            MySphereZOffset += (float)(e.Time * 3.1);
-            MySphereXOffset += (float)(e.Time * 4.2);
-
-            #region Transform setup
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
-
-            // Camera
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-
-            GL.Translate(0f, 0f, CameraZoom);
-            GL.Rotate(CameraRotX, Vector3.UnitY);
-            GL.Rotate(CameraRotY, Vector3.UnitX);
-            #endregion Transform setup
-
-            RenderCsg();
-
-            // ---------------------------------
-
-            if (ShowDebugWireFrame)
-            {
-                GL.Color3(System.Drawing.Color.LightGray);
-                GL.Disable(EnableCap.StencilTest);
-                GL.Disable(EnableCap.Lighting);
-                //GL.Disable( EnableCap.DepthTest );
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-                DrawOperandB();
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-                GL.Enable(EnableCap.DepthTest);
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.StencilTest);
-            }
-            SwapBuffers();
-        }
-
-    }
-}
diff --git a/KAOS/Scene/StereoVisionScene.cs b/KAOS/Scene/StereoVisionScene.cs
deleted file mode 100644
index 2b84210..0000000
--- a/KAOS/Scene/StereoVisionScene.cs
+++ /dev/null
@@ -1,164 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVisionScene : DefaultScene
-    {
-        public StereoVisionScene()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            Angle += (float)(e.Time * 20.0);
-
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    
-    }
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/KAOS/Scene/Texture2DScene.cs b/KAOS/Scene/Texture2DScene.cs
deleted file mode 100644
index ec53ee7..0000000
--- a/KAOS/Scene/Texture2DScene.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class Texture2DScene : DefaultScene
-    {
-        #region Private Members
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.Texture2D);
-
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            bitmap.UnlockBits(data);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
-        }
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref texture);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.Begin(BeginMode.Quads);
-
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            GL.End();
-
-            SwapBuffers();
-        }
-        #endregion
-
-    }
-}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
deleted file mode 100644
index c41a56d..0000000
--- a/KAOS/States/DrawSpriteState.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Utilities;
-//using OpenTK;
-//using OpenTK.Graphics.OpenGL;
-//using System.Drawing;
-
-//namespace KAOS.States
-//{
-//    public class DrawSpriteState : IGameObject
-//    {
-//        private StateManager m_stateManager;
-//        private TextureManager m_textureManager;
-
-//        double height, width, halfHeight, halfWidth, x, y, z;
-//        float topUV, bottomUV, leftUV, rightUV;
-
-//        #region IGameObject States
-
-//        public void Update(float elapsedTime)
-//        {
-//            //throw new NotImplementedException();
-//        }
-
-//        public void Render()
-//        {
-//            Texture texture = m_textureManager.Get("sprite1");
-//            GL.Enable(EnableCap.Texture2D);
-//            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-//            GL.ClearColor(Color.Black);
-//            GL.Begin(PrimitiveType.Triangles);
-
-//            GL.TexCoord2(new Vector2d(leftUV, topUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-//            GL.TexCoord2(new Vector2d(rightUV, topUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-//            GL.TexCoord2(new Vector2d(rightUV, topUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-//            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-//            GL.End();
-
-//        } 
-//        #endregion
-
-//        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-//        {
-//            m_stateManager = stateManager;
-//            m_textureManager = texturManager;
-//            Initialise();
-//        }
-
-//        private void Initialise()
-//        {
-//            this.height = 200;
-//            this.width = 200;
-
-//            this.halfHeight = this.height / 2;
-//            this.halfWidth = this.width / 2;
-
-//            this.x = 0;
-//            this.y = 0;
-//            this.z = 2;
-
-//            this.topUV = 0;
-//            this.bottomUV = 1;
-//            this.leftUV = 0;
-//            this.rightUV = 1;
-//        }
-//    }
-//}
diff --git a/KAOS/States/TestSpriteClassState.cs b/KAOS/States/TestSpriteClassState.cs
deleted file mode 100644
index 814b797..0000000
--- a/KAOS/States/TestSpriteClassState.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.States
-{
-    public class TestSpriteClassState : IGameObject
-    {
-        Renderer m_renderer = new Renderer();
-        TextureManager m_textureManager = new TextureManager();
-        Sprite sprite1 = new Sprite();
-        Sprite sprite2 = new Sprite();
-
-        public TestSpriteClassState(TextureManager textureManager)
-        {
-            m_textureManager = textureManager;
-            sprite1.Texture = m_textureManager.Get("sprite1");
-            sprite1.SetHeight(256 * 0.5f);
-            sprite1.SetPosition(new Vector3d(100, 100, 0));
-            sprite1.SetColour(new Color4(256, 256, 256, 1));
-
-            sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetHeight(256 * .5f);
-            sprite2.SetPosition(new Vector3d(-100, -100, 0));
-            sprite2.SetColour(new Color4(256, 256, 256, 1));
-        }
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(1f, 1f, 1f, 1f);
-            m_renderer.DrawSprite(sprite1);
-            m_renderer.DrawSprite(sprite2);
-            GL.Finish();
-        }
-    }
-}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
deleted file mode 100644
index e6f0ee8..0000000
--- a/KAOS/States/VoxelState.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Shapes;
-//using KAOS.Utilities;
-//using OpenTK.Graphics.OpenGL;
-//using System;
-
-//namespace KAOS.States
-//{
-//    public class VoxelState : IGameObject
-//    {
-//        double currentRotation = 0;
-//        public float length = 1f, height = 1f, width = 1f;
-
-//        StateManager m_stateManager = new StateManager();
-
-//        BufferObjectManager m_bufferObjectManager;
-//        BufferObject m_bufferObject;
-
-//        TextureManager m_textureManager = new TextureManager();
-
-//        Cube[][][] m_blocks;
-
-//        public VoxelState(StateManager stateManager)
-//        {
-//            m_stateManager = stateManager;
-
-//            m_bufferObjectManager = new BufferObjectManager();
-
-//            //LoadSkyBox();
-
-//            GenerateChunk();
-//        }
-
-//        private void LoadSkyBox()
-//        {
-//            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-//            m_textureManager.LoadSkyTexture("skybox", 
-//                new string[] 
-//                {
-//                    skyboxTexturePath + "jajlands1_ft.jpg",
-//                    skyboxTexturePath + "jajlands1_bk.jpg",
-//                    skyboxTexturePath + "jajlands1_lf.jpg",
-//                    skyboxTexturePath + "jajlands1_rt.jpg",
-//                    skyboxTexturePath + "jajlands1_up.jpg",
-//                    skyboxTexturePath + "jajlands1_dn.jpg"
-//                }
-//            );
-
-//        }
-
-//        private void GenerateChunk()
-//        {
-//            BufferObject tmpVBO = new BufferObject();
-//            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-//            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
-            
-//            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-//            {
-//                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-//                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-//                {
-//                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-//                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-//                    {
-//                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-//                        if (x == 0 && y == 0 && z == 0) 
-//                        { 
-//                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-//                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-//                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-//                        }
-//                        else
-//                        { 
-//                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-//                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-//                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-//                        }
-//                    }
-//                }
-//            }
-
-//            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-//            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-//        }
-
-//        public void Update(float elapsedTime)
-//        {
-//            currentRotation = 100 * elapsedTime;
-//        }
-
-//        public void Render()
-//        {
-//            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-//            GL.BindVertexArray(m_bufferObject.VaoID);
-//            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
deleted file mode 100644
index 3cee9cd..0000000
--- a/KAOS/Utilities/Block.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿//using System;
-//using System.Collections.Generic;
-//using System.Linq;
-//using System.Text;
-//using System.Threading.Tasks;
-
-//namespace KAOS.Utilities
-//{
-//    public class Block
-//    {
-//        enum BlockType
-//        {
-//            BlockType_Default = 0,
-
-//            BlockType_Grass,
-//            BlockType_Dirt,
-//            BlockType_Water,
-//            BlockType_Stone,
-//            BlockType_Wood,
-//            BlockType_Sand,
-
-//            BlockType_NumTypes,
-//        };
-
-//        public bool IsActive { get; set; }
-//        private bool m_active;
-//        private BlockType type;
-//    }
-//}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
deleted file mode 100644
index 0282844..0000000
--- a/KAOS/Utilities/Chunk.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿//using KAOS.Shapes;
-//using OpenTK;
-//using System;
-//using System.Collections.Generic;
-//using System.Linq;
-//using System.Text;
-//using System.Threading.Tasks;
-//namespace KAOS.Utilities
-//{
-//    public class Chunk : IDisposable
-//    {
-//        public const int CHUNK_SIZE = 16;
-//        private Block[][][] m_blocks;
-//        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
-
-//        public Chunk()
-//        {
-//            //Create Blocks
-//            m_blocks = new Block[CHUNK_SIZE][][];
-//            for (int i = 0; i < CHUNK_SIZE; i++)
-//            {
-//                m_blocks[i] = new Block[CHUNK_SIZE][];
-
-//                for (int j = 0; j < CHUNK_SIZE; j++)
-//                {
-//                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-//                }
-//            }
-//        }
-
-//        public void Update(float dt) { }
-
-//        public void Render() { }
-
-//        public void Dispose()
-//        {
-//            // Delete blocks
-//            for (int i = 0; i < CHUNK_SIZE; i++)
-//            {
-                
-
-//                for (int j = 0; j < CHUNK_SIZE; j++)
-//                {
-//                    m_blocks[i][j] = null;
-//                }
-//                m_blocks[i] = null;
-//            }
-//            m_blocks = null;
-//        }
-
-//        public void CreateMesh()
-//        {
-//            for (int x = 0; x < CHUNK_SIZE; x++)
-//            {
-//                for (int y = 0; y < CHUNK_SIZE; y++)
-//                {
-//                    for (int z = 0; z < CHUNK_SIZE; z++)
-//                    {
-//                        if (m_blocks[x][y][z].IsActive == false)
-//                        {
-//                            // Don't create triangle data for inactive blocks
-//                            continue;
-//                        }
-
-//                        CreateCube(x, y, z);
-//                    }
-//                }
-//            }
-//        }
-
-//        private void CreateCube(int x, int y, int z)
-//        {
-//            float blockSize = 1f;
-
-            
-//            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-//            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-//            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-//            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-//            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-//            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-//            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-//            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
-
-//            Vector3 n1;
-
-
-//            throw new NotImplementedException();
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Sprite.cs b/KAOS/Utilities/Sprite.cs
deleted file mode 100644
index 8ce0c32..0000000
--- a/KAOS/Utilities/Sprite.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class Sprite
-    {
-        internal const int VertexAmount = 6;
-        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
-        Color4[] vertexColours = new Color4[VertexAmount];
-        Vector2[] vertexUVs = new Vector2[VertexAmount];
-        Texture texture = new Texture();
-
-        public Texture Texture
-        {
-            get { return texture; }
-            set
-            {
-                texture = value;
-
-                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
-            }
-        }
-        public Vector3d[] VertexPositions { get { return vertexPositions; } }
-
-        public Color4[] VertexColours { get { return vertexColours; } }
-
-        public Vector2[] VertexUVs { get { return vertexUVs; } }
-
-        public Sprite()
-        {
-            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            //SetColour(new Color4(1, 1, 1, 1));
-            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
-        }
-
-        private Vector3d GetCentre()
-        {
-            double halfWidth = GetWidth() / 2;
-            double halfHeight = GetHeight() / 2;
-
-            return new Vector3d(
-                vertexPositions[0].X + halfWidth,
-                vertexPositions[0].Y - halfHeight,
-                vertexPositions[0].Z);
-        }
-
-        private void InitVertexPositions(Vector3d position, double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-
-            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-
-            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-        }
-
-        public double GetWidth()
-        {
-            //top right -> top left
-            return vertexPositions[1].X - vertexPositions[0].X;
-        }
-
-        public double GetHeight()
-        {
-            //top left -> bottom left
-            return vertexPositions[0].Y - vertexPositions[2].Y;
-        }
-
-        public void SetWidth(double width)
-        {
-            InitVertexPositions(GetCentre(), width, GetHeight());
-        }
-
-        public void SetHeight(double height)
-        {
-            InitVertexPositions(GetCentre(), GetWidth(), height);
-        }
-
-        public void SetPosition(double x, double y)
-        {
-            SetPosition(new Vector3d(x, y, 0));
-        }
-
-        public void SetPosition(Vector3d position)
-        {
-            InitVertexPositions(position, GetWidth(), GetHeight());
-        }
-
-        public void SetColour(Color4 color4)
-        {
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                vertexColours[i] = color4;
-            }
-        }
-
-        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
-        {
-            vertexUVs[0] = topLeft;
-            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
-
-            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[4] = bottomRight;
-            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/00a816df5fc5d185bf8fe187db800d274e737861">Moving input handling to a separate class.</a>  -  00a816d</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 2 files changed, 32 insertions(+), 29 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index f4cdc0e..eb862c7 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -24,4 +24,2 @@ namespace KAOS
         protected AnimationTimer m_Timer;
-
-        MouseState current, previous;
         
@@ -42,3 +40,2 @@ namespace KAOS
             InitialiseTimer();
-            InitialiseInput();
             InitialiseStockShaders();
@@ -46,8 +43,2 @@ namespace KAOS
 
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
         private void InitialiseTimer()
@@ -70,19 +61,4 @@ namespace KAOS
         {
-            #region Mouse Input
-            current = OpenTK.Input.Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-                ResetCursor();
-            }
-            
-            #endregion
+            InputManager.PollInput();
+            ResetCursor();
 
@@ -131,3 +107,3 @@ namespace KAOS
         #region Input Control
-        
+
         private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index c6e84e7..be3edc1 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Input;
+﻿using OpenTK;
+using OpenTK.Input;
 using System.Collections.Generic;
@@ -10,5 +11,31 @@ namespace KAOS.Managers
     {
-        public static List<Key> keyList = new List<Key>();
+        internal static List<Key> keyList = new List<Key>();
 
+        internal static MouseState current, previous;
+        internal static KeyboardState keyState;
 
+        internal static void PollInput()
+        {
+            #region Keyboard
+            keyState = Keyboard.GetState();
+
+            #endregion
+
+            #region Mouse
+            current = Mouse.GetState();
+            if (current[MouseButton.Left])
+            {
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
+            }
+
+            #endregion
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8f9c7a8a3697332dbf2d8aec53739d0ad1819f58">Moved more input implementation into it's own class.</a>  -  8f9c7a8</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 4 files changed, 58 insertions(+), 78 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index eb862c7..e416431 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -40,2 +40,3 @@ namespace KAOS
             InitialiseTimer();
+            InitialiseInput();
             InitialiseStockShaders();
@@ -43,2 +44,8 @@ namespace KAOS
 
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
         private void InitialiseTimer()
@@ -96,9 +103,2 @@ namespace KAOS
             float aspect = ScreenWidth / (float)ScreenHeight;
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
         }
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index be3edc1..21e6993 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -18,8 +18,8 @@ namespace KAOS.Managers
         {
-            #region Keyboard
-            keyState = Keyboard.GetState();
-
-            #endregion
+            KeyboardUpdate();
+            MouseUpdate();
+        }
 
-            #region Mouse
+        private static void MouseUpdate()
+        {
             current = Mouse.GetState();
@@ -37,5 +37,50 @@ namespace KAOS.Managers
             }
+        }
+
+        private static void KeyboardUpdate()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Utilities.Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Utilities.Camera.Move(-0.1f, 0f, 0f);
+                        break;
 
-            #endregion
+                    case Key.S:
+                        Utilities.Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Utilities.Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Utilities.Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Utilities.Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Utilities.Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Utilities.Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+            }
         }
+
     }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index e96452b..9cfca73 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,4 +84,2 @@ namespace KAOS.States
         {
-            MoveCamera();
-
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
@@ -100,51 +98,2 @@ namespace KAOS.States
 
-        #region Input Control
-        private void MoveCamera()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-
-            }
-        #endregion
-        }
-
         public void Dispose()
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index bd94465..abc0782 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -33,16 +33,2 @@ namespace KAOS.Utilities
 
-        public static void DrawSprite(Sprite sprite)
-        {
-            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles);
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                DrawImmediateModeVertex(
-                    sprite.VertexPositions[i],
-                    sprite.VertexColours[i],
-                    sprite.VertexUVs[i]);
-            }
-            GL.End();
-        }
-
         public static void DrawSkyBox(TextureManager textureManager, BufferObject bufferObject)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2287b63bc37ba5a750637cc84efdb99125731e6b">Removing more redundant code.</a>  -  2287b63</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 19 files changed, 367 deletions(-)

diff --git a/KAOS/Data/Shaders/CH02_FS.glsl b/KAOS/Data/Shaders/CH02_FS.glsl
deleted file mode 100644
index dff573e..0000000
--- a/KAOS/Data/Shaders/CH02_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-#version 140 core
-
-out vec4 color;
-
-void main(void)
-{
-	color = vec4(0.0, 0.8, 0.0, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CH02_VS.glsl b/KAOS/Data/Shaders/CH02_VS.glsl
deleted file mode 100644
index 6a17ae4..0000000
--- a/KAOS/Data/Shaders/CH02_VS.glsl
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿#version 140 core
-
-void main(void)
-{
-	const vec4 vertices[3] = vec4[3](
-		vec4(0.25, -0.25, 0.5, 1.0),
-		vec4(-0.25, 0.25, 0.5, 1.0),
-		vec4(0.25, 0.25, 0.5, 1.0)
-		);
-	// Index into our array using gl_VertexID
-	gl_Position = vertices[gl_VertexID];
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_FS.glsl b/KAOS/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/KAOS/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_VS.glsl b/KAOS/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/KAOS/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/FS.glsl b/KAOS/Data/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/KAOS/Data/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_VS.glsl b/KAOS/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/KAOS/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_FS.glsl b/KAOS/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/KAOS/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_VS.glsl b/KAOS/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/KAOS/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_FS.glsl b/KAOS/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/KAOS/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_VS.glsl b/KAOS/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/KAOS/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_FS.glsl b/KAOS/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/KAOS/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_VS.glsl b/KAOS/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/KAOS/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/VS.glsl b/KAOS/Data/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/KAOS/Data/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-fs.glsl b/KAOS/Data/Shaders/opentk-fs.glsl
deleted file mode 100644
index f890462..0000000
--- a/KAOS/Data/Shaders/opentk-fs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in vec3 normal;
-
-out vec4 out_frag_color;
-
-void main(void)
-{
-  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
-  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-vs.glsl b/KAOS/Data/Shaders/opentk-vs.glsl
deleted file mode 100644
index 1cd8777..0000000
--- a/KAOS/Data/Shaders/opentk-vs.glsl
+++ /dev/null
@@ -1,26 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-// object space to camera space transformation
-uniform mat4 modelview_matrix;
- 
-// camera space to clip coordinates
-uniform mat4 projection_matrix;
- 
-// incoming vertex position
-in vec3 in_position;
- 
-// incoming vertex normal
-in vec3 in_normal;
- 
-// transformed vertex normal
-out vec3 normal;
-
-void main(void)
-{
-  //works only for orthogonal modelview
-  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
-  
-  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-fs.glsl b/KAOS/Data/Shaders/spincube-fs.glsl
deleted file mode 100644
index a8d60b9..0000000
--- a/KAOS/Data/Shaders/spincube-fs.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-#version 330 core                                                  
-                                                                               
-out vec4 color;                                                    
-                                                                               
-in VS_OUT                                                          
-{                                                                  
-    vec4 color;                                                    
-} fs_in;                                                           
-                                                                               
-void main(void)                                                    
-{                                                                  
-    color = fs_in.color;                                           
-}    
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-vs.glsl b/KAOS/Data/Shaders/spincube-vs.glsl
deleted file mode 100644
index 9de1ae1..0000000
--- a/KAOS/Data/Shaders/spincube-vs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 330 core                                                   
-                                                                                
-in vec4 position;                                                   
-                                                                                
-out VS_OUT                                                          
-{                                                                   
-    vec4 color;                                                     
-} vs_out;                                                           
-                                                                                
-uniform mat4 mv_matrix;                                             
-uniform mat4 proj_matrix;                                           
-                                                                                
-void main(void)                                                     
-{                                                                   
-    gl_Position = proj_matrix * mv_matrix * position;               
-    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
-}   
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9519e4015c6e0dd051d0678799bdb587807aeec6">and more organising.</a>  -  9519e40</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 9cfca73..d52abeb 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -19,3 +19,3 @@ namespace KAOS.States
 
-        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        static string defaultSkyboxPath = "Data/Textures/skybox/";
         string[] skyboxFaces = new String[]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0eb21b64fad28b9ce647c7d1416796e3cfa40121">More tidying.</a>  -  0eb21b6</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 3 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index f81dc83..359485a 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -21,3 +21,3 @@ namespace KAOS.Managers
 
-        private int textureGpuHandle;
+        private int textureGpuHandle, textureVao;
         private Bitmap bitmap;
@@ -44,3 +44,3 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
@@ -67,3 +67,3 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
@@ -94,3 +94,10 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            //GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            //GL.GenVertexArrays(1, out textureVao);
+            //GL.BindVertexArray(textureVao);
+
+            //GL.DepthFunc(DepthFunction.Lequal);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d52abeb..4b3ac6b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -17,4 +17,2 @@ namespace KAOS.States
 
-        Cube cube;
-
         static string defaultSkyboxPath = "Data/Textures/skybox/";
@@ -30,4 +28,2 @@ namespace KAOS.States
 
-        int skybox_vao;
-
         float aspect = 1024 / (float)600;
@@ -67,8 +63,2 @@ namespace KAOS.States
             m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-            GL.Enable(EnableCap.TextureCubeMapSeamless);
-
-            GL.GenVertexArrays(1, out skybox_vao);
-            GL.BindVertexArray(skybox_vao);
-
-            GL.DepthFunc(DepthFunction.Lequal);
         }
@@ -77,4 +67,3 @@ namespace KAOS.States
         {
-            cube = new Cube(0, 0, 0);
-            m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
+            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
             m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
diff --git a/KAOS/Utilities/Texture.cs b/KAOS/Utilities/Texture.cs
index fffdeb7..77562b6 100644
--- a/KAOS/Utilities/Texture.cs
+++ b/KAOS/Utilities/Texture.cs
@@ -10,2 +10,3 @@ namespace KAOS.Utilities
         public int ID { get; set; }
+        public int VAO { get; set; }
         public int Width { get; set; }
@@ -13,5 +14,6 @@ namespace KAOS.Utilities
 
-        public Texture(int id, int width, int height) :this()
+        public Texture(int id, int vao, int width, int height) :this()
         {
             ID = id;
+            VAO = vao;
             Width = width;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9b30638cf4ebe986cf5d77b29a6629bbffe3ceaf">Separated modelViewMatrix.</a>  -  9b30638</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 3 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
index 4f89dba..c2bfc32 100644
--- a/KAOS/Data/Shaders/render-vs.glsl
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -2,5 +2,7 @@
 
-uniform mat4 mv_matrix;
+uniform mat4 model_matrix;
+uniform mat4 view_matrix;
 uniform mat4 proj_matrix;
 
+
 layout (location = 0) in vec4 in_position;
@@ -16,2 +18,3 @@ void main(void)
 {
+	mat4  mv_matrix = view_matrix * model_matrix;
     vec4 pos_vs = mv_matrix * in_position;
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 4b3ac6b..70d910d 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -53,3 +53,4 @@ namespace KAOS.States
             Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
+            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
 
@@ -75,5 +76,6 @@ namespace KAOS.States
 
-            Renderer.viewMatrix = Matrix4.Invert(Camera.GetViewMatrix());
+            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            Renderer.modelMatrix = Matrix4.CreateScale(2f);
 
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
+            //Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index abc0782..3e3848a 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -19,7 +19,7 @@ namespace KAOS.Utilities
         #region Members
-        internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
+        internal static Matrix4 projectionMatrix, modelMatrix, viewMatrix;
         internal static Vector3 eyePosition;
         internal static int 
-            handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
-            handle_centre, handle_scale, handle_iter;
+            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix, 
+            handle_centre, handle_scale, handle_iter, handle_modelMatrix;
         #endregion
@@ -57,3 +57,5 @@ namespace KAOS.Utilities
 
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+            GL.UniformMatrix4(handle_modelMatrix, false, ref modelMatrix);
             GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e0bf1ea76e5668a0e49558075d34b8d12c95ec60">Fixed camera at last.</a>  -  e0bf1ea</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 70d910d..d33ea8e 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -54,3 +54,3 @@ namespace KAOS.States
             Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
+            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
 
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 3e3848a..dbab8b2 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -21,5 +21,5 @@ namespace KAOS.Utilities
         internal static Vector3 eyePosition;
-        internal static int 
-            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix, 
-            handle_centre, handle_scale, handle_iter, handle_modelMatrix;
+        internal static int
+            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix,
+            handle_centre, handle_scale, handle_iter, handle_modelMatrix, handle_viewMatrix2;
         #endregion
@@ -58,3 +58,3 @@ namespace KAOS.Utilities
 
-            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+            GL.UniformMatrix4(handle_viewMatrix2, false, ref viewMatrix);
             GL.UniformMatrix4(handle_modelMatrix, false, ref modelMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/535c9e93b12e0507b0f91461abe6c98001e9c1f4">removing regions</a>  -  535c9e9</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 1 file changed, 4 insertions(+), 9 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index e416431..41fc861 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -30,3 +30,3 @@ namespace KAOS
 
-        #region Load everything here
+        // Load everything here
         protected override void OnLoad(System.EventArgs e)
@@ -63,5 +63,3 @@ namespace KAOS
 
-        #endregion
-
-        #region Game Loop
+        // Game Loop
         protected override void OnUpdateFrame(FrameEventArgs e)
@@ -104,5 +102,4 @@ namespace KAOS
         }
-        #endregion
-
-        #region Input Control
+        
+        // Input Control
 
@@ -141,4 +138,2 @@ namespace KAOS
         
-        #endregion
-
         protected override void OnUnload(EventArgs e)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/db46e2187120c5e303af1431400bd233b7555be7">Some fixes in order for it work on lab computers.</a>  -  db46e21</p><p>authored by Anthony Woodward, 8 hours ago</p></div><pre>
 8 files changed, 14 insertions(+), 15 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 6115a7c..9e46ee4 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -35,3 +35,3 @@ namespace Game
         {
-            stateManager.Update(elapsedTime);
+            stateManager.Update(elapsedTime, (float)ScreenWidth / ScreenHeight);
         }
diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 028e794..076dc19 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -38,4 +38,4 @@ void main(void)
 
-    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
-    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
+    //c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
+    //c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
 
diff --git a/KAOS/Interfaces/IGameObject.cs b/KAOS/Interfaces/IGameObject.cs
index b2da157..b6249e5 100644
--- a/KAOS/Interfaces/IGameObject.cs
+++ b/KAOS/Interfaces/IGameObject.cs
@@ -5,3 +5,3 @@ namespace KAOS.Interfaces
     {
-        void Update(float elapsedTime);
+        void Update(float elapsedTime, float aspect);
         void Render();
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index 41fc861..1284dae 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -20,4 +20,4 @@ namespace KAOS
 
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        protected int ScreenWidth { get { return this.ClientSize.Width; } }
+        protected int ScreenHeight { get { return this.ClientSize.Height; } }
 
@@ -78,3 +78,6 @@ namespace KAOS
             
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
 
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
index f39e5e1..b4fcefe 100644
--- a/KAOS/Managers/StateManager.cs
+++ b/KAOS/Managers/StateManager.cs
@@ -14,3 +14,3 @@ namespace KAOS.Managers
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
@@ -18,3 +18,3 @@ namespace KAOS.Managers
                 return;
-            currentState.Update(elapsedTime);
+            currentState.Update(elapsedTime, aspect);
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d33ea8e..c005773 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -28,3 +28,2 @@ namespace KAOS.States
 
-        float aspect = 1024 / (float)600;
         float _rotation;
@@ -72,3 +71,3 @@ namespace KAOS.States
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
diff --git a/KAOS/States/SplashScreenState.cs b/KAOS/States/SplashScreenState.cs
index c18d9ec..497ace2 100644
--- a/KAOS/States/SplashScreenState.cs
+++ b/KAOS/States/SplashScreenState.cs
@@ -25,3 +25,3 @@ namespace KAOS.States
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index dbab8b2..1e6c0eb 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -35,5 +35,2 @@ namespace KAOS.Utilities
         {
-            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
             GL.UseProgram(ShaderManager.Skybox.ID);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0f4548031978c9189eed0206b269cf0e213fdcf8">Updated camera, thank you NeoKabuto: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html</a>  -  0f45480</p><p>authored by Anthony Woodward, 8 hours ago</p></div><pre>
 3 files changed, 226 insertions(+), 231 deletions(-)

diff --git a/Game/Program.cs b/Game/Program.cs
index c1a111c..e245025 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 3, 3)) { game.Run(60, 0); }
+            using (Game game = new Game(1280, 720, 3, 3)) { game.Run(60, 0); }
         }
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index 1284dae..ecdade2 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -1,79 +1,86 @@
-﻿using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// This is the main interface to the system. Inherit from here to get started.
-    /// </summary>
-    public abstract class KAOSEngine : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "KAOS-Engine"; } }
-
-        protected int ScreenWidth { get { return this.ClientSize.Width; } }
-        protected int ScreenHeight { get { return this.ClientSize.Height; } }
-
-        protected AnimationTimer m_Timer;
-        
-        public KAOSEngine(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        // Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new AnimationTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultSkyboxShader();
-            ShaderManager.LoadDefaultRenderShader();
-        }
-
-        public abstract void Initialise();
-
-        // Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            InputManager.PollInput();
-            ResetCursor();
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
+﻿using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// This is the main interface to the system. Inherit from here to get started.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS-Engine"; } }
+
+        protected int ScreenWidth { get { return this.ClientSize.Width; } }
+        protected int ScreenHeight { get { return this.ClientSize.Height; } }
+
+        protected AnimationTimer m_Timer;
+        protected Vector2 lastMousePos = new Vector2();
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        // Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new AnimationTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
+        }
+
+        public abstract void Initialise();
+
+        // Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            InputManager.PollKeyboard();
+            if (Focused)
+            {
+                Vector2 delta = lastMousePos - new Vector2(OpenTK.Input.Mouse.GetState().X, OpenTK.Input.Mouse.GetState().Y);
+
+                Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
             GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
@@ -81,67 +88,66 @@ namespace KAOS
             GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
-            Title = KAOSEngine.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-        }
-        
-        // Input Control
-
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-    }
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+        }
+        
+        // Input Control
+
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            lastMousePos = new Vector2(OpenTK.Input.Mouse.GetState().X, OpenTK.Input.Mouse.GetState().Y);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+        }
+    }
 }
\ No newline at end of file
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index 21e6993..1a530f0 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -1,87 +1,76 @@
-﻿using OpenTK;
-using OpenTK.Input;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    /// <summary>
-    /// Responsible for polling user input, updating parameters as and when a change is detected.
-    /// </summary>
-    public static class InputManager
-    {
-        internal static List<Key> keyList = new List<Key>();
-
-        internal static MouseState current, previous;
-        internal static KeyboardState keyState;
-
-        internal static void PollInput()
-        {
-            KeyboardUpdate();
-            MouseUpdate();
-        }
-
-        private static void MouseUpdate()
-        {
-            current = Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-            }
-        }
-
-        private static void KeyboardUpdate()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Utilities.Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Utilities.Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Utilities.Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Utilities.Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Utilities.Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Utilities.Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Utilities.Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Utilities.Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-            }
-        }
-
-    }
-}
+﻿using OpenTK;
+using OpenTK.Input;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    /// <summary>
+    /// Responsible for polling user input, updating parameters as and when a change is detected.
+    /// </summary>
+    public static class InputManager
+    {
+        internal static List<Key> keyList = new List<Key>();
+
+        internal static MouseState current, previous;
+        internal static KeyboardState keyState;
+
+        internal static void PollKeyboard()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Utilities.Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Utilities.Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Utilities.Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Utilities.Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Utilities.Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Utilities.Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Utilities.Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Utilities.Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
+        internal static void PollMouse()
+        {
+            current = Mouse.GetState();
+            if (current != previous)
+            {
+                // Mouse state has changed
+                int xdelta = current.X - previous.X;
+                int ydelta = current.Y - previous.Y;
+                int zdelta = current.Wheel - previous.Wheel;
+                Utilities.Camera.AddRotation(xdelta, ydelta);
+            }
+            previous = current;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1e98c9ee2108a164598c047564b3327a0ce2317e">fixed camera issue</a>  -  1e98c9e</p><p>authored by Anthony Woodward, 7 hours ago</p></div><pre>
 2 files changed, 25 insertions(+), 26 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index c005773..2d7b954 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -48,3 +48,2 @@ namespace KAOS.States
         {
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Skybox.ID, "eye_position");
             Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
@@ -68,3 +67,4 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
+            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
         }
@@ -75,6 +75,5 @@ namespace KAOS.States
 
-            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
             Renderer.modelMatrix = Matrix4.CreateScale(2f);
 
-            //Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
@@ -85,3 +84,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
         }
diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index c60cfeb..cb7f942 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, -2f);
+        public static Vector3 Position = Vector3.Zero;
         public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
@@ -20,9 +20,9 @@ namespace KAOS.Utilities
         public static Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
             return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
@@ -31,15 +31,15 @@ namespace KAOS.Utilities
         public static void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
             Position += offset;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f1101eb63cfc99ad8dba2e2fcec7f88ff4b58893">using normalize(in_position.xyz) in the vertex shader. previously it was not being normalised and so the skybox rotated in the wrong direction. @see http://stackoverflow.com/a/10828100</a>  -  f1101eb</p><p>authored by Anthony Woodward, 7 hours ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
index c433716..0301135 100644
--- a/KAOS/Data/Shaders/skybox-vs.glsl
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -13,3 +13,3 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	vs_out.tc = mat3(view_matrix) * normalize(in_position.xyz);
 	gl_Position = vec4(in_position.xyz, 1.0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8c85052854359475c048ef374d67abd4f49a243f">TextRenderer class taken from the OpenTK Examples.</a>  -  8c85052</p><p>authored by Anthony Woodward, 2 days ago</p></div><pre>
 1 file changed, 158 insertions(+)

diff --git a/KAOS/Utilities/TextRenderer.cs b/KAOS/Utilities/TextRenderer.cs
new file mode 100644
index 0000000..f536e71
--- /dev/null
+++ b/KAOS/Utilities/TextRenderer.cs
@@ -0,0 +1,158 @@
+﻿// This code was written for the OpenTK library and has been released
+// to the Public Domain.
+// It is provided "as is" without express or implied warranty of any kind.
+
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// Uses System.Drawing for 2d text rendering.
+    /// </summary>
+    public class TextRenderer : IDisposable
+    {
+        Bitmap bmp;
+        Graphics gfx;
+        int texture;
+        Rectangle dirty_region;
+        bool disposed;
+
+        #region Constructors
+
+        /// <summary>
+        /// Constructs a new instance.
+        /// </summary>
+        /// <param name="width">The width of the backing store in pixels.</param>
+        /// <param name="height">The height of the backing store in pixels.</param>
+        public TextRenderer(int width, int height)
+        {
+            if (width <= 0)
+                throw new ArgumentOutOfRangeException("width");
+            if (height <= 0)
+                throw new ArgumentOutOfRangeException("height ");
+            if (GraphicsContext.CurrentContext == null)
+                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
+
+            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            gfx = Graphics.FromImage(bmp);
+            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
+
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
+                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+        }
+
+        #endregion
+
+        #region Public Members
+
+        /// <summary>
+        /// Clears the backing store to the specified color.
+        /// </summary>
+        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
+        public void Clear(Color color)
+        {
+            gfx.Clear(color);
+            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
+        }
+
+        /// <summary>
+        /// Draws the specified string to the backing store.
+        /// </summary>
+        /// <param name="text">The <see cref="System.String"/> to draw.</param>
+        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
+        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
+        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
+        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
+        public void DrawString(string text, Font font, Brush brush, PointF point)
+        {
+            gfx.DrawString(text, font, brush, point);
+
+            SizeF size = gfx.MeasureString(text, font);
+            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
+            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
+        }
+
+        /// <summary>
+        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
+        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
+        /// in order to render the drawn text on screen.
+        /// </summary>
+        public int Texture
+        {
+            get
+            {
+                UploadBitmap();
+                return texture;
+            }
+        }
+
+        #endregion
+
+        #region Private Members
+
+        // Uploads the dirty regions of the backing store to the OpenGL texture.
+        void UploadBitmap()
+        {
+            if (dirty_region != RectangleF.Empty)
+            {
+                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
+                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+                GL.BindTexture(TextureTarget.Texture2D, texture);
+                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
+                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
+                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+                bmp.UnlockBits(data);
+
+                dirty_region = Rectangle.Empty;
+            }
+        }
+
+        #endregion
+
+        #region IDisposable Members
+
+        void Dispose(bool manual)
+        {
+            if (!disposed)
+            {
+                if (manual)
+                {
+                    bmp.Dispose();
+                    gfx.Dispose();
+                    if (GraphicsContext.CurrentContext != null)
+                        GL.DeleteTexture(texture);
+                }
+
+                disposed = true;
+            }
+        }
+
+        public void Dispose()
+        {
+            Dispose(true);
+            GC.SuppressFinalize(this);
+        }
+
+        ~TextRenderer()
+        {
+            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
+        }
+
+        #endregion
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3954a2623616fe2bb9f134f9903d24d0369e46bb">Normalised line endings.</a>  -  3954a26</p><p>authored by Anthony Woodward, 5 hours ago</p></div><pre>
 1 file changed, 91 insertions(+), 91 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 2d7b954..f18eb3b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -1,93 +1,93 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-
-namespace KAOS.States
-{
-    public class Skyboxstate : IDisposable, IGameObject
-    {
-        private BufferObjectManager m_bufferManager;
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        static string defaultSkyboxPath = "Data/Textures/skybox/";
-        string[] skyboxFaces = new String[]
-        {
-            defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
-            defaultSkyboxPath + "pos_y.bmp",
-            defaultSkyboxPath + "neg_y.bmp",
-            defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
-        };
-
-        float _rotation;
-
-        public Skyboxstate(StateManager stateManager)
-        {
-            m_bufferManager = new BufferObjectManager();
-            m_stateManager = stateManager;
-            m_textureManager = new TextureManager();
-
-            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
-
-            LoadCubeMap();
-            QueryShaders();
-
-            _rotation = MathHelper.DegreesToRadians(90);
-
-            LoadTestObject();
-        }
-
-        private void QueryShaders()
-        {
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
-
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
-            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
-            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
-
-            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
-            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
-            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
-        }
-
-        private void LoadCubeMap()
-        {
-            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-        }
-
-        private void LoadTestObject()
-        {
-            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+
+namespace KAOS.States
+{
+    public class Skyboxstate : IDisposable, IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        static string defaultSkyboxPath = "Data/Textures/skybox/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
+
+            LoadCubeMap();
+            QueryShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+
+            LoadTestObject();
+        }
+
+        private void QueryShaders()
+        {
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
+            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
+            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
+
+            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
+            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
+            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+        }
+
+        private void LoadTestObject()
+        {
+            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
             m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
-            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
-        }
-
-        public void Update(float elapsedTime, float aspect)
-        {
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-
+            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
+
             Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
-            Renderer.modelMatrix = Matrix4.CreateScale(2f);
-
-            Renderer.eyePosition = Camera.Position;
-        }
-
-        public void Render()
-        {
-            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
-        }
-
-        public void Dispose()
-        {
-            m_textureManager.Dispose();
-        }
-    }
-}
+            Renderer.modelMatrix = Matrix4.CreateScale(2f);
+
+            Renderer.eyePosition = Camera.Position;
+        }
+
+        public void Render()
+        {
+            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
+        }
+
+        public void Dispose()
+        {
+            m_textureManager.Dispose();
+        }
+    }
+}
