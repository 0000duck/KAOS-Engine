using KAOS.Interfaces;
using KAOS.Shapes;
using KAOS.Utilities;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using System;
using System.Collections.Generic;

namespace KAOS.Managers
{
    /// <summary>
    /// Responsible for uploading vertex data to the gpu and setting up vertex arrays.
    /// </summary>
    public class VertexBufferManager
    {
        #region Class Fields
        private Dictionary<string, VertexBuffer> m_bufferStore = new Dictionary<string, VertexBuffer>();
        private int gpuHandle, sizeOfPositionData, sizeOfNormalsData;
        private IntPtr vertexBufferSize, noOffset;
        private VertexBuffer vertexBuffer = new VertexBuffer();
        private VertexT2fN3fV3f[] vertexData;
        private uint[] indices;
        private PrimitiveType type;
        #endregion

        public void GenerateVertexBuffer(string name, IDrawableShape shape, int program)
        {

            LoadBufferData(shape);

            CalculateBufferSize();

            // Generate Vertex Buffer Object and bind it so it is current.
            GenerateVertexBuffer();
            
            SendVertexBufferData();

            // Generate Vertex Array Object and bind it so it is current.
            GenerateVertexArray();

            GetVertexArrayPointers(program);

            // IMPORTANT: vertex array needs unbinding here to avoid rendering incorrectly
            UnbindVertexArrayBuffer();

            m_bufferStore.Add(name, vertexBuffer);
        }

        public VertexBuffer GetBuffer(string name)
        {
            return m_bufferStore[name];
        }

        #region Private Methods

        private void CalculateBufferSize()
        {
            sizeOfPositionData = Vector3.SizeInBytes * vertexBuffer.PositionData.Length;
            sizeOfNormalsData = Vector3.SizeInBytes * vertexBuffer.NormalsData.Length;
            vertexBufferSize = new IntPtr(sizeOfPositionData + sizeOfNormalsData);
            noOffset = new IntPtr(0);
        }

        private void LoadBufferData(IDrawableShape shape)
        {
            shape.GetArraysforVBO(out type, out vertexData, out indices);
            vertexBuffer.PositionData = shape.Vertices;
            vertexBuffer.NormalsData = shape.Normals;
            vertexBuffer.IndicesData = shape.Indices;
            vertexBuffer.PrimitiveType = type;
        }

        private void GenerateVertexBuffer()
        {
            GL.GenBuffers(1, out gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, gpuHandle);

            // Save pointers generated by OpenGL here so i dont forget.
            vertexBuffer.VboID = gpuHandle;
        } 

        private void SendVertexBufferData()
        {
            // Initialise storage space for the Vertex Buffer.
            GL.BufferData(BufferTarget.ArrayBuffer, vertexBufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
            // Send Position data.
            GL.BufferSubData<Vector3>(
                BufferTarget.ArrayBuffer, noOffset, new IntPtr(sizeOfPositionData), vertexBuffer.PositionData);
            // Send Normals data, offset by size of Position data.
            GL.BufferSubData<Vector3>(
                BufferTarget.ArrayBuffer, new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), vertexBuffer.NormalsData);

            GL.GenBuffers(1, out gpuHandle);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, gpuHandle);
            GL.BufferData(
                BufferTarget.ElementArrayBuffer, new IntPtr(sizeof(uint) * vertexBuffer.IndicesData.Length), vertexBuffer.IndicesData, BufferUsageHint.StaticDraw);

            vertexBuffer.IboID = gpuHandle;

            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vertexBuffer.IboID);
        }

        private void GenerateVertexArray()
        {

            // GL3+ allows us to store the vertex layout in a "vertex array object" (VAO).
            // This means we do not have to re-issue VertexAttribPointer calls
            // every time we try to use a different vertex layout - these calls are
            // stored in the VAO so we simply need to bind the correct VAO.
            GL.GenVertexArrays(1, out gpuHandle);
            GL.BindVertexArray(gpuHandle);

            vertexBuffer.VaoID = gpuHandle;
        }
    
        private void GetVertexArrayPointers(int program)
        {
            gpuHandle = GL.GetAttribLocation(program, "in_position");
            GL.EnableVertexAttribArray(gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
            GL.BindAttribLocation(program, gpuHandle, "in_position");

            gpuHandle = GL.GetAttribLocation(program, "in_normal");
            GL.EnableVertexAttribArray(gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
            GL.BindAttribLocation(program, gpuHandle, "in_normal");

            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vertexBuffer.IboID);
        }

        private static void UnbindVertexArrayBuffer()
        {
            GL.BindVertexArray(0);
        }

        #endregion

    }
}
