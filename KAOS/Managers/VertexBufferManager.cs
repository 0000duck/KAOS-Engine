using KAOS.Interfaces;
using KAOS.Shapes;
using KAOS.Utilities;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using System;
using System.Collections.Generic;

namespace KAOS.Managers
{
    /// <summary>
    /// Responsible for uploading vertex data to the gpu and setting up vertex arrays.
    /// </summary>
    public class VertexBufferManager
    {
        #region Class Fields
        private readonly Dictionary<string, VertexBuffer> _vertexBuffers = new Dictionary<string, VertexBuffer>();
        private int _gpuHandle, _sizeOfPositionData, _sizeOfNormalsData;
        private IntPtr _vertexBufferSize, _noOffset;
        private VertexBuffer _vertexBuffer = new VertexBuffer();
        private VertexT2fN3fV3f[] _vertexT2fN3fV3Fs;
        private uint[] _indices;
        private PrimitiveType _primitiveType;
        #endregion

        public void GenerateVertexBuffer(string name, IDrawableShape shape, int program)
        {

            LoadBufferData(shape);

            CalculateBufferSize();

            // Generate Vertex Buffer Object and bind it so it is current.
            GenerateVertexBuffer();
            
            SendVertexBufferData();

            // Generate Vertex Array Object and bind it so it is current.
            GenerateVertexArray();

            GetVertexArrayPointers(program);

            // IMPORTANT: vertex array needs unbinding here to avoid rendering incorrectly
            UnbindVertexArrayBuffer();

            _vertexBuffers.Add(name, _vertexBuffer);
        }

        public VertexBuffer GetBuffer(string name)
        {
            return _vertexBuffers[name];
        }

        #region Private Methods

        private void CalculateBufferSize()
        {
            _sizeOfPositionData = Vector3.SizeInBytes * _vertexBuffer.PositionData.Length;
            _sizeOfNormalsData = Vector3.SizeInBytes * _vertexBuffer.NormalsData.Length;
            _vertexBufferSize = new IntPtr(_sizeOfPositionData + _sizeOfNormalsData);
            _noOffset = new IntPtr(0);
        }

        private void LoadBufferData(IDrawableShape shape)
        {
            shape.GetArraysforVbo(out _primitiveType, out _vertexT2fN3fV3Fs, out _indices);
            _vertexBuffer.PositionData = shape.Vertices;
            _vertexBuffer.NormalsData = shape.Normals;
            _vertexBuffer.IndicesData = shape.Indices;
            _vertexBuffer.PrimitiveType = _primitiveType;
        }

        private void GenerateVertexBuffer()
        {
            GL.GenBuffers(1, out _gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, _gpuHandle);

            // Save pointers generated by OpenGL here so i dont forget.
            _vertexBuffer.VboId = _gpuHandle;
        } 

        private void SendVertexBufferData()
        {
            // Initialise storage space for the Vertex Buffer.
            GL.BufferData(BufferTarget.ArrayBuffer, _vertexBufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
            // Send Position data.
            GL.BufferSubData<Vector3>(
                BufferTarget.ArrayBuffer, _noOffset, new IntPtr(_sizeOfPositionData), _vertexBuffer.PositionData);
            // Send Normals data, offset by size of Position data.
            GL.BufferSubData<Vector3>(
                BufferTarget.ArrayBuffer, new IntPtr(_sizeOfPositionData), new IntPtr(_sizeOfNormalsData), _vertexBuffer.NormalsData);

            GL.GenBuffers(1, out _gpuHandle);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _gpuHandle);
            GL.BufferData(
                BufferTarget.ElementArrayBuffer, new IntPtr(sizeof(uint) * _vertexBuffer.IndicesData.Length), _vertexBuffer.IndicesData, BufferUsageHint.StaticDraw);

            _vertexBuffer.IboId = _gpuHandle;

            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBuffer.VboId);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _vertexBuffer.IboId);
        }

        private void GenerateVertexArray()
        {

            // GL3+ allows us to store the vertex layout in a "vertex array object" (VAO).
            // This means we do not have to re-issue VertexAttribPointer calls
            // every time we try to use a different vertex layout - these calls are
            // stored in the VAO so we simply need to bind the correct VAO.
            GL.GenVertexArrays(1, out _gpuHandle);
            GL.BindVertexArray(_gpuHandle);

            _vertexBuffer.VaoId = _gpuHandle;
        }
    
        private void GetVertexArrayPointers(int program)
        {
            _gpuHandle = GL.GetAttribLocation(program, "in_position");
            GL.EnableVertexAttribArray(_gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBuffer.VboId);
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
            GL.BindAttribLocation(program, _gpuHandle, "in_position");

            _gpuHandle = GL.GetAttribLocation(program, "in_normal");
            GL.EnableVertexAttribArray(_gpuHandle);
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBuffer.VboId);
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, _sizeOfPositionData);
            GL.BindAttribLocation(program, _gpuHandle, "in_normal");

            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _vertexBuffer.IboId);
        }

        private static void UnbindVertexArrayBuffer()
        {
            GL.BindVertexArray(0);
        }

        #endregion

    }
}
