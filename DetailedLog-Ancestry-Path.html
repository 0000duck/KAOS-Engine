<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f515de19639a718bb052f51b0899229401139fe7">Adding Empty Project</a>  -  f515de1</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 48 insertions(+)

diff --git a/AWGL/Class1.cs b/AWGL/Class1.cs
new file mode 100644
index 0000000..25f7686
--- /dev/null
+++ b/AWGL/Class1.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class Class1
+    {
+    }
+}
new file mode 100644
index 0000000..9623e06
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("AWGL")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("AWGL")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/799d9fdf40ee0d1bc59747fdeb4d3f8be001475a">Renamed Main Class</a>  -  799d9fd</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 13 insertions(+)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
new file mode 100644
index 0000000..e91f871
--- /dev/null
+++ b/AWGL/AWGL.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public static class AWGL
+    {
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1e55fdda685c97b3891aec25a3dd152b017faac8">~</a>  -  1e55fdd</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 12 deletions(-)

diff --git a/AWGL/Class1.cs b/AWGL/Class1.cs
deleted file mode 100644
index 25f7686..0000000
--- a/AWGL/Class1.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class Class1
-    {
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b9922713a53840c6594ca530944a1dffaa4282ef">Adding Testing Application</a>  -  b992271</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 55 insertions(+)

diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
new file mode 100644
index 0000000..c75c740
--- /dev/null
+++ b/TestApplication/Program.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+using AWGL;
+
+namespace TestApplication
+{
+    class Program
+    {
+        [STAThread]
+        static void Main(string[] args)
+        {
+            AWGL.AWGL.Main(args);
+        }
+    }
+}
new file mode 100644
index 0000000..5e3ef72
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("TestApplication")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("TestApplication")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("3b8899cd-4523-439e-892a-a7ecfc8390ed")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/86d835b4c8fac46eb74e3639da25f3a2935faa5d">Adding Shaders</a>  -  86d835b</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 5 files changed, 76 insertions(+), 5 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index e91f871..ae051f1 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -1,6 +1,10 @@
-﻿using System;
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
@@ -8,5 +12,13 @@ namespace AWGL
 {
-    public static class AWGL
+    public static class AWGL 
     {
-
+        
+        public static void Main(string[] args)
+        {
+            using (Display display = new Display())
+            {
+                display.Run(30.0);
+            }
+        }
+        
     }
diff --git a/AWGL/Display.cs b/AWGL/Display.cs
new file mode 100644
index 0000000..94ccae3
--- /dev/null
+++ b/AWGL/Display.cs
@@ -0,0 +1,25 @@
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+namespace AWGL
+{
+    public class Display : GameWindow
+    {
+        private int vertexShaderID;
+        private int fragmentShaderID;
+
+        private int compiledShaderProgramID;
+
+        private void initProgram()
+        {
+            
+        }
+    }
+}
diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
new file mode 100644
index 0000000..607bcb0
--- /dev/null
+++ b/AWGL/Graphic.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    abstract class Graphic
+    {
+    }
+}
diff --git a/AWGL/Shaders/FS.glsl b/AWGL/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/AWGL/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/AWGL/Shaders/VS.glsl b/AWGL/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/AWGL/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/46ddc9333e4c12e610fc5e3a76152983032e12e0">Added method stubs</a>  -  46ddc93</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 34 insertions(+)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 94ccae3..437ab75 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -19,6 +19,40 @@ namespace AWGL
 
+        public Display() : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+
+        }   
+
         private void initProgram()
         {
+            compiledShaderProgramID = GL.CreateProgram();
+   
             
         }
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+        }
+
+        private void loadShader(String filename, ShaderType type, int program, out int address)
+        {
+            address = GL.CreateShader(type);
+            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            {
+                GL.ShaderSource(address, sr.ReadToEnd());
+            }
+            GL.CompileShader(address);
+            GL.AttachShader(program, address);
+            Console.WriteLine(GL.GetShaderInfoLog(address));
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/be4d7ae69e22a357f3db1ca9fb3e366abc59f0eb">Adding basic primitive shapes.</a>  -  be4d7ae</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 5 files changed, 310 insertions(+)

diff --git a/AWGL/Abstract/Volume.cs b/AWGL/Abstract/Volume.cs
new file mode 100644
index 0000000..8963d9e
--- /dev/null
+++ b/AWGL/Abstract/Volume.cs
@@ -0,0 +1,27 @@
+﻿using OpenTK;
+
+namespace AWGL.Abstract
+{
+    public abstract class Volume
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Rotation = Vector3.Zero;
+        public Vector3 Scale = Vector3.One;
+
+        public int VertCount;
+        public int IndiceCount;
+        public int ColorDataCount;
+        public Matrix4 ModelMatrix = Matrix4.Identity;
+        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
+        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
+
+        public abstract Vector3[] GetVerts();
+        public abstract int[] GetIndices(int offset = 0);
+        public abstract Vector3[] GetColorData();
+        public abstract void CalculateModelMatrix();
+
+
+
+    } // class
+
+} // namespace
diff --git a/AWGL/Shapes/ColourCube.cs b/AWGL/Shapes/ColourCube.cs
new file mode 100644
index 0000000..18eb637
--- /dev/null
+++ b/AWGL/Shapes/ColourCube.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK;
+
+namespace AWGL.Shapes
+{
+    class ColourCube : Cube
+    {
+        Vector3 Color = new Vector3(1, 1, 1);
+ 
+        public ColourCube(Vector3 color) : base() {
+            Color = color;
+        }
+
+        public ColourCube()
+        {
+
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] { 
+                Color,
+                Color, 
+                Color,
+                Color,
+                Color, 
+                Color, 
+                Color, 
+                Color
+            };
+        }
+    }
+}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
new file mode 100644
index 0000000..aef1266
--- /dev/null
+++ b/AWGL/Shapes/Cube.cs
@@ -0,0 +1,83 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+
+namespace AWGL.Shapes
+{
+    public class Cube : Volume
+    {
+        public Cube()
+        {
+            VertCount = 8;
+            IndiceCount = 36;
+            ColorDataCount = 8;
+        }
+
+        public override Vector3[] GetVerts()
+        {
+            return new Vector3[] {new Vector3(-0.5f, -0.5f,  -0.5f),
+                new Vector3(0.5f, -0.5f,  -0.5f),
+                new Vector3(0.5f, 0.5f,  -0.5f),
+                new Vector3(-0.5f, 0.5f,  -0.5f),
+                new Vector3(-0.5f, -0.5f,  0.5f),
+                new Vector3(0.5f, -0.5f,  0.5f),
+                new Vector3(0.5f, 0.5f,  0.5f),
+                new Vector3(-0.5f, 0.5f,  0.5f),
+            };
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = new int[] {
+                //left
+                0, 2, 1,
+                0, 3, 2,
+                //back
+                1, 2, 6,
+                6, 5, 1,
+                //right
+                4, 5, 6,
+                6, 7, 4,
+                //top
+                2, 3, 6,
+                6, 3, 7,
+                //front
+                0, 7, 3,
+                0, 4, 7,
+                //bottom
+                0, 1, 5,
+                0, 5, 4
+            };
+
+
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] {
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f),
+                new Vector3( 0f, 1f, 0f),
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f),
+                new Vector3( 0f, 1f, 0f),
+                new Vector3( 1f, 0f, 0f),
+                new Vector3( 0f, 0f, 1f)
+            };
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
new file mode 100644
index 0000000..822db60
--- /dev/null
+++ b/AWGL/Shapes/Sierpinski.cs
@@ -0,0 +1,71 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+using System;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    class Sierpinski : Volume
+    {
+        public Sierpinski(int numSubdivisions = 1)
+        {
+            int NumTris = (int)Math.Pow(4, numSubdivisions + 1);
+
+            VertCount = NumTris;
+            ColorDataCount = NumTris;
+            IndiceCount = 3 * NumTris;
+
+            Tetra twhole = new Tetra(
+                new Vector3(0.0f, 0.0f, 1.0f),  // Apex center 
+                new Vector3(0.943f, 0.0f, -0.333f),  // Base center top
+                new Vector3(-0.471f, 0.816f, -0.333f),  // Base left bottom
+                new Vector3(-0.471f, -0.816f, -0.333f));
+
+            List<Tetra> allTets = twhole.Divide(numSubdivisions);
+
+            int offset = 0;
+            foreach (Tetra t in allTets)
+            {
+                verts.AddRange(t.GetVerts());
+                indices.AddRange(t.GetIndices(offset * 4));
+                colors.AddRange(t.GetColorData());
+                offset++;
+            }
+
+        }
+
+        private List<Vector3> verts = new List<Vector3>();
+        private List<int> indices = new List<int>();
+        private List<Vector3> colors = new List<Vector3>();
+
+        public override Vector3[] GetVerts()
+        {
+            return verts.ToArray();
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return colors.ToArray();
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = indices.ToArray();
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
new file mode 100644
index 0000000..5003fa9
--- /dev/null
+++ b/AWGL/Shapes/Tetra.cs
@@ -0,0 +1,97 @@
+﻿using OpenTK;
+using AWGL.Abstract;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    class Tetra : Volume
+    {
+        Vector3 PointApex;
+        Vector3 PointA;
+        Vector3 PointB;
+        Vector3 PointC;
+
+        public Tetra(Vector3 apex, Vector3 a, Vector3 b, Vector3 c)
+        {
+            PointApex = apex;
+            PointA = a;
+            PointB = b;
+            PointC = c;
+
+            VertCount = 4;
+            IndiceCount = 12;
+            ColorDataCount = 4;
+        }
+
+        public List<Tetra> Divide(int n = 0)
+        {
+            if (n == 0)
+            {
+                return new List<Tetra>(new Tetra[] { this });
+            }
+            else
+            {
+
+                Vector3 halfa = (PointApex + PointA) / 2.0f;
+                Vector3 halfb = (PointApex + PointB) / 2.0f;
+                Vector3 halfc = (PointApex + PointC) / 2.0f;
+
+                // Calculate points half way between base points
+                Vector3 halfab = (PointA + PointB) / 2.0f;
+                Vector3 halfbc = (PointB + PointC) / 2.0f;
+                Vector3 halfac = (PointA + PointC) / 2.0f;
+
+                Tetra t1 = new Tetra(PointApex, halfa, halfb, halfc);
+                Tetra t2 = new Tetra(halfa, PointA, halfab, halfac);
+                Tetra t3 = new Tetra(halfb, halfab, PointB, halfbc);
+                Tetra t4 = new Tetra(halfc, halfac, halfbc, PointC);
+
+                List<Tetra> output = new List<Tetra>();
+
+                output.AddRange(t1.Divide(n - 1));
+                output.AddRange(t2.Divide(n - 1));
+                output.AddRange(t3.Divide(n - 1));
+                output.AddRange(t4.Divide(n - 1));
+
+                return output;
+
+            }
+        }
+
+        public override Vector3[] GetVerts()
+        {
+            return new Vector3[] { PointApex, PointA, PointB, PointC };
+        }
+
+        public override int[] GetIndices(int offset = 0)
+        {
+            int[] inds = new int[] { //bottom
+                                1,3,2,
+                                //other sides
+                                0,1,2,
+                                0,2,3,
+                                0,3,1
+        };
+
+            if (offset != 0)
+            {
+                for (int i = 0; i < inds.Length; i++)
+                {
+                    inds[i] += offset;
+                }
+            }
+
+            return inds;
+        }
+
+        public override Vector3[] GetColorData()
+        {
+            return new Vector3[] { new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f), new Vector3(1f, 1f, 0f) };
+        }
+
+        public override void CalculateModelMatrix()
+        {
+            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bc8096d463353702661c263277d3b6428256b14a">Adding primitives to rendering code.</a>  -  bc8096d</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 147 insertions(+), 5 deletions(-)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 437ab75..4d4e0d8 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -1,2 +1,4 @@
-﻿using ObjLoader.Loader.Loaders;
+﻿using AWGL.Abstract;
+using AWGL.Shapes;
+using ObjLoader.Loader.Loaders;
 using OpenTK;
@@ -17,3 +19,19 @@ namespace AWGL
 
-        private int compiledShaderProgramID;
+        private int programID;
+
+        private int attribute_vpos;
+        private int attribute_vcolor;
+        private int uniform_mview;
+
+        private int vbo_position;
+        private int vbo_color;
+        private int vbo_mview;
+        private int ibo_elements;
+
+        private Vector3[] vertData;
+        private Vector3[] colorData;
+        protected List<Volume> objects = new List<Volume>();
+        private int[] indiceData;
+
+        private float time = 0.0f;
 
@@ -26,5 +44,43 @@ namespace AWGL
         {
-            compiledShaderProgramID = GL.CreateProgram();
-   
-            
+            programID = GL.CreateProgram();
+
+            loadShader("VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
+            loadShader("FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
+
+            // Links shaders and output any errors
+            GL.LinkProgram(programID);
+            Console.WriteLine(GL.GetProgramInfoLog(programID));
+
+            // Get the values we need, and also do a simple check to make sure the attributes were found.
+            attribute_vpos = GL.GetAttribLocation(programID, "vPosition");
+            attribute_vcolor = GL.GetAttribLocation(programID, "vColor");
+            uniform_mview = GL.GetUniformLocation(programID, "modelview");
+
+            if (attribute_vpos == -1 || attribute_vcolor == -1 || uniform_mview == -1)
+            {
+                Console.WriteLine("Error binding attributes");
+            }
+
+            // This generates 4 separate buffers and stores their addresses in our variables. 
+            // For multiple buffers like this, there's an option for generating multiple buffers 
+            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
+            GL.GenBuffers(1, out vbo_position);
+            GL.GenBuffers(1, out vbo_color);
+            GL.GenBuffers(1, out vbo_mview);
+            GL.GenBuffers(1, out ibo_elements);
+
+            Random rand = new Random();
+
+            float xPos = -1.0f;
+            for (int i = 0; i < 2; i++)
+            {
+                Sierpinski sier = new Sierpinski();
+
+                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
+                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
+                sier.Scale = Vector3.One;
+                objects.Add(sier);
+
+                xPos = 1.0f;
+            }
         }
@@ -34,2 +90,8 @@ namespace AWGL
             base.OnLoad(e);
+
+            initProgram();
+
+            Title = "AWGL - High level OpenTK wrapper";
+            GL.ClearColor(Color.Black);
+            GL.PointSize(3f);
         }
@@ -39,2 +101,25 @@ namespace AWGL
             base.OnRenderFrame(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.EnableVertexAttribArray(attribute_vpos);
+            GL.EnableVertexAttribArray(attribute_vcolor);
+
+            int indiceAt = 0;
+            
+            foreach (Volume v in objects)
+            {
+                GL.UniformMatrix4(uniform_mview, false, ref v.ModelViewProjectionMatrix);
+                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
+                indiceAt += v.IndiceCount;
+            }
+
+            // Keep things clean:
+            GL.DisableVertexAttribArray(attribute_vpos);
+            GL.DisableVertexAttribArray(attribute_vcolor);
+            GL.Flush();
+
+            SwapBuffers();
         }
@@ -44,2 +129,59 @@ namespace AWGL
             base.OnUpdateFrame(e);
+
+            time += (float)e.Time;
+
+            List<Vector3> verts = new List<Vector3>();
+            List<int> inds = new List<int>();
+            List<Vector3> colors = new List<Vector3>();
+
+            int vertCount = 0;
+
+            foreach (Volume v in objects)
+            {
+                verts.AddRange(v.GetVerts().ToList());
+                inds.AddRange(v.GetIndices().ToList());
+                colors.AddRange(v.GetColorData().ToList());
+                vertCount += v.VertCount;
+            }
+
+            vertData = verts.ToArray();
+            indiceData = inds.ToArray();
+            colorData = colors.ToArray();
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_position);  // 1. Bind vertex data to the buffer.
+            GL.BufferData<Vector3>(                                 // 2. Send data.
+                BufferTarget.ArrayBuffer, (IntPtr)(vertData.Length * Vector3.SizeInBytes), 
+                vertData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                attribute_vpos, 3, VertexAttribPointerType.Float, false, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_color);     // 1. Bind color data to the buffer
+            GL.BufferData<Vector3>(                                 // 2. Send Data
+                BufferTarget.ArrayBuffer, (IntPtr)(colorData.Length * Vector3.SizeInBytes),
+                colorData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                attribute_vcolor, 3, VertexAttribPointerType.Float, true, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ibo_elements);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, (IntPtr)(indiceData.Length * sizeof(int)),
+                indiceData, BufferUsageHint.StaticDraw);
+            
+            // Rotate objects
+            for (int i = 0; i < objects.Count; i++)
+            {
+                objects[i].Rotation = new Vector3(0.55f * time, 0.25f * time, 0);
+            }
+
+            // Send model view matrix
+            foreach (Volume v in objects)
+            {
+                v.CalculateModelMatrix();
+                v.ViewProjectionMatrix = 
+                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
+                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
+            }
+
+            GL.UseProgram(programID);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8f18ddaf450540bb6feef0bd5f89162a2e43c948">More shaders</a>  -  8f18dda</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/AWGL/Display.cs b/AWGL/Display.cs
index 4d4e0d8..3083443 100644
--- a/AWGL/Display.cs
+++ b/AWGL/Display.cs
@@ -46,4 +46,4 @@ namespace AWGL
 
-            loadShader("VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
-            loadShader("FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
+            loadShader("Simple_VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
+            loadShader("Simple_FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
 
diff --git a/AWGL/Shaders/Simple_FS.glsl b/AWGL/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/AWGL/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_VS.glsl b/AWGL/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/AWGL/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8619c275f52b518cdb20ff98043d94f50a4821a7">Rearranged Namespace</a>  -  8619c27</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 6 files changed, 7 insertions(+), 233 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index ae051f1..bfade2c 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -10,2 +10,4 @@ using System.Linq;
 
+using AWGL.Scene;
+
 namespace AWGL
@@ -17,5 +19,5 @@ namespace AWGL
         {
-            using (Display display = new Display())
+            using (Display mainDisplay = new Display())
             {
-                display.Run(30.0);
+                mainDisplay.Run(30.0);
             }
diff --git a/AWGL/Abstract/Volume.cs b/AWGL/Abstract/Volume.cs
deleted file mode 100644
index 8963d9e..0000000
--- a/AWGL/Abstract/Volume.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Abstract
-{
-    public abstract class Volume
-    {
-        public Vector3 Position = Vector3.Zero;
-        public Vector3 Rotation = Vector3.Zero;
-        public Vector3 Scale = Vector3.One;
-
-        public int VertCount;
-        public int IndiceCount;
-        public int ColorDataCount;
-        public Matrix4 ModelMatrix = Matrix4.Identity;
-        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
-        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
-
-        public abstract Vector3[] GetVerts();
-        public abstract int[] GetIndices(int offset = 0);
-        public abstract Vector3[] GetColorData();
-        public abstract void CalculateModelMatrix();
-
-
-
-    } // class
-
-} // namespace
diff --git a/AWGL/Display.cs b/AWGL/Display.cs
deleted file mode 100644
index 3083443..0000000
--- a/AWGL/Display.cs
+++ /dev/null
@@ -1,201 +0,0 @@
-﻿using AWGL.Abstract;
-using AWGL.Shapes;
-using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.IO;
-using System.Linq;
-
-namespace AWGL
-{
-    public class Display : GameWindow
-    {
-        private int vertexShaderID;
-        private int fragmentShaderID;
-
-        private int programID;
-
-        private int attribute_vpos;
-        private int attribute_vcolor;
-        private int uniform_mview;
-
-        private int vbo_position;
-        private int vbo_color;
-        private int vbo_mview;
-        private int ibo_elements;
-
-        private Vector3[] vertData;
-        private Vector3[] colorData;
-        protected List<Volume> objects = new List<Volume>();
-        private int[] indiceData;
-
-        private float time = 0.0f;
-
-        public Display() : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-
-        }   
-
-        private void initProgram()
-        {
-            programID = GL.CreateProgram();
-
-            loadShader("Simple_VS.glsl", ShaderType.VertexShader, programID, out vertexShaderID);
-            loadShader("Simple_FS.glsl", ShaderType.FragmentShader, programID, out fragmentShaderID);
-
-            // Links shaders and output any errors
-            GL.LinkProgram(programID);
-            Console.WriteLine(GL.GetProgramInfoLog(programID));
-
-            // Get the values we need, and also do a simple check to make sure the attributes were found.
-            attribute_vpos = GL.GetAttribLocation(programID, "vPosition");
-            attribute_vcolor = GL.GetAttribLocation(programID, "vColor");
-            uniform_mview = GL.GetUniformLocation(programID, "modelview");
-
-            if (attribute_vpos == -1 || attribute_vcolor == -1 || uniform_mview == -1)
-            {
-                Console.WriteLine("Error binding attributes");
-            }
-
-            // This generates 4 separate buffers and stores their addresses in our variables. 
-            // For multiple buffers like this, there's an option for generating multiple buffers 
-            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
-            GL.GenBuffers(1, out vbo_position);
-            GL.GenBuffers(1, out vbo_color);
-            GL.GenBuffers(1, out vbo_mview);
-            GL.GenBuffers(1, out ibo_elements);
-
-            Random rand = new Random();
-
-            float xPos = -1.0f;
-            for (int i = 0; i < 2; i++)
-            {
-                Sierpinski sier = new Sierpinski();
-
-                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
-                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
-                sier.Scale = Vector3.One;
-                objects.Add(sier);
-
-                xPos = 1.0f;
-            }
-        }
-
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            initProgram();
-
-            Title = "AWGL - High level OpenTK wrapper";
-            GL.ClearColor(Color.Black);
-            GL.PointSize(3f);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.EnableVertexAttribArray(attribute_vpos);
-            GL.EnableVertexAttribArray(attribute_vcolor);
-
-            int indiceAt = 0;
-            
-            foreach (Volume v in objects)
-            {
-                GL.UniformMatrix4(uniform_mview, false, ref v.ModelViewProjectionMatrix);
-                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
-                indiceAt += v.IndiceCount;
-            }
-
-            // Keep things clean:
-            GL.DisableVertexAttribArray(attribute_vpos);
-            GL.DisableVertexAttribArray(attribute_vcolor);
-            GL.Flush();
-
-            SwapBuffers();
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            time += (float)e.Time;
-
-            List<Vector3> verts = new List<Vector3>();
-            List<int> inds = new List<int>();
-            List<Vector3> colors = new List<Vector3>();
-
-            int vertCount = 0;
-
-            foreach (Volume v in objects)
-            {
-                verts.AddRange(v.GetVerts().ToList());
-                inds.AddRange(v.GetIndices().ToList());
-                colors.AddRange(v.GetColorData().ToList());
-                vertCount += v.VertCount;
-            }
-
-            vertData = verts.ToArray();
-            indiceData = inds.ToArray();
-            colorData = colors.ToArray();
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_position);  // 1. Bind vertex data to the buffer.
-            GL.BufferData<Vector3>(                                 // 2. Send data.
-                BufferTarget.ArrayBuffer, (IntPtr)(vertData.Length * Vector3.SizeInBytes), 
-                vertData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                attribute_vpos, 3, VertexAttribPointerType.Float, false, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo_color);     // 1. Bind color data to the buffer
-            GL.BufferData<Vector3>(                                 // 2. Send Data
-                BufferTarget.ArrayBuffer, (IntPtr)(colorData.Length * Vector3.SizeInBytes),
-                colorData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                attribute_vcolor, 3, VertexAttribPointerType.Float, true, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ibo_elements);
-            GL.BufferData(
-                BufferTarget.ElementArrayBuffer, (IntPtr)(indiceData.Length * sizeof(int)),
-                indiceData, BufferUsageHint.StaticDraw);
-            
-            // Rotate objects
-            for (int i = 0; i < objects.Count; i++)
-            {
-                objects[i].Rotation = new Vector3(0.55f * time, 0.25f * time, 0);
-            }
-
-            // Send model view matrix
-            foreach (Volume v in objects)
-            {
-                v.CalculateModelMatrix();
-                v.ViewProjectionMatrix = 
-                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
-                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
-            }
-
-            GL.UseProgram(programID);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-        }
-
-        private void loadShader(String filename, ShaderType type, int program, out int address)
-        {
-            address = GL.CreateShader(type);
-            using (StreamReader sr = new StreamReader("Shaders/" + filename))
-            {
-                GL.ShaderSource(address, sr.ReadToEnd());
-            }
-            GL.CompileShader(address);
-            GL.AttachShader(program, address);
-            Console.WriteLine(GL.GetShaderInfoLog(address));
-        }
-    }
-}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
index aef1266..8e1dc3c 100644
--- a/AWGL/Shapes/Cube.cs
+++ b/AWGL/Shapes/Cube.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
index 822db60..4270204 100644
--- a/AWGL/Shapes/Sierpinski.cs
+++ b/AWGL/Shapes/Sierpinski.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 using System;
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
index 5003fa9..c29c8fe 100644
--- a/AWGL/Shapes/Tetra.cs
+++ b/AWGL/Shapes/Tetra.cs
@@ -1,3 +1,3 @@
 ﻿using OpenTK;
-using AWGL.Abstract;
+using AWGL.Shapes.Base;
 using System.Collections.Generic;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8da4ecd2bc793901ddb191f415f4dae1cda96c4a">Bit more tweaking and fiddling.</a>  -  8da4ecd</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 342 insertions(+)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
new file mode 100644
index 0000000..4881483
--- /dev/null
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -0,0 +1,301 @@
+﻿using AWGL.Shapes;
+using AWGL.Shapes.Base;
+using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+namespace AWGL.Scene.Base
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public abstract class DefaultScene : GameWindow
+    {
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+        }   
+
+        #region Private Fields
+
+        // GLSL Objects
+        private int m_VertexShaderObject, m_FragmentShaderObject, m_ProgramObject, m_TextureObject;
+
+        private int m_AttributeVertexPosition, m_AttributeVertexColor, m_UniformModelView;
+
+        private int m_Position_VBO, m_Color_VBO, m_ModelView_VBO, m_Elements_IBO;
+
+        private Vector3[] m_VertexData, m_ColorData;
+        protected List<Volume> m_Objects = new List<Volume>();
+        private int[] m_IndiceData;
+
+        private float m_Time = 0.0f;
+
+        private Version m_Version, m_TargetLow, m_TargetHigh;
+
+        #endregion Private Fields
+
+        #region InitProgram
+        
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        private void InitProgram()
+        {
+            m_ProgramObject = GL.CreateProgram();
+
+            loadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
+            loadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
+
+            // Links shaders and output any errors
+            GL.LinkProgram(m_ProgramObject);
+            Console.WriteLine(GL.GetProgramInfoLog(m_ProgramObject));
+
+            // Get the values we need, and also do a simple check to make sure the attributes were found.
+            m_AttributeVertexPosition = GL.GetAttribLocation(m_ProgramObject, "vPosition");
+            m_AttributeVertexColor = GL.GetAttribLocation(m_ProgramObject, "vColor");
+            m_UniformModelView = GL.GetUniformLocation(m_ProgramObject, "modelview");
+
+            if (m_AttributeVertexPosition == -1 || m_AttributeVertexColor == -1 || m_UniformModelView == -1)
+            {
+                Console.WriteLine("Error binding attributes");
+            }
+
+            // This generates 4 separate buffers and stores their addresses in our variables. 
+            // For multiple buffers like this, there's an option for generating multiple buffers 
+            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
+            GL.GenBuffers(1, out m_Position_VBO);
+            GL.GenBuffers(1, out m_Color_VBO);
+            GL.GenBuffers(1, out m_ModelView_VBO);
+            GL.GenBuffers(1, out m_Elements_IBO);
+
+            Random rand = new Random();
+
+            float xPos = -1.0f;
+            for (int i = 0; i < 2; i++)
+            {
+                Sierpinski sier = new Sierpinski();
+
+                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
+                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
+                sier.Scale = Vector3.One;
+                m_Objects.Add(sier);
+
+                xPos = 1.0f;
+            }
+        }
+
+        #endregion
+
+        #region OnLoad
+
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GetOpenGLVersion();
+
+            InitProgram();
+
+            Title = "AWGL: High level OpenTK wrapper   -   OpenGL " + m_Version.ToString();
+            GL.ClearColor(Color.MidnightBlue);
+            GL.PointSize(3f);
+        }
+
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+
+        }
+
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.EnableVertexAttribArray(m_AttributeVertexPosition);
+            GL.EnableVertexAttribArray(m_AttributeVertexColor);
+
+            int indiceAt = 0;
+            
+            foreach (Volume v in m_Objects)
+            {
+                GL.UniformMatrix4(m_UniformModelView, false, ref v.ModelViewProjectionMatrix);
+                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
+                indiceAt += v.IndiceCount;
+            }
+
+            // Keep things clean:
+            GL.DisableVertexAttribArray(m_AttributeVertexPosition);
+            GL.DisableVertexAttribArray(m_AttributeVertexColor);
+            GL.Flush();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Keyboard[OpenTK.Input.Key.Escape])
+            {
+                this.Exit();
+            }
+
+            m_Time += (float)e.Time;
+
+            List<Vector3> verts = new List<Vector3>();
+            List<int> inds = new List<int>();
+            List<Vector3> colors = new List<Vector3>();
+
+            int vertCount = 0;
+
+            foreach (Volume v in m_Objects)
+            {
+                verts.AddRange(v.GetVerts().ToList());
+                inds.AddRange(v.GetIndices().ToList());
+                colors.AddRange(v.GetColorData().ToList());
+                vertCount += v.VertCount;
+            }
+
+            m_VertexData = verts.ToArray();
+            m_IndiceData = inds.ToArray();
+            m_ColorData = colors.ToArray();
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Position_VBO);  // 1. Bind vertex data to the buffer.
+            GL.BufferData<Vector3>(                                 // 2. Send data.
+                BufferTarget.ArrayBuffer, (IntPtr)(m_VertexData.Length * Vector3.SizeInBytes), 
+                m_VertexData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                m_AttributeVertexPosition, 3, VertexAttribPointerType.Float, false, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Color_VBO);     // 1. Bind color data to the buffer
+            GL.BufferData<Vector3>(                                 // 2. Send Data
+                BufferTarget.ArrayBuffer, (IntPtr)(m_ColorData.Length * Vector3.SizeInBytes),
+                m_ColorData, BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
+                m_AttributeVertexColor, 3, VertexAttribPointerType.Float, true, 0, 0);
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, m_Elements_IBO);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, (IntPtr)(m_IndiceData.Length * sizeof(int)),
+                m_IndiceData, BufferUsageHint.StaticDraw);
+            
+            // Rotate objects
+            for (int i = 0; i < m_Objects.Count; i++)
+            {
+                m_Objects[i].Rotation = new Vector3(0.55f * m_Time, 0.25f * m_Time, 0);
+            }
+
+            // Send model view matrix
+            foreach (Volume v in m_Objects)
+            {
+                v.CalculateModelMatrix();
+                v.ViewProjectionMatrix = 
+                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
+                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
+            }
+
+            GL.UseProgram(m_ProgramObject);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+        }
+
+        #endregion
+
+        #region GetOpenGLVersion
+
+        /// <summary>
+        /// Get OpenGL Version Information and check system meets requirements
+        /// </summary>
+        private void GetOpenGLVersion()
+        {
+            m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            m_TargetLow = new Version(3, 1);
+            m_TargetHigh = new Version(4, 1);
+            if (m_Version < m_TargetLow)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
+            }
+            else if (m_Version > m_TargetHigh)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
+            }
+        }
+
+        #endregion
+
+        #region loadShader
+
+        /// <summary>
+        /// Helper Funtion for loading shaders
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <param name="program">Program ID to add Shader too</param>
+        /// <param name="address">Shader Pointer</param>
+        private void loadShader(String filename, ShaderType type, int program, out int address)
+        {
+            address = GL.CreateShader(type);
+            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            {
+                GL.ShaderSource(address, sr.ReadToEnd());
+            }
+            GL.CompileShader(address);
+            GL.AttachShader(program, address);
+            Console.WriteLine(GL.GetShaderInfoLog(address));
+        }
+
+        #endregion
+
+    }
+}
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
new file mode 100644
index 0000000..f416196
--- /dev/null
+++ b/AWGL/Scene/Display.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using AWGL.Scene.Base;
+
+namespace AWGL.Scene
+{
+    public class Display : DefaultScene
+    {
+
+    }
+}
diff --git a/AWGL/Shapes/Base/Volume.cs b/AWGL/Shapes/Base/Volume.cs
new file mode 100644
index 0000000..5435f94
--- /dev/null
+++ b/AWGL/Shapes/Base/Volume.cs
@@ -0,0 +1,27 @@
+﻿using OpenTK;
+
+namespace AWGL.Shapes.Base
+{
+    public abstract class Volume
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Rotation = Vector3.Zero;
+        public Vector3 Scale = Vector3.One;
+
+        public int VertCount;
+        public int IndiceCount;
+        public int ColorDataCount;
+        public Matrix4 ModelMatrix = Matrix4.Identity;
+        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
+        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
+
+        public abstract Vector3[] GetVerts();
+        public abstract int[] GetIndices(int offset = 0);
+        public abstract Vector3[] GetColorData();
+        public abstract void CalculateModelMatrix();
+
+
+
+    } // class
+
+} // namespace

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e4a83e843565af0d6283be83bf84611d2ba277db">~</a>  -  e4a83e8</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index bfade2c..7565562 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -17,10 +17,2 @@ namespace AWGL
         
-        public static void Main(string[] args)
-        {
-            using (Display mainDisplay = new Display())
-            {
-                mainDisplay.Run(30.0);
-            }
-        }
-        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 4881483..eb96537 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -34,3 +34,3 @@ namespace AWGL.Scene.Base
         private Vector3[] m_VertexData, m_ColorData;
-        protected List<Volume> m_Objects = new List<Volume>();
+        private List<Volume> m_Objects = new List<Volume>();
         private int[] m_IndiceData;
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index c75c740..7cf872d 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -7,2 +7,5 @@ using System.Threading.Tasks;
 using AWGL;
+using AWGL.Scene;
+
+using OpenTK;
 
@@ -15,3 +18,6 @@ namespace TestApplication
         {
-            AWGL.AWGL.Main(args);
+            using (Display mainDisplay = new Display())
+            {
+                mainDisplay.Run(30.0);
+            }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e66febde0fcee39d753125bfaa08d77e5b8ee009">~</a>  -  e66febd</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
index 607bcb0..2d62a94 100644
--- a/AWGL/Graphic.cs
+++ b/AWGL/Graphic.cs
@@ -8,3 +8,3 @@ namespace AWGL
 {
-    abstract class Graphic
+    public abstract class Graphic
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/54150ceec67eb4e5536e4857f4bddc9f104ab311">Adding various primitive shapes from the OpenTK Example project.</a>  -  54150ce</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 25 files changed, 2627 insertions(+), 332 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index eb96537..fa3ebd3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -6,2 +6,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
@@ -12,3 +13,3 @@ using System.Linq;
 
-namespace AWGL.Scene.Base
+namespace AWGL.Scene
 {
@@ -22,2 +23,4 @@ namespace AWGL.Scene.Base
         {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
         }   
@@ -34,3 +37,3 @@ namespace AWGL.Scene.Base
         private Vector3[] m_VertexData, m_ColorData;
-        private List<Volume> m_Objects = new List<Volume>();
+        private List<DrawableShape> m_Objects = new List<DrawableShape>();
         private int[] m_IndiceData;
@@ -43,2 +46,23 @@ namespace AWGL.Scene.Base
 
+        #region Keyboard_KeyDown
+
+        /// <summary>
+        /// Occurs when a key is pressed.
+        /// </summary>
+        /// <param name="sender">The KeyboardDevice which generated this event.</param>
+        /// <param name="e">The key that was pressed.</param>
+        void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                this.Exit();
+
+            if (e.Key == Key.F11)
+                if (this.WindowState == WindowState.Fullscreen)
+                    this.WindowState = WindowState.Normal;
+                else
+                    this.WindowState = WindowState.Fullscreen;
+        }
+
+        #endregion
+
         #region InitProgram
@@ -52,4 +76,4 @@ namespace AWGL.Scene.Base
 
-            loadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
-            loadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
+            LoadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
+            LoadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
 
@@ -80,13 +104,13 @@ namespace AWGL.Scene.Base
             float xPos = -1.0f;
-            for (int i = 0; i < 2; i++)
-            {
-                Sierpinski sier = new Sierpinski();
+            //for (int i = 0; i < 2; i++)
+            //{
+                Place plane = new Plane();
 
-                sier.Position = new Vector3(xPos, 0.0f, -2.5f);
-                sier.Rotation = new Vector3(0.55f, 0.25f, 0);
-                sier.Scale = Vector3.One;
-                m_Objects.Add(sier);
+                plane.Position = new Vector3(xPos, 0.0f, -2.5f);
+                plane.Rotation = new Vector3(0.55f, 0.25f, 0);
+                plane.Scale = Vector3.One;
+                m_Objects.Add(plane);
 
                 xPos = 1.0f;
-            }
+            //}
         }
@@ -104,3 +128,3 @@ namespace AWGL.Scene.Base
 
-            GetOpenGLVersion();
+            TestOpenGLVersion();
 
@@ -108,3 +132,4 @@ namespace AWGL.Scene.Base
 
-            Title = "AWGL: High level OpenTK wrapper   -   OpenGL " + m_Version.ToString();
+            Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
             GL.ClearColor(Color.MidnightBlue);
@@ -187,7 +212,2 @@ namespace AWGL.Scene.Base
 
-            if (Keyboard[OpenTK.Input.Key.Escape])
-            {
-                this.Exit();
-            }
-
             m_Time += (float)e.Time;
@@ -257,3 +277,3 @@ namespace AWGL.Scene.Base
         /// </summary>
-        private void GetOpenGLVersion()
+        private void TestOpenGLVersion()
         {
@@ -276,3 +296,3 @@ namespace AWGL.Scene.Base
 
-        #region loadShader
+        #region LoadShader
 
@@ -285,3 +305,3 @@ namespace AWGL.Scene.Base
         /// <param name="address">Shader Pointer</param>
-        private void loadShader(String filename, ShaderType type, int program, out int address)
+        private void LoadShader(String filename, ShaderType type, int program, out int address)
         {
@@ -299,2 +319,37 @@ namespace AWGL.Scene.Base
 
+        #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
+
+        Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
+        {
+            Vbo handle = new Vbo();
+            int size;
+
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. Check that the buffer was uploaded correctly.
+
+            GL.GenBuffers(1, out handle.VboID);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(vertices.Length * BlittableValueType.StrideOf(vertices)), vertices,
+                          BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (vertices.Length * BlittableValueType.StrideOf(vertices) != size)
+                throw new ApplicationException("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out handle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(elements.Length * sizeof(short)), elements,
+                          BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (elements.Length * sizeof(short) != size)
+                throw new ApplicationException("Element data not uploaded correctly");
+
+            handle.NumElements = elements.Length;
+            return handle;
+        }
+
+        #endregion
+
+
     }
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
new file mode 100644
index 0000000..d8d71ca
--- /dev/null
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -0,0 +1,181 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL.Shapes
+{
+    // Abstract base class for procedurally generated geometry
+    // 
+    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
+    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
+    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
+    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
+    // Can use a Display List to prevent repeated immediate mode draws.
+    //
+
+    public abstract class DrawableShape: IDisposable
+    {
+        protected BeginMode PrimitiveMode;
+        protected VertexT2dN3dV3d[] VertexArray;
+        protected uint[] IndexArray;
+
+        public int GetTriangleCount
+        {
+            get
+            {
+                switch ( PrimitiveMode )
+                { 
+                case BeginMode.Triangles:
+                    if ( IndexArray != null )
+                    {
+                        return IndexArray.Length / 3;
+                    } else
+                    {
+                        return VertexArray.Length / 3;
+                    }
+                  //  break;
+                default: throw new NotImplementedException("Unknown primitive type.");
+                }
+            }
+        }
+
+        #region Display List
+
+        private bool UseDisplayList;
+        private int DisplayListHandle = 0;
+
+        #endregion Display List
+
+        public DrawableShape( bool useDisplayList )
+        {
+            UseDisplayList = useDisplayList;
+            PrimitiveMode = BeginMode.Triangles;
+            VertexArray = null;
+            IndexArray = null;
+        }
+
+        #region Convert to VBO
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2dN3dV3d[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = VertexArray[i].TexCoord;
+                vertices[i].Normal = VertexArray[i].Normal;
+                vertices[i].Position = VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2fN3fV3f[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2hN3hV3h[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3h)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        #endregion Convert to VBO
+
+        private void DrawImmediateMode()
+        {
+            GL.Begin( PrimitiveMode );
+            {
+                if ( IndexArray == null )
+                    foreach ( VertexT2dN3dV3d v in VertexArray )
+                    {
+                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
+                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
+                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
+                    } else
+                {
+                    for ( uint i = 0; i < IndexArray.Length; i++ )
+                    {
+                        uint index = IndexArray[i];
+                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
+                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
+                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
+                    }
+                }
+            }
+            GL.End();
+        }
+
+        /// <summary>
+        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
+        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
+        /// </summary>
+        public void Draw()
+        {
+            if ( !UseDisplayList )
+                DrawImmediateMode();
+            else
+                if ( DisplayListHandle == 0 )
+                {
+                    if ( VertexArray == null )
+                        throw new Exception("Cannot draw null Vertex Array.");
+                    DisplayListHandle = GL.GenLists( 1 );
+                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
+                    DrawImmediateMode();
+                    GL.EndList();
+                } else
+                    GL.CallList( DisplayListHandle );
+        }
+
+        #region IDisposable Members
+
+        /// <summary>
+        /// Removes reference to VertexArray and IndexArray.
+        /// Deletes the Display List, so it requires an OpenGL context.
+        /// The instance is effectively destroyed.
+        /// </summary>
+        public void Dispose()
+        {
+            if ( VertexArray != null )
+                VertexArray = null;
+            if ( IndexArray != null )
+                IndexArray = null;
+            if ( DisplayListHandle != 0 )
+            {
+                GL.DeleteLists( DisplayListHandle, 1 );
+                DisplayListHandle = 0;
+            }
+        }
+
+        #endregion
+    }
+
+}
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
new file mode 100644
index 0000000..670eb9f
--- /dev/null
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -0,0 +1,36 @@
+using System;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public struct VertexT2dN3dV3d
+    {
+        public Vector2d TexCoord;
+        public Vector3d Normal;
+        public Vector3d Position;
+
+        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        {
+            TexCoord = texcoord;
+            Normal = normal;
+            Position = position;
+        }
+    }
+
+    public struct VertexT2fN3fV3f
+    {
+        public Vector2 TexCoord;
+        public Vector3 Normal;
+        public Vector3 Position;
+    }
+
+    public struct VertexT2hN3hV3h
+    {
+        public Vector2h TexCoord;
+        public Vector3h Normal;
+        public Vector3h Position;
+    }
+
+   
+}
diff --git a/AWGL/Shapes/Base/Volume.cs b/AWGL/Shapes/Base/Volume.cs
deleted file mode 100644
index 5435f94..0000000
--- a/AWGL/Shapes/Base/Volume.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Shapes.Base
-{
-    public abstract class Volume
-    {
-        public Vector3 Position = Vector3.Zero;
-        public Vector3 Rotation = Vector3.Zero;
-        public Vector3 Scale = Vector3.One;
-
-        public int VertCount;
-        public int IndiceCount;
-        public int ColorDataCount;
-        public Matrix4 ModelMatrix = Matrix4.Identity;
-        public Matrix4 ViewProjectionMatrix = Matrix4.Identity;
-        public Matrix4 ModelViewProjectionMatrix = Matrix4.Identity;
-
-        public abstract Vector3[] GetVerts();
-        public abstract int[] GetIndices(int offset = 0);
-        public abstract Vector3[] GetColorData();
-        public abstract void CalculateModelMatrix();
-
-
-
-    } // class
-
-} // namespace
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
new file mode 100644
index 0000000..60abd5b
--- /dev/null
+++ b/AWGL/Shapes/Capsule.cs
@@ -0,0 +1,110 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class Capsule: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+        }
+
+
+        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            uint HoseSubDivs = 0;
+            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+                HoseSubDivs = 0;
+                break;
+            case eSubdivisions.One:
+                spheresubdivs = SlicedSphere.eSubdivisions.One;
+                HoseSubDivs = 1;
+                break;
+            case eSubdivisions.Two:
+                spheresubdivs = SlicedSphere.eSubdivisions.Two;
+                HoseSubDivs = 3;
+                break;
+            case eSubdivisions.Three:
+                spheresubdivs = SlicedSphere.eSubdivisions.Three;
+                HoseSubDivs = 7;
+                break;
+            case eSubdivisions.Four:
+                spheresubdivs = SlicedSphere.eSubdivisions.Four;
+                HoseSubDivs = 15;
+                break;
+            }
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
+                     offset2 = new Vector3d( 0.0, 0.0, -height );
+            for ( int i = 0; i < 4; i++ )
+            {
+                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
+                switch ( i )
+                {
+                case 0:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    break;
+                }
+                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+
+            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
+                                                       new SlicedSphere.eDir[] {
+                                                           SlicedSphere.eDir.BackBottomRight,
+                                                           SlicedSphere.eDir.FrontTopRight,
+                                                           SlicedSphere.eDir.BackTopRight,
+                                                           SlicedSphere.eDir.FrontBottomRight, 
+                                                          },
+                                                       false );
+
+            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            front.Dispose();
+
+            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
+                                                      new SlicedSphere.eDir[] { 
+                                                          SlicedSphere.eDir.FrontBottomLeft,
+                                                          SlicedSphere.eDir.FrontTopLeft, 
+                                                          SlicedSphere.eDir.BackTopLeft,
+                                                          SlicedSphere.eDir.BackBottomLeft },
+                                                      false );
+            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            back.Dispose();
+
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+        }
+    }
+}
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
new file mode 100644
index 0000000..da8df0a
--- /dev/null
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -0,0 +1,280 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class ChamferCube: DrawableShape
+    {
+
+        public enum SubDivs: byte
+        {
+            Zero,
+            One,
+            Two,
+            Three,
+            Four,
+        }
+
+        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
+            : base( useDL )
+        {   
+            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+            uint hoseSubDivs = 0;
+
+            switch ( subdivs )
+            {
+            case SubDivs.Zero:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+                hoseSubDivs = 0;
+                break;
+            case SubDivs.One:
+                sphereSubDivs = SlicedSphere.eSubdivisions.One;
+                hoseSubDivs = 1;
+                break;
+            case SubDivs.Two:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
+                hoseSubDivs = 3;
+                break;
+            case SubDivs.Three:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
+                hoseSubDivs = 7;
+                break;
+            case SubDivs.Four:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
+                hoseSubDivs = 15;
+                break;
+            }
+
+            #region Temporary Storage
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            #endregion Temporary Storage
+
+            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
+            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
+            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
+            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
+            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
+            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
+            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
+            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
+
+            #region 8 sliced Spheres
+            SlicedSphere tempSphere;
+            Vector3d tempVector = Vector3d.Zero;
+            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
+
+            for ( int i = 0; i < 8; i++ )
+            {
+                switch ( i )
+                {
+                case 0:
+                    tempVector = FrontTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
+                    break;
+                case 1:
+                    tempVector = FrontTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
+                    break;
+                case 2:
+                    tempVector = FrontBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
+                    break;
+                case 3:
+                    tempVector = FrontBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
+                    break;
+                case 4:
+                    tempVector = BackBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
+                    break;
+                case 5:
+                    tempVector = BackBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
+                    break;
+                case 6:
+                    tempVector = BackTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
+                    break;
+                case 7:
+                    tempVector = BackTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
+                    break;
+                }
+                tempSphere = new SlicedSphere( radius,
+                                                 tempVector,
+                                                 sphereSubDivs,
+                                                 tempEdge,
+                                                 false );
+                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempSphere.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 8 sliced Spheres
+
+            #region 12 sliced Hoses
+
+            SlicedHose tempHose;
+            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
+            Vector3d tempHoseStart = Vector3d.Zero;
+            Vector3d tempHoseEnd = Vector3d.Zero;
+
+            for ( int i = 0; i < 12; i++ )
+            {
+                switch ( i )
+                {
+                #region Around X Axis
+                case 0:
+                    tempSide = SlicedHose.eSide.BottomRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = FrontBottomRightEdge;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.TopRight;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.TopLeft;
+                    tempHoseStart = BackTopLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.BottomLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around X Axis
+                #region Around Y Axis
+                case 4:
+                    tempSide = SlicedHose.eSide.FrontRight;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 5:
+                    tempSide = SlicedHose.eSide.BackRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackTopRightEdge;
+                    break;
+                case 6:
+                    tempSide = SlicedHose.eSide.BackLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 7:
+                    tempSide = SlicedHose.eSide.FrontLeft;
+                    tempHoseStart = FrontBottomLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                #endregion Around Y Axis
+                #region Around Z Axis
+                case 8:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    tempHoseStart = FrontTopRightEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 9:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 10:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackBottomLeftEdge;
+                    break;
+                case 11:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around Z Axis
+                }
+                tempHose = new SlicedHose( tempSide,
+                                             hoseSubDivs,
+                                             radius,
+                                             tempHoseStart,
+                                             tempHoseEnd,
+                                             false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 12 sliced Hoses
+
+            #region 6 quads for the sides
+
+            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
+            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
+
+            // all quads use the same texcoords
+            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
+            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
+            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
+            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
+
+            // front face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
+            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // back face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
+            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // top face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // bottom face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
+            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // right face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // left face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
+            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+
+            #endregion 6 quads for the sides
+
+            #region Final Assembly of Chunks
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+            #endregion Final Assembly of Chunks
+        }
+    }
+}
diff --git a/AWGL/Shapes/ColourCube.cs b/AWGL/Shapes/ColourCube.cs
deleted file mode 100644
index 18eb637..0000000
--- a/AWGL/Shapes/ColourCube.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK;
-
-namespace AWGL.Shapes
-{
-    class ColourCube : Cube
-    {
-        Vector3 Color = new Vector3(1, 1, 1);
- 
-        public ColourCube(Vector3 color) : base() {
-            Color = color;
-        }
-
-        public ColourCube()
-        {
-
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] { 
-                Color,
-                Color, 
-                Color,
-                Color,
-                Color, 
-                Color, 
-                Color, 
-                Color
-            };
-        }
-    }
-}
diff --git a/AWGL/Shapes/Cube.cs b/AWGL/Shapes/Cube.cs
deleted file mode 100644
index 8e1dc3c..0000000
--- a/AWGL/Shapes/Cube.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-
-namespace AWGL.Shapes
-{
-    public class Cube : Volume
-    {
-        public Cube()
-        {
-            VertCount = 8;
-            IndiceCount = 36;
-            ColorDataCount = 8;
-        }
-
-        public override Vector3[] GetVerts()
-        {
-            return new Vector3[] {new Vector3(-0.5f, -0.5f,  -0.5f),
-                new Vector3(0.5f, -0.5f,  -0.5f),
-                new Vector3(0.5f, 0.5f,  -0.5f),
-                new Vector3(-0.5f, 0.5f,  -0.5f),
-                new Vector3(-0.5f, -0.5f,  0.5f),
-                new Vector3(0.5f, -0.5f,  0.5f),
-                new Vector3(0.5f, 0.5f,  0.5f),
-                new Vector3(-0.5f, 0.5f,  0.5f),
-            };
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = new int[] {
-                //left
-                0, 2, 1,
-                0, 3, 2,
-                //back
-                1, 2, 6,
-                6, 5, 1,
-                //right
-                4, 5, 6,
-                6, 7, 4,
-                //top
-                2, 3, 6,
-                6, 3, 7,
-                //front
-                0, 7, 3,
-                0, 4, 7,
-                //bottom
-                0, 1, 5,
-                0, 5, 4
-            };
-
-
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] {
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f),
-                new Vector3( 0f, 1f, 0f),
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f),
-                new Vector3( 0f, 1f, 0f),
-                new Vector3( 1f, 0f, 0f),
-                new Vector3( 0f, 0f, 1f)
-            };
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
new file mode 100644
index 0000000..40e7ebd
--- /dev/null
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -0,0 +1,82 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace AWGL.Shapes
+{
+    public class Chunk
+    {
+        public VertexT2dN3dV3d[] Vertices;
+        public uint[] Indices;
+
+        public uint VertexCount
+        {
+            get
+            {
+                return (uint)Vertices.Length;
+            }
+        }
+        public uint IndexCount
+        {
+            get
+            {
+                return (uint)Indices.Length;
+            }
+        }
+
+        public Chunk( uint vertexcount, uint indexcount )
+        {
+            Vertices = new VertexT2dN3dV3d[vertexcount];
+            Indices = new uint[indexcount];
+        }
+
+        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
+        {
+            Vertices = new VertexT2dN3dV3d[vbo.Length];
+            for ( int i = 0; i < Vertices.Length; i++ )
+            {
+                Vertices[i] = vbo[i];
+            } 
+            Indices = new uint[ibo.Length];
+            for ( int i = 0; i < Indices.Length; i++ )
+            {
+                Indices[i] = ibo[i];
+            }
+        }
+
+        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
+        {
+
+            uint VertexCounter = 0;
+            uint IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                VertexCounter += ch.VertexCount;
+                IndexCounter += ch.IndexCount;
+            }
+
+            vbo = new VertexT2dN3dV3d[VertexCounter];
+            ibo = new uint[IndexCounter];
+
+            VertexCounter = 0;
+            IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    vbo[VertexCounter + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
+                }
+
+                VertexCounter += (uint)ch.VertexCount;
+                IndexCounter += (uint)ch.IndexCount;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
new file mode 100644
index 0000000..cc08332
--- /dev/null
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -0,0 +1,422 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class MengerSponge
+    {
+        private struct MengerCube
+        {
+            private Vector3d Center;
+            private double SideLength;
+            private eSides[] VisibleSides;
+            private eSides[] VisibilityToInherit;
+
+            public void GetArraySizes( out uint vertexcount, out uint indexcount )
+            {
+                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
+                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
+            }
+
+            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
+            {
+                Center = center;
+                SideLength = sidelength;
+
+                /*  List<eSides> Sides = new List<eSides>();
+                  foreach ( eSides s in visibleSides )
+                  {
+                      bool isVisible = false;
+                      foreach ( eSides p in parentsVisibility )
+                      {
+                          if ( (int)p == (int)s )
+                          {
+                              isVisible = true;
+                              break;
+                          }
+                      }
+                      if ( isVisible )
+                      {
+                          Sides.Add( s );
+                      }
+                  }
+                  VisibleSides = Sides.ToArray();*/
+                VisibleSides = visibleSides;
+                VisibilityToInherit = visibleSides;
+            }
+
+            public void Subdivide( out MengerCube[] cubes )
+            {
+                cubes = new MengerCube[20]; // 8 + 4 + 8
+
+                double NewLength = this.SideLength / 3.0;
+                double six = this.SideLength * 2.0 / 3.0;
+                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
+
+                // front
+                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
+                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
+                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
+
+                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
+                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
+                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
+
+                // center
+                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                // back
+                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
+
+                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+
+                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
+                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
+
+            }
+
+            public enum eSides: byte
+            {
+                Front,
+                Back,
+                Right,
+                Left,
+                Top,
+                Bottom
+            }
+
+            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
+
+            public void GetVboAndIbo( ref List<Chunk> chunks )
+            {
+                foreach ( eSides s in AllSides )
+                {
+                    DrawSide( s, ref chunks );
+                }
+            }
+
+            private void DrawSide( eSides side, ref List<Chunk> chunks )
+            {
+                #region Setup constants for current direction
+
+                double _Zero = 0.0; // 0/3
+                double _Three = 0.3333333333333; // 1/3
+                double _Six = 0.66666666666666; // 2/3
+                double _One = 1.0; // 3/3 
+
+                double ThirdLength = SideLength / 3f;
+
+                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
+                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
+                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
+                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
+
+                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
+                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
+                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
+                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
+
+                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    P0 = C0;
+                    P1 = C1;
+                    P2 = C2;
+                    P3 = C3;
+
+                    P4 = C4;
+                    P5 = C5;
+                    P6 = C6;
+                    P7 = C7;
+                    break;
+                case eSides.Back:
+                    P0 = C5;
+                    P1 = C4;
+                    P2 = C7;
+                    P3 = C6;
+
+                    P4 = C1;
+                    P5 = C0;
+                    P6 = C3;
+                    P7 = C2;
+                    break;
+                case eSides.Right:
+                    P0 = C1;
+                    P1 = C5;
+                    P2 = C6;
+                    P3 = C2;
+
+                    P4 = C0;
+                    P5 = C4;
+                    P6 = C7;
+                    P7 = C3;
+                    break;
+                case eSides.Left:
+                    P0 = C4;
+                    P1 = C0;
+                    P2 = C3;
+                    P3 = C7;
+
+                    P4 = C5;
+                    P5 = C1;
+                    P6 = C2;
+                    P7 = C6;
+                    break;
+                case eSides.Top:
+                    P0 = C3;
+                    P1 = C2;
+                    P2 = C6;
+                    P3 = C7;
+
+                    P4 = C0;
+                    P5 = C1;
+                    P6 = C5;
+                    P7 = C4;
+                    break;
+                case eSides.Bottom:
+                    P0 = C1;
+                    P1 = C0;
+                    P2 = C4;
+                    P3 = C5;
+
+                    P4 = C2;
+                    P5 = C3;
+                    P6 = C7;
+                    P7 = C6;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+
+                #endregion Setup constants for current direction
+
+                #region Set Normal
+
+                Vector3d FaceNormal;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    FaceNormal = Vector3d.UnitZ;
+                    break;
+                case eSides.Back:
+                    FaceNormal = -Vector3d.UnitZ;
+                    break;
+                case eSides.Right:
+                    FaceNormal = Vector3d.UnitX;
+                    break;
+                case eSides.Left:
+                    FaceNormal = -Vector3d.UnitX;
+                    break;
+                case eSides.Top:
+                    FaceNormal = Vector3d.UnitY;
+                    break;
+                case eSides.Bottom:
+                    FaceNormal = -Vector3d.UnitY;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+                #endregion Set Normal
+
+                bool FaceIsVisible = false;
+                foreach ( eSides s in VisibleSides )
+                {
+                    if ( s == side )
+                    {
+                        FaceIsVisible = true;
+                        break;
+                    }
+                }
+
+                if ( FaceIsVisible )
+                {
+                    #region Define Layer1 Vertices
+                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
+
+                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
+                    Layer1.Vertices[0].Normal = FaceNormal;
+                    Layer1.Vertices[0].Position = P0;
+
+                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
+                    Layer1.Vertices[1].Normal = FaceNormal;
+                    Layer1.Vertices[1].Position = P1;
+
+                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
+                    Layer1.Vertices[2].Normal = FaceNormal;
+                    Layer1.Vertices[2].Position = P2;
+
+                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
+                    Layer1.Vertices[3].Normal = FaceNormal;
+                    Layer1.Vertices[3].Position = P3;
+
+                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
+                    Layer1.Vertices[4].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
+
+                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
+                    Layer1.Vertices[5].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
+
+                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
+                    Layer1.Vertices[6].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
+
+                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
+                    Layer1.Vertices[7].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
+                    #endregion Define Layer1 Vertices
+
+                    #region Define Layer1 Indices
+                    Layer1.Indices[0] = 0;
+                    Layer1.Indices[1] = 5;
+                    Layer1.Indices[2] = 4;
+
+                    Layer1.Indices[3] = 0;
+                    Layer1.Indices[4] = 1;
+                    Layer1.Indices[5] = 5;
+
+                    Layer1.Indices[6] = 5;
+                    Layer1.Indices[7] = 1;
+                    Layer1.Indices[8] = 2;
+
+                    Layer1.Indices[9] = 6;
+                    Layer1.Indices[10] = 5;
+                    Layer1.Indices[11] = 2;
+
+                    Layer1.Indices[12] = 7;
+                    Layer1.Indices[13] = 6;
+                    Layer1.Indices[14] = 2;
+
+                    Layer1.Indices[15] = 3;
+                    Layer1.Indices[16] = 7;
+                    Layer1.Indices[17] = 2;
+
+                    Layer1.Indices[18] = 0;
+                    Layer1.Indices[19] = 7;
+                    Layer1.Indices[20] = 3;
+
+                    Layer1.Indices[21] = 0;
+                    Layer1.Indices[22] = 4;
+                    Layer1.Indices[23] = 7;
+
+                    chunks.Add( Layer1 );
+                    #endregion Define Layer1 Indices
+                }
+
+                #region Define Layer2 Vertices
+                Chunk Layer2 = new Chunk( 12, 8 * 3 );
+
+                Vector3d T0, T1, T2, T3;
+                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
+                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
+                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
+                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
+
+                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
+                Layer2.Vertices[0].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
+
+                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
+                Layer2.Vertices[1].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
+
+                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
+                Layer2.Vertices[3].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
+
+                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
+                Layer2.Vertices[4].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
+
+                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
+                Layer2.Vertices[6].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
+
+                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
+                Layer2.Vertices[7].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
+
+                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
+                Layer2.Vertices[9].Normal = FaceNormal;
+                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
+
+                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
+                Layer2.Vertices[10].Normal = FaceNormal;
+                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
+
+                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
+                Layer2.Vertices[2].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
+
+                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
+                Layer2.Vertices[5].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
+
+                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
+                Layer2.Vertices[8].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
+
+                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
+                Layer2.Vertices[11].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
+                #endregion Define Layer2 Vertices
+
+                #region Define Layer2 Indices
+                Layer2.Indices[0] = 0;
+                Layer2.Indices[1] = 2;
+                Layer2.Indices[2] = 11;
+
+                Layer2.Indices[3] = 0;
+                Layer2.Indices[4] = 1;
+                Layer2.Indices[5] = 2;
+
+                Layer2.Indices[6] = 2;
+                Layer2.Indices[7] = 3;
+                Layer2.Indices[8] = 4;
+
+                Layer2.Indices[9] = 2;
+                Layer2.Indices[10] = 4;
+                Layer2.Indices[11] = 5;
+
+                Layer2.Indices[12] = 5;
+                Layer2.Indices[13] = 6;
+                Layer2.Indices[14] = 8;
+
+                Layer2.Indices[15] = 8;
+                Layer2.Indices[16] = 6;
+                Layer2.Indices[17] = 7;
+
+                Layer2.Indices[18] = 11;
+                Layer2.Indices[19] = 8;
+                Layer2.Indices[20] = 10;
+
+                Layer2.Indices[21] = 10;
+                Layer2.Indices[22] = 8;
+                Layer2.Indices[23] = 9;
+
+                chunks.Add( Layer2 );
+                #endregion Define Layer2 Indices
+            }
+        }
+    }
+
+   
+}
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
new file mode 100644
index 0000000..65f7f0b
--- /dev/null
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -0,0 +1,230 @@
+using System;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+
+    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
+    internal struct TetrahedronFace
+    {
+        private Vector3d APosition, BPosition, CPosition;
+        private Vector3d DPosition, Normal;
+        private Vector2d ATexCoord, BTexCoord, CTexCoord;
+
+        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
+                                   ref Vector3d bpos, ref Vector2d btc,
+                                   ref Vector3d cpos, ref Vector2d ctc,
+                                   ref Vector3d dpos,
+                                   ref Vector3d normal )
+        {
+            APosition = apos; ATexCoord = atc;
+            BPosition = bpos; BTexCoord = btc;
+            CPosition = cpos; CTexCoord = ctc;
+            DPosition = dpos;
+            Normal = normal;
+        }
+
+        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
+        /// <param name="first">1st output Triangle</param>
+        /// <param name="second">2nd output Triangle</param>
+        /// <param name="third">3rd output Triangle</param>
+        /// <param name="fourth">4th output Triangle</param>
+        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
+        {
+            Vector3d temp;
+
+            // find the 3 points AB, BC, CA 
+            Vector3d CenterAB;
+            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
+
+            Vector3d CenterBC;
+            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
+
+            Vector3d CenterCA;
+            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
+
+            // find the 3 points AD, BD, CD 
+            Vector3d CenterAD;
+            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
+
+            Vector3d CenterBD;
+            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
+
+            Vector3d CenterCD;
+            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
+
+            // emit 4 new CCW triangles
+            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
+                              ref CenterAB, ref this.BTexCoord,
+                              ref CenterCA, ref this.CTexCoord,
+                              ref CenterAD,
+                              ref this.Normal );
+
+            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
+                               ref this.BPosition, ref this.BTexCoord,
+                               ref CenterBC, ref this.CTexCoord,
+                               ref CenterBD,
+                               ref this.Normal );
+
+            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
+                              ref CenterBC, ref this.BTexCoord,
+                              ref this.CPosition, ref this.CTexCoord,
+                              ref CenterCD,
+                              ref this.Normal );
+
+            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
+                               ref CenterBD, ref this.BTexCoord,
+                               ref CenterCD, ref this.CTexCoord,
+                               ref this.DPosition,
+                               ref this.Normal );
+        }
+
+
+        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
+        {
+            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
+            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
+
+            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
+            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
+            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
+            CenterD = CenterAB;
+            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
+            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
+            CenterD /= 3.0;
+            Vector3d E = CenterD + ( this.Normal * 0.5 );
+            Vector3d temp = this.Normal;
+            temp *= height;
+            Vector3d.Add(ref CenterD, ref temp, out CenterD);
+
+            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
+            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
+            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
+            TexCoordD = TexCoordAB;
+            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
+            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
+            TexCoordD /= 3.0;
+            #region 1
+            first.APosition = this.APosition;
+            first.ATexCoord = this.ATexCoord;
+
+            first.BPosition = CenterAB;
+            first.BTexCoord = TexCoordAB;
+
+            first.CPosition = CenterCA;
+            first.CTexCoord = TexCoordCA;
+
+            first.Normal = this.Normal;
+            temp = ( this.APosition + CenterAB + CenterCA );
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            first.DPosition = temp;
+            #endregion 1
+            #region 2
+            second.APosition = CenterAB;
+            second.ATexCoord = TexCoordAB;
+
+            second.BPosition = this.BPosition;
+            second.BTexCoord = this.BTexCoord;
+
+            second.CPosition = CenterBC;
+            second.CTexCoord = TexCoordBC;
+
+            second.Normal = this.Normal;
+
+            temp = CenterAB + this.BPosition + CenterBC;
+            temp /=  3.0;
+            temp += this.Normal * -1.0;
+            second.DPosition = temp;
+
+            #endregion 2
+            #region 3
+            third.APosition = CenterBC;
+            third.ATexCoord = TexCoordBC;
+
+            third.BPosition = this.CPosition;
+            third.BTexCoord = this.CTexCoord;
+
+            third.CPosition = CenterCA;
+            third.CTexCoord = TexCoordCA;
+
+            third.Normal = this.Normal;
+            temp = CenterBC + this.CPosition + CenterCA;
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            third.DPosition = temp;
+            #endregion 3
+            #region 4
+            fourth.APosition = CenterAB;
+            fourth.ATexCoord = TexCoordAB;
+
+            fourth.BPosition = CenterD;
+            fourth.BTexCoord = TexCoordD;
+
+            fourth.CPosition = CenterCA;
+            fourth.CTexCoord = TexCoordCA;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
+            fourth.DPosition = E;
+            #endregion 4
+            #region 5
+            fifth.APosition = CenterAB;
+            fifth.ATexCoord = TexCoordAB;
+
+            fifth.BPosition = CenterBC;
+            fifth.BTexCoord = TexCoordBC;
+
+            fifth.CPosition = CenterD;
+            fifth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
+            fifth.DPosition = E;
+
+            #endregion 5
+            #region 6
+            sixth.APosition = CenterBC;
+            sixth.ATexCoord = TexCoordBC;
+
+            sixth.BPosition = CenterCA;
+            sixth.BTexCoord = TexCoordCA;
+
+            sixth.CPosition = CenterD;
+            sixth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
+            sixth.DPosition = E;
+            #endregion 6
+        }
+
+        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
+        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            first.TexCoord = this.ATexCoord;
+            first.Normal = this.Normal;
+            first.Position = this.APosition;
+
+            second.TexCoord = this.BTexCoord;
+            second.Normal = this.Normal;
+            second.Position = this.BPosition;
+
+            third.TexCoord = this.CTexCoord;
+            third.Normal = this.Normal;
+            third.Position = this.CPosition;
+        }
+
+        /// <summary>Debugging Aid, no real purpose</summary>
+        public override string ToString()
+        {
+            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "Normal= " + this.Normal.ToString();
+        }
+    }
+
+
+}
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
new file mode 100644
index 0000000..c791eb8
--- /dev/null
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -0,0 +1,27 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace AWGL.Shapes
+{
+    public sealed class VboShape: DrawableShape
+    {
+        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = primitives;
+
+            VertexArray = new VertexT2dN3dV3d[vertices.Length];
+            for ( uint i = 0; i < vertices.Length; i++ )
+            {
+                VertexArray[i] = vertices[i];
+            }
+
+            IndexArray = new uint[indices.Length];
+            for ( uint i = 0; i < indices.Length; i++ )
+            {
+                IndexArray[i] = indices[i];
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
new file mode 100644
index 0000000..1334082
--- /dev/null
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -0,0 +1,71 @@
+using System;
+using System.Collections.Generic;
+
+namespace AWGL.Shapes
+{
+    public sealed class KochTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
+                    Triangles = temp;
+                    extrusionHeight *= extrusionMultiplier;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
+        {
+            output = new TetrahedronFace[input.Length * 6];
+
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
+                counter += 6; // every source triangle emits 6 new triangles
+            }
+
+        }
+    }
+}
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
new file mode 100644
index 0000000..f81c6ad
--- /dev/null
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -0,0 +1,116 @@
+using System;
+using System.Collections.Generic;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class MengerSponge: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+        }
+
+        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            List<MengerCube> Cubes;
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    List<MengerCube> temp;
+                    SubdivideMengerSponge( ref Cubes, out temp );
+                    Cubes = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            #region Get Array Dimensions
+            uint
+                VertexCount = 0,
+                IndexCount = 0;
+
+            foreach ( MengerCube c in Cubes )
+            {
+                uint t1, t2;
+                c.GetArraySizes( out t1, out t2 );
+                VertexCount += t1;
+                IndexCount += t2;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[VertexCount];
+            IndexArray = new uint[IndexCount];
+            #endregion Get Array Dimensions
+
+            List<Chunk> AllChunks = new List<Chunk>();
+
+            #region Build a temporary List of all loose pieces
+            foreach ( MengerCube c in Cubes )
+            {
+                c.GetVboAndIbo( ref AllChunks );
+            }
+            #endregion Build a temporary List of all loose pieces
+
+            #region Assemble pieces into a single VBO and IBO
+            VertexCount = 0;
+            IndexCount = 0;
+
+            foreach ( Chunk ch in AllChunks )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    VertexArray[VertexCount + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
+                }
+
+                VertexCount += (uint)ch.Vertices.Length;
+                IndexCount += (uint)ch.Indices.Length;
+            }
+
+            #endregion Assemble pieces into a single VBO and IBO
+
+            AllChunks.Clear();
+        }
+
+        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( 1 );
+            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
+        }
+
+        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( input.Count * 20 );
+            foreach ( MengerCube InputCube in input )
+            {
+                MengerCube[] SubdividedCubes;
+                InputCube.Subdivide( out SubdividedCubes );
+                for ( int i = 0; i < SubdividedCubes.Length; i++ )
+                {
+                    output.Add( SubdividedCubes[i] );
+                }
+            }
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
new file mode 100644
index 0000000..b24f97e
--- /dev/null
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -0,0 +1,75 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Drawing;
+
+using System.Runtime.InteropServices;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public class Cube : Shape
+    {
+        public Cube()
+        {
+            Vertices = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f), 
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f)
+            };
+
+            Indices = new int[]
+            {
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1,
+            };
+
+            Normals = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f),
+            };
+
+            Colors = new int[]
+            {
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.DarkRed),
+                Utilities.ColorToRgba32(Color.Gold),
+                Utilities.ColorToRgba32(Color.Gold),
+            };
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
new file mode 100644
index 0000000..f10a171
--- /dev/null
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    class IsoSphere : Shape
+    {
+        const double DoublePI = System.Math.PI * 2.0;
+
+        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
+        {
+            int count = 4 * s_steps * t_steps ;
+            
+            Vertices = new Vector3[count];
+            Normals = new Vector3[count];
+            Texcoords = new Vector2[count];
+            Indices = new int[6 * count / 4];
+
+            int i = 0;
+            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
+            {
+                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
+                {
+                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
+                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
+                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
+                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
+                    Normals[i] = Vector3.Normalize(Vertices[i]);
+
+                    ++i;
+                }
+            }
+            
+            for (i = 0; i < 6*count/4; i+=6)
+            {
+                Indices[i] = i;
+                Indices[i + 1] = i + 1;
+                Indices[i + 2] = i + 2 * s_steps + 1;
+                Indices[i + 3] = i + 2 * s_steps;
+                Indices[i + 4] = i;
+                Indices[i + 5] = i + 2 * s_steps + 1;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
new file mode 100644
index 0000000..6c4801c
--- /dev/null
+++ b/AWGL/Shapes/Old/Plane.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public class Plane : Shape
+    {
+        public Plane(int x_res, int y_res, float x_scale, float y_scale)
+        {
+            Vertices = new Vector3[x_res * y_res];
+            Normals = new Vector3[x_res * y_res];
+            Indices = new int[6 * x_res * y_res];
+            Texcoords = new Vector2[x_res * y_res];
+
+            int i = 0;
+            for (int y = -y_res / 2; y < y_res / 2; y++)
+            {
+                for (int x = -x_res / 2; x < x_res / 2; x++)
+                {
+                    Vertices[i].X = x_scale * (float)x / (float)x_res;
+                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
+                    Vertices[i].Z = 0;
+                    Normals[i].X = Normals[i].Y = 0;
+                    Normals[i].Z = 1;
+                    i++;
+                }
+            }
+
+            i = 0;
+            for (int y = 0; y < y_res - 1; y++)
+            {
+                for (int x = 0; x < x_res - 1; x++)
+                {
+                    Indices[i++] = (y + 0) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x + 1;
+                }
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
new file mode 100644
index 0000000..e151ed1
--- /dev/null
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -0,0 +1,70 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using System.Runtime.InteropServices;
+using System.Drawing;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public abstract class Shape
+    {
+        private Vector3[] vertices, normals;
+        private Vector2[] texcoords;
+        private int[] indices;
+        private int[] colors;
+
+        public Vector3[] Vertices
+        {
+            get { return vertices; }
+            protected set
+            {
+                vertices = value;
+            }
+        }
+
+        public Vector3[] Normals
+        {
+            get { return normals; }
+            protected set
+            {
+                normals = value;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get { return texcoords; }
+            protected set
+            {
+                texcoords = value;
+            }
+        }
+
+        public int[] Indices
+        {
+            get { return indices; }
+            protected set
+            {
+                indices = value;
+            }
+        }
+
+        public int[] Colors
+        {
+            get { return colors; }
+            protected set
+            {
+                colors = value;
+            }
+        }
+    }
+}
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
new file mode 100644
index 0000000..da9a161
--- /dev/null
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -0,0 +1,173 @@
+using System;
+using System.Diagnostics;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed partial class SierpinskiTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
+            Zero = 0,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
+            One = 1,
+            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
+            Two = 2,
+            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
+            Three = 3,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
+            Four = 4,
+            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
+            Five = 5,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
+            Six = 6,
+            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
+            Seven = 7,
+            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
+            Eight = 8,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
+            Nine = 9,
+        }
+
+        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
+        /// <param name="scale">Default: 1f.</param>
+        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
+        /// <param name="useDL"></param>
+        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+            case eSubdivisions.Nine:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    SubdivideTetrahedron( ref Triangles, out temp );
+                    Triangles = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
+        {
+            output = new VertexT2dN3dV3d[input.Length * 3];
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
+                counter += 3;
+            }
+        }
+
+        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
+        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
+        {
+            Vector3d[] Points = new Vector3d[4];
+            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
+            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
+
+            Vector2d[] TexCoords = new Vector2d[4];
+            TexCoords[0] = new Vector2d( 0.0, 0.0 );
+            TexCoords[1] = new Vector2d( 1.0, 0.0 );
+            TexCoords[2] = new Vector2d( 0.0, 1.0 );
+            TexCoords[3] = new Vector2d( 1.0, 1.0 );
+
+            Vector3d Normal;
+            array = new TetrahedronFace[4];
+
+            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
+            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[2], ref TexCoords[0],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
+            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[1],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
+            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3], ref TexCoords[3],
+                                                   ref Points[2],
+                                                   ref Normal );
+
+            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
+            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[0],
+                                                   ref Normal );
+        }
+
+        /// <summary>Subdivides each triangle into 4 new ones.</summary>
+        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
+        {
+
+            output = new TetrahedronFace[source.Length * 4];
+
+            int counter = 0;
+            for ( int i = 0; i < source.Length; i++ )
+            {
+                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
+                counter += 4; // every source triangle emits 4 new triangles
+            }
+        }
+
+        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
+        {
+            Vector3d temp1, temp2, temp3;
+
+            Vector3d.Subtract( ref A, ref D, out temp1 );
+            Vector3d.Subtract( ref B, ref D, out temp2 );
+            Vector3d.Subtract( ref C, ref D, out temp3 );
+
+            Vector3d.Add( ref temp1, ref temp2, out result );
+            Vector3d.Add(ref result, ref temp3, out result);
+            result.Normalize();
+        }
+
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
+        {
+            Vector3d temp1, temp2;
+            Vector3d.Subtract( ref A, ref B, out temp1 );
+            temp1.Normalize();
+            Vector3d.Subtract(ref C, ref B, out temp2);
+            temp2.Normalize();
+            Vector3d.Cross( ref temp1, ref temp2, out result );
+            result *=  -1.0;
+            result.Normalize();
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Sierpinski.cs b/AWGL/Shapes/Sierpinski.cs
deleted file mode 100644
index 4270204..0000000
--- a/AWGL/Shapes/Sierpinski.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-using System;
-using System.Collections.Generic;
-
-namespace AWGL.Shapes
-{
-    class Sierpinski : Volume
-    {
-        public Sierpinski(int numSubdivisions = 1)
-        {
-            int NumTris = (int)Math.Pow(4, numSubdivisions + 1);
-
-            VertCount = NumTris;
-            ColorDataCount = NumTris;
-            IndiceCount = 3 * NumTris;
-
-            Tetra twhole = new Tetra(
-                new Vector3(0.0f, 0.0f, 1.0f),  // Apex center 
-                new Vector3(0.943f, 0.0f, -0.333f),  // Base center top
-                new Vector3(-0.471f, 0.816f, -0.333f),  // Base left bottom
-                new Vector3(-0.471f, -0.816f, -0.333f));
-
-            List<Tetra> allTets = twhole.Divide(numSubdivisions);
-
-            int offset = 0;
-            foreach (Tetra t in allTets)
-            {
-                verts.AddRange(t.GetVerts());
-                indices.AddRange(t.GetIndices(offset * 4));
-                colors.AddRange(t.GetColorData());
-                offset++;
-            }
-
-        }
-
-        private List<Vector3> verts = new List<Vector3>();
-        private List<int> indices = new List<int>();
-        private List<Vector3> colors = new List<Vector3>();
-
-        public override Vector3[] GetVerts()
-        {
-            return verts.ToArray();
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return colors.ToArray();
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = indices.ToArray();
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
new file mode 100644
index 0000000..4d7a536
--- /dev/null
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -0,0 +1,194 @@
+using System;
+using System.Collections.Generic;
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+	public sealed class SlicedHose : DrawableShape
+	{
+
+        public enum eSide:byte
+        {
+            // Around X Axis
+            BottomRight,
+            TopRight,
+            TopLeft,
+            BottomLeft,
+
+            // Around Y Axis
+
+            FrontRight,
+            BackRight,
+            BackLeft,
+            FrontLeft,
+
+            // Around Z Axis
+            FrontBottom,
+            BackBottom,
+            BackTop,
+            FrontTop,
+        }
+
+        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            Vector3d start = Vector3d.Zero,
+                     end = Vector3d.Zero;
+            double TexCoordStart=0f, TexCoordEnd=0f;
+
+            switch ( side )
+            {
+            #region Around X Axis
+            case eSide.BottomRight:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.TopRight:
+                start = Vector3d.UnitZ;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.TopLeft:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.BottomLeft:
+                start = -Vector3d.UnitZ;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+            #endregion Around X Axis
+            #region Around Y Axis
+            case eSide.FrontRight:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackRight:
+                start = Vector3d.UnitZ;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackLeft:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontLeft:
+                start = -Vector3d.UnitZ;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Y Axis
+            #region Around Z Axis
+            case eSide.FrontBottom:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackBottom:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackTop:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontTop:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Z Axis
+
+            }
+
+            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
+
+            double divisor = 1.0/ ((double)temp.Length-1.0);
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                float Multiplier = (float)( i * divisor );
+
+                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
+
+                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
+                temp[i].Normal.Normalize();
+                temp[i].Position = temp[i].Normal;
+                temp[i].Position *= scale;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
+            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
+
+            uint VertexCounter = 0,
+                 IndexCounter = 0,
+                 QuadCounter = 0;
+
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
+                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
+
+
+                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
+                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
+                VertexCounter += 2;
+
+                if ( i < temp.Length - 1 )
+                {
+                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
+                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
+
+                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
+                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
+
+                    IndexCounter += 6;
+                    QuadCounter += 2;
+                }
+            }
+
+        }
+ 
+    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
+    {
+        double t1;
+        Vector3d.Dot( ref a, ref b, out t1 );
+        double theta = System.Math.Acos( t1 );
+
+        double temp = 1.0 / System.Math.Sin( theta );
+        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
+        double t3 = System.Math.Sin( factor * theta ) * temp;
+
+        Vector3d v1 = Vector3d.Multiply( a, t2);
+        Vector3d v2 = Vector3d.Multiply( b, t3 );
+        result = Vector3d.Add( v1, v2 );
+    }
+
+
+    }
+}
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
new file mode 100644
index 0000000..772629e
--- /dev/null
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -0,0 +1,196 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class SlicedSphere: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public enum eDir
+        {
+            All,
+            FrontTopRight,
+            FrontBottomRight,
+            FrontBottomLeft,
+            FrontTopLeft,
+            BackTopRight,
+            BackBottomRight,
+            BackBottomLeft,
+            BackTopLeft,
+
+        }
+
+        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
+            : base( useDL )
+        {
+            double Diameter = radius;
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            if ( sides[0] == eDir.All )
+            {
+                sides = new eDir[] {  eDir.FrontTopRight,
+            eDir.FrontBottomRight,
+            eDir.FrontBottomLeft,
+            eDir.FrontTopLeft,
+            eDir.BackTopRight,
+            eDir.BackBottomRight,
+            eDir.BackBottomLeft,
+            eDir.BackTopLeft,};
+            }
+
+            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
+            IndexArray = new uint[sides.Length * 3];
+
+            uint counter = 0;
+            foreach ( eDir s in sides )
+            {
+                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
+                IndexArray[counter + 0] = counter + 0;
+                IndexArray[counter + 1] = counter + 1;
+                IndexArray[counter + 2] = counter + 2;
+                counter += 3;
+            }
+
+            if ( subdivs != eSubdivisions.Zero )
+            {
+
+                for ( int s = 0; s < (int)subdivs; s++ )
+                {
+                    #region Assemble Chunks and convert to Arrays
+                    List<Chunk> AllChunks = new List<Chunk>();
+                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
+                    {
+                        Chunk chu;
+                        Subdivide( Diameter,
+                                   ref VertexArray[IndexArray[i + 0]],
+                                   ref VertexArray[IndexArray[i + 1]],
+                                   ref VertexArray[IndexArray[i + 2]],
+                                   out chu );
+                        AllChunks.Add( chu );
+                    }
+
+                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+                    AllChunks.Clear();
+                    #endregion Assemble Chunks and convert to Arrays
+                }
+            }
+
+            for (int i=0; i<VertexArray.Length;i++)
+            {
+                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
+            }
+        }
+
+        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
+                            t2 = new VertexT2dN3dV3d(),
+                            t3 = new VertexT2dN3dV3d();
+            switch ( s )
+            {
+            case eDir.FrontTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.FrontBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                break;
+            case eDir.FrontBottomLeft: 
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.FrontTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.BackTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            case eDir.BackBottomLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            }
+            first = t1;
+            second = t2;
+            third = t3;
+        }
+
+
+        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
+        {
+            c = new Chunk(6, 12);
+
+            c.Vertices[0] = first;
+            
+            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
+            c.Vertices[1].Normal.Normalize();
+            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
+            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
+
+            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
+            c.Vertices[2].Normal.Normalize();
+            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
+            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
+
+            c.Vertices[3] = second;
+    
+            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
+            c.Vertices[4].Normal.Normalize();
+            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
+            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
+
+            c.Vertices[5] = third;
+
+            #region Indices
+            c.Indices[0]=0;
+            c.Indices[1]=1;
+            c.Indices[2]=2;
+            c.Indices[3]=2;
+            c.Indices[4]=1;
+            c.Indices[5]=4;
+            c.Indices[6]=1;
+            c.Indices[7]=3;
+            c.Indices[8]=4;
+            c.Indices[9]=2;
+            c.Indices[10]=4;
+            c.Indices[11]=5;
+            #endregion Indices
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/Tetra.cs b/AWGL/Shapes/Tetra.cs
deleted file mode 100644
index c29c8fe..0000000
--- a/AWGL/Shapes/Tetra.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿using OpenTK;
-using AWGL.Shapes.Base;
-using System.Collections.Generic;
-
-namespace AWGL.Shapes
-{
-    class Tetra : Volume
-    {
-        Vector3 PointApex;
-        Vector3 PointA;
-        Vector3 PointB;
-        Vector3 PointC;
-
-        public Tetra(Vector3 apex, Vector3 a, Vector3 b, Vector3 c)
-        {
-            PointApex = apex;
-            PointA = a;
-            PointB = b;
-            PointC = c;
-
-            VertCount = 4;
-            IndiceCount = 12;
-            ColorDataCount = 4;
-        }
-
-        public List<Tetra> Divide(int n = 0)
-        {
-            if (n == 0)
-            {
-                return new List<Tetra>(new Tetra[] { this });
-            }
-            else
-            {
-
-                Vector3 halfa = (PointApex + PointA) / 2.0f;
-                Vector3 halfb = (PointApex + PointB) / 2.0f;
-                Vector3 halfc = (PointApex + PointC) / 2.0f;
-
-                // Calculate points half way between base points
-                Vector3 halfab = (PointA + PointB) / 2.0f;
-                Vector3 halfbc = (PointB + PointC) / 2.0f;
-                Vector3 halfac = (PointA + PointC) / 2.0f;
-
-                Tetra t1 = new Tetra(PointApex, halfa, halfb, halfc);
-                Tetra t2 = new Tetra(halfa, PointA, halfab, halfac);
-                Tetra t3 = new Tetra(halfb, halfab, PointB, halfbc);
-                Tetra t4 = new Tetra(halfc, halfac, halfbc, PointC);
-
-                List<Tetra> output = new List<Tetra>();
-
-                output.AddRange(t1.Divide(n - 1));
-                output.AddRange(t2.Divide(n - 1));
-                output.AddRange(t3.Divide(n - 1));
-                output.AddRange(t4.Divide(n - 1));
-
-                return output;
-
-            }
-        }
-
-        public override Vector3[] GetVerts()
-        {
-            return new Vector3[] { PointApex, PointA, PointB, PointC };
-        }
-
-        public override int[] GetIndices(int offset = 0)
-        {
-            int[] inds = new int[] { //bottom
-                                1,3,2,
-                                //other sides
-                                0,1,2,
-                                0,2,3,
-                                0,3,1
-        };
-
-            if (offset != 0)
-            {
-                for (int i = 0; i < inds.Length; i++)
-                {
-                    inds[i] += offset;
-                }
-            }
-
-            return inds;
-        }
-
-        public override Vector3[] GetColorData()
-        {
-            return new Vector3[] { new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f), new Vector3(1f, 1f, 0f) };
-        }
-
-        public override void CalculateModelMatrix()
-        {
-            ModelMatrix = Matrix4.Scale(Scale) * Matrix4.CreateRotationX(Rotation.X) * Matrix4.CreateRotationY(Rotation.Y) * Matrix4.CreateRotationZ(Rotation.Z) * Matrix4.CreateTranslation(Position);
-        }
-    }
-}
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
new file mode 100644
index 0000000..ff7ec7d
--- /dev/null
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -0,0 +1,128 @@
+﻿using System;
+using System.Diagnostics;
+
+using OpenTK;
+
+namespace AWGL.Shapes
+{
+    public sealed class TorusKnot: DrawableShape
+    {
+        #region Constants
+        // hard minimums to make sure the created Torusknot is 3D
+        private const int MINShapeVertices = 3;
+        private const int MINPathSteps = 32;
+        private const double TwoPi = ( 2.0 * System.Math.PI );
+        #endregion Constants
+
+        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
+            : base( useDL )
+        {
+            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
+            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
+            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+
+            Vector3d[] PathPositions = new Vector3d[pathsteps];
+
+            #region Find the center Points for each step on the path
+
+            for ( int i = 0; i < pathsteps; i++ )
+            {
+                double Angle = ( i / (double)pathsteps ) * TwoPi;
+                double AngleTimesP = Angle * p;
+                double AngleTimesQ = Angle * q;
+                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
+
+                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
+                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
+                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
+
+            }
+            #endregion Find the center Points for each step on the path
+
+            #region Find the Torus length
+            Vector3d result;
+            double[] Lengths = new double[pathsteps];
+            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
+            Lengths[0] = result.Length;
+            double TotalLength = result.Length;
+            for ( int i = 1; i < pathsteps; i++ ) // skipping 
+            {
+                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
+                Lengths[i] = result.Length;
+                TotalLength += result.Length;
+            }
+            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
+            #endregion Find the Torus length
+
+            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
+
+            #region Loft a circle Shape along the path
+            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                Vector3d last, next, normal, tangent;
+                if ( i == pathsteps - 1 )
+                    next = PathPositions[0];
+                else
+                    next = PathPositions[i + 1];
+                if ( i == 0 )
+                    last = PathPositions[pathsteps - 1];
+                else
+                    last = PathPositions[i - 1];
+
+                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
+                tangent.Normalize();
+
+                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
+                normal.Normalize();
+                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
+
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    uint index = i * (uint)shapevertices + j;
+
+                    // Create a point on the plane and rotate it
+                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
+                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
+                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
+                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
+                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
+                    VertexArray[index].Normal.Normalize();
+                    // just generate some semi-useful UVs to fill blanks
+                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
+                }
+            }
+            #endregion Loft a circle Shape along the path
+
+            PathPositions = null; // not needed anymore
+
+            uint currentindex = 0;
+
+            #region Build a Triangle strip from the Vertices
+            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                uint RowCurrent = i * (uint)shapevertices;
+                uint RowBelow;
+                if ( i == pathsteps - 1 )
+                    RowBelow = 0; // for the last row, the first row is the following
+                else
+                    RowBelow = ( i + 1 ) * (uint)shapevertices;
+
+                // new ring begins here
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    IndexArray[currentindex++] = RowCurrent + j;
+                    IndexArray[currentindex++] = RowBelow + j;
+                }
+                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
+                IndexArray[currentindex++] = RowCurrent;
+                IndexArray[currentindex++] = RowBelow;
+            }
+            #endregion Build a Triangle strip from the Vertices
+        }
+
+    }
+}
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
new file mode 100644
index 0000000..4643452
--- /dev/null
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -0,0 +1,51 @@
+﻿#region License
+//
+// The Open Toolkit Library License
+//
+// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights to 
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+// OTHER DEALINGS IN THE SOFTWARE.
+//
+#endregion
+
+using System.Drawing;
+using System.Runtime.InteropServices;
+using OpenTK;
+
+namespace AWGL.Tutorial
+{
+    [StructLayout(LayoutKind.Sequential, Pack = 1)]
+    struct VertexPositionColor
+    {
+        public Vector3 Position;
+        public uint Color;
+
+        public VertexPositionColor(float x, float y, float z, Color color)
+        {
+            Position = new Vector3(x, y, z);
+            Color = ToRgba(color);
+        }
+
+        static uint ToRgba(Color color)
+        {
+            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/33c67b20348e42365482e8ed4ff9d87ecf681d86">~</a>  -  33c67b2</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 7565562..04bd107 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -16,3 +16,10 @@ namespace AWGL
     {
-        
+        [STAThread]
+        public static void Main(string[] args)
+        {
+            using (Display mainDisplay = new Display())
+            {
+                mainDisplay.Run(30.0);
+            }
+        }
     }
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
index f416196..e2d7ff5 100644
--- a/AWGL/Scene/Display.cs
+++ b/AWGL/Scene/Display.cs
@@ -5,3 +5,2 @@ using System.Text;
 using System.Threading.Tasks;
-using AWGL.Scene.Base;
 
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index 7cf872d..595ae6e 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -9,4 +9,2 @@ using AWGL.Scene;
 
-using OpenTK;
-
 namespace TestApplication
@@ -16,8 +14,5 @@ namespace TestApplication
         [STAThread]
-        static void Main(string[] args)
+        public static void Main(string[] args)
         {
-            using (Display mainDisplay = new Display())
-            {
-                mainDisplay.Run(30.0);
-            }
+            AWGL.AWGL.Main(args);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2e6e60b1687f9366229c86177918e2c4a58a2486">Added simple VBO Struct.</a>  -  2e6e60b</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 7 insertions(+)

diff --git a/AWGL/VBO.cs b/AWGL/VBO.cs
new file mode 100644
index 0000000..0dd834c
--- /dev/null
+++ b/AWGL/VBO.cs
@@ -0,0 +1,7 @@
+﻿namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, EboID, NumElements;
+    }
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/806282cb768b34fdd3a7c4e4e12478d1a1502c90">Static VBO</a>  -  806282c</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 4 files changed, 117 insertions(+), 173 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 04bd107..d4f61a0 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -24,2 +24,4 @@ namespace AWGL
         }
+
+        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fa3ebd3..a452631 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -1,3 +1,3 @@
 ﻿using AWGL.Shapes;
-using AWGL.Shapes.Base;
+using AWGL.Tutorial;
 using ObjLoader.Loader.Loaders;
@@ -20,8 +20,2 @@ namespace AWGL.Scene
     {
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
-        }   
 
@@ -29,18 +23,38 @@ namespace AWGL.Scene
 
-        // GLSL Objects
-        private int m_VertexShaderObject, m_FragmentShaderObject, m_ProgramObject, m_TextureObject;
+        private const float rotation_speed = 180.0f;
+        private float angle;
 
-        private int m_AttributeVertexPosition, m_AttributeVertexColor, m_UniformModelView;
+        private struct Vbo { public int VboID, EboID, NumElements; }
+        private Vbo[] vbo = new Vbo[2];
 
-        private int m_Position_VBO, m_Color_VBO, m_ModelView_VBO, m_Elements_IBO;
-
-        private Vector3[] m_VertexData, m_ColorData;
-        private List<DrawableShape> m_Objects = new List<DrawableShape>();
-        private int[] m_IndiceData;
-
-        private float m_Time = 0.0f;
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
 
-        private Version m_Version, m_TargetLow, m_TargetHigh;
+        #endregion  
 
-        #endregion Private Fields
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
+        }   
 
@@ -67,54 +81,2 @@ namespace AWGL.Scene
 
-        #region InitProgram
-        
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        private void InitProgram()
-        {
-            m_ProgramObject = GL.CreateProgram();
-
-            LoadShader("VS.glsl", ShaderType.VertexShader, m_ProgramObject, out m_VertexShaderObject);
-            LoadShader("FS.glsl", ShaderType.FragmentShader, m_ProgramObject, out m_FragmentShaderObject);
-
-            // Links shaders and output any errors
-            GL.LinkProgram(m_ProgramObject);
-            Console.WriteLine(GL.GetProgramInfoLog(m_ProgramObject));
-
-            // Get the values we need, and also do a simple check to make sure the attributes were found.
-            m_AttributeVertexPosition = GL.GetAttribLocation(m_ProgramObject, "vPosition");
-            m_AttributeVertexColor = GL.GetAttribLocation(m_ProgramObject, "vColor");
-            m_UniformModelView = GL.GetUniformLocation(m_ProgramObject, "modelview");
-
-            if (m_AttributeVertexPosition == -1 || m_AttributeVertexColor == -1 || m_UniformModelView == -1)
-            {
-                Console.WriteLine("Error binding attributes");
-            }
-
-            // This generates 4 separate buffers and stores their addresses in our variables. 
-            // For multiple buffers like this, there's an option for generating multiple buffers 
-            // and storing them in an array, but for simplicity's sake, we're keeping them in separate ints.
-            GL.GenBuffers(1, out m_Position_VBO);
-            GL.GenBuffers(1, out m_Color_VBO);
-            GL.GenBuffers(1, out m_ModelView_VBO);
-            GL.GenBuffers(1, out m_Elements_IBO);
-
-            Random rand = new Random();
-
-            float xPos = -1.0f;
-            //for (int i = 0; i < 2; i++)
-            //{
-                Place plane = new Plane();
-
-                plane.Position = new Vector3(xPos, 0.0f, -2.5f);
-                plane.Rotation = new Vector3(0.55f, 0.25f, 0);
-                plane.Scale = Vector3.One;
-                m_Objects.Add(plane);
-
-                xPos = 1.0f;
-            //}
-        }
-
-        #endregion
-
         #region OnLoad
@@ -130,3 +92,3 @@ namespace AWGL.Scene
 
-            InitProgram();
+            //InitProgram();
 
@@ -134,13 +96,7 @@ namespace AWGL.Scene
 
-            GL.ClearColor(Color.MidnightBlue);
-            GL.PointSize(3f);
-        }
-
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.Enable(EnableCap.DepthTest);
 
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
         }
@@ -161,2 +117,21 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+        
+        #region OnUpdateFrame
+
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
         }
@@ -175,22 +150,13 @@ namespace AWGL.Scene
             base.OnRenderFrame(e);
-            
+
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-            GL.Enable(EnableCap.DepthTest);
 
-            GL.EnableVertexAttribArray(m_AttributeVertexPosition);
-            GL.EnableVertexAttribArray(m_AttributeVertexColor);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
 
-            int indiceAt = 0;
-            
-            foreach (Volume v in m_Objects)
-            {
-                GL.UniformMatrix4(m_UniformModelView, false, ref v.ModelViewProjectionMatrix);
-                GL.DrawElements(BeginMode.Triangles, v.IndiceCount, DrawElementsType.UnsignedInt, indiceAt*sizeof(uint));
-                indiceAt += v.IndiceCount;
-            }
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
 
-            // Keep things clean:
-            GL.DisableVertexAttribArray(m_AttributeVertexPosition);
-            GL.DisableVertexAttribArray(m_AttributeVertexColor);
-            GL.Flush();
+            Draw(vbo[0]);
 
@@ -201,69 +167,7 @@ namespace AWGL.Scene
 
-        #region OnUpdateFrame
+        #region OnUnload
 
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnUpdateFrame(FrameEventArgs e)
+        protected override void OnUnload(EventArgs e)
         {
-            base.OnUpdateFrame(e);
-
-            m_Time += (float)e.Time;
-
-            List<Vector3> verts = new List<Vector3>();
-            List<int> inds = new List<int>();
-            List<Vector3> colors = new List<Vector3>();
-
-            int vertCount = 0;
-
-            foreach (Volume v in m_Objects)
-            {
-                verts.AddRange(v.GetVerts().ToList());
-                inds.AddRange(v.GetIndices().ToList());
-                colors.AddRange(v.GetColorData().ToList());
-                vertCount += v.VertCount;
-            }
-
-            m_VertexData = verts.ToArray();
-            m_IndiceData = inds.ToArray();
-            m_ColorData = colors.ToArray();
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Position_VBO);  // 1. Bind vertex data to the buffer.
-            GL.BufferData<Vector3>(                                 // 2. Send data.
-                BufferTarget.ArrayBuffer, (IntPtr)(m_VertexData.Length * Vector3.SizeInBytes), 
-                m_VertexData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                m_AttributeVertexPosition, 3, VertexAttribPointerType.Float, false, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, m_Color_VBO);     // 1. Bind color data to the buffer
-            GL.BufferData<Vector3>(                                 // 2. Send Data
-                BufferTarget.ArrayBuffer, (IntPtr)(m_ColorData.Length * Vector3.SizeInBytes),
-                m_ColorData, BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(                                 // 3. Tell OpenGL to use the last buffer bound to.
-                m_AttributeVertexColor, 3, VertexAttribPointerType.Float, true, 0, 0);
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, m_Elements_IBO);
-            GL.BufferData(
-                BufferTarget.ElementArrayBuffer, (IntPtr)(m_IndiceData.Length * sizeof(int)),
-                m_IndiceData, BufferUsageHint.StaticDraw);
-            
-            // Rotate objects
-            for (int i = 0; i < m_Objects.Count; i++)
-            {
-                m_Objects[i].Rotation = new Vector3(0.55f * m_Time, 0.25f * m_Time, 0);
-            }
 
-            // Send model view matrix
-            foreach (Volume v in m_Objects)
-            {
-                v.CalculateModelMatrix();
-                v.ViewProjectionMatrix = 
-                    Matrix4.CreatePerspectiveFieldOfView(1.0f, ClientSize.Width / (float)ClientSize.Height, 1.0f, 40.0f);
-                v.ModelViewProjectionMatrix = v.ModelMatrix * v.ViewProjectionMatrix;
-            }
-
-            GL.UseProgram(m_ProgramObject);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
         }
@@ -279,5 +183,5 @@ namespace AWGL.Scene
         {
-            m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            m_TargetLow = new Version(3, 1);
-            m_TargetHigh = new Version(4, 1);
+            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetHigh = new Version(4, 1);
             if (m_Version < m_TargetLow)
@@ -353,2 +257,22 @@ namespace AWGL.Scene
 
+        void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
 
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index d8d71ca..019722b 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -10,2 +10,3 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using System.Drawing;
 
@@ -157,2 +158,4 @@ namespace AWGL.Shapes
 
+        
+
         #region IDisposable Members
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index b24f97e..fd8e0c0 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -14,2 +14,3 @@ using System.Runtime.InteropServices;
 using OpenTK;
+using AWGL;
 
@@ -63,12 +64,26 @@ namespace AWGL.Shapes
             {
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.DarkRed),
-                Utilities.ColorToRgba32(Color.Gold),
-                Utilities.ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
             };
         }
+
+        /// <summary>
+        /// Converts a Color instance into an int representation
+        /// </summary>
+        /// <param name="c">
+        /// A <see cref="Color"/> instance to be converted
+        /// </param>
+        /// <returns>
+        /// A <see cref="System.Int32"/>
+        /// </returns>
+        public static int ColorToRgba32(Color c)
+        {
+            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0360a0cd636b00fb27f4878be7f4658fd88ffd4d">Tweaks</a>  -  0360a0c</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index a452631..27f30b2 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -20,2 +20,8 @@ namespace AWGL.Scene
     {
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            this.WindowState = WindowState.Fullscreen;
+            Keyboard.KeyDown += Keyboard_KeyDown;
+        }   
 
@@ -53,9 +59,2 @@ namespace AWGL.Scene
 
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
-        }   
-
         #region Keyboard_KeyDown
@@ -232,4 +231,6 @@ namespace AWGL.Scene
             // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. Check that the buffer was uploaded correctly.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
 
@@ -257,2 +258,4 @@ namespace AWGL.Scene
 
+        #region Draw(Vbo handle)
+
         void Draw(Vbo handle)
@@ -278,2 +281,3 @@ namespace AWGL.Scene
 
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a5b8d1816321819b334ef58f2710720954995780">Particles</a>  -  a5b8d18</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 133 insertions(+), 17 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 27f30b2..76dd42a 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -25,2 +25,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
+            this.VSync = VSyncMode.Off;
         }   
@@ -59,2 +60,34 @@ namespace AWGL.Scene
 
+        #region Particles
+
+        private static int MaxParticleCount = 2000;
+        private int VisibleParticleCount;
+        private VertexC4ubV3f[] VBO = new VertexC4ubV3f[MaxParticleCount];
+        private ParticleAttribut[] ParticleAttributes = new ParticleAttribut[MaxParticleCount];
+
+        // this struct is used for drawing
+        struct VertexC4ubV3f
+        {
+            public byte R, G, B, A;
+            public Vector3 Position;
+
+            public static int SizeInBytes = 16;
+        }
+
+        // this struct is used for updates
+        struct ParticleAttribut
+        {
+            public Vector3 Direction;
+            public uint Age;
+
+            //  more stuff could be here: Rotation, Radius, whatever
+        }
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+
+        #endregion Particles
+
         #region Keyboard_KeyDown
@@ -91,13 +124,61 @@ namespace AWGL.Scene
 
-            //InitProgram();
-
             Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
 
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.ClearColor(.1f, 0f, .1f, 0f);
             GL.Enable(EnableCap.DepthTest);
 
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+            // Set our point parameters
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSprite);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceatd as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = new Vector3();
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < MaxParticleCount; i++)
+            {
+                if (xPos >= 4.0f)
+                {
+                    xPos = -4.0f;
+                }
+                if (yPos >= 4.0f)
+                {
+                    yPos = -4.0f;
+                }
+                VBO[i].R = (byte)rndNum.Next(0, 256);
+                VBO[i].G = (byte)rndNum.Next(0, 256);
+                VBO[i].B = (byte)rndNum.Next(0, 256);
+                VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                ParticleAttributes[i].Direction = tmp; // copy 
+                ParticleAttributes[i].Age = 0;
+
+                xPos = xPos + 0.0231f;
+                yPos = yPos + 0.0253f;
+            }
+
+            VisibleParticleCount = 0;
+
         }
 
+        //private void
         #endregion
@@ -117,6 +198,9 @@ namespace AWGL.Scene
 
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
             GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
         }
@@ -134,3 +218,26 @@ namespace AWGL.Scene
         {
-            base.OnUpdateFrame(e);
+            //base.OnUpdateFrame(e);
+
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (VisibleParticleCount < MaxParticleCount)
+                VisibleParticleCount++;
+
+            Vector3 temp;
+
+            for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
+            {
+                if (ParticleAttributes[i].Age >= MaxParticleCount)
+                {
+                    // reset particle
+                    ParticleAttributes[i].Age = 0;
+                    VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
+                    Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
+                }
+            }
         }
@@ -148,3 +255,5 @@ namespace AWGL.Scene
         {
-            base.OnRenderFrame(e);
+            //base.OnRenderFrame(e);
+
+            this.Title = "AWGL: High level OpenTK wrapper - " + VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
 
@@ -152,10 +261,15 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
+            GL.PushMatrix();
 
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+            GL.Translate(0f, 0f, -5f);
 
-            Draw(vbo[0]);
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+
+            GL.PopMatrix();
 
@@ -170,3 +284,3 @@ namespace AWGL.Scene
         {
-
+            GL.DeleteBuffers(1, ref VBOHandle);
         }
@@ -282,2 +396,4 @@ namespace AWGL.Scene
         #endregion
+
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ee23372a2eba2813ac7f9abfa03d058f6fe70606">Implemented Simple Texture</a>  -  ee23372</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 125 insertions(+), 84 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 76dd42a..e2e7646 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -10,2 +10,3 @@ using System.Collections.Generic;
 using System.Drawing;
+using System.Drawing.Imaging;
 using System.IO;
@@ -62,3 +63,3 @@ namespace AWGL.Scene
 
-        private static int MaxParticleCount = 2000;
+        protected static int MaxParticleCount = 2000;
         private int VisibleParticleCount;
@@ -92,2 +93,9 @@ namespace AWGL.Scene
 
+        #region Textures
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");//("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
         #region Keyboard_KeyDown
@@ -127,54 +135,72 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Texture2D);
 
-            // Set our point parameters
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSprite);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+            //// Set our point parameters
+            //GL.PointSize(5f);
+            //GL.Enable(EnableCap.PointSprite);
 
-            // set up vbo state - depreceatd as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
 
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
 
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            Random rndNum = new Random();
-            Vector3 tmp = new Vector3();
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
 
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < MaxParticleCount; i++)
-            {
-                if (xPos >= 4.0f)
-                {
-                    xPos = -4.0f;
-                }
-                if (yPos >= 4.0f)
-                {
-                    yPos = -4.0f;
-                }
-                VBO[i].R = (byte)rndNum.Next(0, 256);
-                VBO[i].G = (byte)rndNum.Next(0, 256);
-                VBO[i].B = (byte)rndNum.Next(0, 256);
-                VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                ParticleAttributes[i].Direction = tmp; // copy 
-                ParticleAttributes[i].Age = 0;
-
-                xPos = xPos + 0.0231f;
-                yPos = yPos + 0.0253f;
-            }
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
 
-            VisibleParticleCount = 0;
+            bitmap.UnlockBits(data);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            #region particles
+            //GL.EnableClientState(ArrayCap.ColorArray);
+            //GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            //GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            //GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            //GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            //Random rndNum = new Random();
+            //Vector3 tmp = new Vector3();
+
+            //// generate some random stuff for the particle system
+            //for (uint i = 0; i < MaxParticleCount; i++)
+            //{
+            //    if (xPos >= 4.0f)
+            //    {
+            //        xPos = -4.0f;
+            //    }
+            //    if (yPos >= 4.0f)
+            //    {
+            //        yPos = -4.0f;
+            //    }
+            //    VBO[i].R = (byte)rndNum.Next(0, 256);
+            //    VBO[i].G = (byte)rndNum.Next(0, 256);
+            //    VBO[i].B = (byte)rndNum.Next(0, 256);
+            //    VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+            //    VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
+
+            //    // generate direction vector in the range [-0.25f...+0.25f] 
+            //    // that's slow enough so you can see particles 'disappear' when they are respawned
+            //    tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+            //    ParticleAttributes[i].Direction = tmp; // copy 
+            //    ParticleAttributes[i].Age = 0;
+
+            //    xPos = xPos + 0.0231f;
+            //    yPos = yPos + 0.0253f;
+            //}
+
+            //VisibleParticleCount = 0;
+            #endregion
 
@@ -182,3 +208,2 @@ namespace AWGL.Scene
 
-        //private void
         #endregion
@@ -199,8 +224,4 @@ namespace AWGL.Scene
             GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
         }
@@ -220,24 +241,27 @@ namespace AWGL.Scene
 
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (VisibleParticleCount < MaxParticleCount)
-                VisibleParticleCount++;
+            #region Particles
+            //// will update particles here. When using a Physics SDK, it's update rate is much higher than
+            //// the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            //if (VisibleParticleCount < MaxParticleCount)
+            //    VisibleParticleCount++;
+
+            //Vector3 temp;
+
+            //for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
+            //{
+            //    if (ParticleAttributes[i].Age >= MaxParticleCount)
+            //    {
+            //        // reset particle
+            //        ParticleAttributes[i].Age = 0;
+            //        VBO[i].Position = Vector3.Zero;
+            //    }
+            //    else
+            //    {
+            //        ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
+            //        Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
+            //        Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
+            //    }
+            //}
+            #endregion
 
-            Vector3 temp;
-
-            for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
-            {
-                if (ParticleAttributes[i].Age >= MaxParticleCount)
-                {
-                    // reset particle
-                    ParticleAttributes[i].Age = 0;
-                    VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
-                    Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
-                }
-            }
         }
@@ -261,15 +285,32 @@ namespace AWGL.Scene
 
-            GL.PushMatrix();
+            #region Particles
+            //GL.PushMatrix();
+
+            //GL.Translate(0f, 0f, -5f);
+
+            //// Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            //// without this, GL would wait until draw operations on old VBO are complete before writing to it
+            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            //// Fill newly allocated buffer
+            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
+            //// Only draw particles that are alive
+            //GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+
+            //GL.PopMatrix();
+            #endregion
+
+            #region Textures
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            GL.Translate(0f, 0f, -5f);
+            GL.Begin(BeginMode.Quads);
 
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
 
-            GL.PopMatrix();
+            GL.End();
+            #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7a38e0262b0c7d4c7340a52ba1c8e09f28c38f65">3D Glasses effect (old school red and blue)</a>  -  7a38e02</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 150 insertions(+), 32 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index e2e7646..225dadc 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -26,3 +26,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.Off;
+            this.VSync = VSyncMode.On;
         }   
@@ -95,3 +95,3 @@ namespace AWGL.Scene
 
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");//("Data/Textures/logo.jpg");
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
         private int texture;
@@ -100,2 +100,4 @@ namespace AWGL.Scene
 
+        private MengerSponge sponge;
+
         #region Keyboard_KeyDown
@@ -135,25 +137,33 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.DepthTest);
 
-            //// Set our point parameters
-            //GL.PointSize(5f);
-            //GL.Enable(EnableCap.PointSprite);
+            #region 3D Glasses Effect
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
 
+            sponge= new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true);
 
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            #endregion
 
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
+            #region Texture
+            //// Set our point parameters
+            //GL.PointSize(5f);
+            //GL.Enable(EnableCap.PointSprite);
 
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            
+            //GL.GenTextures(1, out texture);
+            //GL.BindTexture(TextureTarget.Texture2D, texture);
 
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            //BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+            //    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
 
-            bitmap.UnlockBits(data);
+            //GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+            //    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
 
+            //bitmap.UnlockBits(data);
+            #endregion
             // set up vbo state - depreceted as of 3.0>> (?)
@@ -221,7 +231,3 @@ namespace AWGL.Scene
 
-            GL.Viewport(0, 0, Width, Height);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+            GL.Viewport(ClientRectangle);
         }
@@ -239,3 +245,3 @@ namespace AWGL.Scene
         {
-            //base.OnUpdateFrame(e);
+            base.OnUpdateFrame(e);
 
@@ -266,4 +272,100 @@ namespace AWGL.Scene
 
+            #region 3D Lighting Effect
+            
+            #endregion
+        }
+
+        #endregion
+
+        #region 3D Lighting Effect
+        struct Camera
+        {
+            public Vector3 Position, Direction, Up;
+            public double NearPlane, FarPlane;
+            public double EyeSeparation;
+            public double Aperture; // FOV in degrees
+            public double FocalLength;
+        }
+
+        enum Eye
+        {
+            left,
+            right,
+        }
+
+        void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+
         }
 
+        float Angle;
+
+        void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            sponge.Draw();
+        }
         #endregion
@@ -280,2 +382,3 @@ namespace AWGL.Scene
             //base.OnRenderFrame(e);
+            Angle += (float)(e.Time * 20.0);
 
@@ -302,14 +405,27 @@ namespace AWGL.Scene
             #region Textures
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //GL.LoadIdentity();
+            //GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            //GL.Begin(BeginMode.Quads);
+
+            //GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            //GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            //GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            //GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            //GL.End();
+            #endregion
 
-            GL.Begin(BeginMode.Quads);
+            #region 3D Lighting Effect
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
 
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
 
-            GL.End();
+            GL.ColorMask(true, true, true, true);
             #endregion
@@ -325,3 +441,5 @@ namespace AWGL.Scene
         {
-            GL.DeleteBuffers(1, ref VBOHandle);
+            base.OnUnload(e);
+            //GL.DeleteBuffers(1, ref VBOHandle);
+            sponge.Dispose();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c38fb47d4bcb2bcc242d490df3839cca85f3fd5d">Torus</a>  -  c38fb47</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 225dadc..169c1e2 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -26,3 +26,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.On;
+            this.VSync = VSyncMode.Off;
         }   
@@ -100,3 +100,3 @@ namespace AWGL.Scene
 
-        private MengerSponge sponge;
+        private TorusKnot obj;
 
@@ -143,3 +143,3 @@ namespace AWGL.Scene
 
-            sponge= new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true);
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
 
@@ -368,3 +368,3 @@ namespace AWGL.Scene
             GL.Rotate(Angle, Vector3.UnitY);
-            sponge.Draw();
+            obj.Draw();
         }
@@ -443,3 +443,3 @@ namespace AWGL.Scene
             //GL.DeleteBuffers(1, ref VBOHandle);
-            sponge.Dispose();
+            obj.Dispose();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/03cf089ec55f6c00e4167a6763804f64314edd6a">Stereo Vision</a>  -  03cf089</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 189 insertions(+), 360 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index d4f61a0..31cc877 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,5 +19,5 @@ namespace AWGL
         {
-            using (Display mainDisplay = new Display())
+            using (VBOCube particles = new VBOCube())
             {
-                mainDisplay.Run(30.0);
+                particles.Run(30.0);
             }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 169c1e2..9572a51 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -2,3 +2,2 @@
 using AWGL.Tutorial;
-using ObjLoader.Loader.Loaders;
 using OpenTK;
@@ -26,77 +25,3 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-            this.VSync = VSyncMode.Off;
-        }   
-
-        #region Private Fields
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private struct Vbo { public int VboID, EboID, NumElements; }
-        private Vbo[] vbo = new Vbo[2];
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-
-        #endregion  
-
-        #region Particles
-
-        protected static int MaxParticleCount = 2000;
-        private int VisibleParticleCount;
-        private VertexC4ubV3f[] VBO = new VertexC4ubV3f[MaxParticleCount];
-        private ParticleAttribut[] ParticleAttributes = new ParticleAttribut[MaxParticleCount];
-
-        // this struct is used for drawing
-        struct VertexC4ubV3f
-        {
-            public byte R, G, B, A;
-            public Vector3 Position;
-
-            public static int SizeInBytes = 16;
-        }
-
-        // this struct is used for updates
-        struct ParticleAttribut
-        {
-            public Vector3 Direction;
-            public uint Age;
-
-            //  more stuff could be here: Rotation, Radius, whatever
-        }
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-
-        #endregion Particles
-
-        #region Textures
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        private TorusKnot obj;
+        }       
 
@@ -109,3 +34,3 @@ namespace AWGL.Scene
         /// <param name="e">The key that was pressed.</param>
-        void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
         {
@@ -137,81 +62,3 @@ namespace AWGL.Scene
             GL.ClearColor(.1f, 0f, .1f, 0f);
-            GL.Enable(EnableCap.DepthTest);
-
-            #region 3D Glasses Effect
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-
-            #endregion
-
-            #region Texture
-            //// Set our point parameters
-            //GL.PointSize(5f);
-            //GL.Enable(EnableCap.PointSprite);
-
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
             
-            //GL.GenTextures(1, out texture);
-            //GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            //GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            //BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-            //    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            //GL.TexImage2D(TextureTarget.Texture2D, 0 ,PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-            //    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            //bitmap.UnlockBits(data);
-            #endregion
-            // set up vbo state - depreceted as of 3.0>> (?)
-            #region particles
-            //GL.EnableClientState(ArrayCap.ColorArray);
-            //GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            //GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            //GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            //GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            //Random rndNum = new Random();
-            //Vector3 tmp = new Vector3();
-
-            //// generate some random stuff for the particle system
-            //for (uint i = 0; i < MaxParticleCount; i++)
-            //{
-            //    if (xPos >= 4.0f)
-            //    {
-            //        xPos = -4.0f;
-            //    }
-            //    if (yPos >= 4.0f)
-            //    {
-            //        yPos = -4.0f;
-            //    }
-            //    VBO[i].R = (byte)rndNum.Next(0, 256);
-            //    VBO[i].G = (byte)rndNum.Next(0, 256);
-            //    VBO[i].B = (byte)rndNum.Next(0, 256);
-            //    VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-            //    VBO[i].Position = new Vector3(xPos, yPos, -1.0f); // all particles are born at the origin
-
-            //    // generate direction vector in the range [-0.25f...+0.25f] 
-            //    // that's slow enough so you can see particles 'disappear' when they are respawned
-            //    tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-            //    ParticleAttributes[i].Direction = tmp; // copy 
-            //    ParticleAttributes[i].Age = 0;
-
-            //    xPos = xPos + 0.0231f;
-            //    yPos = yPos + 0.0253f;
-            //}
-
-            //VisibleParticleCount = 0;
-            #endregion
-
         }
@@ -246,31 +93,2 @@ namespace AWGL.Scene
             base.OnUpdateFrame(e);
-
-            #region Particles
-            //// will update particles here. When using a Physics SDK, it's update rate is much higher than
-            //// the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            //if (VisibleParticleCount < MaxParticleCount)
-            //    VisibleParticleCount++;
-
-            //Vector3 temp;
-
-            //for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)
-            //{
-            //    if (ParticleAttributes[i].Age >= MaxParticleCount)
-            //    {
-            //        // reset particle
-            //        ParticleAttributes[i].Age = 0;
-            //        VBO[i].Position = Vector3.Zero;
-            //    }
-            //    else
-            //    {
-            //        ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10, 1);
-            //        Vector3.Multiply(ref ParticleAttributes[i].Direction, (float)e.Time, out temp);
-            //        Vector3.Add(ref VBO[i].Position, ref temp, out VBO[i].Position);
-            //    }
-            //}
-            #endregion
-
-            #region 3D Lighting Effect
-            
-            #endregion
         }
@@ -279,95 +97,2 @@ namespace AWGL.Scene
 
-        #region 3D Lighting Effect
-        struct Camera
-        {
-            public Vector3 Position, Direction, Up;
-            public double NearPlane, FarPlane;
-            public double EyeSeparation;
-            public double Aperture; // FOV in degrees
-            public double FocalLength;
-        }
-
-        enum Eye
-        {
-            left,
-            right,
-        }
-
-        void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-
-        }
-
-        float Angle;
-
-        void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-
         #region OnRenderFrame
@@ -381,54 +106,3 @@ namespace AWGL.Scene
         {
-            //base.OnRenderFrame(e);
-            Angle += (float)(e.Time * 20.0);
-
-            this.Title = "AWGL: High level OpenTK wrapper - " + VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            #region Particles
-            //GL.PushMatrix();
-
-            //GL.Translate(0f, 0f, -5f);
-
-            //// Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            //// without this, GL would wait until draw operations on old VBO are complete before writing to it
-            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            //// Fill newly allocated buffer
-            //GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount), VBO, BufferUsageHint.StreamDraw);
-            //// Only draw particles that are alive
-            //GL.DrawArrays(BeginMode.Points, MaxParticleCount - VisibleParticleCount, VisibleParticleCount);
-
-            //GL.PopMatrix();
-            #endregion
-
-            #region Textures
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //GL.LoadIdentity();
-            //GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            //GL.Begin(BeginMode.Quads);
-
-            //GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            //GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            //GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            //GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            //GL.End();
-            #endregion
-
-            #region 3D Lighting Effect
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-            #endregion
-
-            SwapBuffers();
+            base.OnRenderFrame(e);
         }
@@ -442,4 +116,2 @@ namespace AWGL.Scene
             base.OnUnload(e);
-            //GL.DeleteBuffers(1, ref VBOHandle);
-            obj.Dispose();
         }
@@ -497,3 +169,3 @@ namespace AWGL.Scene
 
-        Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
+        protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
         {
@@ -531,28 +203,2 @@ namespace AWGL.Scene
 
-        #region Draw(Vbo handle)
-
-        void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-
-
     }
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
new file mode 100644
index 0000000..3e0276e
--- /dev/null
+++ b/AWGL/Scene/StereoVision.cs
@@ -0,0 +1,183 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVision : DefaultScene
+    {
+        public StereoVision()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(ClientRectangle);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            //base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            Angle += (float)(e.Time * 20.0);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    }
+
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/57f2055936bb0d8425d3b05966d411d5979b3b43">Separated VBO Cube</a>  -  57f2055</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 130 insertions(+)

diff --git a/AWGL/Scene/VBOCube.cs b/AWGL/Scene/VBOCube.cs
new file mode 100644
index 0000000..09da741
--- /dev/null
+++ b/AWGL/Scene/VBOCube.cs
@@ -0,0 +1,130 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+
+namespace AWGL.Scene
+{
+    public class VBOCube : DefaultScene
+    {
+        #region Private Members
+        
+        private Vbo[] vbo = new Vbo[2];
+
+        private const float rotation_speed = 180.0f;
+        private float angle;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+
+            Draw(vbo[0]);
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region Draw(Vbo handle)
+
+        private void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+
+        #endregion
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5d2eda142c1739dd3dec61fcd10edff784ae849e">Tweaks</a>  -  5d2eda1</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 9572a51..18037c8 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -68,3 +68,2 @@ namespace AWGL.Scene
         #region OnResize
-
         /// <summary>
@@ -77,6 +76,3 @@ namespace AWGL.Scene
             base.OnResize(e);
-
-            GL.Viewport(ClientRectangle);
         }
-
         #endregion
@@ -107,2 +103,4 @@ namespace AWGL.Scene
             base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
         }
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
index 3e0276e..9844b96 100644
--- a/AWGL/Scene/StereoVision.cs
+++ b/AWGL/Scene/StereoVision.cs
@@ -61,4 +61,2 @@ namespace AWGL.Scene
 
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
             Angle += (float)(e.Time * 20.0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1a712d9e138ebaa02dc741bc5a9730f64165fa64">Successfully extracted examples into their own classes.</a>  -  1a712d9</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 11 files changed, 632 insertions(+), 350 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 31cc877..ec667aa 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,3 +19,3 @@ namespace AWGL
         {
-            using (VBOCube particles = new VBOCube())
+            using (Texture2DScene particles = new Texture2DScene())
             {
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
new file mode 100644
index 0000000..af7ef4d
--- /dev/null
+++ b/AWGL/Data.cs
@@ -0,0 +1,26 @@
+﻿using OpenTK;
+namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, EboID, NumElements;
+    }
+    
+    // this struct is used for drawing
+    public struct VertexC4ubV3f
+    {
+        public byte R, G, B, A;
+        public Vector3 Position;
+
+        public static int SizeInBytes = 16;
+    }
+
+    // this struct is used for updates
+    public struct ParticleAttribut
+    {
+        public Vector3 Direction;
+        public uint Age;
+
+        //  more stuff could be here: Rotation, Radius, whatever
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 18037c8..610829a 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -61,4 +61,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(.1f, 0f, .1f, 0f);
-            
+            GL.ClearColor(.1f, 0f, .1f, 0f);         
         }
@@ -76,2 +75,4 @@ namespace AWGL.Scene
             base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
         }
@@ -93,18 +94,2 @@ namespace AWGL.Scene
 
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-        }
-
-        #endregion
-
         #region OnUnload
diff --git a/AWGL/Scene/Display.cs b/AWGL/Scene/Display.cs
deleted file mode 100644
index e2d7ff5..0000000
--- a/AWGL/Scene/Display.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL.Scene
-{
-    public class Display : DefaultScene
-    {
-
-    }
-}
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
new file mode 100644
index 0000000..d46e66e
--- /dev/null
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -0,0 +1,179 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class DynamicVBOScene : DefaultScene
+    {
+        public DynamicVBOScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        private int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+        #endregion
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+        }
+
+        #region OnUpdateFrame
+        /// <summary>
+        /// Add your game logic here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)e.Time, out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            this.Title = "AWGL: High level OpenTK wrapper - " + m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+
+            GL.Translate(0f, 0f, -5f);
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(BeginMode.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteBuffers(1, ref VBOHandle);
+        }
+
+        #endregion        
+    }
+
+    
+
+}
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
new file mode 100644
index 0000000..e93d3ed
--- /dev/null
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -0,0 +1,132 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+
+namespace AWGL.Scene
+{
+    public class StaticVBOScene : DefaultScene
+    {
+        #region Private Members
+        
+        private Vbo[] vbo = new Vbo[2];
+
+        private const float rotation_speed = 180.0f;
+        private float angle;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            vbo[0] = LoadVBO(CubeVertices, CubeElements);
+            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            angle += rotation_speed * (float)e.Time;
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+
+            Draw(vbo[0]);
+
+            SwapBuffers();
+        }
+        #endregion
+
+        #region Draw(Vbo handle)
+
+        private void Draw(Vbo handle)
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+
+            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+
+        #endregion
+    }
+}
diff --git a/AWGL/Scene/StereoVision.cs b/AWGL/Scene/StereoVision.cs
deleted file mode 100644
index 9844b96..0000000
--- a/AWGL/Scene/StereoVision.cs
+++ /dev/null
@@ -1,181 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVision : DefaultScene
-    {
-        public StereoVision()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-        #endregion
-
-        #region OnResize
-
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(ClientRectangle);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            //base.OnRenderFrame(e);
-
-            Angle += (float)(e.Time * 20.0);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    }
-
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
new file mode 100644
index 0000000..3ab21de
--- /dev/null
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -0,0 +1,179 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVisionScene : DefaultScene
+    {
+        public StereoVisionScene()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            Angle += (float)(e.Time * 20.0);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    }
+
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
new file mode 100644
index 0000000..8944273
--- /dev/null
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -0,0 +1,112 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class Texture2DScene : DefaultScene
+    {
+
+        #region Private Members
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.Texture2D);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+        }
+        #endregion
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref texture);
+        }
+
+        #endregion
+
+        #region OnResize
+
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.Begin(BeginMode.Quads);
+
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            GL.End();
+
+            SwapBuffers();
+        }
+        #endregion
+    }
+}
diff --git a/AWGL/Scene/VBOCube.cs b/AWGL/Scene/VBOCube.cs
deleted file mode 100644
index 09da741..0000000
--- a/AWGL/Scene/VBOCube.cs
+++ /dev/null
@@ -1,130 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-
-namespace AWGL.Scene
-{
-    public class VBOCube : DefaultScene
-    {
-        #region Private Members
-        
-        private Vbo[] vbo = new Vbo[2];
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
-        }
-        #endregion
-
-        #region OnResize
-
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            Draw(vbo[0]);
-
-            SwapBuffers();
-        }
-        #endregion
-
-        #region Draw(Vbo handle)
-
-        private void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-    }
-}
diff --git a/AWGL/VBO.cs b/AWGL/VBO.cs
deleted file mode 100644
index 0dd834c..0000000
--- a/AWGL/VBO.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, EboID, NumElements;
-    }
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a8f0f93697a6059586658782926d45b48315e18b">Added shaders. Added new scenes.</a>  -  a8f0f93</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 22 files changed, 883 insertions(+), 65 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index ec667aa..15604b8 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -19,5 +19,52 @@ namespace AWGL
         {
-            using (Texture2DScene particles = new Texture2DScene())
+            Int32 Selection;
+
+            Console.WriteLine("Please select a scene to load:");
+            Console.WriteLine("");
+            Console.WriteLine("1. Static VBO");
+            Console.WriteLine("2. Dynamic VBO");
+            Console.WriteLine("3. Texture 2D");
+            Console.WriteLine("4. Anaylgraph Stereo");
+            Console.WriteLine("5. FBO");
+            Console.WriteLine("6. Picker");
+            Int32.TryParse(Console.ReadLine(), out Selection);
+
+            switch (Selection)
             {
-                particles.Run(30.0);
+                case 1:
+                    using (StaticVBOScene scene = new StaticVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 2:
+                    using (DynamicVBOScene scene = new DynamicVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 3:
+                    using (Texture2DScene scene = new Texture2DScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 4:
+                    using (StereoVisionScene scene = new StereoVisionScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 5:
+                    using (FBOScene scene = new FBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 6:
+                    using (PickerScene scene = new PickerScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
@@ -25,3 +72,2 @@ namespace AWGL
 
-        
     }
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index af7ef4d..ee0651e 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -1,2 +1,3 @@
 ﻿using OpenTK;
+using System;
 namespace AWGL
@@ -7,3 +8,4 @@ namespace AWGL
     }
-    
+
+    #region Particles
     // this struct is used for drawing
@@ -25,2 +27,38 @@ namespace AWGL
     }
+    #endregion
+
+    #region Picker
+    public struct Byte4
+    {
+        public byte R, G, B, A;
+
+        public Byte4(byte[] input)
+        {
+            R = input[0];
+            G = input[1];
+            B = input[2];
+            A = input[3];
+        }
+
+        public uint ToUInt32()
+        {
+            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
+            return BitConverter.ToUInt32(temp, 0);
+        }
+
+        public override string ToString()
+        {
+            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
+        }
+    }
+
+    struct Vertex
+    {
+        public Byte4 Color; // 4 bytes
+        public Vector3 Position; // 12 bytes
+
+        public const byte SizeInBytes = 16;
+    }
+    #endregion
+
 }
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_FS.glsl b/AWGL/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/AWGL/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_VS.glsl b/AWGL/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/AWGL/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/FS.glsl b/AWGL/Data/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/AWGL/Data/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_VS.glsl b/AWGL/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/AWGL/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_FS.glsl b/AWGL/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/AWGL/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_VS.glsl b/AWGL/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/AWGL/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_FS.glsl b/AWGL/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/AWGL/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_VS.glsl b/AWGL/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/AWGL/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_FS.glsl b/AWGL/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/AWGL/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_VS.glsl b/AWGL/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/AWGL/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/VS.glsl b/AWGL/Data/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/AWGL/Data/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 610829a..6f7134d 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -28,3 +28,2 @@ namespace AWGL.Scene
         #region Keyboard_KeyDown
-
         /// <summary>
@@ -45,3 +44,2 @@ namespace AWGL.Scene
         }
-
         #endregion
@@ -49,3 +47,2 @@ namespace AWGL.Scene
         #region OnLoad
-
         /// <summary>
@@ -79,25 +76,2 @@ namespace AWGL.Scene
         #endregion
-        
-        #region OnUpdateFrame
-
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-        }
-
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-
-        #endregion
 
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
new file mode 100644
index 0000000..000fb1d
--- /dev/null
+++ b/AWGL/Scene/FBOScene.cs
@@ -0,0 +1,260 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Input;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    public class FBOScene : DefaultScene
+    {
+        #region Private Member Variables
+        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
+
+        private uint ColorTexture;
+        private uint DepthTexture;
+        private uint FBOHandle;
+
+        private const int TextureSize = 512;
+
+        private DrawableShape Object;
+        #endregion
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
+            {
+                throw new NotSupportedException(
+                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
+                Exit();
+            }
+
+            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearDepth(1.0);
+            GL.DepthFunc(DepthFunction.Lequal);
+
+            GL.Enable(EnableCap.CullFace);
+
+            // Create Color Tex
+            GL.GenTextures(1, out ColorTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create Depth Tex
+            GL.GenTextures(1, out DepthTexture);
+            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
+            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create a FBO and attach the textures
+            GL.Ext.GenFramebuffers(1, out FBOHandle);
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
+
+            #region Test for Error
+
+            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
+            {
+                case FramebufferErrorCode.FramebufferCompleteExt:
+                    {
+                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: There are no attachments.");
+                        break;
+                    }
+                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
+                     {
+                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
+                         break;
+                     }*/
+                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
+                    {
+                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
+                    {
+                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
+                    {
+                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
+                    {
+                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferUnsupportedExt:
+                    {
+                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
+                        break;
+                    }
+                default:
+                    {
+                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
+                        break;
+                    }
+            }
+
+            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
+            int[] queryinfo = new int[6];
+            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
+            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
+            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
+            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
+            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
+            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
+            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
+                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
+
+            Console.WriteLine("Last GL Error: " + GL.GetError());
+
+            #endregion Test for Error
+
+            GL.PushAttrib(AttribMask.ViewportBit);
+            {
+                GL.Viewport(0, 0, TextureSize, TextureSize);
+
+                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
+                GL.ClearColor(1f, 0f, 0f, 0f);
+                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
+                GL.MatrixMode(MatrixMode.Projection);
+                GL.LoadMatrix(ref perspective);
+
+                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
+                GL.MatrixMode(MatrixMode.Modelview);
+                GL.LoadMatrix(ref lookat);
+
+                // draw some complex object into the FBO's textures
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.Light0);
+                GL.Enable(EnableCap.ColorMaterial);
+                GL.Color3(0f, 1f, 0f);
+                Object.Draw();
+                GL.Disable(EnableCap.ColorMaterial);
+                GL.Disable(EnableCap.Light0);
+                GL.Disable(EnableCap.Lighting);
+
+            }
+            GL.PopAttrib();
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
+
+            GL.ClearColor(.1f, .2f, .3f, 0f);
+            GL.Color3(1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
+            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            double aspect_ratio = Width / (double)Height;
+
+            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            base.OnResize(e);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+
+    }
+}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
new file mode 100644
index 0000000..7065a96
--- /dev/null
+++ b/AWGL/Scene/PickerScene.cs
@@ -0,0 +1,261 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
+using AWGL.Shapes;
+using System.Drawing;
+using System.IO;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
+    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
+    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
+    /// </summary>
+    public class PickerScene : DefaultScene
+    {
+        public PickerScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Member variable
+        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
+        private float angle;
+        private BeginMode VBO_PrimMode;
+        private Vertex[] VBO_Array;
+        uint VBO_Handle;
+
+        private uint SelectedTriangle;
+
+        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
+        #endregion
+
+        #region OnLoad
+        /// <summary>Load resources here.</summary>
+        /// <param name="e">Not used.</param>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.CullFace);
+
+            #region prepare data for VBO from procedural object
+            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
+            VertexT2fN3fV3f[] temp_VBO;
+            uint[] temp_IBO;
+            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
+            temp_obj.Dispose();
+            if (temp_IBO != null)
+                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
+
+            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
+            VBO_Array = new Vertex[temp_VBO.Length];
+            int TriangleCounter = -1;
+            for (int i = 0; i < temp_VBO.Length; i++)
+            {
+                // Position
+                VBO_Array[i].Position = temp_VBO[i].Position;
+
+                // Index
+                if (i % 3 == 0)
+                    TriangleCounter++;
+                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
+            }
+            #endregion prepare data for VBO from procedural object
+
+            #region Setup VBO for drawing
+            GL.GenBuffers(1, out VBO_Handle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
+            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
+            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
+            #endregion Setup VBO for drawing
+
+            #region Shader
+            
+            // Load&Compile Vertex Shader
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_VS.glsl"))
+            {
+                VertexShaderObject = GL.CreateShader(ShaderType.VertexShader);
+                GL.ShaderSource(VertexShaderObject, sr.ReadToEnd());
+                GL.CompileShader(VertexShaderObject);
+            }
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Vertex Shader: " + err);
+
+            string LogInfo;
+            GL.GetShaderInfoLog(VertexShaderObject, out LogInfo);
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+                Trace.WriteLine("Vertex Shader failed!\nLog:\n" + LogInfo);
+            else
+                Trace.WriteLine("Vertex Shader compiled without complaint.");
+
+            // Load&Compile Fragment Shader
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_FS.glsl"))
+            {
+                FragmentShaderObject = GL.CreateShader(ShaderType.FragmentShader);
+                GL.ShaderSource(FragmentShaderObject, sr.ReadToEnd());
+                GL.CompileShader(FragmentShaderObject);
+            }
+            GL.GetShaderInfoLog(FragmentShaderObject, out LogInfo);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Fragment Shader: " + err);
+
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+                Trace.WriteLine("Fragment Shader failed!\nLog:\n" + LogInfo);
+            else
+                Trace.WriteLine("Fragment Shader compiled without complaint.");
+
+            // Link the Shaders to a usable Program
+            ProgramObject = GL.CreateProgram();
+            GL.AttachShader(ProgramObject, VertexShaderObject);
+            GL.AttachShader(ProgramObject, FragmentShaderObject);
+
+            // link it all together
+            GL.LinkProgram(ProgramObject);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("LinkProgram: " + err);
+
+            GL.UseProgram(ProgramObject);
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("UseProgram: " + err);
+
+            // flag ShaderObjects for delete when not used anymore
+            GL.DeleteShader(VertexShaderObject);
+            GL.DeleteShader(FragmentShaderObject);
+
+            int temp;
+            GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);
+            Trace.WriteLine("Linking Program (" + ProgramObject + ") " + ((temp == 1) ? "succeeded." : "FAILED!"));
+            if (temp != 1)
+            {
+                GL.GetProgramInfoLog(ProgramObject, out LogInfo);
+                Trace.WriteLine("Program Log:\n" + LogInfo);
+            }
+
+            Trace.WriteLine("End of Shader build. GL Error: " + GL.GetError());
+
+            GL.UseProgram(0);
+
+            #endregion Shader
+
+        }
+        #endregion
+
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DeleteBuffers(1, ref VBO_Handle);
+
+            base.OnUnload(e);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Called when your window is resized. Set your viewport here. It is also
+        /// a good place to set up your projection matrix (which probably changes
+        /// along when the aspect ratio of your window).
+        /// </summary>
+        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref projection);
+        }
+        #endregion
+
+        #region OnRenderFrae
+        /// <summary>
+        /// Called when it is time to render the next frame. Add your rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Color3(Color.White);
+            GL.EnableClientState(EnableCap.ColorArray);
+
+            #region Pass 1: Draw Object and pick Triangle
+            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref modelview);
+            GL.Translate(0f, 0f, -3f);
+            GL.Rotate(angle, Vector3.UnitX);
+            GL.Rotate(angle, Vector3.UnitY);
+            angle += (float)e.Time * 3.0f;
+
+            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
+             GL.UseProgram(ProgramObject);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            // GL.UseProgram(0);
+
+            // Read Pixel under mouse cursor
+            Byte4 Pixel = new Byte4();
+            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
+            SelectedTriangle = Pixel.ToUInt32();
+            #endregion Pass 1: Draw Object and pick Triangle
+
+            GL.Color3(Color.White);
+            GL.DisableClientState(EnableCap.ColorArray);
+
+            #region Pass 2: Draw Shape
+            if (SelectedTriangle == uint.MaxValue)
+                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
+            else
+                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.Color3(1f, 1f, 1f);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+            GL.Color3(Color.Red);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+
+            if (SelectedTriangle != uint.MaxValue)
+            {
+                GL.Disable(EnableCap.DepthTest);
+                GL.Color3(Color.Green);
+                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
+                GL.Enable(EnableCap.DepthTest);
+            }
+            #endregion Pass 2: Draw Shape
+
+            this.SwapBuffers();
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Error at Swapbuffers: " + err);
+        }
+        #endregion
+    }
+}
diff --git a/AWGL/Shaders/FS.glsl b/AWGL/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/AWGL/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_FS.glsl b/AWGL/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/AWGL/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/Simple_VS.glsl b/AWGL/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/AWGL/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Shaders/VS.glsl b/AWGL/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/AWGL/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5fe72f4b9e451e21020f4e7c3035ecbaab740f06">Added shader to picker example and refactored code to use LoadShader helper function.</a>  -  5fe72f4</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 61 insertions(+), 72 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 6f7134d..b6efb3d 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -8,2 +8,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Drawing;
@@ -25,22 +26,5 @@ namespace AWGL.Scene
             Keyboard.KeyDown += Keyboard_KeyDown;
-        }       
-
-        #region Keyboard_KeyDown
-        /// <summary>
-        /// Occurs when a key is pressed.
-        /// </summary>
-        /// <param name="sender">The KeyboardDevice which generated this event.</param>
-        /// <param name="e">The key that was pressed.</param>
-        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                this.Exit();
-
-            if (e.Key == Key.F11)
-                if (this.WindowState == WindowState.Fullscreen)
-                    this.WindowState = WindowState.Normal;
-                else
-                    this.WindowState = WindowState.Fullscreen;
         }
-        #endregion
+
+        protected ErrorCode err;
 
@@ -60,3 +44,2 @@ namespace AWGL.Scene
         }
-
         #endregion
@@ -71,4 +54,2 @@ namespace AWGL.Scene
         {
-            base.OnResize(e);
-
             GL.Viewport(0, 0, Width, Height);
@@ -77,4 +58,3 @@ namespace AWGL.Scene
 
-        #region GetOpenGLVersion
-
+        #region TestOpenGLVersion
         /// <summary>
@@ -98,7 +78,5 @@ namespace AWGL.Scene
         }
-
         #endregion
 
-        #region LoadShader
-
+        #region LoadShader(String filename, ShaderType type, int program, out int address)
         /// <summary>
@@ -110,12 +88,38 @@ namespace AWGL.Scene
         /// <param name="address">Shader Pointer</param>
-        private void LoadShader(String filename, ShaderType type, int program, out int address)
+        protected void LoadShader(String filename, ShaderType type, int program, out int address)
         {
             address = GL.CreateShader(type);
-            using (StreamReader sr = new StreamReader("Shaders/" + filename))
+            string sType = "";
+
+            switch (type)
+            {
+                case ShaderType.VertexShader:
+                    sType = "Vertex ";
+                    break;
+                case ShaderType.FragmentShader:
+                    sType = "Fragment ";
+                    break;
+            }
+
+            using (StreamReader sr = new StreamReader("Data/Shaders/" + filename))
             {
                 GL.ShaderSource(address, sr.ReadToEnd());
+                GL.CompileShader(address);
+            }
+
+            err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine(sType + "Shader: " + err);
+
+            string LogInfo;
+            GL.GetShaderInfoLog(address, out LogInfo);
+            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
+            {
+                Trace.WriteLine(sType + "Shader failed!\nLog:\n" + LogInfo);
+            }
+            else
+            {
+                Trace.WriteLine(sType + "Shader compiled without complaint.");
+                GL.AttachShader(program, address);
             }
-            GL.CompileShader(address);
-            GL.AttachShader(program, address);
-            Console.WriteLine(GL.GetShaderInfoLog(address));
         }
@@ -125,3 +129,2 @@ namespace AWGL.Scene
         #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
-
         protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
@@ -160,2 +163,21 @@ namespace AWGL.Scene
 
+        #region Keyboard_KeyDown
+        /// <summary>
+        /// Occurs when a key is pressed.
+        /// </summary>
+        /// <param name="sender">The KeyboardDevice which generated this event.</param>
+        /// <param name="e">The key that was pressed.</param>
+        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                this.Exit();
+
+            if (e.Key == Key.F11)
+                if (this.WindowState == WindowState.Fullscreen)
+                    this.WindowState = WindowState.Normal;
+                else
+                    this.WindowState = WindowState.Fullscreen;
+        }
+        #endregion
+
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 7065a96..1cacd88 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -85,46 +85,12 @@ namespace AWGL.Scene
             #region Shader
-            
-            // Load&Compile Vertex Shader
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_VS.glsl"))
-            {
-                VertexShaderObject = GL.CreateShader(ShaderType.VertexShader);
-                GL.ShaderSource(VertexShaderObject, sr.ReadToEnd());
-                GL.CompileShader(VertexShaderObject);
-            }
 
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Vertex Shader: " + err);
+            ProgramObject = GL.CreateProgram();
 
-            string LogInfo;
-            GL.GetShaderInfoLog(VertexShaderObject, out LogInfo);
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-                Trace.WriteLine("Vertex Shader failed!\nLog:\n" + LogInfo);
-            else
-                Trace.WriteLine("Vertex Shader compiled without complaint.");
+            // Load&Compile Vertex Shader
+            LoadShader("Picking_VS.glsl", ShaderType.VertexShader, ProgramObject, out VertexShaderObject);
 
             // Load&Compile Fragment Shader
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/Picking_FS.glsl"))
-            {
-                FragmentShaderObject = GL.CreateShader(ShaderType.FragmentShader);
-                GL.ShaderSource(FragmentShaderObject, sr.ReadToEnd());
-                GL.CompileShader(FragmentShaderObject);
-            }
-            GL.GetShaderInfoLog(FragmentShaderObject, out LogInfo);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Fragment Shader: " + err);
-
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-                Trace.WriteLine("Fragment Shader failed!\nLog:\n" + LogInfo);
-            else
-                Trace.WriteLine("Fragment Shader compiled without complaint.");
-
+            LoadShader("Picking_FS.glsl", ShaderType.FragmentShader, ProgramObject, out FragmentShaderObject);
+            
             // Link the Shaders to a usable Program
-            ProgramObject = GL.CreateProgram();
-            GL.AttachShader(ProgramObject, VertexShaderObject);
-            GL.AttachShader(ProgramObject, FragmentShaderObject);
 
@@ -148,2 +114,3 @@ namespace AWGL.Scene
             int temp;
+            string LogInfo;
             GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3a17726dd6db63ed8bf7ec29df5a9fc2d8939fed">This sample demonstrates the use of the stencil buffer for rendering constructive solid geometry (or CSG in short).</a>  -  3a17726</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 304 insertions(+)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index 15604b8..b838149 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -29,2 +29,3 @@ namespace AWGL
             Console.WriteLine("6. Picker");
+            Console.WriteLine("7. Stencil CSG");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -69,2 +70,8 @@ namespace AWGL
                     break;
+                case 7:
+                    using (StencilCSGScene scene = new StencilCSGScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
new file mode 100644
index 0000000..a17e666
--- /dev/null
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -0,0 +1,297 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Input;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class StencilCSGScene : DefaultScene
+    {
+        #region Model Related
+        private DrawableShape OperandB;
+        private DrawableShape OperandA;
+        private float MySphereZOffset = 0f;
+        private float MySphereXOffset = 0f;
+
+        private int Texture;
+        #endregion Model Related
+
+        private bool ShowDebugWireFrame = true;
+
+        private float CameraZoom;
+        private float CameraRotX;
+        private float CameraRotY;
+        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
+
+        #region Window
+        public StencilCSGScene()
+        {
+            base.VSync = VSyncMode.Off;
+            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
+            {
+                switch (e.Key)
+                {
+                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
+                }
+            };
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
+            GL.LoadMatrix(ref p);
+        }
+        #endregion Window
+
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            #region Abort on platforms which will not be able to execute the ops properly
+            /*
+            if (!GL.SupportsExtension("VERSION_1_2"))
+            {
+                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
+                this.Exit();
+            }
+
+            int[] t = new int[2];
+            GL.GetInteger(GetPName.MajorVersion, out t[0]);
+            GL.GetInteger(GetPName.MinorVersion, out t[1]);
+            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
+
+            GL.GetInteger(GetPName.DepthBits, out t[0]);
+            Trace.WriteLine("Depth Bits: " + t[0]);
+            GL.GetInteger(GetPName.StencilBits, out t[1]);
+            Trace.WriteLine("Stencil Bits: " + t[1]);
+
+            if (t[0] < 16)
+            {
+                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
+                this.Exit();
+            }
+
+            if (t[1] < 1)
+            {
+                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
+                this.Exit();
+            }
+            */
+            #endregion Abort on platforms which will not be able to execute the ops properly
+
+            #region GL States
+            GL.ClearColor(.08f, .12f, .16f, 1f);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Less);
+            GL.ClearDepth(1.0);
+
+            GL.Enable(EnableCap.StencilTest);
+            GL.ClearStencil(0);
+            GL.StencilMask(0xFFFFFFFF); // read&write
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+            GL.CullFace(CullFaceMode.Back);
+
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+
+            GL.Color4(1f, 1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.ShadeModel(ShadingModel.Smooth);
+
+            #endregion GL States
+
+            #region Load Texture
+            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
+            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
+
+            GL.GenTextures(1, out Texture);
+            GL.BindTexture(TextureTarget.Texture2D, Texture);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.Finish();
+            bitmap.UnlockBits(data);
+            #endregion Load Texture
+
+            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
+            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
+                                           SlicedSphere.eSubdivisions.Three,
+                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
+                                           true);
+
+            #region Invert Operand B's Normals
+            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
+            BeginMode tempPrimMode;
+            VertexT2dN3dV3d[] tempVertices;
+            uint[] tempIndices;
+
+            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
+            OperandB.Dispose();
+
+            for (int i = 0; i < tempVertices.Length; i++)
+            {
+                tempVertices[i].Normal *= -1.0;
+                tempVertices[i].Normal.Normalize();
+            }
+
+            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
+            #endregion Invert Operand B's Normals
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref Texture);
+
+            OperandA.Dispose();
+            OperandB.Dispose();
+
+            base.OnUnload(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Magic numbers for camera
+            CameraRotX = -Mouse.X * .5f;
+            CameraRotY = Mouse.Y * .5f;
+            CameraZoom = Mouse.Wheel * .2f;
+            #endregion Magic numbers for camera
+        }
+
+        public void DrawOperandB()
+        {
+            GL.PushMatrix();
+            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
+            OperandB.Draw();
+            GL.PopMatrix();
+        }
+
+        public void DrawOperandA()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            OperandA.Draw();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        public void RenderCsg()
+        {
+            // first pass
+            GL.Disable(EnableCap.StencilTest);
+
+            GL.ColorMask(false, false, false, false);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB();// draw front-faces into depth buffer
+
+            // use stencil plane to find parts of b in a 
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // increment the stencil where the front face of a is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
+            DrawOperandB(); // draw the part of b that's in a
+
+            // fix depth
+            GL.ColorMask(false, false, false, false);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Disable(EnableCap.StencilTest);
+            GL.DepthFunc(DepthFunction.Always);
+            DrawOperandA();
+            GL.DepthFunc(DepthFunction.Less);
+
+            // second pass
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA();
+
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            DrawOperandB(); // increment the stencil where the front face of b is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Equal, 0, 1);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // draw the part of a that's in b
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
+
+            MySphereZOffset += (float)(e.Time * 3.1);
+            MySphereXOffset += (float)(e.Time * 4.2);
+
+            #region Transform setup
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
+
+            // Camera
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+
+            GL.Translate(0f, 0f, CameraZoom);
+            GL.Rotate(CameraRotX, Vector3.UnitY);
+            GL.Rotate(CameraRotY, Vector3.UnitX);
+            #endregion Transform setup
+
+            RenderCsg();
+
+            // ---------------------------------
+
+            if (ShowDebugWireFrame)
+            {
+                GL.Color3(System.Drawing.Color.LightGray);
+                GL.Disable(EnableCap.StencilTest);
+                GL.Disable(EnableCap.Lighting);
+                //GL.Disable( EnableCap.DepthTest );
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+                DrawOperandB();
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+                GL.Enable(EnableCap.DepthTest);
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.StencilTest);
+            }
+            SwapBuffers();
+        }
+
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/640930ac41f404de7636a8d608862168d59bba9d">~</a>  -  640930a</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 9 files changed, 38 insertions(+), 8 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
index b838149..76e99e2 100644
--- a/AWGL/AWGL.cs
+++ b/AWGL/AWGL.cs
@@ -14,9 +14,25 @@ namespace AWGL
 {
-    public static class AWGL 
+    public sealed class OGL
     {
+        private static OGL instance = new OGL();
+
+        private OGL()
+        {
+        }
+
+        public static OGL getInstance()
+        {
+            return instance;
+        }
+
+        public static void SetupScene()
+        {
+            Run();
+        }
+
         [STAThread]
-        public static void Main(string[] args)
+        public static void Run()
         {
             Int32 Selection;
-
+            
             Console.WriteLine("Please select a scene to load:");
@@ -78,3 +94,3 @@ namespace AWGL
         }
-
+        
     }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index b6efb3d..7770253 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -38,3 +38,9 @@ namespace AWGL.Scene
 
-            TestOpenGLVersion();
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            //TestOpenGLVersion();
 
@@ -182,2 +188,7 @@ namespace AWGL.Scene
 
+        public new void Run()
+        {
+            base.Run();
+        }
+
     }
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index d46e66e..3ed70c9 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -174,2 +174,3 @@ namespace AWGL.Scene
         #endregion        
+    
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 1cacd88..1262556 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -6,3 +6,2 @@ using System.Text;
 using System.Threading.Tasks;
-using OpenTK;
 using OpenTK.Graphics.OpenGL;
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index e93d3ed..8b6f074 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -130,2 +130,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index a17e666..17bc239 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -294,3 +294,2 @@ namespace AWGL.Scene
 
-
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 3ab21de..880a930 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -160,2 +160,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 8944273..756c596 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -110,2 +110,3 @@ namespace AWGL.Scene
         #endregion
+
     }
diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
index 595ae6e..2cceac7 100644
--- a/TestApplication/Program.cs
+++ b/TestApplication/Program.cs
@@ -13,2 +13,3 @@ namespace TestApplication
     {
+
         [STAThread]
@@ -16,3 +17,3 @@ namespace TestApplication
         {
-            AWGL.AWGL.Main(args);
+            OGL.Run();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d91942a78e3a0f610719d6555dd0a5170d559b45">OGL Singleton partially implemented</a>  -  d91942a</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 99 insertions(+), 98 deletions(-)

diff --git a/AWGL/AWGL.cs b/AWGL/AWGL.cs
deleted file mode 100644
index 76e99e2..0000000
--- a/AWGL/AWGL.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.IO;
-using System.Linq;
-
-using AWGL.Scene;
-
-namespace AWGL
-{
-    public sealed class OGL
-    {
-        private static OGL instance = new OGL();
-
-        private OGL()
-        {
-        }
-
-        public static OGL getInstance()
-        {
-            return instance;
-        }
-
-        public static void SetupScene()
-        {
-            Run();
-        }
-
-        [STAThread]
-        public static void Run()
-        {
-            Int32 Selection;
-            
-            Console.WriteLine("Please select a scene to load:");
-            Console.WriteLine("");
-            Console.WriteLine("1. Static VBO");
-            Console.WriteLine("2. Dynamic VBO");
-            Console.WriteLine("3. Texture 2D");
-            Console.WriteLine("4. Anaylgraph Stereo");
-            Console.WriteLine("5. FBO");
-            Console.WriteLine("6. Picker");
-            Console.WriteLine("7. Stencil CSG");
-            Int32.TryParse(Console.ReadLine(), out Selection);
-
-            switch (Selection)
-            {
-                case 1:
-                    using (StaticVBOScene scene = new StaticVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 2:
-                    using (DynamicVBOScene scene = new DynamicVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
-                    using (Texture2DScene scene = new Texture2DScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 4:
-                    using (StereoVisionScene scene = new StereoVisionScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 5:
-                    using (FBOScene scene = new FBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 6:
-                    using (PickerScene scene = new PickerScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 7:
-                    using (StencilCSGScene scene = new StencilCSGScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-            }
-        }
-        
-    }
-}
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
new file mode 100644
index 0000000..d4af983
--- /dev/null
+++ b/AWGL/OGL.cs
@@ -0,0 +1,96 @@
+﻿using ObjLoader.Loader.Loaders;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.IO;
+using System.Linq;
+
+using AWGL.Scene;
+
+namespace AWGL
+{
+    public sealed class OGL
+    {
+        private static OGL instance = new OGL();
+
+        private OGL()
+        {
+        }
+
+        public static OGL getInstance()
+        {
+            return instance;
+        }
+
+        public static void SetupScene(Color backgroundColor)
+        {
+        }
+
+        [STAThread]
+        public static void Run()
+        {
+            Int32 Selection;
+            
+            Console.WriteLine("Please select a scene to load:");
+            Console.WriteLine("");
+            Console.WriteLine("1. Static VBO");
+            Console.WriteLine("2. Dynamic VBO");
+            Console.WriteLine("3. Texture 2D");
+            Console.WriteLine("4. Anaylgraph Stereo");
+            Console.WriteLine("5. FBO");
+            Console.WriteLine("6. Picker");
+            Console.WriteLine("7. Stencil CSG");
+            Int32.TryParse(Console.ReadLine(), out Selection);
+
+            switch (Selection)
+            {
+                case 1:
+                    using (StaticVBOScene scene = new StaticVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 2:
+                    using (DynamicVBOScene scene = new DynamicVBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 3:
+                    using (Texture2DScene scene = new Texture2DScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 4:
+                    using (StereoVisionScene scene = new StereoVisionScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 5:
+                    using (FBOScene scene = new FBOScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 6:
+                    using (PickerScene scene = new PickerScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+                case 7:
+                    using (StencilCSGScene scene = new StencilCSGScene())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
+            }
+        }
+        
+    }
+}
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7770253..ebfcebe 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -28,2 +28,4 @@ namespace AWGL.Scene
 
+        private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
+
         protected ErrorCode err;
@@ -48,3 +50,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(.1f, 0f, .1f, 0f);         
+            GL.ClearColor(m_backgroundColor);         
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bc530808eb1083fc578f5feff34edecb7632e798">Trying to hide OpenTK methods behind friendlier names</a>  -  bc53080</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 8 files changed, 130 insertions(+), 67 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index ebfcebe..7e613f4 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -50,4 +50,9 @@ namespace AWGL.Scene
 
-            GL.ClearColor(m_backgroundColor);         
+            GL.ClearColor(m_backgroundColor);
+
+            Setup(e);
         }
+
+        protected abstract void Setup(EventArgs e);
+
         #endregion
@@ -63,3 +68,8 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
+
+            Resize(e);
         }
+
+        protected abstract void Resize(EventArgs e);
+
         #endregion
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 3ed70c9..91eb923 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -175,2 +175,12 @@ namespace AWGL.Scene
     
+    
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index 000fb1d..4c82565 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -29,6 +29,63 @@ namespace AWGL.Scene
 
-        protected override void OnLoad(EventArgs e)
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
         {
-            base.OnLoad(e);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
 
+            SwapBuffers();
+        }
+
+
+        protected override void Setup(EventArgs e)
+        {
             if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
@@ -183,21 +240,4 @@ namespace AWGL.Scene
 
-        protected override void OnUnload(EventArgs e)
+        protected override void Resize(EventArgs e)
         {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-
             double aspect_ratio = Width / (double)Height;
@@ -211,49 +251,3 @@ namespace AWGL.Scene
             GL.LoadMatrix(ref lookat);
-
-            base.OnResize(e);
         }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
     }
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index 1262556..de2ddab 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -225,2 +225,12 @@ namespace AWGL.Scene
         #endregion
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 8b6f074..f9971fa 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -131,2 +131,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 17bc239..36984f6 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -294,2 +294,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 880a930..dfd8a27 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -161,2 +161,12 @@ namespace AWGL.Scene
 
+
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 756c596..9bfbf4a 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -111,2 +111,11 @@ namespace AWGL.Scene
 
+        protected override void Setup(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void Resize(EventArgs e)
+        {
+            throw new NotImplementedException();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/dfa83a4a29ab95c6abfd9e263bf8eb1c21c1e8fc">Added Utility Class</a>  -  dfa83a4</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 9 files changed, 261 insertions(+), 266 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7e613f4..5e637ec 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -29,5 +29,3 @@ namespace AWGL.Scene
         private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-
-        protected ErrorCode err;
-
+        
         #region OnLoad
@@ -46,3 +44,3 @@ namespace AWGL.Scene
             Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            //TestOpenGLVersion();
+            TestOpenGLVersion();
 
@@ -54,5 +52,2 @@ namespace AWGL.Scene
         }
-
-        protected abstract void Setup(EventArgs e);
-
         #endregion
@@ -68,3 +63,2 @@ namespace AWGL.Scene
             GL.Viewport(0, 0, Width, Height);
-
             Resize(e);
@@ -72,6 +66,8 @@ namespace AWGL.Scene
 
-        protected abstract void Resize(EventArgs e);
-
         #endregion
 
+        new public abstract void Setup(EventArgs e);
+
+        new public abstract void Resize(EventArgs e);
+
         #region TestOpenGLVersion
@@ -98,86 +94,3 @@ namespace AWGL.Scene
 
-        #region LoadShader(String filename, ShaderType type, int program, out int address)
-        /// <summary>
-        /// Helper Funtion for loading shaders
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <param name="program">Program ID to add Shader too</param>
-        /// <param name="address">Shader Pointer</param>
-        protected void LoadShader(String filename, ShaderType type, int program, out int address)
-        {
-            address = GL.CreateShader(type);
-            string sType = "";
-
-            switch (type)
-            {
-                case ShaderType.VertexShader:
-                    sType = "Vertex ";
-                    break;
-                case ShaderType.FragmentShader:
-                    sType = "Fragment ";
-                    break;
-            }
-
-            using (StreamReader sr = new StreamReader("Data/Shaders/" + filename))
-            {
-                GL.ShaderSource(address, sr.ReadToEnd());
-                GL.CompileShader(address);
-            }
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine(sType + "Shader: " + err);
-
-            string LogInfo;
-            GL.GetShaderInfoLog(address, out LogInfo);
-            if (LogInfo.Length > 0 && !LogInfo.Contains("hardware"))
-            {
-                Trace.WriteLine(sType + "Shader failed!\nLog:\n" + LogInfo);
-            }
-            else
-            {
-                Trace.WriteLine(sType + "Shader compiled without complaint.");
-                GL.AttachShader(program, address);
-            }
-        }
-
-        #endregion
-
-        #region LoadVBO<TVertex> (TVertex[] vertices, short[] elements) where TVertex : struct
-        protected Vbo LoadVBO<TVertex>(TVertex[] vertices, short[] elements) where TVertex : struct
-        {
-            Vbo handle = new Vbo();
-            int size;
-
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-
-            GL.GenBuffers(1, out handle.VboID);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(vertices.Length * BlittableValueType.StrideOf(vertices)), vertices,
-                          BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (vertices.Length * BlittableValueType.StrideOf(vertices) != size)
-                throw new ApplicationException("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out handle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(elements.Length * sizeof(short)), elements,
-                          BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (elements.Length * sizeof(short) != size)
-                throw new ApplicationException("Element data not uploaded correctly");
-
-            handle.NumElements = elements.Length;
-            return handle;
-        }
-
-        #endregion
-
-        #region Keyboard_KeyDown
+        #region Input
         /// <summary>
@@ -200,8 +113,3 @@ namespace AWGL.Scene
 
-        public new void Run()
-        {
-            base.Run();
-        }
-
     }
-}
+}
\ No newline at end of file
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 91eb923..3ae9627 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -32,67 +32,2 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-        #endregion
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-        }
-
         #region OnUpdateFrame
@@ -174,17 +109,62 @@ namespace AWGL.Scene
         #endregion        
-    
-    
-        protected override void Setup(EventArgs e)
+
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            GL.Enable(EnableCap.DepthTest);
+
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
-        }
-    }
 
-    
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
+            GL.LoadMatrix(ref p);
 
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+        }
+    
+    
+    } 
 }
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index 4c82565..efe295d 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -87,4 +87,3 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
@@ -240,3 +239,3 @@ namespace AWGL.Scene
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index de2ddab..a7c9ce6 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -9,2 +9,3 @@ using System.Diagnostics;
 using AWGL.Shapes;
+using AWGL;
 using System.Drawing;
@@ -85,24 +86,8 @@ namespace AWGL.Scene
 
-            ProgramObject = GL.CreateProgram();
+            //create and compile shaders
+            VertexShaderObject = Utils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = Utils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
 
-            // Load&Compile Vertex Shader
-            LoadShader("Picking_VS.glsl", ShaderType.VertexShader, ProgramObject, out VertexShaderObject);
-
-            // Load&Compile Fragment Shader
-            LoadShader("Picking_FS.glsl", ShaderType.FragmentShader, ProgramObject, out FragmentShaderObject);
-            
-            // Link the Shaders to a usable Program
-
-            // link it all together
-            GL.LinkProgram(ProgramObject);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("LinkProgram: " + err);
-
-            GL.UseProgram(ProgramObject);
-
-            err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("UseProgram: " + err);
+            //create program object, attach shaders and link
+            ProgramObject = Utils.BuildProgram(VertexShaderObject, FragmentShaderObject);
 
@@ -112,14 +97,2 @@ namespace AWGL.Scene
 
-            int temp;
-            string LogInfo;
-            GL.GetProgram(ProgramObject, ProgramParameter.LinkStatus, out temp);
-            Trace.WriteLine("Linking Program (" + ProgramObject + ") " + ((temp == 1) ? "succeeded." : "FAILED!"));
-            if (temp != 1)
-            {
-                GL.GetProgramInfoLog(ProgramObject, out LogInfo);
-                Trace.WriteLine("Program Log:\n" + LogInfo);
-            }
-
-            Trace.WriteLine("End of Shader build. GL Error: " + GL.GetError());
-
             GL.UseProgram(0);
@@ -158,3 +131,3 @@ namespace AWGL.Scene
 
-        #region OnRenderFrae
+        #region OnRenderFrame
         /// <summary>
@@ -226,10 +199,10 @@ namespace AWGL.Scene
 
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index f9971fa..ad2361b 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -19,3 +19,3 @@ namespace AWGL.Scene
         
-        private Vbo[] vbo = new Vbo[2];
+        private Vbo vbo = new Vbo();
 
@@ -47,28 +47,11 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.Enable(EnableCap.DepthTest);
 
-            vbo[0] = LoadVBO(CubeVertices, CubeElements);
-            vbo[1] = LoadVBO(CubeVertices, CubeElements);
+            vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
         }
-        #endregion
-
-        #region OnResize
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            base.OnResize(e);
-
             float aspect_ratio = Width / (float)Height;
@@ -79,4 +62,2 @@ namespace AWGL.Scene
 
-        #endregion
-
         #region OnRenderFrame
@@ -100,3 +81,3 @@ namespace AWGL.Scene
 
-            Draw(vbo[0]);
+            Draw(vbo);
 
@@ -130,13 +111,2 @@ namespace AWGL.Scene
         #endregion
-
-
-        protected override void Setup(EventArgs e)
-        {
-            throw new NotImplementedException();
-        }
-
-        protected override void Resize(EventArgs e)
-        {
-            throw new NotImplementedException();
-        }
     }
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 36984f6..b4abc6b 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -55,3 +55,2 @@ namespace AWGL.Scene
 
-
         protected override void OnLoad(EventArgs e)
@@ -294,11 +293,10 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index dfd8a27..28629f9 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -161,14 +161,13 @@ namespace AWGL.Scene
 
-
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
+    
     }
-
     #region StereoVison Structs
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 9bfbf4a..7e5f167 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -111,10 +111,10 @@ namespace AWGL.Scene
 
-        protected override void Setup(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
 
-        protected override void Resize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            throw new NotImplementedException();
+            //throw new NotImplementedException();
         }
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
new file mode 100644
index 0000000..b42e2aa
--- /dev/null
+++ b/AWGL/Utils.cs
@@ -0,0 +1,168 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Utility functions
+    /// </summary>
+    public class Utils
+    {
+        /// <summary>
+        /// Helper Funtion for loading shaders. Returns Shader Source from file.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <returns>Shader Source Code</returns>
+        public static string LoadShader(String filename)
+        {
+            string dataPath = "Data/Shaders/";
+            string shaderSource;
+
+            using (StreamReader sr = new StreamReader(dataPath + filename))
+            {
+                shaderSource = sr.ReadToEnd();
+            }
+
+            return shaderSource;
+        }     
+        
+        /// <summary>
+        /// Load the shader file, creates an OpenGL shader object, compiles the 
+        /// source code and returns the handle to the internal shader object. 
+        /// If the compilation fails, the application will exit.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <returns>Shader Handle</returns>
+        public static int BuildShader(string filename, ShaderType shaderType)
+        {
+            string shaderSource = LoadShader(filename);
+
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, shaderSource);
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// Creates a program object, attaches the shaders, links them and 
+        /// returns the OpenGL handle of the program.
+        /// </summary>
+        /// <param name="vertexShaderId">Shader Handle</param>
+        /// <param name="fragmentShaderId">Shader Handle</param>
+        /// <returns>Shader Program Handle</returns>
+        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
+        {
+            int programHandle = GL.CreateProgram();
+            GL.AttachShader(programHandle, vertexShaderId);
+            GL.AttachShader(programHandle, fragmentShaderId);
+            GL.LinkProgram(programHandle);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+
+            return programHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <typeparam name="TVertex"></typeparam>
+        /// <param name="vertices"></param>
+        /// <param name="elements"></param>
+        /// <param name="elementSize"></param>
+        /// <param name="typeSize"></param>
+        /// <param name="bufferUsageTypeGL"></param>
+        /// <returns></returns>
+        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements, 
+                                           int elementSize, 
+                                           int typeSize, 
+                                           BufferUsageHint bufferUsageTypeGL) 
+            where TVertex : struct
+        {
+            Vbo vboHandle = new Vbo();
+
+            vboHandle.NumElements = elements.Length;
+
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+
+            #region
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
+            #endregion
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != vbo_Size)
+                throw new Exception("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != ebo_Size)
+                throw new Exception("Element data not uploaded correctly");
+
+            return vboHandle;
+        }
+    
+    
+    }
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d09826c871a64744e28c418ab3ff615a1bff5d94">jiggled some stuff around</a>  -  d09826c</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 17 insertions(+), 76 deletions(-)

diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index b4abc6b..5236b05 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -55,6 +55,4 @@ namespace AWGL.Scene
 
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             #region Abort on platforms which will not be able to execute the ops properly
@@ -156,2 +154,7 @@ namespace AWGL.Scene
 
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
         protected override void OnUnload(EventArgs e)
@@ -293,11 +296,2 @@ namespace AWGL.Scene
 
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     }
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
index 28629f9..2b84210 100644
--- a/AWGL/Scene/StereoVisionScene.cs
+++ b/AWGL/Scene/StereoVisionScene.cs
@@ -19,10 +19,4 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.Enable(EnableCap.DepthTest);
@@ -34,17 +28,8 @@ namespace AWGL.Scene
         }
-        #endregion
-
-        #region OnResize
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        protected override void OnResize(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            base.OnResize(e);
+            //throw new NotImplementedException();
         }
 
-        #endregion
-
         #region OnRenderFrame
@@ -160,12 +145,2 @@ namespace AWGL.Scene
         #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 7e5f167..2db8d57 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -18,3 +18,2 @@ namespace AWGL.Scene
     {
-
         #region Private Members
@@ -26,10 +25,4 @@ namespace AWGL.Scene
 
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
+        public override void Setup(EventArgs e)
         {
-            base.OnLoad(e);
-
             GL.PointSize(5f);
@@ -53,27 +46,15 @@ namespace AWGL.Scene
         }
-        #endregion
-
-        #region OnUnload
 
-        protected override void OnUnload(EventArgs e)
+        public override void Resize(EventArgs e)
         {
-            GL.DeleteTextures(1, ref texture);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
         }
 
-        #endregion
-
-        #region OnResize
+        #region OnUnload
 
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
+        protected override void OnUnload(EventArgs e)
         {
-            base.OnResize(e);
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+            GL.DeleteTextures(1, ref texture);
         }
@@ -111,11 +92,2 @@ namespace AWGL.Scene
 
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/951c5a1a8b288b5c805be06611f3870ec92bc278">Sorted all usings</a>  -  951c5a1</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 28 files changed, 23 insertions(+), 126 deletions(-)

diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index ee0651e..4ebbf45 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -2,2 +2,3 @@
 using System;
+
 namespace AWGL
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index d4af983..6f74820 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -1,12 +1,4 @@
-﻿using ObjLoader.Loader.Loaders;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
+﻿using AWGL.Scene;
 using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.IO;
-using System.Linq;
-
-using AWGL.Scene;
 
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 5e637ec..fb7b696 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -1,4 +1,2 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
+﻿using OpenTK;
 using OpenTK.Graphics;
@@ -7,8 +5,2 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
 
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
index 3ae9627..5bc302e 100644
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ b/AWGL/Scene/DynamicVBOScene.cs
@@ -1,11 +1,4 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics;
+﻿using OpenTK;
 using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
index efe295d..ee33056 100644
--- a/AWGL/Scene/FBOScene.cs
+++ b/AWGL/Scene/FBOScene.cs
@@ -2,12 +2,5 @@
 using OpenTK;
-using OpenTK.Input;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-
 using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index a7c9ce6..fa67844 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -1,13 +1,7 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿using AWGL.Shapes;
+using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using System;
 using System.Diagnostics;
-using AWGL.Shapes;
-using AWGL;
 using System.Drawing;
-using System.IO;
 
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index ad2361b..7361dc9 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -1,13 +1,6 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿using AWGL.Tutorial;
 using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
+using System;
+using System.Drawing;
 
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
index 5236b05..8acb843 100644
--- a/AWGL/Scene/StencilCSGScene.cs
+++ b/AWGL/Scene/StencilCSGScene.cs
@@ -2,10 +2,5 @@
 using OpenTK;
-using OpenTK.Input;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.Drawing;
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
index 2db8d57..ec53ee7 100644
--- a/AWGL/Scene/Texture2DScene.cs
+++ b/AWGL/Scene/Texture2DScene.cs
@@ -1,14 +1,6 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics;
+﻿using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
 using System;
-using System.Collections.Generic;
 using System.Drawing;
 using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index 019722b..908685b 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -6,7 +6,5 @@
 
-using System;
-
 using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using System.Drawing;
+using System;
 
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index 670eb9f..7988a3f 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -1,3 +1 @@
-using System;
-
 using OpenTK;
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
index 60abd5b..be7248a 100644
--- a/AWGL/Shapes/Capsule.cs
+++ b/AWGL/Shapes/Capsule.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Collections.Generic;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
index da8df0a..e72266a 100644
--- a/AWGL/Shapes/ChamferCube.cs
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Collections.Generic;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
index 40e7ebd..1d029c9 100644
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -1,4 +1,2 @@
-using System;
 using System.Collections.Generic;
-using System.Text;
 
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
index cc08332..96d04a5 100644
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -1 +1,2 @@
+using OpenTK;
 using System;
@@ -3,4 +4,2 @@ using System.Collections.Generic;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
index 65f7f0b..b6dd18e 100644
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -1,3 +1 @@
-using System;
-
 using OpenTK;
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
index c791eb8..935452e 100644
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -1,5 +1 @@
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
index 1334082..b83ee64 100644
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -1,3 +1,2 @@
 using System;
-using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
index f81c6ad..a7821e3 100644
--- a/AWGL/Shapes/MengerSponge.cs
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -1 +1,2 @@
+using OpenTK;
 using System;
@@ -3,4 +4,2 @@ using System.Collections.Generic;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index fd8e0c0..d9fb493 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -6,11 +6,4 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Drawing;
-
-using System.Runtime.InteropServices;
-
 using OpenTK;
-using AWGL;
+using System.Drawing;
 
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
index f10a171..dea9734 100644
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -6,7 +6,4 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using OpenTK;
+using System;
 
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
index e151ed1..18ba007 100644
--- a/AWGL/Shapes/Old/Shape.cs
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -6,8 +6,3 @@
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 
-using System.Runtime.InteropServices;
-using System.Drawing;
 
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
index da9a161..4d7db8e 100644
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Diagnostics;
-
 using OpenTK;
+using System;
 
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
index 4d7a536..3718073 100644
--- a/AWGL/Shapes/SlicedHose.cs
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -1,3 +1 @@
-using System;
-using System.Collections.Generic;
 using OpenTK;
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
index 772629e..0562c49 100644
--- a/AWGL/Shapes/SlicedSphere.cs
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -1,6 +1,3 @@
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using OpenTK;
+using System.Collections.Generic;
 
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
index ff7ec7d..e8953f0 100644
--- a/AWGL/Shapes/TorusKnot.cs
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -1,6 +1,4 @@
-﻿using System;
+﻿using OpenTK;
 using System.Diagnostics;
 
-using OpenTK;
-
 namespace AWGL.Shapes
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
index 4643452..e194506 100644
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -27,5 +27,5 @@
 
+using OpenTK;
 using System.Drawing;
 using System.Runtime.InteropServices;
-using OpenTK;
 
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
index b42e2aa..c8a14ea 100644
--- a/AWGL/Utils.cs
+++ b/AWGL/Utils.cs
@@ -3,8 +3,3 @@ using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/064a885dd2bc9cdea12d12677101dbae3c691a2b">Text Renderer Class</a>  -  064a885</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 172 insertions(+)

diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 7361dc9..6b60cf9 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -10,2 +10,7 @@ namespace AWGL.Scene
     {
+        TextRenderer renderer;
+        Font serif = new Font(FontFamily.GenericSerif, 24);
+        Font sans = new Font(FontFamily.GenericSansSerif, 24);
+        Font mono = new Font(FontFamily.GenericMonospace, 24);
+
         #region Private Members
@@ -45,2 +50,13 @@ namespace AWGL.Scene
             vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+
+            renderer = new TextRenderer(Width, Height);
+            PointF position = PointF.Empty;
+
+            renderer.Clear(Color.MidnightBlue);
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", serif, Brushes.White, position);
+            position.Y += serif.Height;
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", sans, Brushes.White, position);
+            position.Y += sans.Height;
+            renderer.DrawString("The quick brown fox jumps over the lazy dog", mono, Brushes.White, position);
+            position.Y += mono.Height;
         }
@@ -77,2 +93,3 @@ namespace AWGL.Scene
             SwapBuffers();
+
         }
diff --git a/AWGL/TextRenderer.cs b/AWGL/TextRenderer.cs
new file mode 100644
index 0000000..cc94917
--- /dev/null
+++ b/AWGL/TextRenderer.cs
@@ -0,0 +1,155 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using OpenTK;
+using System.Drawing;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Uses System.Drawing for 2d text rendering.
+    /// </summary>
+    public class TextRenderer : IDisposable
+    {
+        Bitmap bmp;
+        Graphics gfx;
+        int texture;
+        Rectangle dirty_region;
+        bool disposed;
+
+        #region Constructors
+
+        /// <summary>
+        /// Constructs a new instance.
+        /// </summary>
+        /// <param name="width">The width of the backing store in pixels.</param>
+        /// <param name="height">The height of the backing store in pixels.</param>
+        public TextRenderer(int width, int height)
+        {
+            if (width <= 0)
+                throw new ArgumentOutOfRangeException("width");
+            if (height <= 0)
+                throw new ArgumentOutOfRangeException("height ");
+            if (GraphicsContext.CurrentContext == null)
+                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
+
+            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            gfx = Graphics.FromImage(bmp);
+            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
+
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
+                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+        }
+
+        #endregion
+
+        #region Public Members
+
+        /// <summary>
+        /// Clears the backing store to the specified color.
+        /// </summary>
+        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
+        public void Clear(Color color)
+        {
+            gfx.Clear(color);
+            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
+        }
+
+        /// <summary>
+        /// Draws the specified string to the backing store.
+        /// </summary>
+        /// <param name="text">The <see cref="System.String"/> to draw.</param>
+        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
+        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
+        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
+        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
+        public void DrawString(string text, Font font, Brush brush, PointF point)
+        {
+            gfx.DrawString(text, font, brush, point);
+
+            SizeF size = gfx.MeasureString(text, font);
+            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
+            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
+        }
+
+        /// <summary>
+        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
+        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
+        /// in order to render the drawn text on screen.
+        /// </summary>
+        public int Texture
+        {
+            get
+            {
+                UploadBitmap();
+                return texture;
+            }
+        }
+
+        #endregion
+
+        #region Private Members
+
+        // Uploads the dirty regions of the backing store to the OpenGL texture.
+        void UploadBitmap()
+        {
+            if (dirty_region != RectangleF.Empty)
+            {
+                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
+                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+                GL.BindTexture(TextureTarget.Texture2D, texture);
+                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
+                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
+                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+                bmp.UnlockBits(data);
+
+                dirty_region = Rectangle.Empty;
+            }
+        }
+
+        #endregion
+
+        #region IDisposable Members
+
+        void Dispose(bool manual)
+        {
+            if (!disposed)
+            {
+                if (manual)
+                {
+                    bmp.Dispose();
+                    gfx.Dispose();
+                    if (GraphicsContext.CurrentContext != null)
+                        GL.DeleteTexture(texture);
+                }
+
+                disposed = true;
+            }
+        }
+
+        public void Dispose()
+        {
+            Dispose(true);
+            GC.SuppressFinalize(this);
+        }
+
+        ~TextRenderer()
+        {
+            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
+        }
+
+        #endregion
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/766a9f153ec6733f9fa2fa0bbe1878459492313b">Win Forms Test</a>  -  766a9f1</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 6 files changed, 433 insertions(+)

diff --git a/WinFormTest/GameLoopForm.Designer.cs b/WinFormTest/GameLoopForm.Designer.cs
new file mode 100644
index 0000000..bd47093
--- /dev/null
+++ b/WinFormTest/GameLoopForm.Designer.cs
@@ -0,0 +1,61 @@
+﻿namespace WinFormTest
+{
+    partial class GameLoopForm
+    {
+        /// <summary>
+        /// Required designer variable.
+        /// </summary>
+        private System.ComponentModel.IContainer components = null;
+
+        /// <summary>
+        /// Clean up any resources being used.
+        /// </summary>
+        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
+        protected override void Dispose(bool disposing)
+        {
+            if (disposing && (components != null))
+            {
+                components.Dispose();
+            }
+            base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// <summary>
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// </summary>
+        private void InitializeComponent()
+        {
+            this.glControl = new OpenTK.GLControl();
+            this.SuspendLayout();
+            // 
+            // glControl
+            // 
+            this.glControl.BackColor = System.Drawing.Color.Black;
+            this.glControl.Dock = System.Windows.Forms.DockStyle.Top;
+            this.glControl.Location = new System.Drawing.Point(0, 0);
+            this.glControl.Name = "glControl";
+            this.glControl.Size = new System.Drawing.Size(717, 403);
+            this.glControl.TabIndex = 0;
+            this.glControl.VSync = false;
+            // 
+            // GameLoopForm
+            // 
+            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+            this.ClientSize = new System.Drawing.Size(717, 477);
+            this.Controls.Add(this.glControl);
+            this.Name = "GameLoopForm";
+            this.Text = "Form1";
+            this.ResumeLayout(false);
+
+        }
+
+        #endregion
+
+        private OpenTK.GLControl glControl;
+    }
+}
+
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
new file mode 100644
index 0000000..0443296
--- /dev/null
+++ b/WinFormTest/GameLoopForm.cs
@@ -0,0 +1,213 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace WinFormTest
+{
+    public partial class GameLoopForm : Form
+    {
+        static float angle = 0.0f;
+
+        #region --- Constructor ---
+
+        public GameLoopForm()
+        {
+            InitializeComponent();
+        }
+        
+        #endregion
+
+        #region OnLoad
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            glControl.KeyDown += new KeyEventHandler(glControl_KeyDown);
+            glControl.KeyUp += new KeyEventHandler(glControl_KeyUp);
+            glControl.Resize += new EventHandler(glControl_Resize);
+            glControl.Paint += new PaintEventHandler(glControl_Paint);
+
+            Text =
+                GL.GetString(StringName.Vendor) + " " +
+                GL.GetString(StringName.Renderer) + " " +
+                GL.GetString(StringName.Version);
+
+            GL.ClearColor(Color.MidnightBlue);
+            GL.Enable(EnableCap.DepthTest);
+
+            Application.Idle += Application_Idle;
+
+            // Ensure that the viewport and projection matrix are set correctly.
+            glControl_Resize(glControl, EventArgs.Empty);
+        }
+
+        void glControl_KeyUp(object sender, KeyEventArgs e)
+        {
+            if (e.KeyCode == Keys.F12)
+            {
+                GrabScreenshot().Save("screenshot.png");
+            }
+        }
+
+        #endregion
+
+        #region OnClosing
+
+        protected override void OnClosing(CancelEventArgs e)
+        {
+            Application.Idle -= Application_Idle;
+
+            base.OnClosing(e);
+        }
+
+        #endregion
+
+        #region Application_Idle event
+
+        void Application_Idle(object sender, EventArgs e)
+        {
+            while (glControl.IsIdle)
+            {
+                Render();
+            }
+        }
+
+        #endregion
+
+        #region GLControl.Resize event handler
+
+        void glControl_Resize(object sender, EventArgs e)
+        {
+            OpenTK.GLControl c = sender as OpenTK.GLControl;
+
+            if (c.ClientSize.Height == 0)
+                c.ClientSize = new System.Drawing.Size(c.ClientSize.Width, 1);
+
+            GL.Viewport(0, 0, c.ClientSize.Width, c.ClientSize.Height);
+
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        #endregion
+
+        #region GLControl.KeyDown event handler
+
+        void glControl_KeyDown(object sender, KeyEventArgs e)
+        {
+            switch (e.KeyData)
+            {
+                case Keys.Escape:
+                    this.Close();
+                    break;
+            }
+        }
+
+        #endregion
+
+        #region GLControl.Paint event handler
+
+        void glControl_Paint(object sender, PaintEventArgs e)
+        {
+            Render();
+        }
+
+        #endregion
+
+        #region private void Render()
+
+        private void Render()
+        {
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
+            angle += 0.5f;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            DrawCube();
+
+            glControl.SwapBuffers();
+        }
+
+        #endregion
+
+        #region private void DrawCube()
+
+        private void DrawCube()
+        {
+            GL.Begin(BeginMode.Quads);
+
+            GL.Color3(Color.Silver);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+
+            GL.Color3(Color.Honeydew);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+
+            GL.Color3(Color.Moccasin);
+
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.IndianRed);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+
+            GL.Color3(Color.PaleVioletRed);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.ForestGreen);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+
+            GL.End();
+        }
+
+        #endregion
+
+        #region private void GrabScreenshot()
+
+        Bitmap GrabScreenshot()
+        {
+            Bitmap bmp = new Bitmap(this.ClientSize.Width, this.ClientSize.Height);
+            System.Drawing.Imaging.BitmapData data =
+            bmp.LockBits(this.ClientRectangle, System.Drawing.Imaging.ImageLockMode.WriteOnly,
+                System.Drawing.Imaging.PixelFormat.Format24bppRgb);
+            GL.ReadPixels(0, 0, this.ClientSize.Width, this.ClientSize.Height, PixelFormat.Bgr, PixelType.UnsignedByte,
+                data.Scan0);
+            bmp.UnlockBits(data);
+            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);
+            return bmp;
+        }
+
+        #endregion
+    }
+}
diff --git a/WinFormTest/Program.cs b/WinFormTest/Program.cs
new file mode 100644
index 0000000..b301879
--- /dev/null
+++ b/WinFormTest/Program.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace WinFormTest
+{
+    static class Program
+    {
+        /// <summary>
+        /// The main entry point for the application.
+        /// </summary>
+        [STAThread]
+        static void Main()
+        {
+            Application.EnableVisualStyles();
+            Application.SetCompatibleTextRenderingDefault(false);
+            Application.Run(new GameLoopForm());
+        }
+    }
+}
new file mode 100644
index 0000000..f2a9af5
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("WinFormTest")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("WinFormTest")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("59ce37cf-9660-4196-991a-0a3039839f38")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
new file mode 100644
index 0000000..8f82795
--- /dev/null
@@ -0,0 +1,71 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18052
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace WinFormTest.Properties
+{
+
+
+    /// <summary>
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// </summary>
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources
+    {
+
+        private static global::System.Resources.ResourceManager resourceMan;
+
+        private static global::System.Globalization.CultureInfo resourceCulture;
+
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
+        internal Resources()
+        {
+        }
+
+        /// <summary>
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager
+        {
+            get
+            {
+                if ((resourceMan == null))
+                {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("WinFormTest.Properties.Resources", typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+
+        /// <summary>
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture
+        {
+            get
+            {
+                return resourceCulture;
+            }
+            set
+            {
+                resourceCulture = value;
+            }
+        }
+    }
+}
new file mode 100644
index 0000000..0394d77
--- /dev/null
@@ -0,0 +1,30 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18052
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace WinFormTest.Properties
+{
+
+
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
+    {
+
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+
+        public static Settings Default
+        {
+            get
+            {
+                return defaultInstance;
+            }
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb6e824a3fe400f0c7158778ff3edcf32f3cfbfc">more setup</a>  -  bb6e824</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 100 insertions(+), 4 deletions(-)

diff --git a/AWGL/Data.cs b/AWGL/Data.cs
index 4ebbf45..9517898 100644
--- a/AWGL/Data.cs
+++ b/AWGL/Data.cs
@@ -7,3 +7,3 @@ namespace AWGL
     {
-        public int VboID, EboID, NumElements;
+        public int VboID, CboID ,EboID;
     }
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
index 0443296..d47f2b5 100644
--- a/WinFormTest/GameLoopForm.cs
+++ b/WinFormTest/GameLoopForm.cs
@@ -11,2 +11,4 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
+using AWGL;
+using AWGL.Shapes;
 
@@ -17,2 +19,6 @@ namespace WinFormTest
         static float angle = 0.0f;
+        private int programObject;
+
+        private int vertex_buffer_object, color_buffer_object, element_buffer_object;
+        Shape shape = new Cube();
 
@@ -46,2 +52,16 @@ namespace WinFormTest
 
+            CreateVBO();
+
+            // create and compile shader objects
+            int vertexShader = Utils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
+            int fragmentShader = Utils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
+
+            // attach and link to main program then use
+            programObject = Utils.BuildProgram(vertexShader, fragmentShader);
+            GL.UseProgram(programObject);
+
+            // clean up
+            GL.DeleteShader(vertexShader);
+            GL.DeleteShader(fragmentShader);
+            
             Application.Idle += Application_Idle;
@@ -62,2 +82,45 @@ namespace WinFormTest
 
+        #region private void CreateVBO()
+
+        void CreateVBO()
+        {
+            int size;
+
+            GL.GenBuffers(1, out vertex_buffer_object);
+            GL.GenBuffers(1, out color_buffer_object);
+            GL.GenBuffers(1, out element_buffer_object);
+
+            // Upload the vertex buffer.
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Vertices.Length * 3 * sizeof(float)), shape.Vertices,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Vertices.Length * 3 * sizeof(Single))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Vertices.Length * 3 * sizeof(Single), size));
+
+            // Upload the color buffer.
+            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Colors.Length * sizeof(int)), shape.Colors,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Colors.Length * sizeof(int))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (colors). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Colors.Length * sizeof(int), size));
+
+            // Upload the index buffer (elements inside the vertex buffer, not color indices as per the IndexPointer function!)
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(shape.Indices.Length * sizeof(Int32)), shape.Indices,
+                BufferUsageHint.StaticDraw);
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
+            if (size != shape.Indices.Length * sizeof(int))
+                throw new ApplicationException(String.Format(
+                    "Problem uploading vertex buffer to VBO (offsets). Tried to upload {0} bytes, uploaded {1}.",
+                    shape.Indices.Length * sizeof(int), size));
+        }
+
+        #endregion
+
         #region OnClosing
@@ -66,2 +129,10 @@ namespace WinFormTest
         {
+            if (programObject != 0)
+                GL.DeleteProgram(programObject);
+            if (vboHandle.VboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.VboID);
+            if (vboHandle.CboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.CboID);
+            if (vboHandle.EboID != 0)
+                GL.DeleteBuffers(1, ref vboHandle.EboID);
             Application.Idle -= Application_Idle;
@@ -129,4 +200,11 @@ namespace WinFormTest
 
+        private Vbo vboHandle = new Vbo();
+        private float rotation_speed = 3.0f;
+
+
         private void Render()
         {
+            GL.Clear(ClearBufferMask.ColorBufferBit |
+         ClearBufferMask.DepthBufferBit);
+
             Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
@@ -135,8 +213,26 @@ namespace WinFormTest
 
+            //angle += rotation_speed * (float)Time;
             GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-            angle += 0.5f;
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.EnableClientState(ArrayCap.VertexArray);
+            GL.EnableClientState(ArrayCap.ColorArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
+            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
+
+            GL.DrawElements(BeginMode.Triangles, shape.Indices.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            //GL.DrawArrays(GL.Enums.BeginMode.POINTS, 0, shape.Vertices.Length);
+
+            GL.DisableClientState(ArrayCap.VertexArray);
+            GL.DisableClientState(ArrayCap.ColorArray);
+
 
-            DrawCube();
+            //int error = GL.GetError();
+            //if (error != 0)
+            //    Debug.Print(Glu.ErrorString(Glu.Enums.ErrorCode.INVALID_OPERATION));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e657fdc0529e8b2f4e5bd6806a690fb5ff5e5953">Added basic shader manager class</a>  -  e657fdc</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 105 insertions(+)

diff --git a/AWGL/ShaderManager.cs b/AWGL/ShaderManager.cs
new file mode 100644
index 0000000..18eb1fb
--- /dev/null
+++ b/AWGL/ShaderManager.cs
@@ -0,0 +1,105 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class ShaderManager
+    {
+        /// <summary>
+        /// Shader Pointers
+        /// </summary>
+        private int vShader, fShader, linkedProgram;
+
+        private string defaultDataPath = "Data/Shaders/";
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename">Shader Filename</param>
+        /// <returns>Shader Source Code</returns>
+        private string LoadShader(string filename) 
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+        
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename"></param>
+        /// <param name="shaderType"></param>
+        /// <returns></returns>
+        private int BuildShader(string filename, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(filename));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        private void BuildProgram() 
+        {
+            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
+            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+
+            this.linkedProgram = GL.CreateProgram();
+            GL.AttachShader(linkedProgram, vShader);
+            GL.AttachShader(linkedProgram, fShader);
+            GL.LinkProgram(linkedProgram);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(this.linkedProgram);
+            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+        }
+
+        public int getShaderProgram() 
+        {
+            BuildProgram();
+
+            return linkedProgram;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/25a1ff5c3825ea9999b838a52fdb3dc1e9b2e45f">class stubs</a>  -  25a1ff5</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 24 insertions(+)

diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
new file mode 100644
index 0000000..8f58090
--- /dev/null
+++ b/AWGL/BufferManager.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class BufferManager
+    {
+    }
+}
diff --git a/AWGL/SceneManager.cs b/AWGL/SceneManager.cs
new file mode 100644
index 0000000..f4c15d9
--- /dev/null
+++ b/AWGL/SceneManager.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class SceneManager
+    {
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cdd5cfa57dbb0493d3452cd0b91218d7376f28f4">Added basic implementation of BufferManager.cs</a>  -  cdd5cfa</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 62 insertions(+), 1 deletion(-)

diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
index 8f58090..a8efd7c 100644
--- a/AWGL/BufferManager.cs
+++ b/AWGL/BufferManager.cs
@@ -1,2 +1,4 @@
-﻿using System;
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
@@ -8,4 +10,63 @@ namespace AWGL
 {
+    /// <summary>
+    /// 
+    /// </summary>
     class BufferManager
     {
+        #region
+        // To create a VBO:
+        // 1) Generate the buffer handles for the vertex and element buffers.
+        // 2) Bind the vertex buffer handle and upload your vertex data. 
+        //    Check that the buffer was uploaded correctly.
+        // 3) Bind the element buffer handle and upload your element data. 
+        //    Check that the buffer was uploaded correctly.
+        #endregion
+
+        private Vbo vboHandle;
+
+        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements,
+                                           int elementSize,
+                                           int typeSize,
+                                           BufferUsageHint bufferUsageTypeGL)
+            where TVertex : struct
+        {
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            CheckForErrors(vbo_Size);
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            CheckForErrors(ebo_Size);
+
+            return vboHandle;
+        }
+
+        private static void CheckForErrors(int size)
+        {
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != size)
+                throw new Exception("Data not uploaded correctly");
+        }
+
+
+        public Vbo getBufferObjects()
+        {
+            return new Vbo();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a164502b6626f52f2957e7a1173638fdf158871b">Renaming Files</a>  -  a164502</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 15 files changed, 465 insertions(+), 437 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
new file mode 100644
index 0000000..3b297f7
--- /dev/null
+++ b/AWGL/AWBufferManager.cs
@@ -0,0 +1,83 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    class AWBufferManager : IDisposable
+    {
+        #region
+        // To create a VBO:
+        // 1) Generate the buffer handles for the vertex and element buffers.
+        // 2) Bind the vertex buffer handle and upload your vertex data. 
+        //    Check that the buffer was uploaded correctly.
+        // 3) Bind the element buffer handle and upload your element data. 
+        //    Check that the buffer was uploaded correctly.
+        #endregion
+
+        private Vbo vboHandle;
+
+        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements,
+                                           int elementSize,
+                                           int typeSize,
+                                           BufferUsageHint bufferUsageTypeGL)
+            where TVertex : struct
+        {
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            CheckForErrors(vbo_Size);
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.EboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            CheckForErrors(ebo_Size);
+
+            return this.vboHandle;
+        }
+
+        private static void CheckForErrors(int size)
+        {
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != size)
+                throw new Exception("Data not uploaded correctly");
+        }
+
+        public Vbo getBufferObjects(DrawableShape shape)
+        {
+            return new Vbo();//GenerateVBO(
+        }
+
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
new file mode 100644
index 0000000..526fb4b
--- /dev/null
+++ b/AWGL/AWData.cs
@@ -0,0 +1,67 @@
+﻿using OpenTK;
+using System;
+
+namespace AWGL
+{
+    public struct Vbo
+    {
+        public int VboID, CboID ,EboID;
+
+        public int NumElements { get; set; }
+    }
+
+    #region Particles
+    // this struct is used for drawing
+    public struct VertexC4ubV3f
+    {
+        public byte R, G, B, A;
+        public Vector3 Position;
+
+        public static int SizeInBytes = 16;
+    }
+
+    // this struct is used for updates
+    public struct ParticleAttribut
+    {
+        public Vector3 Direction;
+        public uint Age;
+
+        //  more stuff could be here: Rotation, Radius, whatever
+    }
+    #endregion
+
+    #region Picker
+    public struct Byte4
+    {
+        public byte R, G, B, A;
+
+        public Byte4(byte[] input)
+        {
+            R = input[0];
+            G = input[1];
+            B = input[2];
+            A = input[3];
+        }
+
+        public uint ToUInt32()
+        {
+            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
+            return BitConverter.ToUInt32(temp, 0);
+        }
+
+        public override string ToString()
+        {
+            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
+        }
+    }
+
+    struct Vertex
+    {
+        public Byte4 Color; // 4 bytes
+        public Vector3 Position; // 12 bytes
+
+        public const byte SizeInBytes = 16;
+    }
+    #endregion
+
+}
\ No newline at end of file
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
new file mode 100644
index 0000000..a5eb49d
--- /dev/null
+++ b/AWGL/AWNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public abstract class AWNode
+    {
+
+    }
+}
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
new file mode 100644
index 0000000..1e26a65
--- /dev/null
+++ b/AWGL/AWSceneManager.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    class AWSceneManager : ISceneNode
+    {
+        private List<AWNode> graphic;
+    }
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
new file mode 100644
index 0000000..dcf64ca
--- /dev/null
+++ b/AWGL/AWShaderManager.cs
@@ -0,0 +1,117 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class AWShaderManager : IDisposable
+    {
+        /// <summary>
+        /// Shader Pointers
+        /// </summary>
+        private int vShader, fShader, linkedProgram;
+
+        private string defaultDataPath = "Data/Shaders/";
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename">Shader Filename</param>
+        /// <returns>Shader Source Code</returns>
+        private string LoadShader(string filename) 
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+        
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="filename"></param>
+        /// <param name="shaderType"></param>
+        /// <returns></returns>
+        private int BuildShader(string filename, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(filename));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        private void BuildProgram() 
+        {
+            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
+            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+
+            this.linkedProgram = GL.CreateProgram();
+            GL.AttachShader(linkedProgram, vShader);
+            GL.AttachShader(linkedProgram, fShader);
+            GL.LinkProgram(linkedProgram);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(this.linkedProgram);
+            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(this.linkedProgram, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public int getShaderProgram() 
+        {
+            BuildProgram();
+
+            return linkedProgram;
+        }
+
+        public void Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
new file mode 100644
index 0000000..56b81b2
--- /dev/null
+++ b/AWGL/AWUtils.cs
@@ -0,0 +1,162 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.IO;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Utility functions
+    /// </summary>
+    public class AWUtils
+    {
+        /// <summary>
+        /// Helper Funtion for loading shaders. Returns Shader Source from file.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <returns>Shader Source Code</returns>
+        public static string LoadShader(String filename)
+        {
+            string dataPath = "Data/Shaders/";
+            string shaderSource;
+
+            using (StreamReader sr = new StreamReader(dataPath + filename))
+            {
+                shaderSource = sr.ReadToEnd();
+            }
+
+            return shaderSource;
+        }     
+        
+        /// <summary>
+        /// Load the shader file, creates an OpenGL shader object, compiles the 
+        /// source code and returns the handle to the internal shader object. 
+        /// If the compilation fails, the application will exit.
+        /// </summary>
+        /// <param name="filename">Filename of GLSL Shader</param>
+        /// <param name="type">Type of GLSL Shader to load</param>
+        /// <returns>Shader Handle</returns>
+        public static int BuildShader(string filename, ShaderType shaderType)
+        {
+            string shaderSource = LoadShader(filename);
+
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, shaderSource);
+            GL.CompileShader(shaderHandle);
+
+            // Check compile success
+            int compileStatus;
+            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
+
+            if (compileStatus == 0)
+            {
+                String message;
+                GL.GetShaderInfoLog(shaderHandle, out message);
+                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                return -1;
+            }
+
+            return shaderHandle;
+        }
+
+        /// <summary>
+        /// Creates a program object, attaches the shaders, links them and 
+        /// returns the OpenGL handle of the program.
+        /// </summary>
+        /// <param name="vertexShaderId">Shader Handle</param>
+        /// <param name="fragmentShaderId">Shader Handle</param>
+        /// <returns>Shader Program Handle</returns>
+        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
+        {
+            int programHandle = GL.CreateProgram();
+            GL.AttachShader(programHandle, vertexShaderId);
+            GL.AttachShader(programHandle, fragmentShaderId);
+            GL.LinkProgram(programHandle);
+
+            // Check linker success
+            int linkSuccess;
+            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program link failed: " + message);
+            }
+
+            // Validate program
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Console.WriteLine("Program validation failed", message);
+            }
+
+            return programHandle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <typeparam name="TVertex"></typeparam>
+        /// <param name="vertices"></param>
+        /// <param name="elements"></param>
+        /// <param name="elementSize"></param>
+        /// <param name="typeSize"></param>
+        /// <param name="bufferUsageTypeGL"></param>
+        /// <returns></returns>
+        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
+                                           short[] elements, 
+                                           int elementSize, 
+                                           int typeSize, 
+                                           BufferUsageHint bufferUsageTypeGL) 
+            where TVertex : struct
+        {
+            Vbo vboHandle = new Vbo();
+
+            //vboHandle.NumElements = elements.Length;
+
+            // Determine size of Buffer
+            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
+            int ebo_Size = elements.Length * sizeof(short);
+
+            #region
+            // To create a VBO:
+            // 1) Generate the buffer handles for the vertex and element buffers.
+            // 2) Bind the vertex buffer handle and upload your vertex data. 
+            //    Check that the buffer was uploaded correctly.
+            // 3) Bind the element buffer handle and upload your element data. 
+            //    Check that the buffer was uploaded correctly.
+            #endregion
+
+            //Generate Buffer ID
+            GL.GenBuffers(1, out vboHandle.VboID);
+
+            // Binds the buffer that is used next
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
+
+            // Copy data to the VBO on the GPU.
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
+
+            int getBufferSize;
+            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != vbo_Size)
+                throw new Exception("Vertex data not uploaded correctly");
+
+            GL.GenBuffers(1, out vboHandle.EboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
+
+            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
+
+            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
+            if (getBufferSize != ebo_Size)
+                throw new Exception("Element data not uploaded correctly");
+
+            return vboHandle;
+        }
+    
+    
+    }
+}
\ No newline at end of file
diff --git a/AWGL/BufferManager.cs b/AWGL/BufferManager.cs
deleted file mode 100644
index a8efd7c..0000000
--- a/AWGL/BufferManager.cs
+++ /dev/null
@@ -1,73 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class BufferManager
-    {
-        #region
-        // To create a VBO:
-        // 1) Generate the buffer handles for the vertex and element buffers.
-        // 2) Bind the vertex buffer handle and upload your vertex data. 
-        //    Check that the buffer was uploaded correctly.
-        // 3) Bind the element buffer handle and upload your element data. 
-        //    Check that the buffer was uploaded correctly.
-        #endregion
-
-        private Vbo vboHandle;
-
-        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements,
-                                           int elementSize,
-                                           int typeSize,
-                                           BufferUsageHint bufferUsageTypeGL)
-            where TVertex : struct
-        {
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            CheckForErrors(vbo_Size);
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            CheckForErrors(ebo_Size);
-
-            return vboHandle;
-        }
-
-        private static void CheckForErrors(int size)
-        {
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != size)
-                throw new Exception("Data not uploaded correctly");
-        }
-
-
-        public Vbo getBufferObjects()
-        {
-            return new Vbo();
-        }
-    }
-}
diff --git a/AWGL/Data.cs b/AWGL/Data.cs
deleted file mode 100644
index 9517898..0000000
--- a/AWGL/Data.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿using OpenTK;
-using System;
-
-namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, CboID ,EboID;
-    }
-
-    #region Particles
-    // this struct is used for drawing
-    public struct VertexC4ubV3f
-    {
-        public byte R, G, B, A;
-        public Vector3 Position;
-
-        public static int SizeInBytes = 16;
-    }
-
-    // this struct is used for updates
-    public struct ParticleAttribut
-    {
-        public Vector3 Direction;
-        public uint Age;
-
-        //  more stuff could be here: Rotation, Radius, whatever
-    }
-    #endregion
-
-    #region Picker
-    public struct Byte4
-    {
-        public byte R, G, B, A;
-
-        public Byte4(byte[] input)
-        {
-            R = input[0];
-            G = input[1];
-            B = input[2];
-            A = input[3];
-        }
-
-        public uint ToUInt32()
-        {
-            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
-            return BitConverter.ToUInt32(temp, 0);
-        }
-
-        public override string ToString()
-        {
-            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
-        }
-    }
-
-    struct Vertex
-    {
-        public Byte4 Color; // 4 bytes
-        public Vector3 Position; // 12 bytes
-
-        public const byte SizeInBytes = 16;
-    }
-    #endregion
-
-}
\ No newline at end of file
diff --git a/AWGL/Graphic.cs b/AWGL/Graphic.cs
deleted file mode 100644
index 2d62a94..0000000
--- a/AWGL/Graphic.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class Graphic
-    {
-    }
-}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
index fa67844..3aca921 100644
--- a/AWGL/Scene/PickerScene.cs
+++ b/AWGL/Scene/PickerScene.cs
@@ -81,7 +81,7 @@ namespace AWGL.Scene
             //create and compile shaders
-            VertexShaderObject = Utils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = Utils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
+            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
 
             //create program object, attach shaders and link
-            ProgramObject = Utils.BuildProgram(VertexShaderObject, FragmentShaderObject);
+            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
 
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index 6b60cf9..f162f26 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -49,3 +49,3 @@ namespace AWGL.Scene
 
-            vbo = Utils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
 
diff --git a/AWGL/SceneManager.cs b/AWGL/SceneManager.cs
deleted file mode 100644
index f4c15d9..0000000
--- a/AWGL/SceneManager.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class SceneManager
-    {
-    }
-}
diff --git a/AWGL/ShaderManager.cs b/AWGL/ShaderManager.cs
deleted file mode 100644
index 18eb1fb..0000000
--- a/AWGL/ShaderManager.cs
+++ /dev/null
@@ -1,105 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.IO;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    class ShaderManager
-    {
-        /// <summary>
-        /// Shader Pointers
-        /// </summary>
-        private int vShader, fShader, linkedProgram;
-
-        private string defaultDataPath = "Data/Shaders/";
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename">Shader Filename</param>
-        /// <returns>Shader Source Code</returns>
-        private string LoadShader(string filename) 
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-        
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <param name="shaderType"></param>
-        /// <returns></returns>
-        private int BuildShader(string filename, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(filename));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        private void BuildProgram() 
-        {
-            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
-            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
-
-            this.linkedProgram = GL.CreateProgram();
-            GL.AttachShader(linkedProgram, vShader);
-            GL.AttachShader(linkedProgram, fShader);
-            GL.LinkProgram(linkedProgram);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program validation failed", message);
-            }
-        }
-
-        public int getShaderProgram() 
-        {
-            BuildProgram();
-
-            return linkedProgram;
-        }
-    }
-}
diff --git a/AWGL/Utils.cs b/AWGL/Utils.cs
deleted file mode 100644
index c8a14ea..0000000
--- a/AWGL/Utils.cs
+++ /dev/null
@@ -1,163 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.IO;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Utility functions
-    /// </summary>
-    public class Utils
-    {
-        /// <summary>
-        /// Helper Funtion for loading shaders. Returns Shader Source from file.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <returns>Shader Source Code</returns>
-        public static string LoadShader(String filename)
-        {
-            string dataPath = "Data/Shaders/";
-            string shaderSource;
-
-            using (StreamReader sr = new StreamReader(dataPath + filename))
-            {
-                shaderSource = sr.ReadToEnd();
-            }
-
-            return shaderSource;
-        }     
-        
-        /// <summary>
-        /// Load the shader file, creates an OpenGL shader object, compiles the 
-        /// source code and returns the handle to the internal shader object. 
-        /// If the compilation fails, the application will exit.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <returns>Shader Handle</returns>
-        public static int BuildShader(string filename, ShaderType shaderType)
-        {
-            string shaderSource = LoadShader(filename);
-
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, shaderSource);
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        /// <summary>
-        /// Creates a program object, attaches the shaders, links them and 
-        /// returns the OpenGL handle of the program.
-        /// </summary>
-        /// <param name="vertexShaderId">Shader Handle</param>
-        /// <param name="fragmentShaderId">Shader Handle</param>
-        /// <returns>Shader Program Handle</returns>
-        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
-        {
-            int programHandle = GL.CreateProgram();
-            GL.AttachShader(programHandle, vertexShaderId);
-            GL.AttachShader(programHandle, fragmentShaderId);
-            GL.LinkProgram(programHandle);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program validation failed", message);
-            }
-
-            return programHandle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <typeparam name="TVertex"></typeparam>
-        /// <param name="vertices"></param>
-        /// <param name="elements"></param>
-        /// <param name="elementSize"></param>
-        /// <param name="typeSize"></param>
-        /// <param name="bufferUsageTypeGL"></param>
-        /// <returns></returns>
-        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements, 
-                                           int elementSize, 
-                                           int typeSize, 
-                                           BufferUsageHint bufferUsageTypeGL) 
-            where TVertex : struct
-        {
-            Vbo vboHandle = new Vbo();
-
-            vboHandle.NumElements = elements.Length;
-
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-
-            #region
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-            #endregion
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != vbo_Size)
-                throw new Exception("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != ebo_Size)
-                throw new Exception("Element data not uploaded correctly");
-
-            return vboHandle;
-        }
-    
-    
-    }
-}
\ No newline at end of file
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
index d47f2b5..7a857d2 100644
--- a/WinFormTest/GameLoopForm.cs
+++ b/WinFormTest/GameLoopForm.cs
@@ -55,7 +55,7 @@ namespace WinFormTest
             // create and compile shader objects
-            int vertexShader = Utils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
-            int fragmentShader = Utils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
+            int vertexShader = AWUtils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
+            int fragmentShader = AWUtils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
 
             // attach and link to main program then use
-            programObject = Utils.BuildProgram(vertexShader, fragmentShader);
+            programObject = AWUtils.BuildProgram(vertexShader, fragmentShader);
             GL.UseProgram(programObject);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8546ab04153686d8398af7a478e63643fdb3a3d2">Initial Simple Graph</a>  -  8546ab0</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 5 files changed, 112 insertions(+), 3 deletions(-)

diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index a5eb49d..c3ab3c8 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -10,3 +10,3 @@ namespace AWGL
     {
-
+        public abstract void Render();
     }
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
new file mode 100644
index 0000000..15d803d
--- /dev/null
+++ b/AWGL/AWPolygon.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies, m_Normals, m_TexCoords;
+
+        public override void Render()
+        {
+            GL.Begin(BeginMode.Polygon);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if(i < m_Normals.Length){
+                    GL.Normal3(m_Normals[i]);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(Vector3 v) 
+        {
+            m_Verticies.SetValue(v, m_Verticies.Length + 1);
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals.SetValue(n, m_Normals.Length + 1);
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
index 1e26a65..0e969a6 100644
--- a/AWGL/AWSceneManager.cs
+++ b/AWGL/AWSceneManager.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK;
+using System;
 using System.Collections.Generic;
@@ -13,3 +14,3 @@ namespace AWGL
     {
-        private List<AWNode> graphic;
+        
     }
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 6f74820..2a5682c 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -37,2 +37,3 @@ namespace AWGL
             Console.WriteLine("7. Stencil CSG");
+            Console.WriteLine("8. Scene Graph Test");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -83,2 +84,8 @@ namespace AWGL
                     break;
+                case 8:
+                    using (SceneGraphTest scene = new SceneGraphTest())
+                    {
+                        scene.Run(30.0);
+                    }
+                    break;
             }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
new file mode 100644
index 0000000..0643e86
--- /dev/null
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -0,0 +1,56 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Scene
+{
+    class SceneGraphTest : DefaultScene
+    {
+        AWNode m_sceneGraph;
+
+        public void CreateSceneGraph()
+        {
+            AWPolygon poly = new AWPolygon();
+            
+            poly.AddNormal(new Vector3(0.861411f, 0.269191f, 0.430706f));
+
+            poly.AddVertex(new Vector3(.0f, 4.0f, .0f));
+            poly.AddVertex(new Vector3(.0f, .0f, 2.5f));
+            poly.AddVertex(new Vector3(2.5f, .0f, -2.5f));
+
+            m_sceneGraph = poly;
+        }
+        public override void Setup(EventArgs e)
+        {
+            CreateSceneGraph();
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/56eecae713a477383e9cf256a916ef77412a1ddb">IEnumerater Setup</a>  -  56eecae</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 5 files changed, 88 insertions(+), 4 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
new file mode 100644
index 0000000..e5a7f50
--- /dev/null
+++ b/AWGL/AWGroupNode.cs
@@ -0,0 +1,64 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+    } 
+}
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index c3ab3c8..247ec9d 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -12,2 +12,3 @@ namespace AWGL
     }
+
 }
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
new file mode 100644
index 0000000..f45afaf
--- /dev/null
+++ b/AWGL/IGroupNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
new file mode 100644
index 0000000..29c9dc4
--- /dev/null
+++ b/AWGL/ISceneNode.cs
@@ -0,0 +1,7 @@
+﻿
+namespace AWGL
+{
+    interface ISceneNode
+    {
+    }
+}
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0643e86..a8caa1e 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -20,5 +20,5 @@ namespace AWGL.Scene
 
-            poly.AddVertex(new Vector3(.0f, 4.0f, .0f));
-            poly.AddVertex(new Vector3(.0f, .0f, 2.5f));
-            poly.AddVertex(new Vector3(2.5f, .0f, -2.5f));
+            poly.AddVertex(0, new Vector3(.0f, 4.0f, .0f));
+            poly.AddVertex(1, new Vector3(.0f, .0f, 2.5f));
+            poly.AddVertex(2, new Vector3(2.5f, .0f, -2.5f));
 
@@ -46,3 +46,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(0, 10, 10, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e257be39d1841b7d23561624ec6703677e0afc73">More work towards having a working, yet simple scene-graph using IEnumerator.</a>  -  e257be3</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 4 files changed, 28 insertions(+), 10 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index e5a7f50..abfbb54 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -9,3 +9,3 @@ namespace AWGL
 {
-    class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
     {
@@ -48,2 +48,3 @@ namespace AWGL
 
+        #region IEnumerator Implementation
         public IEnumerator<ISceneNode> GetEnumerator()
@@ -57,2 +58,5 @@ namespace AWGL
         }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
 
@@ -62,2 +66,4 @@ namespace AWGL
         }
+
+        #endregion IGroupNode Implementation
     } 
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
index 15d803d..a619ff0 100644
--- a/AWGL/AWPolygon.cs
+++ b/AWGL/AWPolygon.cs
@@ -12,4 +12,10 @@ namespace AWGL
     {
-        Vector3[] m_Verticies, m_Normals, m_TexCoords;
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
 
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
         public override void Render()
@@ -19,4 +25,5 @@ namespace AWGL
             {
-                if(i < m_Normals.Length){
-                    GL.Normal3(m_Normals[i]);
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
                 }
@@ -28,5 +35,5 @@ namespace AWGL
 
-        public void AddVertex(Vector3 v) 
+        public void AddVertex(int index, Vector3 v) 
         {
-            m_Verticies.SetValue(v, m_Verticies.Length + 1);
+            m_Verticies[index] = v;
         }
@@ -35,3 +42,3 @@ namespace AWGL
         {
-            m_Normals.SetValue(n, m_Normals.Length + 1);
+            m_Normals = n;
         }
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
index f45afaf..7a8f5e7 100644
--- a/AWGL/IGroupNode.cs
+++ b/AWGL/IGroupNode.cs
@@ -7,3 +7,3 @@ namespace AWGL
 {
-    interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
     {
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index 29c9dc4..e7bd38d 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -1,6 +1,11 @@
-﻿
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
 namespace AWGL
 {
-    interface ISceneNode
+    public interface ISceneNode
     {
+        
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9d1d47e0c76cbe11ef9ebdb66019df9b976ca465">Added code to iterate through all child nodes.</a>  -  9d1d47e</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index abfbb54..fc343da 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections;
@@ -45,3 +46,14 @@ namespace AWGL
         {
-            throw new NotImplementedException();
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+            while (GetEnumerator().Current != null)
+            {
+                GetEnumerator().Current.Render();
+                GetEnumerator().MoveNext();
+            }
+            GL.PopMatrix();
         }
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
index 0e969a6..adf29da 100644
--- a/AWGL/AWSceneManager.cs
+++ b/AWGL/AWSceneManager.cs
@@ -12,5 +12,5 @@ namespace AWGL
     /// </summary>
-    class AWSceneManager : ISceneNode
+    class AWSceneManager
     {
-        
+
     }
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index e7bd38d..67bc773 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -9,3 +9,3 @@ namespace AWGL
     {
-        
+        void Render();
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9261bb7c18edc34afb9c25b410687a9d4a39d015">Fixed infinite loop while rendering children.</a>  -  9261bb7</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 42 insertions(+), 11 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index fc343da..98b4008 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -16,2 +16,3 @@ namespace AWGL
         private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
 
@@ -52,6 +53,6 @@ namespace AWGL
             }
-            while (GetEnumerator().Current != null)
+
+            foreach (ISceneNode child in m_children)
             {
-                GetEnumerator().Current.Render();
-                GetEnumerator().MoveNext();
+                child.Render();
             }
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
index 247ec9d..39bef32 100644
--- a/AWGL/AWNode.cs
+++ b/AWGL/AWNode.cs
@@ -8,3 +8,3 @@ namespace AWGL
 {
-    public abstract class AWNode
+    public abstract class AWNode : ISceneNode
     {
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index a8caa1e..c87c5ee 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -16,12 +16,42 @@ namespace AWGL.Scene
         {
-            AWPolygon poly = new AWPolygon();
+
+            AWPolygon poly1 = new AWPolygon();
+            AWPolygon poly2 = new AWPolygon();
+            AWPolygon poly3 = new AWPolygon();
+            AWPolygon poly4 = new AWPolygon();
+            AWGroupNode root = new AWGroupNode();
             
-            poly.AddNormal(new Vector3(0.861411f, 0.269191f, 0.430706f));
+            Vector3 a = new Vector3(.0f, .0f, 2.5f);
+            Vector3 b = new Vector3(2.5f, .0f, -2.5f);
+            Vector3 c = new Vector3(-2.5f, .0f, 2.5f);
+            Vector3 d = new Vector3(.0f, 4.0f, .0f);
+
+            poly1.AddNormal(new Vector3(.0f, -1.0f, .0f));
+            poly1.AddVertex(0, c);
+            poly1.AddVertex(1, b);
+            poly1.AddVertex(2, c);
+
+            poly2.AddNormal(new Vector3(.861411f, .269191f, .430706f));
+            poly2.AddVertex(0, d);
+            poly2.AddVertex(1, a);
+            poly2.AddVertex(2, b);
 
-            poly.AddVertex(0, new Vector3(.0f, 4.0f, .0f));
-            poly.AddVertex(1, new Vector3(.0f, .0f, 2.5f));
-            poly.AddVertex(2, new Vector3(2.5f, .0f, -2.5f));
+            poly3.AddNormal(new Vector3(.0f, .529999f, -.847998f));
+            poly3.AddVertex(0, d);
+            poly3.AddVertex(1, b);
+            poly3.AddVertex(2, c);
 
-            m_sceneGraph = poly;
+            poly4.AddNormal(new Vector3(-.861411f, .269191f, .430706f));
+            poly4.AddVertex(0, d);
+            poly4.AddVertex(1, c);
+            poly4.AddVertex(2, a);
+
+            root.AddChild(poly1);
+            root.AddChild(poly2);
+            root.AddChild(poly3);
+            root.AddChild(poly4);
+
+            m_sceneGraph = root;
         }
+
         public override void Setup(EventArgs e)
@@ -46,3 +76,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 10, 10, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(0, 20, 20, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/508c449e7e326b8807f12aab230199f115501da3">Basic Scene-graph with hooks.</a>  -  508c449</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index c87c5ee..0aecff2 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -13,2 +13,4 @@ namespace AWGL.Scene
         AWNode m_sceneGraph;
+        AWGroupNode m_hook1;
+        AWGroupNode m_hook2;
 
@@ -21,4 +23,4 @@ namespace AWGL.Scene
             AWPolygon poly4 = new AWPolygon();
-            AWGroupNode root = new AWGroupNode();
-            
+            AWGroupNode rt = new AWGroupNode();
+
             Vector3 a = new Vector3(.0f, .0f, 2.5f);
@@ -48,8 +50,24 @@ namespace AWGL.Scene
 
-            root.AddChild(poly1);
-            root.AddChild(poly2);
-            root.AddChild(poly3);
-            root.AddChild(poly4);
+            AWGroupNode root = new AWGroupNode();
+            AWGroupNode rt1 = new AWGroupNode();
+            AWGroupNode rt2 = new AWGroupNode();
+
+            root.AddChild(rt1);
+            root.AddChild(rt2);
+
+            rt1.AddChild(rt);
+            rt2.AddChild(rt);
+
+            rt1.SetTranslation(5, 0, 0);
+            rt2.SetTranslation(-5, 0, 0);
+
+            rt.AddChild(poly1);
+            rt.AddChild(poly2);
+            rt.AddChild(poly3);
+            rt.AddChild(poly4);
 
             m_sceneGraph = root;
+
+            m_hook1 = rt1;
+            m_hook2 = rt2;
         }
@@ -80,2 +98,5 @@ namespace AWGL.Scene
 
+            m_hook1.SetRotation(20, 0, 1, 0);
+            m_hook2.SetRotation(-20, 0, 0, 1);
+
             m_sceneGraph.Render();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/33ed8b666d6cf0798ecb23ce087667cde876b4a4">Set default window mode to non-fullscreen.</a>  -  33ed8b6</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fb7b696..93eafe3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -16,3 +16,3 @@ namespace AWGL.Scene
         {
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
             Keyboard.KeyDown += Keyboard_KeyDown;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/222a78c980b4238ac1d445f5dae4ff396926ec1a">Simple Graph</a>  -  222a78c</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
index 67bc773..6f6da08 100644
--- a/AWGL/ISceneNode.cs
+++ b/AWGL/ISceneNode.cs
@@ -7,3 +7,3 @@ namespace AWGL
 {
-    public interface ISceneNode
+    public interface ISceneNode 
     {
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0aecff2..56adb60 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -12,5 +12,7 @@ namespace AWGL.Scene
     {
-        AWNode m_sceneGraph;
-        AWGroupNode m_hook1;
-        AWGroupNode m_hook2;
+        private AWNode m_sceneGraph;
+        private AWGroupNode m_hook1, m_hook2;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle;
 
@@ -51,2 +53,3 @@ namespace AWGL.Scene
             AWGroupNode root = new AWGroupNode();
+            AWGraphLines graph = new AWGraphLines();
             AWGroupNode rt1 = new AWGroupNode();
@@ -54,4 +57,3 @@ namespace AWGL.Scene
 
-            root.AddChild(rt1);
-            root.AddChild(rt2);
+            root.AddChild(graph);
 
@@ -92,2 +94,4 @@ namespace AWGL.Scene
 
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
@@ -98,4 +102,4 @@ namespace AWGL.Scene
 
-            m_hook1.SetRotation(20, 0, 1, 0);
-            m_hook2.SetRotation(-20, 0, 0, 1);
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+            m_hook2.SetRotation(-m_spinangle, 0, 0, 1);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c26759c20c1ec1f74bc6a093701d240ff803365d">Added basic graphlines on the xplane.</a>  -  c26759c</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 57 insertions(+)

diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
new file mode 100644
index 0000000..9bbd5e9
--- /dev/null
+++ b/AWGL/AWGraphLines.cs
@@ -0,0 +1,39 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGraphLines : AWNode
+    {
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+
+        public override void Render()
+        {
+            GL.Color3(.3d, .3f, .3f);
+            GL.Begin(PrimitiveType.Quads);
+            GL.Vertex3(.0f, -.001f, .0f);
+            GL.Vertex3(.0f, -.001f, 10.0f);
+            GL.Vertex3(10.0f, -.001f, 10.0f);
+            GL.Vertex3(10.0f, -.001f, .0f);
+            GL.End();
+
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = 0; i <= 10; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(.25f, .25f, .25f); }
+                GL.Vertex3((float)i, .0f, .0f);
+                GL.Vertex3((float)i, .0f, 10.0f);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(.25f, .25f, .25f); }
+                GL.Vertex3(.0f, .0f, (float)i);
+                GL.Vertex3(10.0f, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/AWMesh.cs b/AWGL/AWMesh.cs
new file mode 100644
index 0000000..bd58995
--- /dev/null
+++ b/AWGL/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 56adb60..7e55758 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -58,2 +58,4 @@ namespace AWGL.Scene
             root.AddChild(graph);
+            root.AddChild(rt1);
+            root.AddChild(rt2);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e460feb0dd7dff93c2f5b6af669b9550211a410d">Very Basic Camera Control</a>  -  e460feb</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 2 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 93eafe3..7e99c9b 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -21,3 +21,9 @@ namespace AWGL.Scene
         private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-        
+
+        #region Camera
+        protected float m_eyeX = .0f;
+        protected float m_eyeY = 10.0f;
+        protected float m_eyeZ = 10.0f;
+        #endregion
+
         #region OnLoad
@@ -40,3 +46,3 @@ namespace AWGL.Scene
 
-            GL.ClearColor(m_backgroundColor);
+            GL.ClearColor(Color4.Gray);
 
@@ -102,2 +108,14 @@ namespace AWGL.Scene
                     this.WindowState = WindowState.Fullscreen;
+            if (e.Key == Key.Up)
+            {
+                m_eyeY += 2f;
+            }
+            if (e.Key == Key.Down)
+            {
+                m_eyeY -= 2f;
+            }
+            if (e.Key == Key.Right)
+                m_eyeX += 2f;
+            if (e.Key == Key.Left)
+                m_eyeX -= 2f;
         }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 7e55758..0492073 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -12,4 +12,6 @@ namespace AWGL.Scene
     {
+        #region SceneGraph
         private AWNode m_sceneGraph;
         private AWGroupNode m_hook1, m_hook2;
+        #endregion
 
@@ -100,3 +102,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(0, 20, 20, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = Matrix4.LookAt(m_eyeX, m_eyeY, m_eyeZ, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a1125c6010294af19c52f22f40653f893ce74d72">Simple Grid Implemented for testing purposes. Includes some controls which don't completely work just yet.</a>  -  a1125c6</p><p>authored by Anthony Woodward, 3 months ago</p></div><pre>
 3 files changed, 42 insertions(+), 37 deletions(-)

diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
index 9bbd5e9..7f280ce 100644
--- a/AWGL/AWGraphLines.cs
+++ b/AWGL/AWGraphLines.cs
@@ -4,2 +4,3 @@ using System.Collections;
 using System.Collections.Generic;
+using System.Drawing;
 using System.Linq;
@@ -12,3 +13,3 @@ namespace AWGL
     {
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        private int m_gridSize = 20;
 
@@ -16,19 +17,11 @@ namespace AWGL
         {
-            GL.Color3(.3d, .3f, .3f);
-            GL.Begin(PrimitiveType.Quads);
-            GL.Vertex3(.0f, -.001f, .0f);
-            GL.Vertex3(.0f, -.001f, 10.0f);
-            GL.Vertex3(10.0f, -.001f, 10.0f);
-            GL.Vertex3(10.0f, -.001f, .0f);
-            GL.End();
-
             GL.Begin(PrimitiveType.Lines);
-            for (int i = 0; i <= 10; i++)
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
             {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(.25f, .25f, .25f); }
-                GL.Vertex3((float)i, .0f, .0f);
-                GL.Vertex3((float)i, .0f, 10.0f);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(.25f, .25f, .25f); }
-                GL.Vertex3(.0f, .0f, (float)i);
-                GL.Vertex3(10.0f, .0f, (float)i);
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
             }
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
index a619ff0..eb2ca03 100644
--- a/AWGL/AWPolygon.cs
+++ b/AWGL/AWPolygon.cs
@@ -4,2 +4,3 @@ using System;
 using System.Collections.Generic;
+using System.Drawing;
 using System.Linq;
@@ -22,3 +23,4 @@ namespace AWGL
         {
-            GL.Begin(BeginMode.Polygon);
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
             for (int i = 0; i < m_Verticies.Length; i++)
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 7e99c9b..fd1d068 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -66,3 +66,3 @@ namespace AWGL.Scene
 
-        new public abstract void Setup(EventArgs e);
+        public abstract void Setup(EventArgs e);
 
@@ -100,22 +100,32 @@ namespace AWGL.Scene
         {
-            if (e.Key == Key.Escape)
-                this.Exit();
-
-            if (e.Key == Key.F11)
-                if (this.WindowState == WindowState.Fullscreen)
-                    this.WindowState = WindowState.Normal;
-                else
-                    this.WindowState = WindowState.Fullscreen;
-            if (e.Key == Key.Up)
-            {
-                m_eyeY += 2f;
-            }
-            if (e.Key == Key.Down)
+
+            switch (e.Key)
             {
-                m_eyeY -= 2f;
-            }
-            if (e.Key == Key.Right)
-                m_eyeX += 2f;
-            if (e.Key == Key.Left)
-                m_eyeX -= 2f;
+                #region Window Controls
+
+                case Key.Escape: this.Exit();
+                    break;
+                case Key.F11:
+                    if (this.WindowState == WindowState.Fullscreen)
+                        this.WindowState = WindowState.Normal;
+                    else
+                        this.WindowState = WindowState.Fullscreen;
+                    break;
+
+                #endregion
+
+                #region Camera Controls
+
+                case Key.Up: m_eyeY += 2f;
+                    break;
+                case Key.Down: m_eyeY += -2f;
+                    break;
+                case Key.Right: m_eyeX += 2f;
+                    break;
+                case Key.Left: m_eyeX += -2f;
+                    break;
+
+                #endregion
+
+            }   
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d7bd2635d6c08e2b72624dd86c42491bbf48a71e">new cube node</a>  -  d7bd263</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 71 insertions(+)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
new file mode 100644
index 0000000..fcb02d9
--- /dev/null
+++ b/AWGL/AWCube.cs
@@ -0,0 +1,71 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        private Cube Cube;
+
+        private Vbo vbo;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        public AWCube()
+        {
+            vbo = new Vbo();
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+        }
+
+        public override void Render()
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+            
+            GL.DrawElements(BeginMode.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/53b333e1c9e8d168d923a2a5cc371e9e4c8aeab6">Removed TextRenderer</a>  -  53b333e</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 15 deletions(-)

diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
index f162f26..557a659 100644
--- a/AWGL/Scene/StaticVBOScene.cs
+++ b/AWGL/Scene/StaticVBOScene.cs
@@ -10,6 +10,2 @@ namespace AWGL.Scene
     {
-        TextRenderer renderer;
-        Font serif = new Font(FontFamily.GenericSerif, 24);
-        Font sans = new Font(FontFamily.GenericSansSerif, 24);
-        Font mono = new Font(FontFamily.GenericMonospace, 24);
 
@@ -50,13 +46,2 @@ namespace AWGL.Scene
             vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-
-            renderer = new TextRenderer(Width, Height);
-            PointF position = PointF.Empty;
-
-            renderer.Clear(Color.MidnightBlue);
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", serif, Brushes.White, position);
-            position.Y += serif.Height;
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", sans, Brushes.White, position);
-            position.Y += sans.Height;
-            renderer.DrawString("The quick brown fox jumps over the lazy dog", mono, Brushes.White, position);
-            position.Y += mono.Height;
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb4fed84365385914c83087fb2360ffdab490d06">rolled back vbo struct, needs more work</a>  -  bb4fed8</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
index 526fb4b..4ebbf45 100644
--- a/AWGL/AWData.cs
+++ b/AWGL/AWData.cs
@@ -7,5 +7,3 @@ namespace AWGL
     {
-        public int VboID, CboID ,EboID;
-
-        public int NumElements { get; set; }
+        public int VboID, EboID, NumElements;
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/76616d383f0e1ff9ae649e6c44903a29f123f74f">added NumElements back into buffer creation</a>  -  76616d3</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 56b81b2..1d47a04 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -118,3 +118,3 @@ namespace AWGL
 
-            //vboHandle.NumElements = elements.Length;
+            vboHandle.NumElements = elements.Length;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/31c23c57e3521dd85d2cef3a460d579d94ae305e">VBO's now correctly draw in scene graph</a>  -  31c23c5</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 7 insertions(+), 37 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 0492073..8e011de 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -22,36 +22,5 @@ namespace AWGL.Scene
         {
-
-            AWPolygon poly1 = new AWPolygon();
-            AWPolygon poly2 = new AWPolygon();
-            AWPolygon poly3 = new AWPolygon();
-            AWPolygon poly4 = new AWPolygon();
-            AWGroupNode rt = new AWGroupNode();
-
-            Vector3 a = new Vector3(.0f, .0f, 2.5f);
-            Vector3 b = new Vector3(2.5f, .0f, -2.5f);
-            Vector3 c = new Vector3(-2.5f, .0f, 2.5f);
-            Vector3 d = new Vector3(.0f, 4.0f, .0f);
-
-            poly1.AddNormal(new Vector3(.0f, -1.0f, .0f));
-            poly1.AddVertex(0, c);
-            poly1.AddVertex(1, b);
-            poly1.AddVertex(2, c);
-
-            poly2.AddNormal(new Vector3(.861411f, .269191f, .430706f));
-            poly2.AddVertex(0, d);
-            poly2.AddVertex(1, a);
-            poly2.AddVertex(2, b);
-
-            poly3.AddNormal(new Vector3(.0f, .529999f, -.847998f));
-            poly3.AddVertex(0, d);
-            poly3.AddVertex(1, b);
-            poly3.AddVertex(2, c);
-
-            poly4.AddNormal(new Vector3(-.861411f, .269191f, .430706f));
-            poly4.AddVertex(0, d);
-            poly4.AddVertex(1, c);
-            poly4.AddVertex(2, a);
-
             AWGroupNode root = new AWGroupNode();
             AWGraphLines graph = new AWGraphLines();
+
             AWGroupNode rt1 = new AWGroupNode();
@@ -59,3 +28,7 @@ namespace AWGL.Scene
 
+            AWGroupNode rt = new AWGroupNode();
+            AWCube cube = new AWCube();
+
             root.AddChild(graph);
+
             root.AddChild(rt1);
@@ -67,8 +40,5 @@ namespace AWGL.Scene
             rt1.SetTranslation(5, 0, 0);
-            rt2.SetTranslation(-5, 0, 0);
+            rt2.SetTranslation(-10, 2, 0);
 
-            rt.AddChild(poly1);
-            rt.AddChild(poly2);
-            rt.AddChild(poly3);
-            rt.AddChild(poly4);
+            rt.AddChild(cube);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ad33998aa7bc6d28915771c440b954d9688cce22">Added new method to group nodes for removing child nodes.</a>  -  ad33998</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 8 insertions(+)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index 98b4008..52c7b8e 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -80,3 +80,10 @@ namespace AWGL
 
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
         #endregion IGroupNode Implementation
+
+
     } 
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
index 7a8f5e7..5ac83e3 100644
--- a/AWGL/IGroupNode.cs
+++ b/AWGL/IGroupNode.cs
@@ -10,2 +10,3 @@ namespace AWGL
         void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b6f15d48344858a170c242f874f628ec7c8608af">Removed old examples.</a>  -  b6f15d4</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 3 files changed, 112 insertions(+), 271 deletions(-)

diff --git a/AWGL/AWParticles.cs b/AWGL/AWParticles.cs
new file mode 100644
index 0000000..2b2f7c6
--- /dev/null
+++ b/AWGL/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Scene/DynamicVBOScene.cs b/AWGL/Scene/DynamicVBOScene.cs
deleted file mode 100644
index 5bc302e..0000000
--- a/AWGL/Scene/DynamicVBOScene.cs
+++ /dev/null
@@ -1,163 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class DynamicVBOScene : DefaultScene
-    {
-        public DynamicVBOScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        private int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        #region OnUpdateFrame
-        /// <summary>
-        /// Add your game logic here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)e.Time, out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            this.Title = "AWGL: High level OpenTK wrapper - " + m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-
-            GL.Translate(0f, 0f, -5f);
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(BeginMode.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-        #endregion
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteBuffers(1, ref VBOHandle);
-        }
-
-        #endregion        
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public override void Resize(EventArgs e)
-        {
-
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 50.0f);
-            GL.LoadMatrix(ref p);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-        }
-    
-    
-    } 
-}
diff --git a/AWGL/Scene/StaticVBOScene.cs b/AWGL/Scene/StaticVBOScene.cs
deleted file mode 100644
index 557a659..0000000
--- a/AWGL/Scene/StaticVBOScene.cs
+++ /dev/null
@@ -1,108 +0,0 @@
-﻿using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class StaticVBOScene : DefaultScene
-    {
-
-        #region Private Members
-        
-        private Vbo vbo = new Vbo();
-
-        private const float rotation_speed = 180.0f;
-        private float angle;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            angle += rotation_speed * (float)e.Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            Draw(vbo);
-
-            SwapBuffers();
-
-        }
-        #endregion
-
-        #region Draw(Vbo handle)
-
-        private void Draw(Vbo handle)
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, handle.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, handle.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-
-            GL.DrawElements(BeginMode.Triangles, handle.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-
-        #endregion
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2242df6f73c14922f18c70d3046b81626b27611c">Removed menu options.</a>  -  2242df6</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 14 insertions(+), 27 deletions(-)

diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 2a5682c..3802f15 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -28,12 +28,11 @@ namespace AWGL
             
-            Console.WriteLine("Please select a scene to load:");
-            Console.WriteLine("");
-            Console.WriteLine("1. Static VBO");
-            Console.WriteLine("2. Dynamic VBO");
-            Console.WriteLine("3. Texture 2D");
-            Console.WriteLine("4. Anaylgraph Stereo");
-            Console.WriteLine("5. FBO");
-            Console.WriteLine("6. Picker");
-            Console.WriteLine("7. Stencil CSG");
-            Console.WriteLine("8. Scene Graph Test");
+            Console.WriteLine("Please select a scene to load:\n");
+
+            Console.WriteLine("1. Dynamic VBO");
+            Console.WriteLine("2. Texture 2D");
+            Console.WriteLine("3. Anaylgraph Stereo");
+            Console.WriteLine("4. FBO");
+            Console.WriteLine("5. Picker");
+            Console.WriteLine("6. Stencil CSG");
+            Console.WriteLine("7. Scene Graph Test\n");
             Int32.TryParse(Console.ReadLine(), out Selection);
@@ -42,15 +41,3 @@ namespace AWGL
             {
-                case 1:
-                    using (StaticVBOScene scene = new StaticVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
                 case 2:
-                    using (DynamicVBOScene scene = new DynamicVBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
                     using (Texture2DScene scene = new Texture2DScene())
@@ -60,3 +47,3 @@ namespace AWGL
                     break;
-                case 4:
+                case 3:
                     using (StereoVisionScene scene = new StereoVisionScene())
@@ -66,3 +53,3 @@ namespace AWGL
                     break;
-                case 5:
+                case 4:
                     using (FBOScene scene = new FBOScene())
@@ -72,3 +59,3 @@ namespace AWGL
                     break;
-                case 6:
+                case 5:
                     using (PickerScene scene = new PickerScene())
@@ -78,3 +65,3 @@ namespace AWGL
                     break;
-                case 7:
+                case 6:
                     using (StencilCSGScene scene = new StencilCSGScene())
@@ -84,3 +71,3 @@ namespace AWGL
                     break;
-                case 8:
+                case 7:
                     using (SceneGraphTest scene = new SceneGraphTest())

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/854d4e1e82d41034cf911b26bba612053e4778ea">Removed obsolete OpenTK BeginMode in favor of PrimitiveType.</a>  -  854d4e1</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
index fcb02d9..d6c112a 100644
--- a/AWGL/AWCube.cs
+++ b/AWGL/AWCube.cs
@@ -67,3 +67,3 @@ namespace AWGL
             
-            GL.DrawElements(BeginMode.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e57d6e3b8e6de2d0dc5ec2f10dcc59bafe566252">Refactoring SceneGraph client code.</a>  -  e57d6e3</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 26 insertions(+), 9 deletions(-)

diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 8e011de..ea3e770 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -14,2 +14,9 @@ namespace AWGL.Scene
         private AWNode m_sceneGraph;
+
+        AWGroupNode root, rt1, rt2, rt, rtt;
+        AWGraphLines graph;
+
+        AWCube cube;
+        AWParticles particles;
+
         private AWGroupNode m_hook1, m_hook2;
@@ -22,10 +29,3 @@ namespace AWGL.Scene
         {
-            AWGroupNode root = new AWGroupNode();
-            AWGraphLines graph = new AWGraphLines();
-
-            AWGroupNode rt1 = new AWGroupNode();
-            AWGroupNode rt2 = new AWGroupNode();
-
-            AWGroupNode rt = new AWGroupNode();
-            AWCube cube = new AWCube();
+            InitialiseNodes();
 
@@ -37,3 +37,3 @@ namespace AWGL.Scene
             rt1.AddChild(rt);
-            rt2.AddChild(rt);
+            rt2.AddChild(rtt);
 
@@ -43,2 +43,3 @@ namespace AWGL.Scene
             rt.AddChild(cube);
+            //rt.AddChild(particles);
 
@@ -50,2 +51,15 @@ namespace AWGL.Scene
 
+        private void InitialiseNodes()
+        {
+            root = new AWGroupNode();
+            rt1 = new AWGroupNode();
+            rt2 = new AWGroupNode();
+            rt = new AWGroupNode();
+            rtt = new AWGroupNode();
+
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            particles = new AWParticles(); ;
+        }
+
         public override void Setup(EventArgs e)
@@ -68,2 +82,5 @@ namespace AWGL.Scene
 
+            Title = "AWGL: High level OpenTK wrapper - " + particles.m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+
             m_spinangle += m_rotationspeed * (float)e.Time;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e485e92f6ec8b0d6fffc7c6b41104df30b97111c">Trimmed nodes.</a>  -  e485e92</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 13 insertions(+), 32 deletions(-)

diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
index 52c7b8e..0e656cc 100644
--- a/AWGL/AWGroupNode.cs
+++ b/AWGL/AWGroupNode.cs
@@ -17,3 +17,2 @@ namespace AWGL
         
-
         public AWGroupNode()
@@ -51,3 +50,3 @@ namespace AWGL
             {
-                GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
             }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index ea3e770..61c4dd4 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -15,9 +15,8 @@ namespace AWGL.Scene
 
-        AWGroupNode root, rt1, rt2, rt, rtt;
-        AWGraphLines graph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
 
-        AWCube cube;
-        AWParticles particles;
+        private AWCube cube;
 
-        private AWGroupNode m_hook1, m_hook2;
+        private AWGroupNode m_hook1;
         #endregion
@@ -31,20 +30,11 @@ namespace AWGL.Scene
 
-            root.AddChild(graph);
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
 
-            root.AddChild(rt1);
-            root.AddChild(rt2);
+            landRoot.SetTranslation(0, 0, -10);
+            landRoot.AddChild(cube);
 
-            rt1.AddChild(rt);
-            rt2.AddChild(rtt);
+            m_sceneGraph = worldRoot;
 
-            rt1.SetTranslation(5, 0, 0);
-            rt2.SetTranslation(-10, 2, 0);
-
-            rt.AddChild(cube);
-            //rt.AddChild(particles);
-
-            m_sceneGraph = root;
-
-            m_hook1 = rt1;
-            m_hook2 = rt2;
+            m_hook1 = landRoot;
         }
@@ -53,7 +43,4 @@ namespace AWGL.Scene
         {
-            root = new AWGroupNode();
-            rt1 = new AWGroupNode();
-            rt2 = new AWGroupNode();
-            rt = new AWGroupNode();
-            rtt = new AWGroupNode();
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
 
@@ -61,3 +48,2 @@ namespace AWGL.Scene
             cube = new AWCube();
-            particles = new AWParticles(); ;
         }
@@ -82,5 +68,2 @@ namespace AWGL.Scene
 
-            Title = "AWGL: High level OpenTK wrapper - " + particles.m_VisibleParticleCount + " Points. FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-
             m_spinangle += m_rotationspeed * (float)e.Time;
@@ -94,3 +77,2 @@ namespace AWGL.Scene
             m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-            m_hook2.SetRotation(-m_spinangle, 0, 0, 1);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/97ea4889745a892b7f511183a84661b181ce629f">Basic camera implementation from Neo Kabuto's blog: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html</a>  -  97ea488</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 3 files changed, 113 insertions(+), 33 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
new file mode 100644
index 0000000..71a2527
--- /dev/null
+++ b/AWGL/AWCamera.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWCamera
+    {
+        public Vector3 Position = Vector3.Zero;
+        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public float MoveSpeed = 0.2f;
+        public float MouseSensitivity = 0.01f;
+
+        public Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+        }
+
+        public void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index fd1d068..1c124e3 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -5,2 +5,3 @@ using OpenTK.Input;
 using System;
+using System.Drawing;
 
@@ -17,3 +18,2 @@ namespace AWGL.Scene
             //this.WindowState = WindowState.Fullscreen;
-            Keyboard.KeyDown += Keyboard_KeyDown;
         }
@@ -23,5 +23,3 @@ namespace AWGL.Scene
         #region Camera
-        protected float m_eyeX = .0f;
-        protected float m_eyeY = 10.0f;
-        protected float m_eyeZ = 10.0f;
+        protected AWCamera camera;
         #endregion
@@ -48,2 +46,3 @@ namespace AWGL.Scene
 
+            camera = new AWCamera();
             Setup(e);
@@ -66,2 +65,26 @@ namespace AWGL.Scene
 
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+ 	         base.OnUpdateFrame(e);
+
+             if (Focused)
+             {
+                 Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                 Point delta = new Point(center.X - OpenTK.Input.Mouse.GetState().X, center.Y - OpenTK.Input.Mouse.GetState().Y);
+
+                 camera.AddRotation(delta.X, delta.Y);
+                 ResetCursor();
+             }
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
         public abstract void Setup(EventArgs e);
@@ -93,39 +116,38 @@ namespace AWGL.Scene
         #region Input
-        /// <summary>
-        /// Occurs when a key is pressed.
-        /// </summary>
-        /// <param name="sender">The KeyboardDevice which generated this event.</param>
-        /// <param name="e">The key that was pressed.</param>
-        protected void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        protected override void OnKeyPress(KeyPressEventArgs e)
         {
+            base.OnKeyPress(e);
 
-            switch (e.Key)
+            if (e.KeyChar == 27)
             {
-                #region Window Controls
+                Exit();
+            }
 
-                case Key.Escape: this.Exit();
+            switch (e.KeyChar)
+            {
+                case 'w':
+                    camera.Move(0f, 0.1f, 0f);
                     break;
-                case Key.F11:
-                    if (this.WindowState == WindowState.Fullscreen)
-                        this.WindowState = WindowState.Normal;
-                    else
-                        this.WindowState = WindowState.Fullscreen;
+                case 'a':
+                    camera.Move(-0.1f, 0f, 0f);
                     break;
-
-                #endregion
-
-                #region Camera Controls
-
-                case Key.Up: m_eyeY += 2f;
+                case 's':
+                    camera.Move(0f, -0.1f, 0f);
                     break;
-                case Key.Down: m_eyeY += -2f;
+                case 'd':
+                    camera.Move(0.1f, 0f, 0f);
                     break;
-                case Key.Right: m_eyeX += 2f;
+                case 'q':
+                    camera.Move(0f, 0f, 0.1f);
                     break;
-                case Key.Left: m_eyeX += -2f;
+                case 'e':
+                    camera.Move(0f, 0f, -0.1f);
                     break;
-
-                #endregion
-
-            }   
+                case 'f':
+                    if (this.WindowState == WindowState.Fullscreen)
+                        this.WindowState = WindowState.Normal;
+                    else
+                        this.WindowState = WindowState.Fullscreen;
+                    break;
+            }
         }
@@ -133,2 +155,6 @@ namespace AWGL.Scene
 
+        void ResetCursor()
+        {
+            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
     }
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
index 61c4dd4..009b774 100644
--- a/AWGL/Scene/SceneGraphTest.cs
+++ b/AWGL/Scene/SceneGraphTest.cs
@@ -59,3 +59,3 @@ namespace AWGL.Scene
             float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            Matrix4 perpective = camera.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
             GL.MatrixMode(MatrixMode.Projection);
@@ -72,3 +72,3 @@ namespace AWGL.Scene
 
-            Matrix4 lookat = Matrix4.LookAt(m_eyeX, m_eyeY, m_eyeZ, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = camera.GetViewMatrix();
             GL.MatrixMode(MatrixMode.Modelview);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8a31553ad76be1cb435dec29005567efa60edaa0">fixed camera issues using System.Windows.Forms.Cursor</a>  -  8a31553</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 3 insertions(+), 11 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 1c124e3..47638c6 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -17,3 +17,3 @@ namespace AWGL.Scene
         {
-            //this.WindowState = WindowState.Fullscreen;
+            this.WindowState = WindowState.Fullscreen;
         }
@@ -22,5 +22,3 @@ namespace AWGL.Scene
 
-        #region Camera
         protected AWCamera camera;
-        #endregion
 
@@ -72,3 +70,3 @@ namespace AWGL.Scene
                  Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                 Point delta = new Point(center.X - OpenTK.Input.Mouse.GetState().X, center.Y - OpenTK.Input.Mouse.GetState().Y);
+                 Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
@@ -145,8 +143,2 @@ namespace AWGL.Scene
                     break;
-                case 'f':
-                    if (this.WindowState == WindowState.Fullscreen)
-                        this.WindowState = WindowState.Normal;
-                    else
-                        this.WindowState = WindowState.Fullscreen;
-                    break;
             }
@@ -157,3 +149,3 @@ namespace AWGL.Scene
         {
-            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ac1f10c6e04072030182c337f4d98678d12dffbe">added keylist to handle multiple key presses simultaneously</a>  -  ac1f10c</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 66 insertions(+), 36 deletions(-)

diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
index 47638c6..f06d9b6 100644
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ b/AWGL/Scene/Base/DefaultScene.cs
@@ -5,2 +5,3 @@ using OpenTK.Input;
 using System;
+using System.Collections.Generic;
 using System.Drawing;
@@ -17,3 +18,3 @@ namespace AWGL.Scene
         {
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
         }
@@ -23,2 +24,3 @@ namespace AWGL.Scene
         protected AWCamera camera;
+        private List<Key> keyList;
 
@@ -45,2 +47,5 @@ namespace AWGL.Scene
             camera = new AWCamera();
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
             Setup(e);
@@ -49,2 +54,59 @@ namespace AWGL.Scene
 
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
         #region OnResize
@@ -66,5 +128,7 @@ namespace AWGL.Scene
  	         base.OnUpdateFrame(e);
-
+             
              if (Focused)
              {
+                 MoveCamera();
+
                  Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
@@ -113,36 +177,2 @@ namespace AWGL.Scene
 
-        #region Input
-        protected override void OnKeyPress(KeyPressEventArgs e)
-        {
-            base.OnKeyPress(e);
-
-            if (e.KeyChar == 27)
-            {
-                Exit();
-            }
-
-            switch (e.KeyChar)
-            {
-                case 'w':
-                    camera.Move(0f, 0.1f, 0f);
-                    break;
-                case 'a':
-                    camera.Move(-0.1f, 0f, 0f);
-                    break;
-                case 's':
-                    camera.Move(0f, -0.1f, 0f);
-                    break;
-                case 'd':
-                    camera.Move(0.1f, 0f, 0f);
-                    break;
-                case 'q':
-                    camera.Move(0f, 0f, 0.1f);
-                    break;
-                case 'e':
-                    camera.Move(0f, 0f, -0.1f);
-                    break;
-            }
-        }
-        #endregion
-
         void ResetCursor()

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/48fd39c656af080a22bca7f4ae5bb665811434b2">~</a>  -  48fd39c</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 19 files changed, 25 insertions(+), 1264 deletions(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
deleted file mode 100644
index d6c112a..0000000
--- a/AWGL/AWCube.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWCube : AWNode
-    {
-        #region Private Members
-        private Cube Cube;
-
-        private Vbo vbo;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public AWCube()
-        {
-            vbo = new Vbo();
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Render()
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-            
-            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/AWGraphLines.cs b/AWGL/AWGraphLines.cs
deleted file mode 100644
index 7f280ce..0000000
--- a/AWGL/AWGraphLines.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWGraphLines : AWNode
-    {
-        private int m_gridSize = 20;
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/AWGroupNode.cs b/AWGL/AWGroupNode.cs
deleted file mode 100644
index 0e656cc..0000000
--- a/AWGL/AWGroupNode.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-    } 
-}
diff --git a/AWGL/AWMesh.cs b/AWGL/AWMesh.cs
deleted file mode 100644
index bd58995..0000000
--- a/AWGL/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWNode.cs b/AWGL/AWNode.cs
deleted file mode 100644
index 39bef32..0000000
--- a/AWGL/AWNode.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class AWNode : ISceneNode
-    {
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/AWParticles.cs b/AWGL/AWParticles.cs
deleted file mode 100644
index 2b2f7c6..0000000
--- a/AWGL/AWParticles.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWParticles : AWNode
-    {
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
diff --git a/AWGL/AWPolygon.cs b/AWGL/AWPolygon.cs
deleted file mode 100644
index eb2ca03..0000000
--- a/AWGL/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 1d47a04..9489bce 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -158,3 +158,24 @@ namespace AWGL
         }
-    
+
+        #region TestOpenGLVersion
+        /// <summary>
+        /// Get OpenGL Version Information and check system meets requirements
+        /// </summary>
+        public static void TestOpenGLVersion()
+        {
+            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
+            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetHigh = new Version(4, 1);
+            if (m_Version < m_TargetLow)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
+            }
+            else if (m_Version > m_TargetHigh)
+            {
+                throw new NotSupportedException(String.Format(
+                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
+            }
+        }
+        #endregion
     
diff --git a/AWGL/IGroupNode.cs b/AWGL/IGroupNode.cs
deleted file mode 100644
index 5ac83e3..0000000
--- a/AWGL/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/ISceneNode.cs b/AWGL/ISceneNode.cs
deleted file mode 100644
index 6f6da08..0000000
--- a/AWGL/ISceneNode.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 3802f15..9fb38cb 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -1,2 +1,3 @@
 ﻿using AWGL.Scene;
+using OpenTK;
 using System;
@@ -19,6 +20,2 @@ namespace AWGL
 
-        public static void SetupScene(Color backgroundColor)
-        {
-        }
-
         [STAThread]
@@ -26,53 +23,5 @@ namespace AWGL
         {
-            Int32 Selection;
-            
-            Console.WriteLine("Please select a scene to load:\n");
-
-            Console.WriteLine("1. Dynamic VBO");
-            Console.WriteLine("2. Texture 2D");
-            Console.WriteLine("3. Anaylgraph Stereo");
-            Console.WriteLine("4. FBO");
-            Console.WriteLine("5. Picker");
-            Console.WriteLine("6. Stencil CSG");
-            Console.WriteLine("7. Scene Graph Test\n");
-            Int32.TryParse(Console.ReadLine(), out Selection);
-
-            switch (Selection)
+            using (DefaultScene game = new DefaultScene())
             {
-                case 2:
-                    using (Texture2DScene scene = new Texture2DScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 3:
-                    using (StereoVisionScene scene = new StereoVisionScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 4:
-                    using (FBOScene scene = new FBOScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 5:
-                    using (PickerScene scene = new PickerScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 6:
-                    using (StencilCSGScene scene = new StencilCSGScene())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
-                case 7:
-                    using (SceneGraphTest scene = new SceneGraphTest())
-                    {
-                        scene.Run(30.0);
-                    }
-                    break;
+                game.Run(30,0);
             }
diff --git a/AWGL/Scene/Base/DefaultScene.cs b/AWGL/Scene/Base/DefaultScene.cs
deleted file mode 100644
index f06d9b6..0000000
--- a/AWGL/Scene/Base/DefaultScene.cs
+++ /dev/null
@@ -1,183 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public abstract class DefaultScene : GameWindow
-    {
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            //this.WindowState = WindowState.Fullscreen;
-        }
-
-        private Color4 m_backgroundColor = new Color4(.1f, 0f, .1f, 0f);
-
-        protected AWCamera camera;
-        private List<Key> keyList;
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            TestOpenGLVersion();
-
-            Title = "AWGL: High level OpenTK wrapper - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-
-            GL.ClearColor(Color4.Gray);
-
-            camera = new AWCamera();
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-            Setup(e);
-        }
-        #endregion
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
-                }
-            }
-        }
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-            Resize(e);
-        }
-
-        #endregion
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
- 	         base.OnUpdateFrame(e);
-             
-             if (Focused)
-             {
-                 MoveCamera();
-
-                 Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                 Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                 camera.AddRotation(delta.X, delta.Y);
-                 ResetCursor();
-             }
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        public abstract void Setup(EventArgs e);
-
-        new public abstract void Resize(EventArgs e);
-
-        #region TestOpenGLVersion
-        /// <summary>
-        /// Get OpenGL Version Information and check system meets requirements
-        /// </summary>
-        private void TestOpenGLVersion()
-        {
-            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 1);
-            Version m_TargetHigh = new Version(4, 1);
-            if (m_Version < m_TargetLow)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
-            }
-            else if (m_Version > m_TargetHigh)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
-            }
-        }
-        #endregion
-
-        void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Scene/SceneGraphTest.cs b/AWGL/Scene/SceneGraphTest.cs
deleted file mode 100644
index 009b774..0000000
--- a/AWGL/Scene/SceneGraphTest.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL.Scene
-{
-    class SceneGraphTest : DefaultScene
-    {
-        #region SceneGraph
-        private AWNode m_sceneGraph;
-
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-
-        private AWCube cube;
-
-        private AWGroupNode m_hook1;
-        #endregion
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle;
-
-        public void CreateSceneGraph()
-        {
-            InitialiseNodes();
-
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, 0, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-        }
-
-        private void InitialiseNodes()
-        {
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            CreateSceneGraph();
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = camera.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-    }
-}
diff --git a/WinFormTest/GameLoopForm.Designer.cs b/WinFormTest/GameLoopForm.Designer.cs
deleted file mode 100644
index bd47093..0000000
--- a/WinFormTest/GameLoopForm.Designer.cs
+++ /dev/null
@@ -1,61 +0,0 @@
-﻿namespace WinFormTest
-{
-    partial class GameLoopForm
-    {
-        /// <summary>
-        /// Required designer variable.
-        /// </summary>
-        private System.ComponentModel.IContainer components = null;
-
-        /// <summary>
-        /// Clean up any resources being used.
-        /// </summary>
-        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing && (components != null))
-            {
-                components.Dispose();
-            }
-            base.Dispose(disposing);
-        }
-
-        #region Windows Form Designer generated code
-
-        /// <summary>
-        /// Required method for Designer support - do not modify
-        /// the contents of this method with the code editor.
-        /// </summary>
-        private void InitializeComponent()
-        {
-            this.glControl = new OpenTK.GLControl();
-            this.SuspendLayout();
-            // 
-            // glControl
-            // 
-            this.glControl.BackColor = System.Drawing.Color.Black;
-            this.glControl.Dock = System.Windows.Forms.DockStyle.Top;
-            this.glControl.Location = new System.Drawing.Point(0, 0);
-            this.glControl.Name = "glControl";
-            this.glControl.Size = new System.Drawing.Size(717, 403);
-            this.glControl.TabIndex = 0;
-            this.glControl.VSync = false;
-            // 
-            // GameLoopForm
-            // 
-            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
-            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
-            this.ClientSize = new System.Drawing.Size(717, 477);
-            this.Controls.Add(this.glControl);
-            this.Name = "GameLoopForm";
-            this.Text = "Form1";
-            this.ResumeLayout(false);
-
-        }
-
-        #endregion
-
-        private OpenTK.GLControl glControl;
-    }
-}
-
diff --git a/WinFormTest/GameLoopForm.cs b/WinFormTest/GameLoopForm.cs
deleted file mode 100644
index 7a857d2..0000000
--- a/WinFormTest/GameLoopForm.cs
+++ /dev/null
@@ -1,309 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Data;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Windows.Forms;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using AWGL;
-using AWGL.Shapes;
-
-namespace WinFormTest
-{
-    public partial class GameLoopForm : Form
-    {
-        static float angle = 0.0f;
-        private int programObject;
-
-        private int vertex_buffer_object, color_buffer_object, element_buffer_object;
-        Shape shape = new Cube();
-
-        #region --- Constructor ---
-
-        public GameLoopForm()
-        {
-            InitializeComponent();
-        }
-        
-        #endregion
-
-        #region OnLoad
-
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            glControl.KeyDown += new KeyEventHandler(glControl_KeyDown);
-            glControl.KeyUp += new KeyEventHandler(glControl_KeyUp);
-            glControl.Resize += new EventHandler(glControl_Resize);
-            glControl.Paint += new PaintEventHandler(glControl_Paint);
-
-            Text =
-                GL.GetString(StringName.Vendor) + " " +
-                GL.GetString(StringName.Renderer) + " " +
-                GL.GetString(StringName.Version);
-
-            GL.ClearColor(Color.MidnightBlue);
-            GL.Enable(EnableCap.DepthTest);
-
-            CreateVBO();
-
-            // create and compile shader objects
-            int vertexShader = AWUtils.BuildShader("Simple_VS.glsl", ShaderType.VertexShader);
-            int fragmentShader = AWUtils.BuildShader("Simple_FS.glsl", ShaderType.FragmentShader);
-
-            // attach and link to main program then use
-            programObject = AWUtils.BuildProgram(vertexShader, fragmentShader);
-            GL.UseProgram(programObject);
-
-            // clean up
-            GL.DeleteShader(vertexShader);
-            GL.DeleteShader(fragmentShader);
-            
-            Application.Idle += Application_Idle;
-
-            // Ensure that the viewport and projection matrix are set correctly.
-            glControl_Resize(glControl, EventArgs.Empty);
-        }
-
-        void glControl_KeyUp(object sender, KeyEventArgs e)
-        {
-            if (e.KeyCode == Keys.F12)
-            {
-                GrabScreenshot().Save("screenshot.png");
-            }
-        }
-
-        #endregion
-
-        #region private void CreateVBO()
-
-        void CreateVBO()
-        {
-            int size;
-
-            GL.GenBuffers(1, out vertex_buffer_object);
-            GL.GenBuffers(1, out color_buffer_object);
-            GL.GenBuffers(1, out element_buffer_object);
-
-            // Upload the vertex buffer.
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Vertices.Length * 3 * sizeof(float)), shape.Vertices,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Vertices.Length * 3 * sizeof(Single))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Vertices.Length * 3 * sizeof(Single), size));
-
-            // Upload the color buffer.
-            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(shape.Colors.Length * sizeof(int)), shape.Colors,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Colors.Length * sizeof(int))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (colors). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Colors.Length * sizeof(int), size));
-
-            // Upload the index buffer (elements inside the vertex buffer, not color indices as per the IndexPointer function!)
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(shape.Indices.Length * sizeof(Int32)), shape.Indices,
-                BufferUsageHint.StaticDraw);
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out size);
-            if (size != shape.Indices.Length * sizeof(int))
-                throw new ApplicationException(String.Format(
-                    "Problem uploading vertex buffer to VBO (offsets). Tried to upload {0} bytes, uploaded {1}.",
-                    shape.Indices.Length * sizeof(int), size));
-        }
-
-        #endregion
-
-        #region OnClosing
-
-        protected override void OnClosing(CancelEventArgs e)
-        {
-            if (programObject != 0)
-                GL.DeleteProgram(programObject);
-            if (vboHandle.VboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.VboID);
-            if (vboHandle.CboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.CboID);
-            if (vboHandle.EboID != 0)
-                GL.DeleteBuffers(1, ref vboHandle.EboID);
-            Application.Idle -= Application_Idle;
-
-            base.OnClosing(e);
-        }
-
-        #endregion
-
-        #region Application_Idle event
-
-        void Application_Idle(object sender, EventArgs e)
-        {
-            while (glControl.IsIdle)
-            {
-                Render();
-            }
-        }
-
-        #endregion
-
-        #region GLControl.Resize event handler
-
-        void glControl_Resize(object sender, EventArgs e)
-        {
-            OpenTK.GLControl c = sender as OpenTK.GLControl;
-
-            if (c.ClientSize.Height == 0)
-                c.ClientSize = new System.Drawing.Size(c.ClientSize.Width, 1);
-
-            GL.Viewport(0, 0, c.ClientSize.Width, c.ClientSize.Height);
-
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-
-        #endregion
-
-        #region GLControl.KeyDown event handler
-
-        void glControl_KeyDown(object sender, KeyEventArgs e)
-        {
-            switch (e.KeyData)
-            {
-                case Keys.Escape:
-                    this.Close();
-                    break;
-            }
-        }
-
-        #endregion
-
-        #region GLControl.Paint event handler
-
-        void glControl_Paint(object sender, PaintEventArgs e)
-        {
-            Render();
-        }
-
-        #endregion
-
-        #region private void Render()
-
-        private Vbo vboHandle = new Vbo();
-        private float rotation_speed = 3.0f;
-
-
-        private void Render()
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit |
-         ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            //angle += rotation_speed * (float)Time;
-            GL.Rotate(angle, 0.0f, 1.0f, 0.0f);
-
-            GL.EnableClientState(ArrayCap.VertexArray);
-            GL.EnableClientState(ArrayCap.ColorArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vertex_buffer_object);
-            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, color_buffer_object);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, element_buffer_object);
-
-            GL.DrawElements(BeginMode.Triangles, shape.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
-
-            //GL.DrawArrays(GL.Enums.BeginMode.POINTS, 0, shape.Vertices.Length);
-
-            GL.DisableClientState(ArrayCap.VertexArray);
-            GL.DisableClientState(ArrayCap.ColorArray);
-
-
-            //int error = GL.GetError();
-            //if (error != 0)
-            //    Debug.Print(Glu.ErrorString(Glu.Enums.ErrorCode.INVALID_OPERATION));
-
-            glControl.SwapBuffers();
-        }
-
-        #endregion
-
-        #region private void DrawCube()
-
-        private void DrawCube()
-        {
-            GL.Begin(BeginMode.Quads);
-
-            GL.Color3(Color.Silver);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-
-            GL.Color3(Color.Honeydew);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-
-            GL.Color3(Color.Moccasin);
-
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.IndianRed);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-
-            GL.Color3(Color.PaleVioletRed);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.ForestGreen);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-
-            GL.End();
-        }
-
-        #endregion
-
-        #region private void GrabScreenshot()
-
-        Bitmap GrabScreenshot()
-        {
-            Bitmap bmp = new Bitmap(this.ClientSize.Width, this.ClientSize.Height);
-            System.Drawing.Imaging.BitmapData data =
-            bmp.LockBits(this.ClientRectangle, System.Drawing.Imaging.ImageLockMode.WriteOnly,
-                System.Drawing.Imaging.PixelFormat.Format24bppRgb);
-            GL.ReadPixels(0, 0, this.ClientSize.Width, this.ClientSize.Height, PixelFormat.Bgr, PixelType.UnsignedByte,
-                data.Scan0);
-            bmp.UnlockBits(data);
-            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);
-            return bmp;
-        }
-
-        #endregion
-    }
-}
diff --git a/WinFormTest/Program.cs b/WinFormTest/Program.cs
deleted file mode 100644
index b301879..0000000
--- a/WinFormTest/Program.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Threading.Tasks;
-using System.Windows.Forms;
-
-namespace WinFormTest
-{
-    static class Program
-    {
-        /// <summary>
-        /// The main entry point for the application.
-        /// </summary>
-        [STAThread]
-        static void Main()
-        {
-            Application.EnableVisualStyles();
-            Application.SetCompatibleTextRenderingDefault(false);
-            Application.Run(new GameLoopForm());
-        }
-    }
-}
deleted file mode 100644
index f2a9af5..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("WinFormTest")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("WinFormTest")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("59ce37cf-9660-4196-991a-0a3039839f38")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
deleted file mode 100644
index 8f82795..0000000
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-//     Runtime Version:4.0.30319.18052
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace WinFormTest.Properties
-{
-
-
-    /// <summary>
-    ///   A strongly-typed resource class, for looking up localized strings, etc.
-    /// </summary>
-    // This class was auto-generated by the StronglyTypedResourceBuilder
-    // class via a tool like ResGen or Visual Studio.
-    // To add or remove a member, edit your .ResX file then rerun ResGen
-    // with the /str option, or rebuild your VS project.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
-    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    internal class Resources
-    {
-
-        private static global::System.Resources.ResourceManager resourceMan;
-
-        private static global::System.Globalization.CultureInfo resourceCulture;
-
-        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
-        internal Resources()
-        {
-        }
-
-        /// <summary>
-        ///   Returns the cached ResourceManager instance used by this class.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Resources.ResourceManager ResourceManager
-        {
-            get
-            {
-                if ((resourceMan == null))
-                {
-                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("WinFormTest.Properties.Resources", typeof(Resources).Assembly);
-                    resourceMan = temp;
-                }
-                return resourceMan;
-            }
-        }
-
-        /// <summary>
-        ///   Overrides the current thread's CurrentUICulture property for all
-        ///   resource lookups using this strongly typed resource class.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Globalization.CultureInfo Culture
-        {
-            get
-            {
-                return resourceCulture;
-            }
-            set
-            {
-                resourceCulture = value;
-            }
-        }
-    }
-}
deleted file mode 100644
index 0394d77..0000000
+++ /dev/null
@@ -1,30 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-//     Runtime Version:4.0.30319.18052
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace WinFormTest.Properties
-{
-
-
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
-    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
-    {
-
-        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
-
-        public static Settings Default
-        {
-            get
-            {
-                return defaultInstance;
-            }
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0720e6a0468cd39fe03106c2e994c5051dbce810">Backing Up old source for reference.</a>  -  0720e6a</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 10 files changed, 660 insertions(+)

diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
new file mode 100644
index 0000000..d6c112a
--- /dev/null
+++ b/AWGL/Scene/AWCube.cs
@@ -0,0 +1,71 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        private Cube Cube;
+
+        private Vbo vbo;
+
+        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
+        {
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+        };
+
+        private readonly short[] CubeElements = new short[]
+        {
+            0, 1, 2, 2, 3, 0, // front face
+            3, 2, 6, 6, 7, 3, // top face
+            7, 6, 5, 5, 4, 7, // back face
+            4, 0, 3, 3, 7, 4, // left face
+            0, 1, 5, 5, 4, 0, // bottom face
+            1, 5, 6, 6, 2, 1, // right face
+        };
+        #endregion
+
+        public AWCube()
+        {
+            vbo = new Vbo();
+            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+        }
+
+        public override void Render()
+        {
+            // To draw a VBO:
+            // 1) Ensure that the VertexArray client state is enabled.
+            // 2) Bind the vertex and element buffer handles.
+            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
+            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
+            //    and will usually be IntPtr.Zero).
+
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
+
+            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
+            
+            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
+        }
+    }
+}
diff --git a/AWGL/Scene/AWGraphLines.cs b/AWGL/Scene/AWGraphLines.cs
new file mode 100644
index 0000000..7f280ce
--- /dev/null
+++ b/AWGL/Scene/AWGraphLines.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWGraphLines : AWNode
+    {
+        private int m_gridSize = 20;
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/Scene/AWGroupNode.cs b/AWGL/Scene/AWGroupNode.cs
new file mode 100644
index 0000000..0e656cc
--- /dev/null
+++ b/AWGL/Scene/AWGroupNode.cs
@@ -0,0 +1,89 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+    } 
+}
diff --git a/AWGL/Scene/AWMesh.cs b/AWGL/Scene/AWMesh.cs
new file mode 100644
index 0000000..bd58995
--- /dev/null
+++ b/AWGL/Scene/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
new file mode 100644
index 0000000..39bef32
--- /dev/null
+++ b/AWGL/Scene/AWNode.cs
@@ -0,0 +1,14 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public abstract class AWNode : ISceneNode
+    {
+        public abstract void Render();
+    }
+
+}
diff --git a/AWGL/Scene/AWParticles.cs b/AWGL/Scene/AWParticles.cs
new file mode 100644
index 0000000..2b2f7c6
--- /dev/null
+++ b/AWGL/Scene/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Scene/AWPolygon.cs b/AWGL/Scene/AWPolygon.cs
new file mode 100644
index 0000000..eb2ca03
--- /dev/null
+++ b/AWGL/Scene/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/Scene/DefaultScene.cs b/AWGL/Scene/DefaultScene.cs
new file mode 100644
index 0000000..e7d2e4d
--- /dev/null
+++ b/AWGL/Scene/DefaultScene.cs
@@ -0,0 +1,247 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class DefaultScene : GameWindow
+    {
+        #region Constructor
+        
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            //set context
+            this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.0f;
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            AWUtils.TestOpenGLVersion();
+
+            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/IGroupNode.cs b/AWGL/Scene/IGroupNode.cs
new file mode 100644
index 0000000..5ac83e3
--- /dev/null
+++ b/AWGL/Scene/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/ISceneNode.cs b/AWGL/Scene/ISceneNode.cs
new file mode 100644
index 0000000..6f6da08
--- /dev/null
+++ b/AWGL/Scene/ISceneNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d7a760d683e1751305aa7188edc800e4466e5dba">Removing more old junk code.</a>  -  d7a760d</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
index d6c112a..6635235 100644
--- a/AWGL/Scene/AWCube.cs
+++ b/AWGL/Scene/AWCube.cs
@@ -22,10 +22,10 @@ namespace AWGL
         {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.DarkRed),
+                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.Khaki),
                 new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Gold),
+                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Black),
+                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Black),
                 new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.DarkRed), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Gold),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Gold) 
+                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.Khaki), 
+                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Black),
+                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Black) 
         };

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0ac588a59098aee3397319293f3609b7754c2ec6">Minor refactoring.</a>  -  0ac588a</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 3 files changed, 258 insertions(+), 249 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index dcf64ca..cbbbeaa 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -104,5 +104,6 @@ namespace AWGL
         /// <returns></returns>
-        public int getShaderProgram() 
+        public int programID() 
         {
-            BuildProgram();
+            if(linkedProgram == null)
+                BuildProgram();
 
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
new file mode 100644
index 0000000..32f76fc
--- /dev/null
+++ b/AWGL/DefaultScene.cs
@@ -0,0 +1,255 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class DefaultScene : GameWindow
+    {
+        #region Constructor
+        
+        public DefaultScene()
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+        {
+            //set context
+            this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+
+            shaderManager = new AWShaderManager();
+            GL.UseProgram(shaderManager.programID());
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private AWShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            AWUtils.TestOpenGLVersion();
+
+            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Scene/DefaultScene.cs b/AWGL/Scene/DefaultScene.cs
deleted file mode 100644
index e7d2e4d..0000000
--- a/AWGL/Scene/DefaultScene.cs
+++ /dev/null
@@ -1,247 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class DefaultScene : GameWindow
-    {
-        #region Constructor
-        
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
-        {
-            //set context
-            this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new AWCamera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.0f;
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected AWCamera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            AWUtils.TestOpenGLVersion();
-
-            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ed3837b166071d3d1bc02e9a23f5b376166226d4">Move player view up Y axis OnLoad.</a>  -  ed3837b</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 32f76fc..dba482a 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -52,2 +52,3 @@ namespace AWGL.Scene
             cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eb79d20616b11591ac04535b622c8ea810b25e74">Add Contructor to ShaderManager to specify different Vertex and Fragment shader files.</a>  -  eb79d20</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index cbbbeaa..2d448f6 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -21,2 +21,15 @@ namespace AWGL
         private string defaultDataPath = "Data/Shaders/";
+        private string m_vsFilePath, m_fsFilePath;
+
+        public AWShaderManager(string vs_path, string fs_path)
+        {
+            this.m_vsFilePath = vs_path;
+            this.m_fsFilePath = fs_path;
+        }
+
+        public AWShaderManager()
+        {
+            this.m_vsFilePath   = "Simple_VS";
+            this.m_fsFilePath   = "Simple_FS";
+        }
 
@@ -70,4 +83,4 @@ namespace AWGL
         {
-            this.vShader = BuildShader("Simple_VS", ShaderType.VertexShader);
-            this.fShader = BuildShader("Simple_FS", ShaderType.FragmentShader);
+            this.vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
+            this.fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f7e325982686f76e72d512b5f9d374de88887727">Simple Colour Animation</a>  -  f7e3259</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 52 insertions(+)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
new file mode 100644
index 0000000..719bdf9
--- /dev/null
+++ b/AWGL/ShaderTutorials.cs
@@ -0,0 +1,52 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL4;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class ShaderTutorials : GameWindow
+    {
+        static Timer timer;
+        static double elapsedSeconds;
+
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            Title = AWUtils.PrintOpenGLInfo();
+            elapsedSeconds = 0;
+
+            timer = new Timer(1000);
+            timer.Elapsed += new ElapsedEventHandler(OnTimerElapsed);
+            timer.Enabled = true;
+        }
+
+        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
+        {
+            elapsedSeconds++;
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            float[] color = new float[] 
+            { 
+                (float)(Math.Sin(elapsedSeconds) * 0.5f + 0.5f), 
+                (float)(Math.Cos(elapsedSeconds) * 0.5f + 0.5f),
+                0.0f, 
+                1.0f 
+            };
+
+            GL.ClearBuffer(ClearBuffer.Color, 0, color);
+
+            SwapBuffers();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/559e08b87df4f8c4fd5ff19931c1fad3c6a3a454">Add initial chapter2 shader.</a>  -  559e08b</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 6 insertions(+)

diff --git a/AWGL/Data/Shaders/CH01_VS.glsl b/AWGL/Data/Shaders/CH01_VS.glsl
new file mode 100644
index 0000000..90a7a31
--- /dev/null
+++ b/AWGL/Data/Shaders/CH01_VS.glsl
@@ -0,0 +1,6 @@
+﻿#version 410 core
+
+void main(void)
+{
+	gl_Position = vec4(0.0, 0.0, 0.5, 1.0);
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2e05f815e3bc4d2e480e520ce0799810f8699d21">Corrected check for ProgramID failing.</a>  -  2e05f81</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 2d448f6..b5ea776 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -119,3 +119,3 @@ namespace AWGL
         {
-            if(linkedProgram == null)
+            if(linkedProgram == 0)
                 BuildProgram();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e39ac8c3e65cedefb86a3fcfcfa079fd3d379ece">Moved Printing of OpenGL info to utility class.</a>  -  e39ac8c</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 9489bce..78a6d70 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -180,2 +180,16 @@ namespace AWGL
         #endregion
+
+        public static string PrintOpenGLInfo()
+        {
+            Console.WriteLine("");
+            Console.WriteLine("Video informations :");
+            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
+            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
+            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
+            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            
+            TestOpenGLVersion();
+
+            return "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+        }
     
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index dba482a..5be1708 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -90,11 +90,3 @@ namespace AWGL.Scene
 
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
-            AWUtils.TestOpenGLVersion();
-
-            Title = "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            Title = AWUtils.PrintOpenGLInfo();
 
@@ -104,2 +96,3 @@ namespace AWGL.Scene
         }
+
         #endregion

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6f398574b1bcc04fc2ff67e1d9903adba5c6364f">Added ShaderTutorial as default launch.</a>  -  6f39857</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 9fb38cb..773fa24 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -23,3 +23,3 @@ namespace AWGL
         {
-            using (DefaultScene game = new DefaultScene())
+            using (ShaderTutorials game = new ShaderTutorials())
             {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b96c4e17b5ad753a75acb051785e588ea99d1046">Set explicit profiles. Added sb6 shaders.</a>  -  b96c4e1</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 8 files changed, 97 insertions(+), 44 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b5ea776..00deea2 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL;
+using OpenTK.Graphics.OpenGL4;
 
@@ -27,2 +27,3 @@ namespace AWGL
             this.m_fsFilePath = fs_path;
+            BuildProgram();
         }
@@ -93,3 +94,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(this.linkedProgram, ProgramParameter.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(this.linkedProgram, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -104,3 +105,3 @@ namespace AWGL
             GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, ProgramParameter.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.GetProgram(this.linkedProgram, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -111,19 +112,19 @@ namespace AWGL
             }
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(vShader);
+            GL.DeleteShader(fShader);
         }
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <returns></returns>
-        public int programID() 
+        public void Dispose()
         {
-            if(linkedProgram == 0)
-                BuildProgram();
-
-            return linkedProgram;
+            GL.DeleteProgram(this.linkedProgram);
         }
 
-        public void Dispose()
+        public int ProgramID
         {
-            throw new NotImplementedException();
+            get
+            {
+                return this.linkedProgram;
+            }
         }
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 78a6d70..9b8c7df 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -77,3 +77,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(programHandle, ProgramParameter.LinkStatus, out linkSuccess);
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess);
             if (linkSuccess == 0)
@@ -88,3 +88,3 @@ namespace AWGL
             GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, ProgramParameter.ValidateStatus, out validateSuccess);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess);
             if (validateSuccess == 0)
@@ -194,3 +194,3 @@ namespace AWGL
         }
-    
+
     }
diff --git a/AWGL/Data/Shaders/CH01_VS.glsl b/AWGL/Data/Shaders/CH01_VS.glsl
deleted file mode 100644
index 90a7a31..0000000
--- a/AWGL/Data/Shaders/CH01_VS.glsl
+++ /dev/null
@@ -1,6 +0,0 @@
-﻿#version 410 core
-
-void main(void)
-{
-	gl_Position = vec4(0.0, 0.0, 0.5, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
new file mode 100644
index 0000000..410ba8d
--- /dev/null
+++ b/AWGL/Data/Shaders/CH02_FS.glsl
@@ -0,0 +1,8 @@
+#version 330 core
+
+out vec4 color;
+
+void main(void)
+{
+	color = vec4(0.0, 0.8, 0.0, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
new file mode 100644
index 0000000..4513442
--- /dev/null
+++ b/AWGL/Data/Shaders/CH02_VS.glsl
@@ -0,0 +1,12 @@
+﻿#version 330 core
+
+void main(void)
+{
+	const vec4 vertices[3] = vec4[3](
+		vec4(0.25, -0.25, 0.5, 1.0),
+		vec4(-0.25, 0.25, 0.5, 1.0),
+		vec4(0.25, 0.25, 0.5, 1.0)
+		);
+	// Index into our array using gl_VertexID
+	gl_Position = vertices[gl_VertexID];
+}
\ No newline at end of file
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 5be1708..27a08e1 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -17,8 +17,9 @@ namespace AWGL.Scene
         #region Constructor
-        
-        public DefaultScene()
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4))
+
+        public DefaultScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
         {
             //set context
-            this.WindowState = WindowState.Fullscreen;
+            //this.WindowState = WindowState.Fullscreen;
             m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
@@ -54,4 +55,4 @@ namespace AWGL.Scene
 
-            shaderManager = new AWShaderManager();
-            GL.UseProgram(shaderManager.programID());
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
         }
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
index 773fa24..c5cb1b2 100644
--- a/AWGL/OGL.cs
+++ b/AWGL/OGL.cs
@@ -21,3 +21,3 @@ namespace AWGL
         [STAThread]
-        public static void Run()
+        public static void Main()
         {
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 719bdf9..417ec4e 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -2,3 +2,3 @@
 using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL4;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -15,3 +15,12 @@ namespace AWGL
         static Timer timer;
-        static double elapsedSeconds;
+        static double elapsedSeconds = 0;
+        static AWShaderManager shaderManager;
+        private int programObject, vertexObject, fragmentObject, VAO;
+
+        public ShaderTutorials()
+            : base(800, 600, GraphicsMode.Default, "HI", GameWindowFlags.Default,
+            DisplayDevice.Default, 2, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        {
+            
+        }
 
@@ -19,7 +28,21 @@ namespace AWGL
         {
-            base.OnLoad(e);
+            //base.OnLoad(e);
 
-            Title = AWUtils.PrintOpenGLInfo();
-            elapsedSeconds = 0;
+            // Shaders
+            shaderManager = new AWShaderManager("CH02_VS", "CH02_FS");
+            //vertexObject = AWUtils.BuildShader("CH02_VS", ShaderType.VertexShader);
 
+            int attachedShaders;
+            GL.GetProgram(shaderManager.ProgramID, GetProgramParameterName.AttachedShaders, out attachedShaders);
+
+            Console.WriteLine("Attached Shaders: " + attachedShaders);
+
+            // VAO Setup
+            GL.GenVertexArrays(1, out VAO);
+            GL.BindVertexArray(VAO);
+            
+
+            Title = AWUtils.PrintOpenGLInfo();
+            
+            // Timer Setup
             timer = new Timer(1000);
@@ -29,2 +52,10 @@ namespace AWGL
 
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+
+            GL.DeleteBuffer(VAO);
+            
+        }
+
         private void OnTimerElapsed(object sender, ElapsedEventArgs e)
@@ -36,13 +67,18 @@ namespace AWGL
         {
-            base.OnRenderFrame(e);
+            //base.OnRenderFrame(e);
 
-            float[] color = new float[] 
-            { 
-                (float)(Math.Sin(elapsedSeconds) * 0.5f + 0.5f), 
-                (float)(Math.Cos(elapsedSeconds) * 0.5f + 0.5f),
-                0.0f, 
-                1.0f 
-            };
+            Color4 color = new Color4(0.0f, 0.0f, 0.2f, 1.0f);            
+            
+            GL.ClearColor(color);
 
-            GL.ClearBuffer(ClearBuffer.Color, 0, color);
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            // Use program object created by the shaderManager
+            GL.UseProgram(shaderManager.ProgramID);
+
+            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
+
+            ErrorCode err;
+            
+            err = GL.GetError();
 
@@ -50,2 +86,3 @@ namespace AWGL
         }
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cda71ecbdd44e1c8a1e575fd307c5d3aae264df1">successfully got vao working from example code</a>  -  cda71ec</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 5 files changed, 205 insertions(+), 73 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 00deea2..62e5e60 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -6,3 +6,4 @@ using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL4;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
 
@@ -18,3 +19,3 @@ namespace AWGL
         /// </summary>
-        private int vShader, fShader, linkedProgram;
+        private int vShader, fShader, programHandle;
 
@@ -72,3 +73,3 @@ namespace AWGL
                 GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
                 return -1;
@@ -84,13 +85,19 @@ namespace AWGL
         {
-            this.vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
-            this.fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
+            vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
+            fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
 
-            this.linkedProgram = GL.CreateProgram();
-            GL.AttachShader(linkedProgram, vShader);
-            GL.AttachShader(linkedProgram, fShader);
-            GL.LinkProgram(linkedProgram);
+            Debug.WriteLine(GL.GetShaderInfoLog(vShader));
+            Debug.WriteLine(GL.GetShaderInfoLog(fShader));
+
+            programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, vShader);
+            GL.AttachShader(programHandle, fShader);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
 
-            // Check linker success
             int linkSuccess;
-            GL.GetProgram(this.linkedProgram, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(this.programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -98,10 +105,13 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program link failed: " + message);
+                GL.GetProgramInfoLog(this.programHandle, out message);
+                Debug.WriteLine("Program link failed: " + message);
             }
 
-            // Validate program
+            #endregion
+
+            #region Validate Program
+
             int validateSuccess;
-            GL.ValidateProgram(this.linkedProgram);
-            GL.GetProgram(this.linkedProgram, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.ValidateProgram(this.programHandle);
+            GL.GetProgram(this.programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -109,5 +119,6 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.linkedProgram, out message);
-                Console.WriteLine("Program validation failed", message);
+                GL.GetProgramInfoLog(this.programHandle, out message);
+                Debug.WriteLine("Program validation failed", message);
             }
+            #endregion
 
@@ -120,6 +131,6 @@ namespace AWGL
         {
-            GL.DeleteProgram(this.linkedProgram);
+            GL.DeleteProgram(this.programHandle);
         }
 
-        public int ProgramID
+        public int ProgramHandle
         {
@@ -127,3 +138,3 @@ namespace AWGL
             {
-                return this.linkedProgram;
+                return this.programHandle;
             }
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 9b8c7df..6bd3868 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -3,2 +3,3 @@ using OpenTK.Graphics.OpenGL;
 using System;
+using System.Diagnostics;
 using System.IO;
@@ -54,3 +55,3 @@ namespace AWGL
                 GL.GetShaderInfoLog(shaderHandle, out message);
-                Console.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
+                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
                 return -1;
@@ -82,3 +83,3 @@ namespace AWGL
                 GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program link failed: " + message);
+                Debug.WriteLine("Program link failed: " + message);
             }
@@ -93,3 +94,3 @@ namespace AWGL
                 GL.GetProgramInfoLog(programHandle, out message);
-                Console.WriteLine("Program validation failed", message);
+                Debug.WriteLine("Program validation failed", message);
             }
@@ -166,3 +167,3 @@ namespace AWGL
             Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 1);
+            Version m_TargetLow = new Version(3, 0);
             Version m_TargetHigh = new Version(4, 1);
@@ -183,8 +184,6 @@ namespace AWGL
         {
-            Console.WriteLine("");
-            Console.WriteLine("Video informations :");
-            Console.WriteLine("Graphics card vendor : {0}", GL.GetString(StringName.Vendor));
-            Console.WriteLine("Renderer : {0}", GL.GetString(StringName.Renderer));
-            Console.WriteLine("Version : {0}", GL.GetString(StringName.Version));
-            Console.WriteLine("Shading Language Version : {0}", GL.GetString(StringName.ShadingLanguageVersion));
+            Debug.WriteLine("Graphics card vendor: " + GL.GetString(StringName.Vendor));
+            Debug.WriteLine("Renderer: " + GL.GetString(StringName.Renderer));
+            Debug.WriteLine("Version: " + GL.GetString(StringName.Version));
+            Debug.WriteLine("Shading Language Version: " + GL.GetString(StringName.ShadingLanguageVersion));
             
@@ -192,3 +191,3 @@ namespace AWGL
 
-            return "AWGL Engine Prototype      - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            return "AWGL Engine Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
new file mode 100644
index 0000000..46f2251
--- /dev/null
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -0,0 +1,17 @@
+﻿#version 130
+
+precision highp float;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(0.9, 0.9, 0.7);
+
+in vec3 normal;
+
+out vec4 out_frag_color;
+
+void main(void)
+{
+  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
+  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
new file mode 100644
index 0000000..3975262
--- /dev/null
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -0,0 +1,19 @@
+﻿#version 130
+
+precision highp float;
+
+uniform mat4 projection_matrix;
+uniform mat4 modelview_matrix;
+
+in vec3 in_position;
+in vec3 in_normal;
+
+out vec3 normal;
+
+void main(void)
+{
+  //works only for orthogonal modelview
+  normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  
+  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
+}
\ No newline at end of file
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 417ec4e..dc55df1 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -5,2 +5,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
@@ -14,10 +15,42 @@ namespace AWGL
     {
-        static Timer timer;
-        static double elapsedSeconds = 0;
-        static AWShaderManager shaderManager;
-        private int programObject, vertexObject, fragmentObject, VAO;
+        private AWShaderManager shaderManager;
+
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        private Vector3[] positionVboData = new Vector3[] {
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f)
+        };
+
+        private int[] indicesVboData = new int[]{
+             // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        Matrix4 projectionMatrix, modelviewMatrix;
 
         public ShaderTutorials()
-            : base(800, 600, GraphicsMode.Default, "HI", GameWindowFlags.Default,
-            DisplayDevice.Default, 2, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(800, 600, new GraphicsMode(), "", 0,
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         {
@@ -28,57 +61,110 @@ namespace AWGL
         {
-            //base.OnLoad(e);
+            base.OnLoad(e);
 
-            // Shaders
-            shaderManager = new AWShaderManager("CH02_VS", "CH02_FS");
-            //vertexObject = AWUtils.BuildShader("CH02_VS", ShaderType.VertexShader);
+            VSync = VSyncMode.On;
 
-            int attachedShaders;
-            GL.GetProgram(shaderManager.ProgramID, GetProgramParameterName.AttachedShaders, out attachedShaders);
-
-            Console.WriteLine("Attached Shaders: " + attachedShaders);
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
 
-            // VAO Setup
-            GL.GenVertexArrays(1, out VAO);
-            GL.BindVertexArray(VAO);
-            
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
 
             Title = AWUtils.PrintOpenGLInfo();
-            
-            // Timer Setup
-            timer = new Timer(1000);
-            timer.Elapsed += new ElapsedEventHandler(OnTimerElapsed);
-            timer.Enabled = true;
         }
 
-        protected override void OnUnload(EventArgs e)
+        private void CreateShaders()
         {
-            base.OnUnload(e);
+            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
 
-            GL.DeleteBuffer(VAO);
-            
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            // Set uniforms
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+
+            int attachedShaders;
+            GL.GetProgram(shaderManager.ProgramHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            Debug.WriteLine("/nAttached Shaders: " + attachedShaders);
         }
 
-        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
+        private void CreateVBOs()
         {
-            elapsedSeconds++;
+            GL.GenBuffers(1, out positionVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out normalVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer,
+                new IntPtr(sizeof(uint) * indicesVboData.Length),
+                indicesVboData, BufferUsageHint.StaticDraw);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
 
-        protected override void OnRenderFrame(FrameEventArgs e)
+        private void CreateVAOs()
         {
-            //base.OnRenderFrame(e);
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+            GL.GenVertexArrays(1, out vaoHandle);
+            GL.BindVertexArray(vaoHandle);
+
+            GL.EnableVertexAttribArray(0);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
+
+            GL.EnableVertexAttribArray(1);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        }
 
-            Color4 color = new Color4(0.0f, 0.0f, 0.2f, 1.0f);            
-            
-            GL.ClearColor(color);
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
-            // Use program object created by the shaderManager
-            GL.UseProgram(shaderManager.ProgramID);
+            if (Keyboard[OpenTK.Input.Key.Escape])
+                Exit();
+        }
 
-            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
 
-            ErrorCode err;
-            
-            err = GL.GetError();
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(PrimitiveType.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0d0da7559fc7816218569d27925192be0f4c4830">Half complete implementation of HelloGL3. This will be used as a starting point for full support of OpenGL 3.3 Core Profle by the engine.</a>  -  0d0da75</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 3 files changed, 127 insertions(+), 93 deletions(-)

diff --git a/AWGL/Data/Shaders/spincube-fs.glsl b/AWGL/Data/Shaders/spincube-fs.glsl
new file mode 100644
index 0000000..a8d60b9
--- /dev/null
+++ b/AWGL/Data/Shaders/spincube-fs.glsl
@@ -0,0 +1,13 @@
+#version 330 core                                                  
+                                                                               
+out vec4 color;                                                    
+                                                                               
+in VS_OUT                                                          
+{                                                                  
+    vec4 color;                                                    
+} fs_in;                                                           
+                                                                               
+void main(void)                                                    
+{                                                                  
+    color = fs_in.color;                                           
+}    
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-vs.glsl b/AWGL/Data/Shaders/spincube-vs.glsl
new file mode 100644
index 0000000..9de1ae1
--- /dev/null
+++ b/AWGL/Data/Shaders/spincube-vs.glsl
@@ -0,0 +1,17 @@
+#version 330 core                                                   
+                                                                                
+in vec4 position;                                                   
+                                                                                
+out VS_OUT                                                          
+{                                                                   
+    vec4 color;                                                     
+} vs_out;                                                           
+                                                                                
+uniform mat4 mv_matrix;                                             
+uniform mat4 proj_matrix;                                           
+                                                                                
+void main(void)                                                     
+{                                                                   
+    gl_Position = proj_matrix * mv_matrix * position;               
+    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
+}   
\ No newline at end of file
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index dc55df1..6e6b5af 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -19,34 +19,8 @@ namespace AWGL
             projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        private Vector3[] positionVboData = new Vector3[] {
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f)
-        };
-
-        private int[] indicesVboData = new int[]{
-             // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
+            buffer,
+            vao,
+            mv_location,
+            proj_location;
 
-        Matrix4 projectionMatrix, modelviewMatrix;
+        Matrix4 proj_matrix, modelviewMatrix;
 
@@ -59,2 +33,53 @@ namespace AWGL
 
+        private Vector3[] vertex_positions = new Vector3[]
+        {
+            new Vector3(0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f, -0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+            new Vector3(0.25f,  0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f, -0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+
+            new Vector3(-0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f, -0.25f,  0.25f),
+            new Vector3( 0.25f, -0.25f, -0.25f),
+
+            new Vector3( 0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f, -0.25f),
+            new Vector3(-0.25f, -0.25f,  0.25f),
+
+            new Vector3(-0.25f,  0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f, -0.25f),
+            new Vector3( 0.25f,  0.25f,  0.25f),
+
+            new Vector3( 0.25f,  0.25f,  0.25f),
+            new Vector3(-0.25f,  0.25f,  0.25f),
+            new Vector3(0.25f,  0.25f, -0.25f)
+        };
+
         protected override void OnLoad(EventArgs e)
@@ -66,7 +91,21 @@ namespace AWGL
             CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
 
-            // Other state
+            GL.GenVertexArrays(1, out vao);
+            GL.BindVertexArray(vao);
+
+            GL.GenBuffers(1, out buffer);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer);
+            GL.BufferData(BufferTarget.ArrayBuffer,
+                         new IntPtr(vertex_positions.Length * Vector3.SizeInBytes),
+                         vertex_positions,
+                         BufferUsageHint.StaticDraw);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, Vector3.SizeInBytes, 0);
+            GL.EnableVertexAttribArray(0);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Cw);
+
             GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Lequal);
+
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
@@ -87,6 +126,6 @@ namespace AWGL
             float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
             modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
             GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
@@ -98,51 +137,3 @@ namespace AWGL
 
-        private void CreateVBOs()
-        {
-            GL.GenBuffers(1, out positionVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out normalVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out eboHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer,
-                new IntPtr(sizeof(uint) * indicesVboData.Length),
-                indicesVboData, BufferUsageHint.StaticDraw);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
-
-        private void CreateVAOs()
-        {
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-            GL.GenVertexArrays(1, out vaoHandle);
-            GL.BindVertexArray(vaoHandle);
-
-            GL.EnableVertexAttribArray(0);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
-
-            GL.EnableVertexAttribArray(1);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
+       protected override void OnUpdateFrame(FrameEventArgs e)
         {
@@ -150,6 +141,2 @@ namespace AWGL
 
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-
             if (Keyboard[OpenTK.Input.Key.Escape])
@@ -162,9 +149,26 @@ namespace AWGL
 
+            float[] green = { 0.0f, 0.25f, 0.0f, 1.0f };
+            float one = 1.0f;
+
             GL.Viewport(0, 0, Width, Height);
+            GL.ClearBuffer(ClearBuffer.Color, 0, green);
+            GL.ClearBuffer(ClearBuffer.Depth, 0, ref one);
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(PrimitiveType.Triangles, indicesVboData.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.UniformMatrix4(proj_location, 1, false, proj_matrix);
+
+            int i;
+            for (i = 0; i < 24; i++)
+            {
+                float f = (float)i + (float)currentTime * 0.3f;
+                vmath::mat4 mv_matrix = vmath::translate(0.0f, 0.0f, -6.0f) *
+                                        vmath::rotate((float)currentTime * 45.0f, 0.0f, 1.0f, 0.0f) *
+                                        vmath::rotate((float)currentTime * 21.0f, 1.0f, 0.0f, 0.0f) *
+                                        vmath::translate(sinf(2.1f * f) * 2.0f,
+                                                         cosf(1.7f * f) * 2.0f,
+                                                         sinf(1.3f * f) * cosf(1.5f * f) * 2.0f);
+                GL.UniformMatrix4fv(mv_location, 1, GL_FALSE, mv_matrix);
+                GL.DrawArrays(GL_TRIANGLES, 0, 36);
+            }
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/171bcd8fe60c4c8705d9cd5df819e1ca219728d1">Removing test app.</a>  -  171bcd8</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 57 deletions(-)

diff --git a/TestApplication/Program.cs b/TestApplication/Program.cs
deleted file mode 100644
index 2cceac7..0000000
--- a/TestApplication/Program.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-using AWGL;
-using AWGL.Scene;
-
-namespace TestApplication
-{
-    class Program
-    {
-
-        [STAThread]
-        public static void Main(string[] args)
-        {
-            OGL.Run();
-        }
-    }
-}
deleted file mode 100644
index 5e3ef72..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("TestApplication")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("TestApplication")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("3b8899cd-4523-439e-892a-a7ecfc8390ed")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6aadb894ebeee6107e0d0fb3ffc29557d37318e9">More Trial and Error.</a>  -  6aadb89</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 30 insertions(+), 24 deletions(-)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 6e6b5af..0656286 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -17,5 +17,3 @@ namespace AWGL
 
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            buffer,
+        int buffer,
             vao,
@@ -24,3 +22,5 @@ namespace AWGL
 
-        Matrix4 proj_matrix, modelviewMatrix;
+        Matrix4 proj_matrix, mv_matrix;
+
+        float aspectRatio;
 
@@ -119,14 +119,12 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.ProgramHandle);
-
             // Set uniforms
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            mv_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            proj_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
 
-            float aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
-            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+            //aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            //Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
+            //mv_matrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            //GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
 
@@ -137,3 +135,11 @@ namespace AWGL
 
-       protected override void OnUpdateFrame(FrameEventArgs e)
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 0.1f, 1000.0f, out proj_matrix); 
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
         {
@@ -158,3 +164,3 @@ namespace AWGL
 
-            GL.UniformMatrix4(proj_location, 1, false, proj_matrix);
+            GL.UniformMatrix4(proj_location, false, ref proj_matrix);   //(proj_location, 1, false, proj_matrix); ??
 
@@ -163,11 +169,11 @@ namespace AWGL
             {
-                float f = (float)i + (float)currentTime * 0.3f;
-                vmath::mat4 mv_matrix = vmath::translate(0.0f, 0.0f, -6.0f) *
-                                        vmath::rotate((float)currentTime * 45.0f, 0.0f, 1.0f, 0.0f) *
-                                        vmath::rotate((float)currentTime * 21.0f, 1.0f, 0.0f, 0.0f) *
-                                        vmath::translate(sinf(2.1f * f) * 2.0f,
-                                                         cosf(1.7f * f) * 2.0f,
-                                                         sinf(1.3f * f) * cosf(1.5f * f) * 2.0f);
-                GL.UniformMatrix4fv(mv_location, 1, GL_FALSE, mv_matrix);
-                GL.DrawArrays(GL_TRIANGLES, 0, 36);
+                float f = (float)i + (float)e.Time * 0.3f;
+                mv_matrix = Matrix4.CreateTranslation(0.0f, 0.0f, -6.0f) *
+                                        Matrix4.CreateRotationY((float)e.Time * 45.0f) *
+                                        Matrix4.CreateRotationX((float)e.Time * 21.0f) *
+                                        Matrix4.CreateTranslation((float)Math.Sin(2.1f * f) * 2.0f,
+                                                         (float)(Math.Cos(1.7f * f) * 2.0f),
+                                                         (float)(Math.Sin(1.3f * f) * (float)(Math.Cos(1.5f * f) * 2.0f)));
+                GL.UniformMatrix4(mv_location, false, ref mv_matrix);
+                GL.DrawArrays(PrimitiveType.Triangles, 0, 36);
             }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a3273f159d50049a14d0d294d4d5c6a51a71a333">- Logger. - Refactor of Application Name</a>  -  a3273f1</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 8 files changed, 103 insertions(+), 62 deletions(-)

diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
new file mode 100644
index 0000000..0e08d78
--- /dev/null
+++ b/AWGL/AWEngine.cs
@@ -0,0 +1,40 @@
+﻿using AWGL.Scene;
+using OpenTK;
+using System;
+using System.Drawing;
+
+namespace AWGL
+{
+    public sealed class AWEngine
+    {
+        private static AWEngine instance = new AWEngine();
+
+        private AWEngine()
+        {
+        }
+
+        public static AWEngine getInstance()
+        {
+            return instance;
+        }
+
+        [STAThread]
+        public static void Main()
+        {
+            using (ShaderTutorials game = new ShaderTutorials())
+            {
+                game.Run(30,0);
+            }
+        }
+
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+            
+        }
+    }
+}
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
new file mode 100644
index 0000000..df611ff
--- /dev/null
+++ b/AWGL/AWLogger.cs
@@ -0,0 +1,53 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL
+{
+    internal static class AWLogger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 62e5e60..b7067ee 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -65,14 +65,4 @@ namespace AWGL
 
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
+            AWLogger.ShaderInfo(shaderHandle);
+            
             return shaderHandle;
@@ -88,5 +78,2 @@ namespace AWGL
 
-            Debug.WriteLine(GL.GetShaderInfoLog(vShader));
-            Debug.WriteLine(GL.GetShaderInfoLog(fShader));
-
             programHandle = GL.CreateProgram();
@@ -134,3 +121,3 @@ namespace AWGL
 
-        public int ProgramHandle
+        public int Program
         {
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
index 6bd3868..66624c7 100644
--- a/AWGL/AWUtils.cs
+++ b/AWGL/AWUtils.cs
@@ -184,6 +184,2 @@ namespace AWGL
         {
-            Debug.WriteLine("Graphics card vendor: " + GL.GetString(StringName.Vendor));
-            Debug.WriteLine("Renderer: " + GL.GetString(StringName.Renderer));
-            Debug.WriteLine("Version: " + GL.GetString(StringName.Version));
-            Debug.WriteLine("Shading Language Version: " + GL.GetString(StringName.ShadingLanguageVersion));
             
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
index 27a08e1..fb9ae28 100644
--- a/AWGL/DefaultScene.cs
+++ b/AWGL/DefaultScene.cs
@@ -91,3 +91,3 @@ namespace AWGL.Scene
 
-            Title = AWUtils.PrintOpenGLInfo();
+            //Title = AWUtils.PrintOpenGLInfo();
 
diff --git a/AWGL/OGL.cs b/AWGL/OGL.cs
deleted file mode 100644
index c5cb1b2..0000000
--- a/AWGL/OGL.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-﻿using AWGL.Scene;
-using OpenTK;
-using System;
-using System.Drawing;
-
-namespace AWGL
-{
-    public sealed class OGL
-    {
-        private static OGL instance = new OGL();
-
-        private OGL()
-        {
-        }
-
-        public static OGL getInstance()
-        {
-            return instance;
-        }
-
-        [STAThread]
-        public static void Main()
-        {
-            using (ShaderTutorials game = new ShaderTutorials())
-            {
-                game.Run(30,0);
-            }
-        }
-        
-    }
-}
diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
index 6635235..09747c3 100644
--- a/AWGL/Scene/AWCube.cs
+++ b/AWGL/Scene/AWCube.cs
@@ -46,3 +46,3 @@ namespace AWGL
             vbo = new Vbo();
-            vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
+            //vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 0656286..855ec06 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -30,3 +30,3 @@ namespace AWGL
         {
-            
+            AWLogger.PlatformInfo();
         }
@@ -112,3 +112,3 @@ namespace AWGL
 
-            Title = AWUtils.PrintOpenGLInfo();
+            Title = AWEngine.AppName + " Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
@@ -120,4 +120,4 @@ namespace AWGL
             // Set uniforms
-            mv_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            proj_location = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            mv_location = GL.GetUniformLocation(shaderManager.Program, "projection_matrix");
+            proj_location = GL.GetUniformLocation(shaderManager.Program, "modelview_matrix");
 
@@ -129,6 +129,2 @@ namespace AWGL
             //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
-
-            int attachedShaders;
-            GL.GetProgram(shaderManager.ProgramHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            Debug.WriteLine("/nAttached Shaders: " + attachedShaders);
         }
@@ -162,3 +158,3 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.ProgramHandle);
+            GL.UseProgram(shaderManager.Program);
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3b812a849fc30e27f6f4ca967fd4ee054de55780">minor tweaks</a>  -  3b812a8</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 855ec06..6c5561f 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -33,2 +33,4 @@ namespace AWGL
 
+        #region Vector3[] vertex_positions
+
         private Vector3[] vertex_positions = new Vector3[]
@@ -83,2 +85,4 @@ namespace AWGL
         };
+        
+        #endregion
 
@@ -112,3 +116,3 @@ namespace AWGL
 
-            Title = AWEngine.AppName + " Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
+            Title = AWEngine.AppName + " Prototype: " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
@@ -151,3 +155,3 @@ namespace AWGL
 
-            float[] green = { 0.0f, 0.25f, 0.0f, 1.0f };
+            float[] green = { 0.0f, 0.25f, 0.60f, 1.0f };
             float one = 1.0f;
@@ -163,3 +167,3 @@ namespace AWGL
             int i;
-            for (i = 0; i < 24; i++)
+            for (i = 0; i < 2; i++)
             {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9d7e1c35fa8aecbb96fb9c2ae8ce67344149b530">Still works.</a>  -  9d7e1c3</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 120 insertions(+), 129 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b7067ee..faec827 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -8,2 +8,4 @@ using OpenTK.Graphics.OpenGL;
 using System.Diagnostics;
+using OpenTK;
+using System.Drawing;
 
@@ -128,2 +130,15 @@ namespace AWGL
         }
+
+        internal void SetUniforms(out int projMatrixHandle, out int mvMatrixHandle, out Matrix4 projMatrix, out Matrix4 mvMatrix, Size dimensions)
+        {
+            projMatrixHandle = GL.GetUniformLocation(this.Program, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.Program, "modelview_matrix");
+
+            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+            mvMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+
+            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        }
     }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 6c5561f..897f53f 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -15,79 +15,47 @@ namespace AWGL
     {
-        private AWShaderManager shaderManager;
 
-        int buffer,
-            vao,
-            mv_location,
-            proj_location;
-
-        Matrix4 proj_matrix, mv_matrix;
-
-        float aspectRatio;
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Vector3[] positionVboData = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) };
+
+        int[] indicesVboData = new int[]{
+             // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, };
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        AWShaderManager shaderManager;
 
         public ShaderTutorials()
-            : base(800, 600, new GraphicsMode(), "", 0,
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        {
-            AWLogger.PlatformInfo();
-        }
-
-        #region Vector3[] vertex_positions
-
-        private Vector3[] vertex_positions = new Vector3[]
-        {
-            new Vector3(0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f, -0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-            new Vector3(0.25f,  0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f, -0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-
-            new Vector3(-0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f, -0.25f,  0.25f),
-            new Vector3( 0.25f, -0.25f, -0.25f),
-
-            new Vector3( 0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f, -0.25f),
-            new Vector3(-0.25f, -0.25f,  0.25f),
-
-            new Vector3(-0.25f,  0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f, -0.25f),
-            new Vector3( 0.25f,  0.25f,  0.25f),
-
-            new Vector3( 0.25f,  0.25f,  0.25f),
-            new Vector3(-0.25f,  0.25f,  0.25f),
-            new Vector3(0.25f,  0.25f, -0.25f)
-        };
+            : base(800, 600,
+            new GraphicsMode(), "OpenGL 3 Example", 0,
+            DisplayDevice.Default, 3, 0,
+            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
         
-        #endregion
-
-        protected override void OnLoad(EventArgs e)
+        protected override void OnLoad (System.EventArgs e)
         {
-            base.OnLoad(e);
-
             VSync = VSyncMode.On;
@@ -95,27 +63,11 @@ namespace AWGL
             CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
 
-            GL.GenVertexArrays(1, out vao);
-            GL.BindVertexArray(vao);
-
-            GL.GenBuffers(1, out buffer);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer);
-            GL.BufferData(BufferTarget.ArrayBuffer,
-                         new IntPtr(vertex_positions.Length * Vector3.SizeInBytes),
-                         vertex_positions,
-                         BufferUsageHint.StaticDraw);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, Vector3.SizeInBytes, 0);
-            GL.EnableVertexAttribArray(0);
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Cw);
-
+            // Other state
             GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Lequal);
-
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
-
-            Title = AWEngine.AppName + " Prototype: " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
         }
 
-        private void CreateShaders()
+        void CreateShaders()
         {
@@ -123,20 +75,60 @@ namespace AWGL
 
-            // Set uniforms
-            mv_location = GL.GetUniformLocation(shaderManager.Program, "projection_matrix");
-            proj_location = GL.GetUniformLocation(shaderManager.Program, "modelview_matrix");
+            GL.UseProgram(shaderManager.Program);
 
-            //aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            //Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out proj_matrix);
-            //mv_matrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
+            shaderManager.SetUniforms
+            (
+                out projectionMatrixLocation,
+                out modelviewMatrixLocation,
+                out projectionMatrix,
+                out modelviewMatrix,
+                ClientSize
+            );
+        }
 
-            //GL.UniformMatrix4(projectionMatrixLocation, false, ref proj_matrix);
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref mv_matrix);
+        void CreateVBOs()
+        {
+            GL.GenBuffers(1, out positionVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out normalVboHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
+                positionVboData, BufferUsageHint.StaticDraw);
+
+            GL.GenBuffers(1, out eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer,
+                new IntPtr(sizeof(uint) * indicesVboData.Length),
+                indicesVboData, BufferUsageHint.StaticDraw);
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
 
-        protected override void OnResize(EventArgs e)
+        void CreateVAOs()
         {
-            base.OnResize(e);
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+            GL.GenVertexArrays(1, out vaoHandle);
+            GL.BindVertexArray(vaoHandle);
+
+            GL.EnableVertexAttribArray(0);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.Program, 0, "in_position");
+
+            GL.EnableVertexAttribArray(1);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(shaderManager.Program, 1, "in_normal");
 
-            aspectRatio = ClientSize.Width / (float)(ClientSize.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 0.1f, 1000.0f, out proj_matrix); 
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
         }
@@ -145,3 +137,5 @@ namespace AWGL
         {
-            base.OnUpdateFrame(e);
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
@@ -153,28 +147,9 @@ namespace AWGL
         {
-            base.OnRenderFrame(e);
-
-            float[] green = { 0.0f, 0.25f, 0.60f, 1.0f };
-            float one = 1.0f;
-
             GL.Viewport(0, 0, Width, Height);
-            GL.ClearBuffer(ClearBuffer.Color, 0, green);
-            GL.ClearBuffer(ClearBuffer.Depth, 0, ref one);
+            
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
-            GL.UseProgram(shaderManager.Program);
-
-            GL.UniformMatrix4(proj_location, false, ref proj_matrix);   //(proj_location, 1, false, proj_matrix); ??
-
-            int i;
-            for (i = 0; i < 2; i++)
-            {
-                float f = (float)i + (float)e.Time * 0.3f;
-                mv_matrix = Matrix4.CreateTranslation(0.0f, 0.0f, -6.0f) *
-                                        Matrix4.CreateRotationY((float)e.Time * 45.0f) *
-                                        Matrix4.CreateRotationX((float)e.Time * 21.0f) *
-                                        Matrix4.CreateTranslation((float)Math.Sin(2.1f * f) * 2.0f,
-                                                         (float)(Math.Cos(1.7f * f) * 2.0f),
-                                                         (float)(Math.Sin(1.3f * f) * (float)(Math.Cos(1.5f * f) * 2.0f)));
-                GL.UniformMatrix4(mv_location, false, ref mv_matrix);
-                GL.DrawArrays(PrimitiveType.Triangles, 0, 36);
-            }
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(BeginMode.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -183,2 +158,3 @@ namespace AWGL
 
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ed51c898af59b489392f18ace7153f633c92bf7e">Refactoring of shader manager.</a>  -  ed51c89</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 64 insertions(+), 56 deletions(-)

diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index faec827..b11f15e 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -18,31 +18,34 @@ namespace AWGL
     {
-        /// <summary>
-        /// Shader Pointers
-        /// </summary>
-        private int vShader, fShader, programHandle;
+        #region Private Members
+
+        // Handles
+        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
 
         private string defaultDataPath = "Data/Shaders/";
-        private string m_vsFilePath, m_fsFilePath;
+        private string m_vertexShaderPath = "Simple_VS";
+        private string m_fragmentShaderPath = "Simple_FS";
+        
+        #endregion
 
-        public AWShaderManager(string vs_path, string fs_path)
-        {
-            this.m_vsFilePath = vs_path;
-            this.m_fsFilePath = fs_path;
-            BuildProgram();
+        #region Contructors
+
+        public AWShaderManager() 
+        { 
+            m_programHandle = BuildProgram(); 
         }
 
-        public AWShaderManager()
+        public AWShaderManager(string vertexShaderPath, string fragmentShaderPath)
         {
-            this.m_vsFilePath   = "Simple_VS";
-            this.m_fsFilePath   = "Simple_FS";
+            m_vertexShaderPath = vertexShaderPath;
+            m_fragmentShaderPath = fragmentShaderPath;
+            m_programHandle = BuildProgram();
         }
+        
+        #endregion
+
+        #region Shader and Program Contruction Methods
 
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename">Shader Filename</param>
-        /// <returns>Shader Source Code</returns>
-        private string LoadShader(string filename) 
+        internal string LoadShader(string shaderSourcePath)
         {
-            using (StreamReader sr = new StreamReader(defaultDataPath + filename + ".glsl"))
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
             {
@@ -51,10 +54,4 @@ namespace AWGL
         }
-        
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <param name="shaderType"></param>
-        /// <returns></returns>
-        private int BuildShader(string filename, ShaderType shaderType)
+
+        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
         {
@@ -62,3 +59,3 @@ namespace AWGL
             int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(filename));
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
 
@@ -68,3 +65,3 @@ namespace AWGL
             AWLogger.ShaderInfo(shaderHandle);
-            
+
             return shaderHandle;
@@ -72,14 +69,11 @@ namespace AWGL
 
-        /// <summary>
-        /// 
-        /// </summary>
-        private void BuildProgram() 
+        internal int BuildProgram()
         {
-            vShader = BuildShader(m_vsFilePath, ShaderType.VertexShader);
-            fShader = BuildShader(m_fsFilePath, ShaderType.FragmentShader);
+            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
 
-            programHandle = GL.CreateProgram();
+            int programHandle = GL.CreateProgram();
 
-            GL.AttachShader(programHandle, vShader);
-            GL.AttachShader(programHandle, fShader);
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
 
@@ -90,3 +84,3 @@ namespace AWGL
             int linkSuccess;
-            GL.GetProgram(this.programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
             if (linkSuccess == 0)
@@ -94,3 +88,3 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.programHandle, out message);
+                GL.GetProgramInfoLog(programHandle, out message);
                 Debug.WriteLine("Program link failed: " + message);
@@ -103,4 +97,4 @@ namespace AWGL
             int validateSuccess;
-            GL.ValidateProgram(this.programHandle);
-            GL.GetProgram(this.programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
             if (validateSuccess == 0)
@@ -108,3 +102,3 @@ namespace AWGL
                 String message;
-                GL.GetProgramInfoLog(this.programHandle, out message);
+                GL.GetProgramInfoLog(programHandle, out message);
                 Debug.WriteLine("Program validation failed", message);
@@ -114,5 +108,11 @@ namespace AWGL
             // Delete the shaders as the program has them now
-            GL.DeleteShader(vShader);
-            GL.DeleteShader(fShader);
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
         }
+        
+        #endregion
+
+        #region IDisposable
 
@@ -120,6 +120,10 @@ namespace AWGL
         {
-            GL.DeleteProgram(this.programHandle);
+            GL.DeleteProgram(m_programHandle);
         }
+        
+        #endregion
+
+        #region Public Methods
 
-        public int Program
+        public int ProgramHandle
         {
@@ -127,3 +131,3 @@ namespace AWGL
             {
-                return this.programHandle;
+                return m_programHandle;
             }
@@ -131,6 +135,9 @@ namespace AWGL
 
-        internal void SetUniforms(out int projMatrixHandle, out int mvMatrixHandle, out Matrix4 projMatrix, out Matrix4 mvMatrix, Size dimensions)
+        public void SetUniforms(
+            out int projMatrixHandle, out int mvMatrixHandle,
+            out Matrix4 projMatrix, out Matrix4 mvMatrix,
+            Size dimensions)
         {
-            projMatrixHandle = GL.GetUniformLocation(this.Program, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.Program, "modelview_matrix");
+            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
 
@@ -142,3 +149,4 @@ namespace AWGL
             GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        }
+        } 
+        #endregion
     }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 897f53f..bd9c1fd 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -75,3 +75,3 @@ namespace AWGL
 
-            GL.UseProgram(shaderManager.Program);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
@@ -123,3 +123,3 @@ namespace AWGL
             GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.Program, 0, "in_position");
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
 
@@ -128,3 +128,3 @@ namespace AWGL
             GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.Program, 1, "in_normal");
+            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e683e2c5c952a9aa8a41c2eb9477c08de4e93a19">Success.</a>  -  e683e2c</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 97 insertions(+), 34 deletions(-)

diff --git a/AWGL/AWBufferManager_2.cs b/AWGL/AWBufferManager_2.cs
new file mode 100644
index 0000000..9f0966e
--- /dev/null
+++ b/AWGL/AWBufferManager_2.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    class AWBufferManager
+    {
+        internal void SetupBuffer(
+            out int handle, Vector3[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupBuffer(
+            out int handle, int[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType, 
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal void GenerateVaoBuffer(out int handle)
+        {
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+        }
+    }
+}
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index bd9c1fd..f4eba04 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿
+using OpenTK;
 using OpenTK.Graphics;
@@ -50,2 +51,3 @@ namespace AWGL
         AWShaderManager shaderManager;
+        AWBufferManager bufferManager;
 
@@ -77,4 +79,3 @@ namespace AWGL
 
-            shaderManager.SetUniforms
-            (
+            shaderManager.SetUniforms(
                 out projectionMatrixLocation,
@@ -89,19 +90,21 @@ namespace AWGL
         {
-            GL.GenBuffers(1, out positionVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out normalVboHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.BufferData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(positionVboData.Length * Vector3.SizeInBytes),
-                positionVboData, BufferUsageHint.StaticDraw);
-
-            GL.GenBuffers(1, out eboHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer,
-                new IntPtr(sizeof(uint) * indicesVboData.Length),
-                indicesVboData, BufferUsageHint.StaticDraw);
+            bufferManager = new AWBufferManager();
+
+            bufferManager.SetupBuffer(
+                out positionVboHandle, positionVboData, 
+                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw);
+
+            bufferManager.SetupBuffer(
+                out normalVboHandle,
+                positionVboData,
+                BufferTarget.ArrayBuffer,
+                BufferUsageHint.StaticDraw
+                );
+
+            bufferManager.SetupBuffer(
+                out eboHandle,
+                indicesVboData,  //indicesVboData, // change this!!!
+                BufferTarget.ElementArrayBuffer,
+                BufferUsageHint.StaticDraw
+                );
 
@@ -117,14 +120,20 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
-            GL.GenVertexArrays(1, out vaoHandle);
-            GL.BindVertexArray(vaoHandle);
-
-            GL.EnableVertexAttribArray(0);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, positionVboHandle);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 0, "in_position");
-
-            GL.EnableVertexAttribArray(1);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, normalVboHandle);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(shaderManager.ProgramHandle, 1, "in_normal");
+            bufferManager.GenerateVaoBuffer(out vaoHandle);
+            bufferManager.SetupVaoBuffer(
+                BufferTarget.ArrayBuffer, 
+                positionVboHandle,
+                shaderManager.ProgramHandle,
+                "in_position",
+                VertexAttribPointerType.Float,
+                0, 3
+                );
+
+            bufferManager.SetupVaoBuffer(
+                BufferTarget.ArrayBuffer, 
+                normalVboHandle, 
+                shaderManager.ProgramHandle, 
+                "in_normal", 
+                VertexAttribPointerType.Float, 
+                1, 3
+                );
 
@@ -152,4 +161,6 @@ namespace AWGL
             GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(BeginMode.Triangles, indicesVboData.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(
+                PrimitiveType.Triangles, indicesVboData.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero
+                );
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e95349ec47c5f73182a27b530b099bbffa3ec609">~</a>  -  e95349e</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 83 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
deleted file mode 100644
index 3b297f7..0000000
--- a/AWGL/AWBufferManager.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class AWBufferManager : IDisposable
-    {
-        #region
-        // To create a VBO:
-        // 1) Generate the buffer handles for the vertex and element buffers.
-        // 2) Bind the vertex buffer handle and upload your vertex data. 
-        //    Check that the buffer was uploaded correctly.
-        // 3) Bind the element buffer handle and upload your element data. 
-        //    Check that the buffer was uploaded correctly.
-        #endregion
-
-        private Vbo vboHandle;
-
-        private Vbo GenerateVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements,
-                                           int elementSize,
-                                           int typeSize,
-                                           BufferUsageHint bufferUsageTypeGL)
-            where TVertex : struct
-        {
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            CheckForErrors(vbo_Size);
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.EboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            CheckForErrors(ebo_Size);
-
-            return this.vboHandle;
-        }
-
-        private static void CheckForErrors(int size)
-        {
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != size)
-                throw new Exception("Data not uploaded correctly");
-        }
-
-        public Vbo getBufferObjects(DrawableShape shape)
-        {
-            return new Vbo();//GenerateVBO(
-        }
-
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d475fdbc0f0100103f998909a513af3b59f70269">~</a>  -  d475fdb</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 52 insertions(+), 52 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
new file mode 100644
index 0000000..9f0966e
--- /dev/null
+++ b/AWGL/AWBufferManager.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL
+{
+    class AWBufferManager
+    {
+        internal void SetupBuffer(
+            out int handle, Vector3[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupBuffer(
+            out int handle, int[] data, 
+            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+        }
+
+        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType, 
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal void GenerateVaoBuffer(out int handle)
+        {
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+        }
+    }
+}
diff --git a/AWGL/AWBufferManager_2.cs b/AWGL/AWBufferManager_2.cs
deleted file mode 100644
index 9f0966e..0000000
--- a/AWGL/AWBufferManager_2.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    class AWBufferManager
-    {
-        internal void SetupBuffer(
-            out int handle, Vector3[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-        }
-
-        internal void SetupBuffer(
-            out int handle, int[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-        }
-
-        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, positionVboHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType, 
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal void GenerateVaoBuffer(out int handle)
-        {
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/994c1813e9b6eb81217edf947f3ef872ffb90115">Moved Login to buffermanager.</a>  -  994c181</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 14 insertions(+), 27 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 9f0966e..a780b4d 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -35,6 +35,8 @@ namespace AWGL
 
-        internal void SetupVaoBuffer(BufferTarget bufferTarget, int positionVboHandle, int ProgramHandle, string attributeName, VertexAttribPointerType vertexAttribPointerType, int index, int size)
+        internal void SetupVaoBuffer(
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
+            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
         {
             GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, positionVboHandle);
+            GL.BindBuffer(bufferTarget, bufferHandle);
             GL.VertexAttribPointer(
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index f4eba04..9e0992b 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -80,7 +80,4 @@ namespace AWGL
             shaderManager.SetUniforms(
-                out projectionMatrixLocation,
-                out modelviewMatrixLocation,
-                out projectionMatrix,
-                out modelviewMatrix,
-                ClientSize
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, out modelviewMatrix, ClientSize
             );
@@ -97,6 +94,4 @@ namespace AWGL
             bufferManager.SetupBuffer(
-                out normalVboHandle,
-                positionVboData,
-                BufferTarget.ArrayBuffer,
-                BufferUsageHint.StaticDraw
+                out normalVboHandle, positionVboData,
+                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -104,6 +99,4 @@ namespace AWGL
             bufferManager.SetupBuffer(
-                out eboHandle,
-                indicesVboData,  //indicesVboData, // change this!!!
-                BufferTarget.ElementArrayBuffer,
-                BufferUsageHint.StaticDraw
+                out eboHandle, indicesVboData, 
+                BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -122,8 +115,4 @@ namespace AWGL
             bufferManager.SetupVaoBuffer(
-                BufferTarget.ArrayBuffer, 
-                positionVboHandle,
-                shaderManager.ProgramHandle,
-                "in_position",
-                VertexAttribPointerType.Float,
-                0, 3
+                positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );
@@ -131,8 +120,4 @@ namespace AWGL
             bufferManager.SetupVaoBuffer(
-                BufferTarget.ArrayBuffer, 
-                normalVboHandle, 
-                shaderManager.ProgramHandle, 
-                "in_normal", 
-                VertexAttribPointerType.Float, 
-                1, 3
+                normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e10e3a49b84b0f61cd7c4ce4480d47bbef00eb5f">Better buffer manager.</a>  -  e10e3a4</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 51 insertions(+), 42 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index a780b4d..4cbeb61 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -9,8 +9,30 @@ namespace AWGL
 {
-    class AWBufferManager
+    public sealed class AWBufferManager
     {
-        internal void SetupBuffer(
-            out int handle, Vector3[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        private static volatile AWBufferManager instance = new AWBufferManager();
+        private static object syncRoot = new Object();
+
+        private AWBufferManager() { }
+
+        public static AWBufferManager Instance
+        {
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new AWBufferManager();
+                    }
+                }
+
+                return instance;
+            }
+        }
+
+        internal static int SetupBuffer(
+            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
         {
+            int handle;
             GL.GenBuffers(1, out handle);
@@ -21,8 +43,9 @@ namespace AWGL
                 );
+            return handle;
         }
 
-        internal void SetupBuffer(
-            out int handle, int[] data, 
-            BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        internal static int SetupBuffer(
+            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
         {
+            int handle;
             GL.GenBuffers(1, out handle);
@@ -33,5 +56,6 @@ namespace AWGL
                 );
+            return handle;
         }
 
-        internal void SetupVaoBuffer(
+        internal static void SetupVaoBuffer(
             int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
@@ -47,6 +71,8 @@ namespace AWGL
 
-        internal void GenerateVaoBuffer(out int handle)
+        internal static int GenerateVaoBuffer()
         {
+            int handle;
             GL.GenVertexArrays(1, out handle);
             GL.BindVertexArray(handle);
+            return handle;
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 9e0992b..801089c 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -24,26 +24,2 @@ namespace AWGL
 
-        Vector3[] positionVboData = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) };
-
-        int[] indicesVboData = new int[]{
-             // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, };
-
         Matrix4 projectionMatrix, modelviewMatrix;
@@ -51,3 +27,7 @@ namespace AWGL
         AWShaderManager shaderManager;
-        AWBufferManager bufferManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
 
@@ -64,2 +44,6 @@ namespace AWGL
 
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+
             CreateShaders();
@@ -87,5 +71,4 @@ namespace AWGL
         {
-            bufferManager = new AWBufferManager();
-
-            bufferManager.SetupBuffer(
+            
+            AWBufferManager.SetupBuffer(
                 out positionVboHandle, positionVboData, 
@@ -93,3 +76,3 @@ namespace AWGL
 
-            bufferManager.SetupBuffer(
+            AWBufferManager.SetupBuffer(
                 out normalVboHandle, positionVboData,
@@ -98,3 +81,3 @@ namespace AWGL
 
-            bufferManager.SetupBuffer(
+            AWBufferManager.SetupBuffer(
                 out eboHandle, indicesVboData, 
@@ -113,4 +96,4 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
-            bufferManager.GenerateVaoBuffer(out vaoHandle);
-            bufferManager.SetupVaoBuffer(
+            vaoHandle = AWBufferManager.GenerateVaoBuffer();
+            AWBufferManager.SetupVaoBuffer(
                 positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
@@ -119,3 +102,3 @@ namespace AWGL
 
-            bufferManager.SetupVaoBuffer(
+            AWBufferManager.SetupVaoBuffer(
                 normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fcad613fcd3e4ec8bdde32eb25b9464c4b68ed70">Buffer Manager</a>  -  fcad613</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 5 files changed, 120 insertions(+), 90 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 4cbeb61..9c673a8 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -59,2 +59,12 @@ namespace AWGL
 
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="bufferHandle"></param>
+        /// <param name="ProgramHandle"></param>
+        /// <param name="index"></param>
+        /// <param name="size"></param>
+        /// <param name="attributeName"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="vertexAttribPointerType"></param>
         internal static void SetupVaoBuffer(
diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
new file mode 100644
index 0000000..3409e23
--- /dev/null
+++ b/AWGL/AWCube.cs
@@ -0,0 +1,65 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL
+{
+    class AWCube : AWNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public static Vector3[] Vertices 
+        {
+            get { return CubeVertices; }
+        }
+
+        public static int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+        }
+
+    }
+}
diff --git a/AWGL/Scene/AWCube.cs b/AWGL/Scene/AWCube.cs
deleted file mode 100644
index 09747c3..0000000
--- a/AWGL/Scene/AWCube.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWCube : AWNode
-    {
-        #region Private Members
-        private Cube Cube;
-
-        private Vbo vbo;
-
-        private VertexPositionColor[] CubeVertices = new VertexPositionColor[]
-        {
-                new VertexPositionColor(-1.0f, -1.0f,  1.0f, Color.Khaki),
-                new VertexPositionColor( 1.0f, -1.0f,  1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f,  1.0f,  1.0f, Color.Black),
-                new VertexPositionColor(-1.0f,  1.0f,  1.0f, Color.Black),
-                new VertexPositionColor(-1.0f, -1.0f, -1.0f, Color.DarkRed),
-                new VertexPositionColor( 1.0f, -1.0f, -1.0f, Color.Khaki), 
-                new VertexPositionColor( 1.0f,  1.0f, -1.0f, Color.Black),
-                new VertexPositionColor(-1.0f,  1.0f, -1.0f, Color.Black) 
-        };
-
-        private readonly short[] CubeElements = new short[]
-        {
-            0, 1, 2, 2, 3, 0, // front face
-            3, 2, 6, 6, 7, 3, // top face
-            7, 6, 5, 5, 4, 7, // back face
-            4, 0, 3, 3, 7, 4, // left face
-            0, 1, 5, 5, 4, 0, // bottom face
-            1, 5, 6, 6, 2, 1, // right face
-        };
-        #endregion
-
-        public AWCube()
-        {
-            vbo = new Vbo();
-            //vbo = AWUtils.LoadVBO(CubeVertices, CubeElements, 3, 4, BufferUsageHint.StaticDraw);
-        }
-
-        public override void Render()
-        {
-            // To draw a VBO:
-            // 1) Ensure that the VertexArray client state is enabled.
-            // 2) Bind the vertex and element buffer handles.
-            // 3) Set up the data pointers (vertex, normal, color) according to your vertex format.
-            // 4) Call DrawElements. (Note: the last parameter is an offset into the element buffer
-            //    and will usually be IntPtr.Zero).
-
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vbo.EboID);
-
-            GL.VertexPointer(3, VertexPointerType.Float, BlittableValueType.StrideOf(CubeVertices), new IntPtr(0));
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, BlittableValueType.StrideOf(CubeVertices), new IntPtr(12));
-            
-            GL.DrawElements(PrimitiveType.Triangles, vbo.NumElements, DrawElementsType.UnsignedShort, IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
index 39bef32..4341e13 100644
--- a/AWGL/Scene/AWNode.cs
+++ b/AWGL/Scene/AWNode.cs
@@ -10,2 +10,9 @@ namespace AWGL
     {
+        protected AWBufferManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
         public abstract void Render();
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
index 801089c..7088979 100644
--- a/AWGL/ShaderTutorials.cs
+++ b/AWGL/ShaderTutorials.cs
@@ -55,4 +55,9 @@ namespace AWGL
             GL.ClearColor(System.Drawing.Color.MidnightBlue);
+
+            #if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+            #endif
         }
 
+        #region Create Shaders
         void CreateShaders()
@@ -67,19 +72,19 @@ namespace AWGL
             );
-        }
+        } 
+        #endregion
 
+        #region Create VBOs
         void CreateVBOs()
         {
-            
-            AWBufferManager.SetupBuffer(
-                out positionVboHandle, positionVboData, 
-                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw);
 
-            AWBufferManager.SetupBuffer(
-                out normalVboHandle, positionVboData,
-                BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            positionVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            AWBufferManager.SetupBuffer(
-                out eboHandle, indicesVboData, 
-                BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            normalVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -88,6 +93,9 @@ namespace AWGL
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
+        } 
+        #endregion
 
+        #region Create VAOs
         void CreateVAOs()
         {
+            #region ---
             // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
@@ -96,10 +104,18 @@ namespace AWGL
             // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
             vaoHandle = AWBufferManager.GenerateVaoBuffer();
-            AWBufferManager.SetupVaoBuffer(
-                positionVboHandle, shaderManager.ProgramHandle, 0, 3,"in_position",
+
+            #region add matrix transform uniforms
+
+            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
+                
+                shaderManager.ProgramHandle, 0, 3, "in_position",
                 BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
                 );
-
-            AWBufferManager.SetupVaoBuffer(
-                normalVboHandle, shaderManager.ProgramHandle, 1, 3, "in_normal",
+            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
+                
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
                 BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
@@ -107,2 +123,4 @@ namespace AWGL
 
+            #endregion
+
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
@@ -110,3 +128,4 @@ namespace AWGL
             GL.BindVertexArray(0);
-        }
+        } 
+        #endregion
 
@@ -130,3 +149,3 @@ namespace AWGL
             GL.DrawElements(
-                PrimitiveType.Triangles, indicesVboData.Length,
+                PrimitiveType.Triangles, AWCube.Indices.Length,
                 DrawElementsType.UnsignedInt, IntPtr.Zero

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fcd0516963dc6f0379bb014d4d8672559cc7e8ac">Documentation Update</a>  -  fcd0516</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 8 files changed, 234 insertions(+), 177 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
index 9c673a8..05d5f7b 100644
--- a/AWGL/AWBufferManager.cs
+++ b/AWGL/AWBufferManager.cs
@@ -9,4 +9,8 @@ namespace AWGL
 {
-    public sealed class AWBufferManager
+    /// <summary>
+    /// 
+    /// </summary>
+    public sealed class AWBufferManager : IDisposable
     {
+        #region Singleton Pattern - Thread Safe
         private static volatile AWBufferManager instance = new AWBufferManager();
@@ -31,4 +35,13 @@ namespace AWGL
             }
-        }
+        } 
+        #endregion
 
+        #region Set up Vertex Buffer Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
         internal static int SetupBuffer(
@@ -46,2 +59,9 @@ namespace AWGL
 
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
         internal static int SetupBuffer(
@@ -57,4 +77,6 @@ namespace AWGL
             return handle;
-        }
+        } 
+        #endregion
 
+        #region Set up Vertex Array Objects
         /// <summary>
@@ -70,3 +92,3 @@ namespace AWGL
         internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName, 
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
             BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
@@ -76,3 +98,3 @@ namespace AWGL
             GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType, 
+                index, size, vertexAttribPointerType,
                 true, Vector3.SizeInBytes, 0);
@@ -87,2 +109,8 @@ namespace AWGL
             return handle;
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
         }
diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index 71a2527..c8035e0 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -9,2 +9,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// Camera
+    /// </summary>
     public class AWCamera
diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
index 3409e23..6515964 100644
--- a/AWGL/AWCube.cs
+++ b/AWGL/AWCube.cs
@@ -13,2 +13,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// Cube Node
+    /// </summary>
     class AWCube : AWNode
@@ -61,4 +64,4 @@ namespace AWGL
         {
+            throw new NotImplementedException();
         }
-
     }
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 0e08d78..17fd964 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -7,14 +7,30 @@ namespace AWGL
 {
+    /// <summary>
+    /// AWEngine Main Entry Piont
+    /// </summary>
     public sealed class AWEngine
     {
-        private static AWEngine instance = new AWEngine();
+        #region Singleton Pattern - Thread Safe
+        private static volatile AWEngine instance = new AWEngine();
+        private static object syncRoot = new Object();
 
-        private AWEngine()
-        {
-        }
+        private AWEngine() { }
 
-        public static AWEngine getInstance()
+        public static AWEngine Instance
         {
-            return instance;
-        }
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new AWEngine();
+                    }
+                }
+
+                return instance;
+            }
+        } 
+        #endregion
 
@@ -23,3 +39,3 @@ namespace AWGL
         {
-            using (ShaderTutorials game = new ShaderTutorials())
+            using (AWScene game = new AWScene())
             {
@@ -29,3 +45,2 @@ namespace AWGL
 
-
         public static string AppName
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
index df611ff..db9d5b1 100644
--- a/AWGL/AWLogger.cs
+++ b/AWGL/AWLogger.cs
@@ -9,2 +9,5 @@ namespace AWGL
 {
+    /// <summary>
+    /// AWLogger
+    /// </summary>
     internal static class AWLogger
@@ -42,3 +45,2 @@ namespace AWGL
 
-
         internal static void ShadersAttached(int programHandle)
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
new file mode 100644
index 0000000..529d6c6
--- /dev/null
+++ b/AWGL/AWScene.cs
@@ -0,0 +1,164 @@
+﻿
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class AWScene : GameWindow, IDisposable
+    {
+
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        AWShaderManager shaderManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
+
+        public AWScene()
+            : base(1366, 768,
+            new GraphicsMode(), AWEngine.AppName, 0,
+            DisplayDevice.Default, 3, 0,
+            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
+        
+        protected override void OnLoad (System.EventArgs e)
+        {
+            VSync = VSyncMode.On;
+
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
+
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+
+            #if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+            #endif
+        }
+
+        #region Create Shaders
+        void CreateShaders()
+        {
+            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
+
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            shaderManager.SetUniforms(
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, out modelviewMatrix, ClientSize
+            );
+        } 
+        #endregion
+
+        #region Create VBOs
+        void CreateVBOs()
+        {
+
+            positionVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            normalVboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = AWBufferManager.SetupBuffer(
+                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+        } 
+        #endregion
+
+        #region Create VAOs
+        void CreateVAOs()
+        {
+            #region ---
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
+            vaoHandle = AWBufferManager.GenerateVaoBuffer();
+
+            #region add matrix transform uniforms
+
+            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
+                
+                shaderManager.ProgramHandle, 0, 3, "in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
+                
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+
+            #endregion
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        } 
+        #endregion
+
+        #region MAIN LOOP
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+
+            if (Keyboard[OpenTK.Input.Key.Escape])
+                Exit();
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawElements(
+                PrimitiveType.Triangles, AWCube.Indices.Length,
+                DrawElementsType.UnsignedInt, IntPtr.Zero
+                );
+
+            SwapBuffers();
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index b11f15e..804bd46 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -118,5 +118,6 @@ namespace AWGL
 
-        public void Dispose()
+        void IDisposable.Dispose()
         {
-            GL.DeleteProgram(m_programHandle);
+            throw new NotImplementedException();
+            //GL.DeleteProgram(m_programHandle);
         }
diff --git a/AWGL/ShaderTutorials.cs b/AWGL/ShaderTutorials.cs
deleted file mode 100644
index 7088979..0000000
--- a/AWGL/ShaderTutorials.cs
+++ /dev/null
@@ -1,159 +0,0 @@
-﻿
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-
-namespace AWGL
-{
-    public class ShaderTutorials : GameWindow
-    {
-
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        AWShaderManager shaderManager;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-
-        public ShaderTutorials()
-            : base(800, 600,
-            new GraphicsMode(), "OpenGL 3 Example", 0,
-            DisplayDevice.Default, 3, 0,
-            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        { }
-        
-        protected override void OnLoad (System.EventArgs e)
-        {
-            VSync = VSyncMode.On;
-
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
-
-            #if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-            #endif
-        }
-
-        #region Create Shaders
-        void CreateShaders()
-        {
-            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, out modelviewMatrix, ClientSize
-            );
-        } 
-        #endregion
-
-        #region Create VBOs
-        void CreateVBOs()
-        {
-
-            positionVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            normalVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            eboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        } 
-        #endregion
-
-        #region Create VAOs
-        void CreateVAOs()
-        {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = AWBufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
-                
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
-                
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-
-            #endregion
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        } 
-        #endregion
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-
-            if (Keyboard[OpenTK.Input.Key.Escape])
-                Exit();
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Viewport(0, 0, Width, Height);
-            
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(
-                PrimitiveType.Triangles, AWCube.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero
-                );
-
-            SwapBuffers();
-        }
-
-
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/18798b16a89d4c1c057a4bd41d4e771ce1d8eea2">Implemented dispose methods.</a>  -  18798b1</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 8 insertions(+), 15 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 529d6c6..f15bb20 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -1,3 +1,2 @@
-﻿
-using OpenTK;
+﻿using OpenTK;
 using OpenTK.Graphics;
@@ -158,6 +157,8 @@ namespace AWGL
 
-        void IDisposable.Dispose()
+        public override void Dispose()
         {
-            throw new NotImplementedException();
+ 	        base.Dispose();
+            shaderManager.Dispose();
         }
+
     }
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 804bd46..1670547 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -19,3 +19,2 @@ namespace AWGL
         #region Private Members
-
         // Handles
@@ -26,3 +25,2 @@ namespace AWGL
         private string m_fragmentShaderPath = "Simple_FS";
-        
         #endregion
@@ -30,3 +28,2 @@ namespace AWGL
         #region Contructors
-
         public AWShaderManager() 
@@ -42,3 +39,2 @@ namespace AWGL
         }
-        
         #endregion
@@ -46,3 +42,2 @@ namespace AWGL
         #region Shader and Program Contruction Methods
-
         internal string LoadShader(string shaderSourcePath)
@@ -113,3 +108,2 @@ namespace AWGL
         }
-        
         #endregion
@@ -117,9 +111,6 @@ namespace AWGL
         #region IDisposable
-
-        void IDisposable.Dispose()
+        public void Dispose()
         {
-            throw new NotImplementedException();
-            //GL.DeleteProgram(m_programHandle);
+            GL.DeleteProgram(m_programHandle);
         }
-        
         #endregion
@@ -152,2 +143,3 @@ namespace AWGL
         #endregion
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fe8df48be5bd9a40b2baad0d99a15e39530385fb">More organisation.</a>  -  fe8df48</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 24 insertions(+), 20 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index f15bb20..000c15a 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -6,2 +6,3 @@ using System.Collections.Generic;
 using System.Diagnostics;
+using System.Drawing;
 using System.Linq;
@@ -15,3 +16,3 @@ namespace AWGL
     {
-
+        #region Members
         int modelviewMatrixLocation,
@@ -30,12 +31,12 @@ namespace AWGL
         AWGroupNode group;
-        AWCube cube;
+        AWCube cube; 
+        #endregion
 
         public AWScene()
-            : base(1366, 768,
-            new GraphicsMode(), AWEngine.AppName, 0,
-            DisplayDevice.Default, 3, 0,
-            GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(1366, 768, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Fullscreen, 
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
-        
-        protected override void OnLoad (System.EventArgs e)
+
+        #region OpenGL Setup
+        protected override void OnLoad(System.EventArgs e)
         {
@@ -53,7 +54,7 @@ namespace AWGL
             GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(System.Drawing.Color.MidnightBlue);
+            GL.ClearColor(Color.CornflowerBlue);
 
-            #if Debug
+#if Debug
             AWLogger.WriteLine("...Exiting OnLoad"); 
-            #endif
+#endif
         }
@@ -71,3 +72,3 @@ namespace AWGL
             );
-        } 
+        }
         #endregion
@@ -92,3 +93,3 @@ namespace AWGL
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        } 
+        }
         #endregion
@@ -111,4 +112,4 @@ namespace AWGL
 
-            AWBufferManager.SetupVaoBuffer( positionVboHandle, 
-                
+            AWBufferManager.SetupVaoBuffer(positionVboHandle,
+
                 shaderManager.ProgramHandle, 0, 3, "in_position",
@@ -116,4 +117,4 @@ namespace AWGL
                 );
-            AWBufferManager.SetupVaoBuffer( normalVboHandle, 
-                
+            AWBufferManager.SetupVaoBuffer(normalVboHandle,
+
                 shaderManager.ProgramHandle, 1, 3, "in_normal",
@@ -127,3 +128,4 @@ namespace AWGL
             GL.BindVertexArray(0);
-        } 
+        }
+        #endregion 
         #endregion
@@ -157,7 +159,9 @@ namespace AWGL
 
+        #region GameWindow.Dispose
         public override void Dispose()
         {
- 	        base.Dispose();
+            base.Dispose();
             shaderManager.Dispose();
-        }
+        } 
+        #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/991e844f8fdbbda05e4c6b62a5243cec6b5be232">Refactoring namspaces. Removed AWGL.Scene and added AWGL.Nodes.</a>  -  991e844</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 22 files changed, 671 insertions(+), 670 deletions(-)

diff --git a/AWGL/AWCube.cs b/AWGL/AWCube.cs
deleted file mode 100644
index 6515964..0000000
--- a/AWGL/AWCube.cs
+++ /dev/null
@@ -1,68 +0,0 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    class AWCube : AWNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public static Vector3[] Vertices 
-        {
-            get { return CubeVertices; }
-        }
-
-        public static int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 17fd964..91df2c0 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -1,3 +1,2 @@
-﻿using AWGL.Scene;
-using OpenTK;
+﻿using OpenTK;
 using System;
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
new file mode 100644
index 0000000..7565e90
--- /dev/null
+++ b/AWGL/AWOldScene.cs
@@ -0,0 +1,251 @@
+﻿using AWGL.Nodes;
+using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class AWOldScene : GameWindow
+    {
+        #region Constructor
+
+        public AWOldScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
+        {
+            //set context
+            //this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new AWCamera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
+
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected AWCamera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private AWShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            //Title = AWUtils.PrintOpenGLInfo();
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 000c15a..5d8f8fc 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿using AWGL.Nodes;
+using OpenTK;
 using OpenTK.Graphics;
diff --git a/AWGL/DefaultScene.cs b/AWGL/DefaultScene.cs
deleted file mode 100644
index fb9ae28..0000000
--- a/AWGL/DefaultScene.cs
+++ /dev/null
@@ -1,250 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class DefaultScene : GameWindow
-    {
-        #region Constructor
-
-        public DefaultScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new AWCamera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected AWCamera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private AWShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
new file mode 100644
index 0000000..570b597
--- /dev/null
+++ b/AWGL/Nodes/AWCube.cs
@@ -0,0 +1,68 @@
+﻿using AWGL.Shapes;
+using AWGL.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    /// <summary>
+    /// Cube Node
+    /// </summary>
+    class AWCube : AWNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public static Vector3[] Vertices 
+        {
+            get { return CubeVertices; }
+        }
+
+        public static int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
new file mode 100644
index 0000000..5c1dc64
--- /dev/null
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -0,0 +1,32 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWGraphLines : AWNode
+    {
+        private int m_gridSize = 20;
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
new file mode 100644
index 0000000..5088673
--- /dev/null
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -0,0 +1,89 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+    } 
+}
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
new file mode 100644
index 0000000..6c266a2
--- /dev/null
+++ b/AWGL/Nodes/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
new file mode 100644
index 0000000..c84a3c2
--- /dev/null
+++ b/AWGL/Nodes/AWNode.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public abstract class AWNode : ISceneNode
+    {
+        protected AWBufferManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
+        public abstract void Render();
+    }
+
+}
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
new file mode 100644
index 0000000..9d9b423
--- /dev/null
+++ b/AWGL/Nodes/AWParticles.cs
@@ -0,0 +1,112 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    class AWParticles : AWNode
+    {
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
new file mode 100644
index 0000000..fddd1ad
--- /dev/null
+++ b/AWGL/Nodes/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Nodes
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
new file mode 100644
index 0000000..d909231
--- /dev/null
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Nodes
+{
+    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
new file mode 100644
index 0000000..9a51902
--- /dev/null
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -0,0 +1,12 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Nodes
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
diff --git a/AWGL/Scene/AWGraphLines.cs b/AWGL/Scene/AWGraphLines.cs
deleted file mode 100644
index 7f280ce..0000000
--- a/AWGL/Scene/AWGraphLines.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWGraphLines : AWNode
-    {
-        private int m_gridSize = 20;
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/Scene/AWGroupNode.cs b/AWGL/Scene/AWGroupNode.cs
deleted file mode 100644
index 0e656cc..0000000
--- a/AWGL/Scene/AWGroupNode.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-    } 
-}
diff --git a/AWGL/Scene/AWMesh.cs b/AWGL/Scene/AWMesh.cs
deleted file mode 100644
index bd58995..0000000
--- a/AWGL/Scene/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Scene/AWNode.cs b/AWGL/Scene/AWNode.cs
deleted file mode 100644
index 4341e13..0000000
--- a/AWGL/Scene/AWNode.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public abstract class AWNode : ISceneNode
-    {
-        protected AWBufferManager m_BufferManager;
-
-        protected AWNode()
-        {
-            //m_BufferManager = new AWBufferManager();
-        }
-
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/Scene/AWParticles.cs b/AWGL/Scene/AWParticles.cs
deleted file mode 100644
index 2b2f7c6..0000000
--- a/AWGL/Scene/AWParticles.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    class AWParticles : AWNode
-    {
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
diff --git a/AWGL/Scene/AWPolygon.cs b/AWGL/Scene/AWPolygon.cs
deleted file mode 100644
index eb2ca03..0000000
--- a/AWGL/Scene/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/Scene/IGroupNode.cs b/AWGL/Scene/IGroupNode.cs
deleted file mode 100644
index 5ac83e3..0000000
--- a/AWGL/Scene/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Scene/ISceneNode.cs b/AWGL/Scene/ISceneNode.cs
deleted file mode 100644
index 6f6da08..0000000
--- a/AWGL/Scene/ISceneNode.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e5e376a2ba76d389fe023f2c30842c8ea96b2a60">Some changes to nodes.</a>  -  e5e376a</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 8 files changed, 60 insertions(+), 26 deletions(-)

diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
index 7565e90..a67acb8 100644
--- a/AWGL/AWOldScene.cs
+++ b/AWGL/AWOldScene.cs
@@ -38,3 +38,3 @@ namespace AWGL
             landRoot = new AWGroupNode();
-            graph = new AWGraphLines(); ;
+            graph = new AWGraphLines(20); ;
             cube = new AWCube();
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 5d8f8fc..c5fc788 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -32,3 +32,4 @@ namespace AWGL
         AWGroupNode group;
-        AWCube cube; 
+        AWCube cube;
+        AWGraphLines graph;
         #endregion
@@ -48,3 +49,3 @@ namespace AWGL
             cube = new AWCube();
-
+            graph = new AWGraphLines(20);
             CreateShaders();
@@ -81,3 +82,3 @@ namespace AWGL
             positionVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -85,3 +86,3 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -89,3 +90,3 @@ namespace AWGL
             eboHandle = AWBufferManager.SetupBuffer(
-                AWCube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -152,3 +153,3 @@ namespace AWGL
             GL.DrawElements(
-                PrimitiveType.Triangles, AWCube.Indices.Length,
+                PrimitiveType.Triangles, cube.Indices.Length,
                 DrawElementsType.UnsignedInt, IntPtr.Zero
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
index 570b597..536eeeb 100644
--- a/AWGL/Nodes/AWCube.cs
+++ b/AWGL/Nodes/AWCube.cs
@@ -16,3 +16,3 @@ namespace AWGL.Nodes
     /// </summary>
-    class AWCube : AWNode
+    public class AWCube : AWNode, ISceneNode
     {
@@ -48,3 +48,3 @@ namespace AWGL.Nodes
 
-        public static Vector3[] Vertices 
+        public Vector3[] Vertices
         {
@@ -53,3 +53,3 @@ namespace AWGL.Nodes
 
-        public static int[] Indices
+        public int[] Indices
         {
@@ -66,2 +66,3 @@ namespace AWGL.Nodes
         }
+
     }
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index 5c1dc64..d3d493b 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Graphics.OpenGL;
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -11,3 +12,3 @@ namespace AWGL.Nodes
 {
-    class AWGraphLines : AWNode
+    class AWGraphLines : AWNode, ISceneNode
     {
@@ -15,15 +16,35 @@ namespace AWGL.Nodes
 
-        public override void Render()
+        public Vector3[] Vertices
+        {
+            get { return m_vertices; }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        private static Vector3[] m_vertices;
+
+        public AWGraphLines(int gridSize)
         {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            m_gridSize = gridSize;
+            m_vertices = new Vector3[m_gridSize];
+            BuildVertices();
+        }
+
+        private void BuildVertices()
+        {
+            for (int i = 0; i < m_gridSize; i += 4)
             {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
+                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
+                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
+                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
             }
-            GL.End();
+        }
+
+        public override void Render()
+        {
+
         }
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
index 5088673..2190c34 100644
--- a/AWGL/Nodes/AWGroupNode.cs
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -10,3 +10,3 @@ namespace AWGL.Nodes
 {
-    public class AWGroupNode : AWNode, IGroupNode, IEnumerable<ISceneNode>
+    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
     {
@@ -87,2 +87,12 @@ namespace AWGL.Nodes
 
+
+        public OpenTK.Vector3[] Vertices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
     } 
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index c84a3c2..6d64581 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -8,3 +8,3 @@ namespace AWGL.Nodes
 {
-    public abstract class AWNode : ISceneNode
+    public abstract class AWNode
     {
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
index d909231..abfbd48 100644
--- a/AWGL/Nodes/IGroupNode.cs
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -7,3 +7,3 @@ namespace AWGL.Nodes
 {
-    public interface IGroupNode : ISceneNode, IEnumerable<ISceneNode>
+    public interface IGroupNode : IEnumerable<ISceneNode>
     {
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
index 9a51902..b1e3f51 100644
--- a/AWGL/Nodes/ISceneNode.cs
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK;
+using System;
 using System.Collections.Generic;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/78286a1257d0cd64b15301c972ae79903cc38b84">Got some graph lines going on up in here.</a>  -  78286a1</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index c5fc788..edabc91 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -82,3 +82,3 @@ namespace AWGL
             positionVboHandle = AWBufferManager.SetupBuffer(
-                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -86,8 +86,8 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                cube.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            eboHandle = AWBufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //eboHandle = AWBufferManager.SetupBuffer(
+            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
@@ -127,3 +127,3 @@ namespace AWGL
 
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
@@ -137,5 +137,6 @@ namespace AWGL
         {
-            Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            
+            //Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
+            //Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
 
@@ -152,6 +153,7 @@ namespace AWGL
             GL.BindVertexArray(vaoHandle);
-            GL.DrawElements(
-                PrimitiveType.Triangles, cube.Indices.Length,
-                DrawElementsType.UnsignedInt, IntPtr.Zero
-                );
+            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+                //Elements(
+                //PrimitiveType.Lines, cube.Indices.Length,
+                //DrawElementsType.UnsignedInt, IntPtr.Zero
+                //);
 
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index d3d493b..e9d9de0 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -21,7 +21,2 @@ namespace AWGL.Nodes
 
-        public int[] Indices
-        {
-            get { throw new NotImplementedException(); }
-        }
-
         private static Vector3[] m_vertices;
@@ -31,3 +26,3 @@ namespace AWGL.Nodes
             m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize];
+            m_vertices = new Vector3[m_gridSize * 2];
             BuildVertices();
@@ -37,3 +32,3 @@ namespace AWGL.Nodes
         {
-            for (int i = 0; i < m_gridSize; i += 4)
+            for (int i = 0; i < m_gridSize *2; i += 4)
             {
@@ -48,3 +43,13 @@ namespace AWGL.Nodes
         {
-
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a8824acae89b5b6b1c801ca24466dc346136149b">Successfully got camera working with shaders.</a>  -  a8824ac</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 3 files changed, 78 insertions(+), 12 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index c8035e0..a72fadf 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -19,2 +19,9 @@ namespace AWGL
 
+        public Matrix4 LookAtMatrix
+        {
+            get
+            {
+                return GetViewMatrix();
+            }
+        }
         public Matrix4 GetViewMatrix()
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index edabc91..325fde8 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -34,2 +34,3 @@ namespace AWGL
         AWGraphLines graph;
+        AWCamera camera;
         #endregion
@@ -37,3 +38,3 @@ namespace AWGL
         public AWScene()
-            : base(1366, 768, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Fullscreen, 
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -45,3 +46,3 @@ namespace AWGL
             VSync = VSyncMode.On;
-
+            camera = new AWCamera();
             root = new AWGroupNode();
@@ -72,3 +73,3 @@ namespace AWGL
                 out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, out modelviewMatrix, ClientSize
+                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
             );
@@ -137,9 +138,14 @@ namespace AWGL
         {
-            
-            //Matrix4 rotation = Matrix4.CreateRotationY((float)e.Time);
-            //Matrix4.Mult(ref rotation, ref modelviewMatrix, out modelviewMatrix);
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-            if (Keyboard[OpenTK.Input.Key.Escape])
-                Exit();
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
         }
@@ -171,2 +177,56 @@ namespace AWGL
 
+        protected override void OnKeyPress(KeyPressEventArgs e)
+        {
+            base.OnKeyPress(e);
+
+            if (e.KeyChar == 27)
+            {
+                Exit();
+            }
+
+            switch (e.KeyChar)
+            {
+                case 'w':
+                    camera.Move(0f, 0.1f, 0f);
+                    break;
+                case 'a':
+                    camera.Move(-0.1f, 0f, 0f);
+                    break;
+                case 's':
+                    camera.Move(0f, -0.1f, 0f);
+                    break;
+                case 'd':
+                    camera.Move(0.1f, 0f, 0f);
+                    break;
+                case 'q':
+                    camera.Move(0f, 0f, 0.1f);
+                    break;
+                case 'e':
+                    camera.Move(0f, 0f, -0.1f);
+                    break;
+                case 'f':
+                    this.WindowState = (this.WindowState != WindowState.Fullscreen) 
+                        ? WindowState.Fullscreen: WindowState.Normal;
+                    break;
+                case 'x':
+                    Exit();
+                    break;
+            }
+        }
+
+        void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
     }
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
index 1670547..2918c1c 100644
--- a/AWGL/AWShaderManager.cs
+++ b/AWGL/AWShaderManager.cs
@@ -129,4 +129,4 @@ namespace AWGL
             out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, out Matrix4 mvMatrix,
-            Size dimensions)
+            out Matrix4 projMatrix, Matrix4 mvMatrix,
+            Size dimensions, ref AWCamera camera)
         {
@@ -137,3 +137,2 @@ namespace AWGL
             Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-            mvMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/539c15293980a3e708fe9a590cad7c91f252b4ab">Better Input Control.</a>  -  539c152</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 2 files changed, 62 insertions(+), 33 deletions(-)

diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
index a72fadf..c731e69 100644
--- a/AWGL/AWCamera.cs
+++ b/AWGL/AWCamera.cs
@@ -14,3 +14,3 @@ namespace AWGL
     {
-        public Vector3 Position = Vector3.Zero;
+        public Vector3 Position = new Vector3(2, 2, 2);
         public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 325fde8..2430108 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -4,2 +4,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
@@ -35,2 +36,3 @@ namespace AWGL
         AWCamera camera;
+        List<Key> keyList;
         #endregion
@@ -46,3 +48,9 @@ namespace AWGL
             VSync = VSyncMode.On;
+            
             camera = new AWCamera();
+            keyList = new List<Key>();
+
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+            
             root = new AWGroupNode();
@@ -147,2 +155,3 @@ namespace AWGL
 
+            MoveCamera();
 
@@ -177,38 +186,57 @@ namespace AWGL
 
-        protected override void OnKeyPress(KeyPressEventArgs e)
+        #region Input Control
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
         {
-            base.OnKeyPress(e);
+            keyList.Add(e.Key);
+        }
 
-            if (e.KeyChar == 27)
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
             {
-                Exit();
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
             }
+        }
 
-            switch (e.KeyChar)
+        private void MoveCamera()
+        {
+            foreach (Key key in keyList)
             {
-                case 'w':
-                    camera.Move(0f, 0.1f, 0f);
-                    break;
-                case 'a':
-                    camera.Move(-0.1f, 0f, 0f);
-                    break;
-                case 's':
-                    camera.Move(0f, -0.1f, 0f);
-                    break;
-                case 'd':
-                    camera.Move(0.1f, 0f, 0f);
-                    break;
-                case 'q':
-                    camera.Move(0f, 0f, 0.1f);
-                    break;
-                case 'e':
-                    camera.Move(0f, 0f, -0.1f);
-                    break;
-                case 'f':
-                    this.WindowState = (this.WindowState != WindowState.Fullscreen) 
-                        ? WindowState.Fullscreen: WindowState.Normal;
-                    break;
-                case 'x':
-                    Exit();
-                    break;
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
             }
@@ -216,3 +244,3 @@ namespace AWGL
 
-        void ResetCursor()
+        private void ResetCursor()
         {
@@ -229,3 +257,4 @@ namespace AWGL
             }
-        }
+        } 
+        #endregion
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/760cb400727a728ef8fc6219ddf70effa09b8cb2">Funky cube error, looks more like a map or summat.</a>  -  760cb40</p><p>authored by Anthony Woodward, 2 months ago</p></div><pre>
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index 2430108..ea35d54 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -89,5 +89,8 @@ namespace AWGL
         {
+            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
 
             positionVboHandle = AWBufferManager.SetupBuffer(
-                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
@@ -95,8 +98,8 @@ namespace AWGL
             normalVboHandle = AWBufferManager.SetupBuffer(
-                graph.Vertices, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
                 );
 
-            //eboHandle = AWBufferManager.SetupBuffer(
-            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
+            eboHandle = AWBufferManager.SetupBuffer(
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
 
@@ -136,3 +139,3 @@ namespace AWGL
 
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
@@ -169,3 +172,3 @@ namespace AWGL
             GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-                //Elements(
+            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
                 //PrimitiveType.Lines, cube.Indices.Length,

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/492bf03d733797f5769996eab210dc25b9b7cdd9">Added FPS Counter.</a>  -  492bf03</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
index ea35d54..a9b78dd 100644
--- a/AWGL/AWScene.cs
+++ b/AWGL/AWScene.cs
@@ -166,2 +166,3 @@ namespace AWGL
         {
+            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             GL.Viewport(0, 0, Width, Height);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ea930771a1da7807a46a01a5765765308cd097f7">A bit of organisation.</a>  -  ea93077</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 15 files changed, 670 insertions(+), 720 deletions(-)

diff --git a/AWGL/AWBufferManager.cs b/AWGL/AWBufferManager.cs
deleted file mode 100644
index 05d5f7b..0000000
--- a/AWGL/AWBufferManager.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    public sealed class AWBufferManager : IDisposable
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile AWBufferManager instance = new AWBufferManager();
-        private static object syncRoot = new Object();
-
-        private AWBufferManager() { }
-
-        public static AWBufferManager Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new AWBufferManager();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        #region Set up Vertex Buffer Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-            return handle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-            return handle;
-        } 
-        #endregion
-
-        #region Set up Vertex Array Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="bufferHandle"></param>
-        /// <param name="ProgramHandle"></param>
-        /// <param name="index"></param>
-        /// <param name="size"></param>
-        /// <param name="attributeName"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="vertexAttribPointerType"></param>
-        internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
-            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, bufferHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType,
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal static int GenerateVaoBuffer()
-        {
-            int handle;
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-            return handle;
-        } 
-        #endregion
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/AWCamera.cs b/AWGL/AWCamera.cs
deleted file mode 100644
index c731e69..0000000
--- a/AWGL/AWCamera.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Camera
-    /// </summary>
-    public class AWCamera
-    {
-        public Vector3 Position = new Vector3(2, 2, 2);
-        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
-        public float MoveSpeed = 0.2f;
-        public float MouseSensitivity = 0.01f;
-
-        public Matrix4 LookAtMatrix
-        {
-            get
-            {
-                return GetViewMatrix();
-            }
-        }
-        public Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
-            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
-        }
-
-        public void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
-            Position += offset;
-        }
-
-        public void AddRotation(float x, float y)
-        {
-            x = x * MouseSensitivity;
-            y = y * MouseSensitivity;
-
-            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
-            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-        }
-    }
-}
diff --git a/AWGL/AWData.cs b/AWGL/AWData.cs
deleted file mode 100644
index 4ebbf45..0000000
--- a/AWGL/AWData.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿using OpenTK;
-using System;
-
-namespace AWGL
-{
-    public struct Vbo
-    {
-        public int VboID, EboID, NumElements;
-    }
-
-    #region Particles
-    // this struct is used for drawing
-    public struct VertexC4ubV3f
-    {
-        public byte R, G, B, A;
-        public Vector3 Position;
-
-        public static int SizeInBytes = 16;
-    }
-
-    // this struct is used for updates
-    public struct ParticleAttribut
-    {
-        public Vector3 Direction;
-        public uint Age;
-
-        //  more stuff could be here: Rotation, Radius, whatever
-    }
-    #endregion
-
-    #region Picker
-    public struct Byte4
-    {
-        public byte R, G, B, A;
-
-        public Byte4(byte[] input)
-        {
-            R = input[0];
-            G = input[1];
-            B = input[2];
-            A = input[3];
-        }
-
-        public uint ToUInt32()
-        {
-            byte[] temp = new byte[] { this.R, this.G, this.B, this.A };
-            return BitConverter.ToUInt32(temp, 0);
-        }
-
-        public override string ToString()
-        {
-            return this.R + ", " + this.G + ", " + this.B + ", " + this.A;
-        }
-    }
-
-    struct Vertex
-    {
-        public Byte4 Color; // 4 bytes
-        public Vector3 Position; // 12 bytes
-
-        public const byte SizeInBytes = 16;
-    }
-    #endregion
-
-}
\ No newline at end of file
diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
index 91df2c0..85bb98f 100644
--- a/AWGL/AWEngine.cs
+++ b/AWGL/AWEngine.cs
@@ -38,3 +38,3 @@ namespace AWGL
         {
-            using (AWScene game = new AWScene())
+            using (AWEngineWindow game = new AWEngineWindow())
             {
diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
new file mode 100644
index 0000000..5482d11
--- /dev/null
+++ b/AWGL/AWEngineWindow.cs
@@ -0,0 +1,268 @@
+﻿using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+
+namespace AWGL
+{
+    public class AWEngineWindow : GameWindow, IDisposable
+    {
+        #region Members
+        int modelviewMatrixLocation,
+            projectionMatrixLocation,
+            vaoHandle,
+            positionVboHandle,
+            normalVboHandle,
+            eboHandle;
+
+        Matrix4 projectionMatrix, modelviewMatrix;
+
+        ShaderManager shaderManager;
+
+        AWNode m_sceneGraph;
+        AWGroupNode root;
+        AWGroupNode group;
+        AWCube cube;
+        AWGraphLines graph;
+        Camera camera;
+        List<Key> keyList;
+        #endregion
+
+        public AWEngineWindow()
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+        { }
+
+        #region OpenGL Setup
+        protected override void OnLoad(System.EventArgs e)
+        {
+            VSync = VSyncMode.On;
+            
+            camera = new Camera();
+            keyList = new List<Key>();
+
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+            
+            root = new AWGroupNode();
+            group = new AWGroupNode();
+            cube = new AWCube();
+            graph = new AWGraphLines(20);
+            CreateShaders();
+            CreateVBOs();
+            CreateVAOs();
+
+            // Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.CornflowerBlue);
+
+#if Debug
+            AWLogger.WriteLine("...Exiting OnLoad"); 
+#endif
+        }
+
+        #region Create Shaders
+        void CreateShaders()
+        {
+            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+            GL.UseProgram(shaderManager.ProgramHandle);
+
+            shaderManager.SetUniforms(
+                out projectionMatrixLocation, out modelviewMatrixLocation,
+                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
+            );
+        }
+        #endregion
+
+        #region Create VBOs
+        void CreateVBOs()
+        {
+            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
+
+            positionVboHandle = BufferManager.SetupBuffer(
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            normalVboHandle = BufferManager.SetupBuffer(
+                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            eboHandle = BufferManager.SetupBuffer(
+                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+                );
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+        }
+        #endregion
+
+        #region Create VAOs
+        void CreateVAOs()
+        {
+            #region ---
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            #endregion
+
+            // generate
+            vaoHandle = BufferManager.GenerateVaoBuffer();
+
+            #region add matrix transform uniforms
+
+            BufferManager.SetupVaoBuffer(positionVboHandle,
+
+                shaderManager.ProgramHandle, 0, 3, "in_position",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+            BufferManager.SetupVaoBuffer(normalVboHandle,
+
+                shaderManager.ProgramHandle, 1, 3, "in_normal",
+                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+                );
+
+            #endregion
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+
+            GL.BindVertexArray(0);
+        }
+        #endregion 
+        #endregion
+
+        #region MAIN LOOP
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            MoveCamera();
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            GL.Viewport(0, 0, Width, Height);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.BindVertexArray(vaoHandle);
+            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
+                //PrimitiveType.Lines, cube.Indices.Length,
+                //DrawElementsType.UnsignedInt, IntPtr.Zero
+                //);
+
+            SwapBuffers();
+        } 
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            base.Dispose();
+            shaderManager.Dispose();
+        } 
+        #endregion
+
+        #region Input Control
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case Key.W:
+                        camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        #endregion
+
+    }
+}
diff --git a/AWGL/AWLogger.cs b/AWGL/AWLogger.cs
deleted file mode 100644
index db9d5b1..0000000
--- a/AWGL/AWLogger.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Text;
-
-namespace AWGL
-{
-    /// <summary>
-    /// AWLogger
-    /// </summary>
-    internal static class AWLogger
-    {
-       
-        internal static void WriteLine(string output)
-        {
-            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
-        }
-
-        internal static void PlatformInfo()
-        {
-            WriteLine("Starting Logger. . .");
-            WriteLine("Getting Platform Information. . .");
-            WriteLine(GL.GetString(StringName.Vendor));
-            WriteLine(GL.GetString(StringName.Renderer));
-            WriteLine(GL.GetString(StringName.Version));
-            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
-        }
-
-        internal static void ShaderInfo(int shaderHandle)
-        {
-            String infoLog;
-            GL.GetShaderInfoLog(shaderHandle, out infoLog);
-            WriteLine(infoLog);
-        }
-
-        internal static void ProgramInfo(int programHandle)
-        {
-            String infoLog;
-            GL.GetProgramInfoLog(programHandle, out infoLog);
-            WriteLine(infoLog);
-            ShadersAttached(programHandle);
-        }
-
-        internal static void ShadersAttached(int programHandle)
-        {
-            int attachedShaders;
-            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
-            WriteLine(attachedShaders + temp + " Attached");
-        }
-    }
-
-}
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
index a67acb8..51cd98d 100644
--- a/AWGL/AWOldScene.cs
+++ b/AWGL/AWOldScene.cs
@@ -1,3 +1,5 @@
-﻿using AWGL.Nodes;
+﻿using AWGL.Managers;
+using AWGL.Nodes;
 using AWGL.Shapes;
+using AWGL.Utilities;
 using OpenTK;
@@ -28,3 +30,3 @@ namespace AWGL
             //create player camera
-            playerView = new AWCamera();
+            playerView = new Camera();
 
@@ -64,3 +66,3 @@ namespace AWGL
 
-        protected AWCamera playerView;
+        protected Camera playerView;
 
@@ -80,3 +82,3 @@ namespace AWGL
 
-        private AWShaderManager shaderManager;
+        private ShaderManager shaderManager;
 
diff --git a/AWGL/AWScene.cs b/AWGL/AWScene.cs
deleted file mode 100644
index a9b78dd..0000000
--- a/AWGL/AWScene.cs
+++ /dev/null
@@ -1,266 +0,0 @@
-﻿using AWGL.Nodes;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-
-namespace AWGL
-{
-    public class AWScene : GameWindow, IDisposable
-    {
-        #region Members
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        AWShaderManager shaderManager;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-        AWGraphLines graph;
-        AWCamera camera;
-        List<Key> keyList;
-        #endregion
-
-        public AWScene()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
-        { }
-
-        #region OpenGL Setup
-        protected override void OnLoad(System.EventArgs e)
-        {
-            VSync = VSyncMode.On;
-            
-            camera = new AWCamera();
-            keyList = new List<Key>();
-
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-            
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-            graph = new AWGraphLines(20);
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.CornflowerBlue);
-
-#if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif
-        }
-
-        #region Create Shaders
-        void CreateShaders()
-        {
-            shaderManager = new AWShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            );
-        }
-        #endregion
-
-        #region Create VBOs
-        void CreateVBOs()
-        {
-            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
-
-            positionVboHandle = AWBufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            normalVboHandle = AWBufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            eboHandle = AWBufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
-        }
-        #endregion
-
-        #region Create VAOs
-        void CreateVAOs()
-        {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = AWBufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            AWBufferManager.SetupVaoBuffer(positionVboHandle,
-
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            AWBufferManager.SetupVaoBuffer(normalVboHandle,
-
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-
-            #endregion
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
-
-            GL.BindVertexArray(0);
-        }
-        #endregion 
-        #endregion
-
-        #region MAIN LOOP
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            MoveCamera();
-
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            GL.Viewport(0, 0, Width, Height);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-                //PrimitiveType.Lines, cube.Indices.Length,
-                //DrawElementsType.UnsignedInt, IntPtr.Zero
-                //);
-
-            SwapBuffers();
-        } 
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            base.Dispose();
-            shaderManager.Dispose();
-        } 
-        #endregion
-
-        #region Input Control
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
-                }
-            }
-        }
-
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        #endregion
-
-    }
-}
diff --git a/AWGL/AWShaderManager.cs b/AWGL/AWShaderManager.cs
deleted file mode 100644
index 2918c1c..0000000
--- a/AWGL/AWShaderManager.cs
+++ /dev/null
@@ -1,145 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.IO;
-using OpenTK.Graphics.OpenGL;
-using System.Diagnostics;
-using OpenTK;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    class AWShaderManager : IDisposable
-    {
-        #region Private Members
-        // Handles
-        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
-
-        private string defaultDataPath = "Data/Shaders/";
-        private string m_vertexShaderPath = "Simple_VS";
-        private string m_fragmentShaderPath = "Simple_FS";
-        #endregion
-
-        #region Contructors
-        public AWShaderManager() 
-        { 
-            m_programHandle = BuildProgram(); 
-        }
-
-        public AWShaderManager(string vertexShaderPath, string fragmentShaderPath)
-        {
-            m_vertexShaderPath = vertexShaderPath;
-            m_fragmentShaderPath = fragmentShaderPath;
-            m_programHandle = BuildProgram();
-        }
-        #endregion
-
-        #region Shader and Program Contruction Methods
-        internal string LoadShader(string shaderSourcePath)
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-
-        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            AWLogger.ShaderInfo(shaderHandle);
-
-            return shaderHandle;
-        }
-
-        internal int BuildProgram()
-        {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
-
-            int programHandle = GL.CreateProgram();
-
-            GL.AttachShader(programHandle, m_vertexShaderHandle);
-            GL.AttachShader(programHandle, m_fragmentShaderHandle);
-
-            GL.LinkProgram(programHandle);
-
-            #region Check linker success
-
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
-            }
-
-            #endregion
-
-            #region Validate Program
-
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
-            }
-            #endregion
-
-            // Delete the shaders as the program has them now
-            GL.DeleteShader(m_vertexShaderHandle);
-            GL.DeleteShader(m_fragmentShaderHandle);
-
-            return programHandle;
-        }
-        #endregion
-
-        #region IDisposable
-        public void Dispose()
-        {
-            GL.DeleteProgram(m_programHandle);
-        }
-        #endregion
-
-        #region Public Methods
-
-        public int ProgramHandle
-        {
-            get
-            {
-                return m_programHandle;
-            }
-        }
-
-        public void SetUniforms(
-            out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, Matrix4 mvMatrix,
-            Size dimensions, ref AWCamera camera)
-        {
-            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        } 
-        #endregion
-
-    }
-}
diff --git a/AWGL/Managers/BufferManager.cs b/AWGL/Managers/BufferManager.cs
new file mode 100644
index 0000000..f3719c4
--- /dev/null
+++ b/AWGL/Managers/BufferManager.cs
@@ -0,0 +1,118 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+
+namespace AWGL.Managers
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    public sealed class BufferManager : IDisposable
+    {
+        #region Singleton Pattern - Thread Safe
+        private static volatile BufferManager instance = new BufferManager();
+        private static object syncRoot = new Object();
+
+        private BufferManager() { }
+
+        public static BufferManager Instance
+        {
+            get
+            {
+                if (instance == null)
+                {
+                    lock (syncRoot)
+                    {
+                        if (instance == null)
+                            instance = new BufferManager();
+                    }
+                }
+
+                return instance;
+            }
+        } 
+        #endregion
+
+        #region Set up Vertex Buffer Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
+        internal static int SetupBuffer(
+            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            int handle;
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData<Vector3>(
+                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
+                data, bufferUsageHint
+                );
+            return handle;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="data"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="bufferUsageHint"></param>
+        /// <returns></returns>
+        internal static int SetupBuffer(
+            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
+        {
+            int handle;
+            GL.GenBuffers(1, out handle);
+            GL.BindBuffer(bufferTarget, handle);
+            GL.BufferData(
+                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
+                data, bufferUsageHint
+                );
+            return handle;
+        } 
+        #endregion
+
+        #region Set up Vertex Array Objects
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="bufferHandle"></param>
+        /// <param name="ProgramHandle"></param>
+        /// <param name="index"></param>
+        /// <param name="size"></param>
+        /// <param name="attributeName"></param>
+        /// <param name="bufferTarget"></param>
+        /// <param name="vertexAttribPointerType"></param>
+        internal static void SetupVaoBuffer(
+            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
+            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
+        {
+            GL.EnableVertexAttribArray(index);
+            GL.BindBuffer(bufferTarget, bufferHandle);
+            GL.VertexAttribPointer(
+                index, size, vertexAttribPointerType,
+                true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
+        }
+
+        internal static int GenerateVaoBuffer()
+        {
+            int handle;
+            GL.GenVertexArrays(1, out handle);
+            GL.BindVertexArray(handle);
+            return handle;
+        } 
+        #endregion
+
+        void IDisposable.Dispose()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
new file mode 100644
index 0000000..72b7fdd
--- /dev/null
+++ b/AWGL/Managers/ShaderManager.cs
@@ -0,0 +1,146 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IO;
+using OpenTK.Graphics.OpenGL;
+using System.Diagnostics;
+using OpenTK;
+using System.Drawing;
+using AWGL.Utilities;
+
+namespace AWGL.Managers
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    class ShaderManager : IDisposable
+    {
+        #region Private Members
+        // Handles
+        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+
+        private string defaultDataPath = "Data/Shaders/";
+        private string m_vertexShaderPath = "Simple_VS";
+        private string m_fragmentShaderPath = "Simple_FS";
+        #endregion
+
+        #region Contructors
+        public ShaderManager() 
+        { 
+            m_programHandle = BuildProgram(); 
+        }
+
+        public ShaderManager(string vertexShaderPath, string fragmentShaderPath)
+        {
+            m_vertexShaderPath = vertexShaderPath;
+            m_fragmentShaderPath = fragmentShaderPath;
+            m_programHandle = BuildProgram();
+        }
+        #endregion
+
+        #region Shader and Program Contruction Methods
+        internal string LoadShader(string shaderSourcePath)
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+
+        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            Logger.ShaderInfo(shaderHandle);
+
+            return shaderHandle;
+        }
+
+        internal int BuildProgram()
+        {
+            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
+
+            int programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
+
+            int linkSuccess;
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
+            if (linkSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Debug.WriteLine("Program link failed: " + message);
+            }
+
+            #endregion
+
+            #region Validate Program
+
+            int validateSuccess;
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
+            if (validateSuccess == 0)
+            {
+                String message;
+                GL.GetProgramInfoLog(programHandle, out message);
+                Debug.WriteLine("Program validation failed", message);
+            }
+            #endregion
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
+        }
+        #endregion
+
+        #region IDisposable
+        public void Dispose()
+        {
+            GL.DeleteProgram(m_programHandle);
+        }
+        #endregion
+
+        #region Public Methods
+
+        public int ProgramHandle
+        {
+            get
+            {
+                return m_programHandle;
+            }
+        }
+
+        public void SetUniforms(
+            out int projMatrixHandle, out int mvMatrixHandle,
+            out Matrix4 projMatrix, Matrix4 mvMatrix,
+            Size dimensions, ref Camera camera)
+        {
+            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+
+            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        } 
+        #endregion
+
+    }
+}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index 6d64581..ca93718 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using AWGL.Managers;
+using System;
 using System.Collections.Generic;
@@ -10,3 +11,3 @@ namespace AWGL.Nodes
     {
-        protected AWBufferManager m_BufferManager;
+        protected BufferManager m_BufferManager;
 
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
index 9d9b423..6d0c8ca 100644
--- a/AWGL/Nodes/AWParticles.cs
+++ b/AWGL/Nodes/AWParticles.cs
@@ -12,2 +12,10 @@ namespace AWGL.Nodes
     {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+}
+/*
         #region Private Members
@@ -112 +120,2 @@ namespace AWGL.Nodes
 }
+        */
\ No newline at end of file
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
new file mode 100644
index 0000000..f806424
--- /dev/null
+++ b/AWGL/Utilities/Camera.cs
@@ -0,0 +1,64 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    /// <summary>
+    /// Camera
+    /// </summary>
+    public class Camera
+    {
+        public Vector3 Position = new Vector3(2, 2, 2);
+        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public float MoveSpeed = 0.2f;
+        public float MouseSensitivity = 0.01f;
+
+        public Matrix4 LookAtMatrix
+        {
+            get
+            {
+                return GetViewMatrix();
+            }
+        }
+        public Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+        }
+
+        public void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
new file mode 100644
index 0000000..5b1701d
--- /dev/null
+++ b/AWGL/Utilities/Logger.cs
@@ -0,0 +1,55 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    /// <summary>
+    /// AWLogger
+    /// </summary>
+    internal static class Logger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c3e3e539e5430f5e0abeb47c10459f530105f749">More Refactoring. Added some class stubs.</a>  -  c3e3e53</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 8 files changed, 306 insertions(+), 310 deletions(-)

diff --git a/AWGL/AWEngine.cs b/AWGL/AWEngine.cs
deleted file mode 100644
index 85bb98f..0000000
--- a/AWGL/AWEngine.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// AWEngine Main Entry Piont
-    /// </summary>
-    public sealed class AWEngine
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile AWEngine instance = new AWEngine();
-        private static object syncRoot = new Object();
-
-        private AWEngine() { }
-
-        public static AWEngine Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new AWEngine();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        [STAThread]
-        public static void Main()
-        {
-            using (AWEngineWindow game = new AWEngineWindow())
-            {
-                game.Run(30,0);
-            }
-        }
-
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
-            
-        }
-    }
-}
diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 5482d11..9256ae5 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -42,3 +42,3 @@ namespace AWGL
         public AWEngineWindow()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngine.AppName, GameWindowFlags.Default, 
+            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -168,3 +168,3 @@ namespace AWGL
         {
-            this.Title = AWEngine.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             GL.Viewport(0, 0, Width, Height);
@@ -266,2 +266,19 @@ namespace AWGL
 
+        [STAThread]
+        public static void Main()
+        {
+            using (AWEngineWindow window = new AWEngineWindow())
+            {
+                window.Run();
+            }
+        }
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+
+        }
     }
diff --git a/AWGL/AWOldEngineWindow.cs b/AWGL/AWOldEngineWindow.cs
new file mode 100644
index 0000000..8b85c34
--- /dev/null
+++ b/AWGL/AWOldEngineWindow.cs
@@ -0,0 +1,253 @@
+﻿using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Controls Main Window functions and sets up OpenGL
+    /// </summary>
+    public class AWOldEngineWindow : GameWindow
+    {
+        #region Constructor
+
+        public AWOldEngineWindow() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
+            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
+            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
+        {
+            //set context
+            //this.WindowState = WindowState.Fullscreen;
+            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
+            
+            //create player camera
+            playerView = new Camera();
+
+            //register key list
+            keyList = new List<Key>();
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+
+            //InitialiseNodes
+            worldRoot = new AWGroupNode();
+            landRoot = new AWGroupNode();
+            graph = new AWGraphLines(20); ;
+            cube = new AWCube();
+            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
+
+            //create scenegraph
+            worldRoot.AddChild(graph);
+            worldRoot.AddChild(landRoot);
+
+            landRoot.SetTranslation(0, .5, -10);
+            landRoot.AddChild(cube);
+
+            m_sceneGraph = worldRoot;
+
+            m_hook1 = landRoot;
+
+            cubePosY = 1.5f;
+            playerView.Move(0f, 0f, 0.1f);
+
+            //shaderManager = new AWShaderManager();
+            //GL.UseProgram(shaderManager.ProgramID);
+        }
+
+        #endregion
+
+        #region Fields
+
+        protected Camera playerView;
+
+        private Color4 m_backgroundColor;
+        private List<Key> keyList;
+
+        //scenegraph
+        private AWNode m_sceneGraph;
+        private AWGroupNode worldRoot, landRoot;
+        private AWGraphLines graph;
+        private AWCube cube;
+        private TorusKnot knot;
+        private AWGroupNode m_hook1;
+
+        private const float m_rotationspeed = 180.0f;
+        private float m_spinangle, cubePosY;
+
+        private ShaderManager shaderManager;
+
+        #endregion
+
+        #region OnLoad
+        /// <summary>
+        /// Setup OpenGL and load resources here.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            //Title = AWUtils.PrintOpenGLInfo();
+
+            GL.ClearColor(m_backgroundColor);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Respond to resize events here.
+        /// </summary>
+        /// <param name="e">Contains information on the new GameWindow size.</param>
+        /// <remarks>There is no need to call the base implementation.</remarks>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            GL.Viewport(0, 0, Width, Height);
+            float aspect_ratio = Width / (float)Height;
+            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+        }
+        #endregion
+
+        #region OnFocusChanged
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnUpdateFrame
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            base.OnUpdateFrame(e);
+
+            if (Focused)
+            {
+                MoveCamera();
+
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+
+                playerView.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            m_spinangle += m_rotationspeed * (float)e.Time;
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 lookat = playerView.GetViewMatrix();
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
+
+            m_sceneGraph.Render();
+
+            SwapBuffers();
+        }
+
+        #endregion
+
+        #region Input & Camera
+
+        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyList.Add(e.Key);
+        }
+
+        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < keyList.Count; count++)
+            {
+                if (keyList[count] == e.Key)
+                {
+                    keyList.Remove(keyList[count]);
+                }
+            }
+        }
+
+        private void MoveCamera()
+        {
+            foreach (OpenTK.Input.Key key in keyList)
+            {
+
+                switch (key)
+                {
+                    case OpenTK.Input.Key.Escape:
+                        Exit();
+                        break;
+
+                    case OpenTK.Input.Key.W:
+                        playerView.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.A:
+                        playerView.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.S:
+                        playerView.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.D:
+                        playerView.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case OpenTK.Input.Key.Q:
+                        playerView.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.E:
+                        playerView.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case OpenTK.Input.Key.Up:
+                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
+                        break;
+
+                    case OpenTK.Input.Key.Down:
+                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+        
+        private void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        #endregion
+
+    }
+}
\ No newline at end of file
diff --git a/AWGL/AWOldScene.cs b/AWGL/AWOldScene.cs
deleted file mode 100644
index 51cd98d..0000000
--- a/AWGL/AWOldScene.cs
+++ /dev/null
@@ -1,253 +0,0 @@
-﻿using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Shapes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class AWOldScene : GameWindow
-    {
-        #region Constructor
-
-        public AWOldScene() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new Camera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(20); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected Camera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private ShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
new file mode 100644
index 0000000..d2f066d
--- /dev/null
+++ b/AWGL/Managers/InputManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class InputManager
+    {
+    }
+}
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
new file mode 100644
index 0000000..0ad1daa
--- /dev/null
+++ b/AWGL/Managers/ModelManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class ModelManager
+    {
+    }
+}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
new file mode 100644
index 0000000..687a689
--- /dev/null
+++ b/AWGL/Managers/TextureManager.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    class TextureManager
+    {
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 5b1701d..2a71e55 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -17,3 +17,3 @@ namespace AWGL.Utilities
         {
-            Debug.WriteLine(AWEngine.AppName + " Logger: " + output.Trim());
+            Debug.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1ec030b90150c26c05f7f8457d40fe9837aa8443">~</a>  -  1ec030b</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 9256ae5..068b970 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -21,2 +21,11 @@ namespace AWGL
         #region Members
+
+        public static string AppName
+        {
+            get
+            {
+                return "AWEngine";
+            }
+
+        }
         int modelviewMatrixLocation,
@@ -275,10 +284,2 @@ namespace AWGL
 
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
-
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/53c8ece7f02fb44a36b41dc914bc173c525ac703">Precise Timer.</a>  -  53c8ece</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 2 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 068b970..efc1b52 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -50,2 +50,5 @@ namespace AWGL
 
+        PreciseTimer m_Timer = new PreciseTimer();
+        public delegate void OnRenderFrame(double elapsedTime);
+
         public AWEngineWindow()
@@ -280,3 +283,3 @@ namespace AWGL
             {
-                window.Run();
+                window.Run(30, 60);
             }
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
new file mode 100644
index 0000000..b5f8c46
--- /dev/null
+++ b/AWGL/Utilities/PreciseTimer.cs
@@ -0,0 +1,38 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class PreciseTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public PreciseTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public double GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+            double elapsedTime = (double)(time - m_previouslyElapsedTime) / (double)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6966da4527604eab92bed9932d317363f3077cff">added external-game</a>  -  6966da4</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 4 files changed, 102 insertions(+), 18 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index efc1b52..ba0d1a8 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -18,3 +18,6 @@ namespace AWGL
 {
-    public class AWEngineWindow : GameWindow, IDisposable
+    /// <summary>
+    /// Inherit me
+    /// </summary>
+    public abstract class AWEngineWindow : GameWindow, IDisposable
     {
@@ -49,8 +52,10 @@ namespace AWGL
         #endregion
+        
+        protected PreciseTimer m_Timer = new PreciseTimer();
 
-        PreciseTimer m_Timer = new PreciseTimer();
-        public delegate void OnRenderFrame(double elapsedTime);
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
 
-        public AWEngineWindow()
-            : base(1024, 680, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+        public AWEngineWindow(int height, int width)
+            : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -163,2 +168,3 @@ namespace AWGL
         {
+            #region Input
             if (Focused)
@@ -172,3 +178,4 @@ namespace AWGL
 
-            MoveCamera();
+            MoveCamera(); 
+            #endregion
 
@@ -176,6 +183,11 @@ namespace AWGL
             GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+
+            UpdateFrame(m_Timer.GetElapsedTime());
         }
 
+        new public abstract void UpdateFrame(double elapsedTime);
+
         protected override void OnRenderFrame(FrameEventArgs e)
         {
+            base.OnRenderFrame(e);
             this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
@@ -191,5 +203,13 @@ namespace AWGL
                 //);
-
             SwapBuffers();
-        } 
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, Width, Height);
+
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+        }
         #endregion
@@ -277,12 +297,2 @@ namespace AWGL
         #endregion
-
-        [STAThread]
-        public static void Main()
-        {
-            using (AWEngineWindow window = new AWEngineWindow())
-            {
-                window.Run(30, 60);
-            }
-        }
-
     }
diff --git a/Game/Program.cs b/Game/Program.cs
new file mode 100644
index 0000000..fa3b2ec
--- /dev/null
+++ b/Game/Program.cs
@@ -0,0 +1,17 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Game
+{
+    static class Program
+    {
+        [STAThread]
+        static void Main()
+        {
+            using (Window game = new Window(1024, 600)) { game.Run(); }
+        }
+    }
+}
new file mode 100644
index 0000000..2ff6e9a
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Game")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("Game")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("4eace48b-4870-46ff-b611-f513a0f075d3")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/Game/Window.cs b/Game/Window.cs
new file mode 100644
index 0000000..c590d7e
--- /dev/null
+++ b/Game/Window.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using AWGL;
+
+namespace Game
+{
+    class Window : AWEngineWindow
+    {
+        public Window(int width, int height) : base(width, height) { }
+
+        public override void UpdateFrame(double elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+    }
+
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7bf73e3f9a8dedc0e90a9b5ca119e557bc188d70">Squashed commit of the following:</a>  -  7bf73e3</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 16 files changed, 508 insertions(+), 111 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index ba0d1a8..4e2185f 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -23,4 +23,3 @@ namespace AWGL
     {
-        #region Members
-
+        #region Old code
         public static string AppName
@@ -49,7 +48,7 @@ namespace AWGL
         AWGraphLines graph;
-        Camera camera;
-        List<Key> keyList;
         #endregion
-        
-        protected PreciseTimer m_Timer = new PreciseTimer();
+
+        protected PreciseTimer m_Timer;
+        protected Camera camera;
+        protected List<Key> keyList;
 
@@ -63,24 +62,28 @@ namespace AWGL
 
-        #region OpenGL Setup
+        #region Load everything here
         protected override void OnLoad(System.EventArgs e)
         {
-            VSync = VSyncMode.On;
-            
+            m_Timer = new PreciseTimer();
+
+            //CameraManager
             camera = new Camera();
+            
+            // InputManager
             keyList = new List<Key>();
-
             Keyboard.KeyDown += HandleKeyDown;
             Keyboard.KeyUp += HandleKeyUp;
-            
-            root = new AWGroupNode();
-            group = new AWGroupNode();
-            cube = new AWCube();
-            graph = new AWGraphLines(20);
-            CreateShaders();
-            CreateVBOs();
-            CreateVAOs();
-
-            // Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.CornflowerBlue);
+
+            #region Old Code
+            //root = new AWGroupNode();
+            //group = new AWGroupNode();
+            //cube = new AWCube();
+            //graph = new AWGraphLines(20);
+            //CreateShaders();
+            //CreateVBOs();
+            //CreateVAOs();
+
+            //// Other state
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.ClearColor(Color.CornflowerBlue); 
+            #endregion
 
@@ -88,5 +91,10 @@ namespace AWGL
             AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif
+#endif      
+            Initialise();
         }
 
+        public abstract void Initialise();
+        #endregion
+
+        #region Old Code
         #region Create Shaders
@@ -94,10 +102,10 @@ namespace AWGL
         {
-            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+            //shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
 
-            GL.UseProgram(shaderManager.ProgramHandle);
+            //GL.UseProgram(shaderManager.ProgramHandle);
 
-            shaderManager.SetUniforms(
-                out projectionMatrixLocation, out modelviewMatrixLocation,
-                out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            );
+            //shaderManager.SetUniforms(
+            //    out projectionMatrixLocation, out modelviewMatrixLocation,
+            //    out projectionMatrix, modelviewMatrix, ClientSize, ref camera
+            //);
         }
@@ -108,20 +116,20 @@ namespace AWGL
         {
-            Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
+            //Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
+            //System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
+            //System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
 
-            positionVboHandle = BufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //positionVboHandle = BufferManager.SetupBuffer(
+            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            normalVboHandle = BufferManager.SetupBuffer(
-                aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //normalVboHandle = BufferManager.SetupBuffer(
+            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            eboHandle = BufferManager.SetupBuffer(
-                cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-                );
+            //eboHandle = BufferManager.SetupBuffer(
+            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
+            //    );
 
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
         }
@@ -145,12 +153,12 @@ namespace AWGL
 
-            BufferManager.SetupVaoBuffer(positionVboHandle,
+            //BufferManager.SetupVaoBuffer(positionVboHandle,
 
-                shaderManager.ProgramHandle, 0, 3, "in_position",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
-            BufferManager.SetupVaoBuffer(normalVboHandle,
+            //    shaderManager.ProgramHandle, 0, 3, "in_position",
+            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+            //    );
+            //BufferManager.SetupVaoBuffer(normalVboHandle,
 
-                shaderManager.ProgramHandle, 1, 3, "in_normal",
-                BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-                );
+            //    shaderManager.ProgramHandle, 1, 3, "in_normal",
+            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
+            //    );
 
@@ -158,10 +166,10 @@ namespace AWGL
 
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
 
-            GL.BindVertexArray(0);
+            //GL.BindVertexArray(0);
         }
-        #endregion 
+        #endregion  
         #endregion
 
-        #region MAIN LOOP
+        #region Game Loop
         protected override void OnUpdateFrame(FrameEventArgs e)
@@ -169,10 +177,10 @@ namespace AWGL
             #region Input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            //if (Focused)
+            //{
+            //    Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            //    Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
+            //    camera.AddRotation(delta.X, delta.Y);
+            //    ResetCursor();
+            //}
 
@@ -181,9 +189,9 @@ namespace AWGL
 
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
-
-            UpdateFrame(m_Timer.GetElapsedTime());
+            #region Old Code
+            //Matrix4 lookat = camera.GetViewMatrix();
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            #endregion
         }
 
-        new public abstract void UpdateFrame(double elapsedTime);
+        new public abstract void UpdateFrame(float elapsedTime);
 
@@ -192,13 +200,19 @@ namespace AWGL
             base.OnRenderFrame(e);
-            this.Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            GL.Viewport(0, 0, Width, Height);
 
+            Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+            
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
-            GL.BindVertexArray(vaoHandle);
-            GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-                //PrimitiveType.Lines, cube.Indices.Length,
-                //DrawElementsType.UnsignedInt, IntPtr.Zero
-                //);
+            #region Old Code
+            //GL.BindVertexArray(vaoHandle);
+            //GL.DrawArrays(PrimitiveType.Lines, 0, 20);
+            //GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
+            //PrimitiveType.Lines, cube.Indices.Length,
+            //DrawElementsType.UnsignedInt, IntPtr.Zero
+            //); 
+            #endregion
+
+            // Single call to StateRenderer to take place here.
+            RenderFrame(m_Timer.GetElapsedTime());
+
             SwapBuffers();
@@ -206,2 +220,4 @@ namespace AWGL
 
+        new public abstract void RenderFrame(float elapsedTime);
+
         protected override void OnResize(EventArgs e)
@@ -209,6 +225,8 @@ namespace AWGL
             base.OnResize(e);
-            GL.Viewport(0, 0, Width, Height);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
 
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat);
+            #region Old Code
+            //Matrix4 lookat = camera.GetViewMatrix();
+            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            #endregion
         }
@@ -220,3 +238,3 @@ namespace AWGL
             base.Dispose();
-            shaderManager.Dispose();
+            //shaderManager.Dispose();
         } 
@@ -248,3 +266,3 @@ namespace AWGL
                 {
-                    case OpenTK.Input.Key.Escape:
+                    case Key.Escape:
                         Exit();
@@ -291,6 +309,6 @@ namespace AWGL
 
-            if (Focused)
-            {
-                ResetCursor();
-            }
+            //if (Focused)
+            //{
+            //    ResetCursor();
+            //}
         } 
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..f0656a9
--- /dev/null
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index d2f066d..3cecb80 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -7,3 +7,3 @@ namespace AWGL.Managers
 {
-    class InputManager
+    public static class InputManager
     {
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
new file mode 100644
index 0000000..f839772
--- /dev/null
+++ b/AWGL/Managers/StateManager.cs
@@ -0,0 +1,46 @@
+﻿using AWGL.Interfaces;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers
+{
+    public class StateManager
+    {
+        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        IGameObject currentState = null;
+
+        public void Update(float elapsedTime)
+        {
+            if (currentState == null)
+                return;
+            currentState.Update(elapsedTime);
+        }
+
+        public void Render()
+        {
+            if (currentState == null)
+                return;
+            currentState.Render();
+        }
+
+        public void AddState(string stateName, IGameObject state)
+        {
+            Debug.Assert( Exists(stateName) == false );
+            stateStore.Add(stateName, state);
+        }
+
+        public void ChangeState(string stateName)
+        {
+            Debug.Assert( Exists(stateName) );
+            currentState = stateStore[stateName];
+        }
+
+        public bool Exists(string stateName)
+        {
+            return stateStore.ContainsKey(stateName);
+        }
+    }
+}
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
new file mode 100644
index 0000000..b5ee17a
--- /dev/null
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -0,0 +1,23 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+using NUnit.Framework;
+using AWGL.States;
+
+namespace AWGL.Managers.Tests
+{
+    [TestFixture]
+    public class StateManagerTest
+    {
+        [Test]
+        public void TestAddStateExists()
+        {
+            StateManager stateManager = new StateManager();
+            stateManager.AddState("test-state", new SplashScreenState(stateManager));
+
+            Assert.IsTrue(stateManager.Exists("test-state"));
+        }
+    }
+}
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
new file mode 100644
index 0000000..9533adb
--- /dev/null
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -0,0 +1,11 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Managers.Tests
+{
+    class TextureManagerTest
+    {
+    }
+}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 687a689..f6b9687 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -1,3 +1,7 @@
-﻿using System;
+﻿using AWGL.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
 using System.Linq;
@@ -7,4 +11,48 @@ namespace AWGL.Managers
 {
-    class TextureManager
+    public class TextureManager : IDisposable
     {
+        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+
+        public Texture Get(string textureId)
+        {
+            return m_textureDatabase[textureId];
+        }
+
+        private Bitmap bitmap;
+        private int textureGpuHandle;
+
+        public void LoadTexture(string textureId, string path)
+        {
+            new Bitmap("Data/Textures/logo.jpg");
+            bitmap = new Bitmap(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height);
+        }
+
+        #region MyRegion
+        
+        #endregion
+
+
+        public void Dispose()
+        {
+            foreach (Texture t in m_textureDatabase.Values)
+            {
+                GL.DeleteTextures(1, new int[] { t.ID });
+            }
+            bitmap.Dispose();
+        }
     }
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
new file mode 100644
index 0000000..70930e5
--- /dev/null
+++ b/AWGL/States/DefaultState.cs
@@ -0,0 +1,48 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class DefaultState : IGameObject
+    {
+        double currentRotation = 0;
+
+        StateManager m_stateManager;
+        public DefaultState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.PointSize(5f);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.TriangleStrip);
+
+            GL.Color4(new Color4(1f, 0f, 0f, .5f));
+            GL.Vertex3(new Vector3(-50f, 0f, 0f));
+            GL.Color3(new Vector3(0f, 1f, 0f));
+            GL.Vertex3(new Vector3(50f, 0, 0));
+            GL.Color3(new Vector3(0f, 0f, 1f));
+            GL.Vertex3(new Vector3(0f, 50f, 0));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
new file mode 100644
index 0000000..f905683
--- /dev/null
+++ b/AWGL/States/DrawSpriteState.cs
@@ -0,0 +1,58 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class DrawSpriteState : IGameObject
+    {
+        private ShaderManager m_shaderManager;
+        private StateManager m_stateManager;
+
+        double height, width, halfHeight, halfWidth, x, y, z;
+
+        #region IGameObject States
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+
+            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+
+            GL.End();
+
+        } 
+        #endregion
+        public DrawSpriteState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+            this.height = 200;
+            this.width = 200;
+
+            this.halfHeight = this.height / 2;
+            this.halfWidth = this.width / 2;
+
+            this.x = 0;
+            this.y = 0;
+            this.z = 2;
+        }
+    }
+}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
new file mode 100644
index 0000000..7477640
--- /dev/null
+++ b/AWGL/States/SplashScreenState.cs
@@ -0,0 +1,51 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Timers;
+
+namespace AWGL.States
+{
+    public class SplashScreenState : IGameObject
+    {
+        double currentRotation = 0;
+        double delay = 300;
+
+        StateManager m_stateManager;
+        public SplashScreenState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            delay--;
+            if (delay <= 0){
+                delay = 3;
+                m_stateManager.ChangeState("Default");
+            }
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
index b5f8c46..6fe09fc 100644
--- a/AWGL/Utilities/PreciseTimer.cs
+++ b/AWGL/Utilities/PreciseTimer.cs
@@ -27,3 +27,3 @@ namespace AWGL.Utilities
 
-        public double GetElapsedTime()
+        public float GetElapsedTime()
         {
@@ -31,3 +31,4 @@ namespace AWGL.Utilities
             QueryPerformanceCounter(ref time);
-            double elapsedTime = (double)(time - m_previouslyElapsedTime) / (double)m_ticksPerSecond;
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
 
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
new file mode 100644
index 0000000..41e0f76
--- /dev/null
+++ b/AWGL/Utilities/Renderer.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    static class Renderer
+    {
+
+        public static void DrawSkyBox()
+        {
+
+        }
+    }
+}
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
new file mode 100644
index 0000000..604d0d5
--- /dev/null
+++ b/AWGL/Utilities/Texture.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct Texture
+    {
+        public int ID { get; set; }
+        public int Width { get; set; }
+        public int Height { get; set; }
+
+        public Texture(int id, int width, int height) :this()
+        {
+            ID = id;
+            Width = width;
+            Height = Height;
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
new file mode 100644
index 0000000..dc84871
--- /dev/null
+++ b/Game/Game.cs
@@ -0,0 +1,64 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+using AWGL;
+
+using OpenTK.Graphics.OpenGL;
+using AWGL.Managers;
+using AWGL.States;
+
+namespace Game
+{
+    class Game : AWEngineWindow
+    {
+        public StateManager stateManager;
+
+        public Game(int width, int height) : base(width, height) { }
+
+        private void Setup2DGraphics(double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -100, 100);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            Setup2DGraphics(ScreenWidth, ScreenHeight);
+        }
+
+        public override void Initialise()
+        {
+            Setup2DGraphics(ScreenWidth, ScreenHeight);
+
+            stateManager = new StateManager();
+            stateManager.AddState("Splash", new SplashScreenState(stateManager));
+            stateManager.AddState("Default", new DefaultState(stateManager));
+            stateManager.AddState("Drawing", new DrawSpriteState(stateManager));
+
+            stateManager.ChangeState("Drawing");
+        }
+
+        public override void UpdateFrame(float elapsedTime)
+        {
+            
+        }
+
+        public override void RenderFrame(float elapsedTime)
+        {
+            stateManager.Update(elapsedTime);
+            stateManager.Render();
+        }
+
+    }
+
+
+}
diff --git a/Game/Program.cs b/Game/Program.cs
index fa3b2ec..8d228e5 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Window game = new Window(1024, 600)) { game.Run(); }
+            using (Game game = new Game(1024, 600)) { game.Run(30, 60); }
         }
diff --git a/Game/Window.cs b/Game/Window.cs
deleted file mode 100644
index c590d7e..0000000
--- a/Game/Window.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using AWGL;
-
-namespace Game
-{
-    class Window : AWEngineWindow
-    {
-        public Window(int width, int height) : base(width, height) { }
-
-        public override void UpdateFrame(double elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-
-
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eac1948d6ffe6cc3e9ef68c35a8174bf35ccc073">missing parentheses</a>  -  eac1948</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index f6b9687..29ec82f 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -41,3 +41,3 @@ namespace AWGL.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height);
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height));
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8fabcf8fa8919b98156e277547472e24b1de530c">Sprites.</a>  -  8fabcf8</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 4 files changed, 71 insertions(+), 15 deletions(-)

diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 9533adb..83a2473 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -5,6 +5,20 @@ using System.Text;
 
+using NUnit.Framework;
+using AWGL.Utilities;
+
 namespace AWGL.Managers.Tests
 {
-    class TextureManagerTest
+    [TestFixture]
+    public class TextureManagerTest
     {
+        [Test]
+        public void TestLoadTexture()
+        {
+            //string textureid = "test-texture";
+            //Texture t = new Texture();
+            //TextureManager manager = new TextureManager();
+            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
+
+            Assert.IsTrue(true);
+        }
     }
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 29ec82f..73c4e82 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -21,2 +21,4 @@ namespace AWGL.Managers
         private Bitmap bitmap;
+        private BitmapData bitmapData;
+
         private int textureGpuHandle;
@@ -25,4 +27,4 @@ namespace AWGL.Managers
         {
-            new Bitmap("Data/Textures/logo.jpg");
-            bitmap = new Bitmap(path);
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
 
@@ -30,14 +32,25 @@ namespace AWGL.Managers
             GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            
+            try
+            {
+                bitmap = new Bitmap(path);
+                bitmap.Save("test.bmp", ImageFormat.Bmp);
+                bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            }
+            catch (Exception e)
+            {
+                Logger.WriteLine("Error loading texture.");
+            }
 
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
 
-            bitmap.UnlockBits(data);
+            bitmap.UnlockBits(bitmapData);
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, data.Width, data.Height));
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
         }
@@ -45,3 +58,3 @@ namespace AWGL.Managers
         #region MyRegion
-        
+
         #endregion
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index f905683..7c2c9e1 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -2,2 +2,3 @@
 using AWGL.Managers;
+using AWGL.Utilities;
 using OpenTK;
@@ -14,6 +15,7 @@ namespace AWGL.States
     {
-        private ShaderManager m_shaderManager;
         private StateManager m_stateManager;
+        private TextureManager m_textureManager;
 
         double height, width, halfHeight, halfWidth, x, y, z;
+        float topUV, bottomUV, leftUV, rightUV;
 
@@ -28,2 +30,7 @@ namespace AWGL.States
         {
+            Texture texture = m_textureManager.Get("test");
+            GL.Enable(EnableCap.Texture2D);
+            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
             GL.ClearColor(Color.Black);
@@ -31,8 +38,14 @@ namespace AWGL.States
 
+            GL.TexCoord2(new Vector2d(leftUV, topUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
 
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
             GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
@@ -43,5 +56,11 @@ namespace AWGL.States
         #endregion
-        public DrawSpriteState(StateManager stateManager)
+        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
         {
             m_stateManager = stateManager;
+            m_textureManager = texturManager;
+            Initialise();
+        }
+
+        private void Initialise()
+        {
             this.height = 200;
@@ -55,2 +74,7 @@ namespace AWGL.States
             this.z = 2;
+
+            this.topUV = 0;
+            this.bottomUV = 1;
+            this.leftUV = 0;
+            this.rightUV = 1;
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index dc84871..15f2687 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -17,2 +17,3 @@ namespace Game
         public StateManager stateManager;
+        public TextureManager texManager;
 
@@ -41,2 +42,6 @@ namespace Game
 
+            texManager = new TextureManager();
+
+            texManager.LoadTexture("test", "Data/Textures/logo.jpg");
+
             stateManager = new StateManager();
@@ -44,3 +49,3 @@ namespace Game
             stateManager.AddState("Default", new DefaultState(stateManager));
-            stateManager.AddState("Drawing", new DrawSpriteState(stateManager));
+            stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a923f153be3b9e117e85a1a3a814c2440be0feda">Incomplete work on Sprite and Renderer classes.</a>  -  a923f15</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 6 files changed, 214 insertions(+), 12 deletions(-)

diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 7c2c9e1..3233424 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
         {
-            Texture texture = m_textureManager.Get("test");
+            Texture texture = m_textureManager.Get("sprite1");
             GL.Enable(EnableCap.Texture2D);
@@ -39,14 +39,14 @@ namespace AWGL.States
             GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y+halfHeight, 0)); //top left
+            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
             GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
             GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
 
             GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+halfHeight, 0)); //top right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
             GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x+halfWidth, y+-halfHeight, 0)); //bottom right
+            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
             GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x-halfWidth, y-halfHeight, 0)); //bottom left
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
 
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
new file mode 100644
index 0000000..a23de30
--- /dev/null
+++ b/AWGL/States/TestSpriteClassState.cs
@@ -0,0 +1,45 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class TestSpriteClassState : IGameObject
+    {
+        Renderer m_renderer = new Renderer();
+        TextureManager m_textureManager = new TextureManager();
+        Sprite sprite1 = new Sprite();
+        Sprite sprite2 = new Sprite();
+
+        public TestSpriteClassState(TextureManager textureManager)
+        {
+            m_textureManager = textureManager;
+            sprite1.Texture = m_textureManager.Get("sprite1");
+            //sprite1.SetHeight(256 * 0.5f);
+
+            sprite2.Texture = m_textureManager.Get("sprite2");
+            sprite2.SetPosition(new Vector3d(-2, -2, 0));
+            //sprite2.SetColour(new Color4(1, 0, 0, 1));
+        }
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(0f, 0f, 0f, 1f);
+            m_renderer.DrawSprite(sprite1);
+            m_renderer.DrawSprite(sprite2);
+            GL.Finish();
+        }
+    }
+}
diff --git a/AWGL/Utilities/Point.cs b/AWGL/Utilities/Point.cs
new file mode 100644
index 0000000..5f28270
--- /dev/null
+++ b/AWGL/Utilities/Point.cs
@@ -0,0 +1 @@
+﻿
\ No newline at end of file
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 41e0f76..5022a5d 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,5 @@
-﻿using System;
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
 using System.Collections.Generic;
@@ -7,6 +10,34 @@ namespace AWGL.Utilities
 {
-    static class Renderer
+    class Renderer
     {
+        public Renderer()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
+        }
+
+        public void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        {
+            GL.Color4(color);
+            GL.TexCoord2(uvs);
+            GL.Vertex3(position);
+        }
+
+        public void DrawSprite(Sprite sprite)
+        {
+            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
+            GL.Begin(PrimitiveType.Triangles);
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                DrawImmediateModeVertex(
+                    sprite.VertexPositions[i],
+                    sprite.VertexColours[i],
+                    sprite.VertexUVs[i]);
+
+            }
+            GL.End();
+        }
 
-        public static void DrawSkyBox()
+        public void DrawSkyBox()
         {
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
new file mode 100644
index 0000000..ecaf2ad
--- /dev/null
+++ b/AWGL/Utilities/Sprite.cs
@@ -0,0 +1,123 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class Sprite
+    {
+        internal const int VertexAmount = 6;
+        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
+        Color4[] vertexColours = new Color4[VertexAmount];
+        Vector2[] vertexUVs = new Vector2[VertexAmount];
+        Texture texture = new Texture();
+
+        public Texture Texture
+        {
+            get { return texture; }
+            set
+            {
+                texture = value;
+
+                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
+            }
+        }
+        public Vector3d[] VertexPositions { get { return vertexPositions; } }
+
+        public Color4[] VertexColours { get { return vertexColours; } }
+
+        public Vector2[] VertexUVs { get { return vertexUVs; } }
+
+        public Sprite()
+        {
+            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
+            SetColour(new Color4(1, 1, 1, 1));
+            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
+        }
+
+        private Vector3d GetCentre()
+        {
+            double halfWidth = GetWidth() / 2;
+            double halfHeight = GetHeight() / 2;
+
+            return new Vector3d(
+                vertexPositions[0].X + halfWidth,
+                vertexPositions[0].Y - halfHeight,
+                vertexPositions[0].Z);
+        }
+
+        private void InitVertexPositions(Vector3d position, double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+
+            //GL.TexCoord2(new Vector2d(leftUV, topUV));
+            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
+            //GL.TexCoord2(new Vector2d(rightUV, topUV));
+            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+
+            //GL.TexCoord2(new Vector2d(rightUV, topUV));
+            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            //GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
+            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+        }
+
+        public double GetWidth()
+        {
+            //top right -> top left
+            return vertexPositions[1].X - vertexPositions[0].X;
+        }
+
+        public double GetHeight()
+        {
+            //top left -> bottom left
+            return vertexPositions[0].Y - vertexPositions[2].Y;
+        }
+
+        public void SetWidth(double width)
+        {
+            InitVertexPositions(GetCentre(), width, GetHeight());
+        }
+
+        public void SetHeight(double height)
+        {
+            InitVertexPositions(GetCentre(), GetWidth(), height);
+        }
+
+        public void SetPosition(double x, double y)
+        {
+            SetPosition(new Vector3d(x, y, 0));
+        }
+
+        public void SetPosition(Vector3d position)
+        {
+            InitVertexPositions(position, GetWidth(), GetHeight());
+        }
+
+        public void SetColour(Color4 color4)
+        {
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                vertexColours[i] = color4;
+            }
+        }
+
+        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
+        {
+            vertexUVs[0] = topLeft;
+            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
+
+            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[4] = bottomRight;
+            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 15f2687..59528f3 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -44,3 +44,4 @@ namespace Game
 
-            texManager.LoadTexture("test", "Data/Textures/logo.jpg");
+            texManager.LoadTexture("sprite1", "Data/Textures/metal.jpg");
+            texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
 
@@ -50,4 +51,5 @@ namespace Game
             stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
+            stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
 
-            stateManager.ChangeState("Drawing");
+            stateManager.ChangeState("TestTexture");
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/07607047892e5e246634a238485ab91a5e5a1e7d">working after a bit of a hitch</a>  -  0760704</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 5 files changed, 13 insertions(+), 14 deletions(-)

diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 3233424..3588115 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -56,2 +56,3 @@ namespace AWGL.States
         #endregion
+
         public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
index a23de30..814b797 100644
--- a/AWGL/States/TestSpriteClassState.cs
+++ b/AWGL/States/TestSpriteClassState.cs
@@ -24,7 +24,10 @@ namespace AWGL.States
             sprite1.Texture = m_textureManager.Get("sprite1");
-            //sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetPosition(new Vector3d(100, 100, 0));
+            sprite1.SetColour(new Color4(256, 256, 256, 1));
 
             sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetPosition(new Vector3d(-2, -2, 0));
-            //sprite2.SetColour(new Color4(1, 0, 0, 1));
+            sprite2.SetHeight(256 * .5f);
+            sprite2.SetPosition(new Vector3d(-100, -100, 0));
+            sprite2.SetColour(new Color4(256, 256, 256, 1));
         }
@@ -38,3 +41,3 @@ namespace AWGL.States
         {
-            GL.ClearColor(0f, 0f, 0f, 1f);
+            GL.ClearColor(1f, 1f, 1f, 1f);
             m_renderer.DrawSprite(sprite1);
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 5022a5d..22d380d 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -15,4 +15,4 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.Texture2D);
-            GL.Enable(EnableCap.Blend);
-            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
+            //GL.Enable(EnableCap.Blend);
+            //GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
         }
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
index ecaf2ad..6cf4b1f 100644
--- a/AWGL/Utilities/Sprite.cs
+++ b/AWGL/Utilities/Sprite.cs
@@ -36,3 +36,3 @@ namespace AWGL.Utilities
             InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            SetColour(new Color4(1, 1, 1, 1));
+            //SetColour(new Color4(1, 1, 1, 1));
             SetUVs(new Vector2(0, 0), new Vector2(1, 1));
@@ -56,14 +56,8 @@ namespace AWGL.Utilities
 
-            //GL.TexCoord2(new Vector2d(leftUV, topUV));
             vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            //GL.TexCoord2(new Vector2d(rightUV, topUV));
             vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
 
-            //GL.TexCoord2(new Vector2d(rightUV, topUV));
             vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            //GL.TexCoord2(new Vector2d(rightUV, bottomUV));
             vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            //GL.TexCoord2(new Vector2d(leftUV, bottomUV));
             vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
diff --git a/Game/Game.cs b/Game/Game.cs
index 59528f3..610b1cf 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -44,3 +44,3 @@ namespace Game
 
-            texManager.LoadTexture("sprite1", "Data/Textures/metal.jpg");
+            texManager.LoadTexture("sprite1", "Data/Textures/logo.jpg");
             texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
@@ -53,2 +53,3 @@ namespace Game
 
+            //stateManager.ChangeState("Drawing");
             stateManager.ChangeState("TestTexture");

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/4003e2a9ab743d98ef1fdad4a1ba182ecea62042">Squashed commit of the following:</a>  -  4003e2a</p><p>authored by Anthony Woodward, 10 weeks ago</p></div><pre>
 15 files changed, 305 insertions(+), 54 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 4e2185f..803587e 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,6 +39,2 @@ namespace AWGL
 
-        Matrix4 projectionMatrix, modelviewMatrix;
-
-        ShaderManager shaderManager;
-
         AWNode m_sceneGraph;
@@ -53,2 +49,4 @@ namespace AWGL
         protected List<Key> keyList;
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected ShaderManager shaderManager;
 
@@ -57,5 +55,5 @@ namespace AWGL
 
-        public AWEngineWindow(int height, int width)
+        public AWEngineWindow(int height, int width, int major, int minor)
             : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 3, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
@@ -75,2 +73,4 @@ namespace AWGL
 
+            CreateShaders();
+            
             #region Old Code
@@ -80,3 +80,3 @@ namespace AWGL
             //graph = new AWGraphLines(20);
-            //CreateShaders();
+            
             //CreateVBOs();
@@ -98,17 +98,20 @@ namespace AWGL
 
-        #region Old Code
-        #region Create Shaders
-        void CreateShaders()
+        private void CreateShaders()
         {
-            //shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
 
-            //GL.UseProgram(shaderManager.ProgramHandle);
+            GL.UseProgram(shaderManager.ProgramHandle);
 
-            //shaderManager.SetUniforms(
-            //    out projectionMatrixLocation, out modelviewMatrixLocation,
-            //    out projectionMatrix, modelviewMatrix, ClientSize, ref camera
-            //);
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+
+            float aspectRatio = ScreenWidth / (float)(ScreenHeight);
+            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
+            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));//camera.GetViewMatrix();
+
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
         }
-        #endregion
 
+        #region Old Code
         #region Create VBOs
@@ -177,10 +180,10 @@ namespace AWGL
             #region Input
-            //if (Focused)
-            //{
-            //    Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-            //    Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
 
-            //    camera.AddRotation(delta.X, delta.Y);
-            //    ResetCursor();
-            //}
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
 
@@ -190,5 +193,7 @@ namespace AWGL
             #region Old Code
-            //Matrix4 lookat = camera.GetViewMatrix();
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
             #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
         }
@@ -200,4 +205,10 @@ namespace AWGL
             base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = AWEngineWindow.AppName +
 
-            Title = AWEngineWindow.AppName + " - FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
             
@@ -228,4 +239,4 @@ namespace AWGL
             #region Old Code
-            //Matrix4 lookat = camera.GetViewMatrix();
-            //GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            Matrix4 lookat = camera.GetViewMatrix();
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
             #endregion
@@ -309,6 +320,6 @@ namespace AWGL
 
-            //if (Focused)
-            //{
-            //    ResetCursor();
-            //}
+            if (Focused)
+            {
+                ResetCursor();
+            }
         } 
diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
index 410ba8d..dff573e 100644
--- a/AWGL/Data/Shaders/CH02_FS.glsl
+++ b/AWGL/Data/Shaders/CH02_FS.glsl
@@ -1,2 +1,2 @@
-#version 330 core
+#version 140 core
 
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
index 4513442..6a17ae4 100644
--- a/AWGL/Data/Shaders/CH02_VS.glsl
+++ b/AWGL/Data/Shaders/CH02_VS.glsl
@@ -1,2 +1,2 @@
-﻿#version 330 core
+﻿#version 140 core
 
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index 46f2251..6b8e738 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 130
+﻿#version 140
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 3975262..98fde5b 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 130
+﻿#version 140
 
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
new file mode 100644
index 0000000..497ce1e
--- /dev/null
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -0,0 +1,95 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using AWGL.Utilities;
+using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Graphics;
+using System.Runtime.InteropServices;
+
+namespace AWGL.Managers
+{
+    public class BufferObjectManager
+    {
+        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
+
+        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        {
+            int bufferHandle;
+
+            #region Get sizes of buffer stores
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
+            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
+            IntPtr noOffset = new IntPtr(0);
+            #endregion
+
+            // Generate Vertex Buffer Object and bind it so it is current.
+            GL.GenBuffers(1, out bufferHandle);         
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
+
+            #region Save pointers generated by OpenGL here so i dont forget.
+            bufferObject.VboID = bufferHandle; 
+            #endregion
+            
+            #region Send all data to the Vertex Buffer
+            // Initialise storage space for the Vertex Buffer.
+            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
+            // Send Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            // Send Normals data, offset by size of Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            
+            GL.GenBuffers(1, out bufferHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, 
+                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
+                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+
+            bufferObject.IboID = bufferHandle;
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+            #endregion
+
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            // Generate Vertex Array Object and bind it so it is current.
+            GL.GenVertexArrays(1, out bufferHandle);
+            GL.BindVertexArray(bufferHandle);
+
+            bufferObject.VaoID = bufferHandle;
+
+            bufferHandle = GL.GetAttribLocation(program, "in_position");
+            GL.EnableVertexAttribArray(bufferHandle); 
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(program, bufferHandle, "in_position");
+
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            GL.EnableVertexAttribArray(bufferHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.BindAttribLocation(program, bufferHandle, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+
+            GL.BindVertexArray(bufferObject.VaoID);
+
+            m_bufferStore.Add(name, bufferObject);
+        }
+
+        public BufferObject GetBuffer(string name)
+        {
+            return m_bufferStore[name];
+        }
+    }
+}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 72b7fdd..7899c0e 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -17,3 +17,3 @@ namespace AWGL.Managers
     /// </summary>
-    class ShaderManager : IDisposable
+    public class ShaderManager : IDisposable
     {
@@ -85,3 +85,3 @@ namespace AWGL.Managers
                 GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
+                Logger.WriteLine("Program link failed: " + message);
             }
@@ -99,3 +99,3 @@ namespace AWGL.Managers
                 GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
+                Logger.WriteLine("Program validation failed" + message);
             }
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 73c4e82..22add0d 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -42,3 +42,3 @@ namespace AWGL.Managers
             {
-                Logger.WriteLine("Error loading texture.");
+                Logger.WriteLine("Error loading texture. " + e.Message);
             }
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index 7988a3f..a83299f 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using System.Runtime.InteropServices;
 
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
new file mode 100644
index 0000000..5d4d2b6
--- /dev/null
+++ b/AWGL/States/VboState.cs
@@ -0,0 +1,68 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using AWGL.Interfaces;
+using AWGL.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using System.Drawing;
+using System.Diagnostics;
+
+namespace AWGL.States
+{
+    public class VboState : IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        ShaderManager m_shaderManager;
+        Cube cube;
+
+        public VboState(StateManager stateManager, ShaderManager shaderManager)
+        {
+            m_stateManager = stateManager;
+            this.m_stateManager = stateManager;
+            this.m_shaderManager = shaderManager;
+
+            cube = new Cube();
+
+            CreateVBOs();
+
+            //// Other state
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.MidnightBlue);
+        }
+
+        private void CreateVBOs()
+        {
+            // this buffer object will take care of VAO generation temporarily - stored in bufferObject.VaoId
+            BufferObject tempVBO = new BufferObject();
+            tempVBO.PositionData = cube.Vertices;//new Vector3[cube.Vertices.Length];
+            tempVBO.NormalsData = cube.Normals; // Vector3[cube.Normals.Length];
+            tempVBO.IndicesData = cube.Indices;
+            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, m_shaderManager.ProgramHandle);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+
+        public void Render()
+        {
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType,
+                            m_bufferObject.IndicesData.Length,
+                            DrawElementsType.UnsignedInt,
+                            IntPtr.Zero);
+        }
+    }
+}
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
new file mode 100644
index 0000000..7b917da
--- /dev/null
+++ b/AWGL/Utilities/BufferObject.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct BufferObject
+    {
+        public int VaoID { get; set; }
+
+        public int VboID { get; set; }
+
+        public int IboID { get; set; }
+
+        public PrimitiveType PrimitiveType { get; set; }
+
+        public Vector3[] PositionData { get; set; }
+
+        public Vector3[] NormalsData { get; set; }
+
+        public Color4[] ColorData { get; set; }
+
+        public int[] IndicesData { get; set; }
+
+        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+        {
+            #region Buffer Pointer IDs
+            VaoID = vaoId;
+            VboID = vboId;
+            IboID = iboId;
+            #endregion
+            
+            PositionData = vPositionData;
+            NormalsData = vNormalsData;
+            ColorData = vColorData;
+            IndicesData = indicesData;
+        }
+
+    }
+}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index f806424..e454405 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -52,2 +52,4 @@ namespace AWGL.Utilities
             Position += offset;
+
+            Logger.WriteLine("Camera Position = " + Position);
         }
@@ -61,2 +63,4 @@ namespace AWGL.Utilities
             Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+
+            Logger.WriteLine("Camera Orientation = " + Orientation);
         }
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
new file mode 100644
index 0000000..2876ecc
--- /dev/null
+++ b/AWGL/Utilities/CustomVertexStruct.cs
@@ -0,0 +1,35 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.InteropServices;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public struct AWVertex
+    {
+        /// <summary>
+        /// Defines the size of the AWVertex struct in bytes.
+        /// </summary>
+        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
+        private Vector3[] vector31;
+        private Vector3[] vector32;
+        private int[] p;
+
+        public Vector3[] Postions { get; set; }
+
+        public Vector3[] Normals {get; set;}
+
+        public int[] Colors {get; set;}
+
+        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
+        {
+            Postions = positions;
+            Normals = nomarls;
+            Colors = colors;
+        }
+
+            
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 610b1cf..12bfbbe 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -19,3 +19,3 @@ namespace Game
 
-        public Game(int width, int height) : base(width, height) { }
+        public Game(int width, int height, int major, int minor) : base(width, height, major, minor) { }
 
@@ -32,11 +32,4 @@ namespace Game
 
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            Setup2DGraphics(ScreenWidth, ScreenHeight);
-        }
-
         public override void Initialise()
         {
-            Setup2DGraphics(ScreenWidth, ScreenHeight);
 
@@ -52,5 +45,5 @@ namespace Game
             stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
+            stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
 
-            //stateManager.ChangeState("Drawing");
-            stateManager.ChangeState("TestTexture");
+            stateManager.ChangeState("VboState");
         }
@@ -59,3 +52,3 @@ namespace Game
         {
-            
+            stateManager.Update(elapsedTime);
         }
@@ -64,3 +57,2 @@ namespace Game
         {
-            stateManager.Update(elapsedTime);
             stateManager.Render();
diff --git a/Game/Program.cs b/Game/Program.cs
index 8d228e5..c87f0aa 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600)) { game.Run(30, 60); }
+            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(30, 60); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/625d8b35abbdc497ffcb713e1a3ffc3704d319ee">Conflicts: 	AWGL/OpenTK/OpenTK.GLControl.dll 	AWGL/OpenTK/OpenTK.dll</a>  -  625d8b3</p><p>authored by Anthony Woodward, 9 weeks ago</p></div><pre>
 9 files changed, 433 insertions(+), 168 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 803587e..8529615 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -1,2 +1,4 @@
-﻿using AWGL.Managers;
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
 using AWGL.Nodes;
@@ -11,3 +13,6 @@ using System.Diagnostics;
 using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Text;
@@ -19,3 +24,4 @@ namespace AWGL
     /// <summary>
-    /// Inherit me
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
     /// </summary>
@@ -23,30 +29,4 @@ namespace AWGL
     {
-        #region Old code
-        public static string AppName
-        {
-            get
-            {
-                return "AWEngine";
-            }
 
-        }
-        int modelviewMatrixLocation,
-            projectionMatrixLocation,
-            vaoHandle,
-            positionVboHandle,
-            normalVboHandle,
-            eboHandle;
-
-        AWNode m_sceneGraph;
-        AWGroupNode root;
-        AWGroupNode group;
-        AWCube cube;
-        AWGraphLines graph;
-        #endregion
-
-        protected PreciseTimer m_Timer;
-        protected Camera camera;
-        protected List<Key> keyList;
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected ShaderManager shaderManager;
+        public static string AppName { get { return "AWEngine"; } }
 
@@ -54,6 +34,20 @@ namespace AWGL
         public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
 
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected ShaderManager shaderManager;
+        protected PreciseTimer m_Timer;
+        protected AWGL.Utilities.Camera camera;
+        protected List<Key> keyList;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(height, width, new GraphicsMode(32, 24, 8, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
         { }
@@ -66,3 +60,3 @@ namespace AWGL
             //CameraManager
-            camera = new Camera();
+            camera = new AWGL.Utilities.Camera();
             
@@ -73,17 +67,15 @@ namespace AWGL
 
-            CreateShaders();
-            
-            #region Old Code
-            //root = new AWGroupNode();
-            //group = new AWGroupNode();
-            //cube = new AWCube();
-            //graph = new AWGraphLines(20);
-            
-            //CreateVBOs();
-            //CreateVAOs();
+            //CreateShaders();
+
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+
+            AssimpContext importer = new AssimpContext();
+            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
+            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
+            ComputeBoundingBox();
 
             //// Other state
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.ClearColor(Color.CornflowerBlue); 
-            #endregion
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearColor(Color.Black); 
+           
 
@@ -96,3 +88,3 @@ namespace AWGL
         public abstract void Initialise();
-        #endregion
+        
 
@@ -103,73 +95,27 @@ namespace AWGL
             GL.UseProgram(shaderManager.ProgramHandle);
-
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            QueryMatrixLocations();
 
             float aspectRatio = ScreenWidth / (float)(ScreenHeight);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projectionMatrix);
-            modelviewMatrix = Matrix4.LookAt(new Vector3(0, 3, 5), new Vector3(0, 0, 0), new Vector3(0, 1, 0));//camera.GetViewMatrix();
-
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
+            SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
         }
 
-        #region Old Code
-        #region Create VBOs
-        void CreateVBOs()
+        protected void QueryMatrixLocations()
         {
-            //Vector3[] aggregateVerts = new Vector3[graph.Vertices.Length + cube.Vertices.Length];
-            //System.Array.Copy(graph.Vertices, aggregateVerts, graph.Vertices.Length);
-            //System.Array.Copy(cube.Vertices, 0, aggregateVerts, graph.Vertices.Length, cube.Vertices.Length);
-
-            //positionVboHandle = BufferManager.SetupBuffer(
-            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //normalVboHandle = BufferManager.SetupBuffer(
-            //    aggregateVerts, BufferTarget.ArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //eboHandle = BufferManager.SetupBuffer(
-            //    cube.Indices, BufferTarget.ElementArrayBuffer, BufferUsageHint.StaticDraw
-            //    );
-
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
         }
-        #endregion
 
-        #region Create VAOs
-        void CreateVAOs()
+        public void SetModelviewMatrix(Matrix4 matrix)
         {
-            #region ---
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            #endregion
-
-            // generate
-            vaoHandle = BufferManager.GenerateVaoBuffer();
-
-            #region add matrix transform uniforms
-
-            //BufferManager.SetupVaoBuffer(positionVboHandle,
-
-            //    shaderManager.ProgramHandle, 0, 3, "in_position",
-            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-            //    );
-            //BufferManager.SetupVaoBuffer(normalVboHandle,
-
-            //    shaderManager.ProgramHandle, 1, 3, "in_normal",
-            //    BufferTarget.ArrayBuffer, VertexAttribPointerType.Float
-            //    );
-
-            #endregion
-
-            //GL.BindBuffer(BufferTarget.ElementArrayBuffer, eboHandle);
+            modelviewMatrix = matrix;
+            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        }
 
-            //GL.BindVertexArray(0);
+        protected void SetProjectionMatrix(Matrix4 matrix)
+        {
+            projectionMatrix = matrix;
+            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
         }
-        #endregion  
+
         #endregion
@@ -179,20 +125,23 @@ namespace AWGL
         {
-            #region Input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
+            #region input
+            //if (focused)
+            //{
+            //    point center = new point(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2);
+            //    point delta = new point(center.x - system.windows.forms.cursor.position.x, center.y - system.windows.forms.cursor.position.y);
 
-                camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
+            //    camera.addrotation(delta.x, delta.y);
+            //    resetcursor();
+            //}
 
-            MoveCamera(); 
-            #endregion
+            //movecamera();
 
-            #region Old Code
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
             #endregion
 
+            m_angle += 25f * (float)e.Time;
+            if (m_angle > 360)
+            {
+                m_angle = 0.0f;
+            }
+
             UpdateFrame(m_Timer.GetElapsedTime());
@@ -215,13 +164,36 @@ namespace AWGL
             GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            // Single call to StateRenderer to take place here.
+            
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
 
-            #region Old Code
-            //GL.BindVertexArray(vaoHandle);
-            //GL.DrawArrays(PrimitiveType.Lines, 0, 20);
-            //GL.DrawArrays(PrimitiveType.Triangles, 20, cube.Indices.Length);
-            //PrimitiveType.Lines, cube.Indices.Length,
-            //DrawElementsType.UnsignedInt, IntPtr.Zero
-            //); 
-            #endregion
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
 
-            // Single call to StateRenderer to take place here.
             RenderFrame(m_Timer.GetElapsedTime());
@@ -238,7 +210,8 @@ namespace AWGL
 
-            #region Old Code
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref lookat); 
-            #endregion
+            float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
         }
+
         #endregion
@@ -326,3 +299,258 @@ namespace AWGL
         #endregion
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index 6b8e738..f80f0ec 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -6,3 +6,3 @@ const vec3 ambient = vec3(0.1, 0.1, 0.1);
 const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(0.9, 0.9, 0.7);
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 98fde5b..8c9d031 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -4,8 +4,15 @@ precision highp float;
 
-uniform mat4 projection_matrix;
+// object space to camera space transformation
 uniform mat4 modelview_matrix;
-
+ 
+// camera space to clip coordinates
+uniform mat4 projection_matrix;
+ 
+// incoming vertex position
 in vec3 in_position;
+ 
+// incoming vertex normal
 in vec3 in_normal;
-
+ 
+// transformed vertex normal
 out vec3 normal;
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 497ce1e..885620e 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -76,3 +76,3 @@ namespace AWGL.Managers
 
-            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+                bufferHandle = GL.GetAttribLocation(program, "in_normal");
             GL.EnableVertexAttribArray(bufferHandle);
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
new file mode 100644
index 0000000..9005258
--- /dev/null
+++ b/AWGL/States/AssimpImportedState.cs
@@ -0,0 +1,46 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Assimp.Configs;
+using Assimp;
+using System.IO;
+using System.Reflection;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.States
+{
+    public class AssimpImportedState :IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        ShaderManager m_shaderManager;
+
+        
+
+        public AssimpImportedState(StateManager stateManager, ShaderManager shaderManager)
+        {
+            m_stateManager = stateManager;
+            m_shaderManager = shaderManager;
+        }
+
+        public void Render()
+        {
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+    }
+}
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index 5d4d2b6..6b2ac74 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -33,6 +33,2 @@ namespace AWGL.States
             CreateVBOs();
-
-            //// Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.MidnightBlue);
         }
@@ -43,4 +39,4 @@ namespace AWGL.States
             BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;//new Vector3[cube.Vertices.Length];
-            tempVBO.NormalsData = cube.Normals; // Vector3[cube.Normals.Length];
+            tempVBO.PositionData = cube.Vertices;
+            tempVBO.NormalsData = cube.Normals;
             tempVBO.IndicesData = cube.Indices;
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index e454405..014da3d 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -14,4 +14,4 @@ namespace AWGL.Utilities
     {
-        public Vector3 Position = new Vector3(2, 2, 2);
-        public Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public Vector3 Position = new Vector3(0f, 5f, 5f);
+        public Vector3 Orientation = new Vector3(0f, 0f, 0f);
         public float MoveSpeed = 0.2f;
diff --git a/Game/Game.cs b/Game/Game.cs
index 12bfbbe..3fac302 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -1,2 +1,5 @@
-﻿using System;
+﻿using AWGL;
+using AWGL.Managers;
+using AWGL.States;
+using System;
 using System.Collections.Generic;
@@ -6,8 +9,2 @@ using System.Threading.Tasks;
 
-using AWGL;
-
-using OpenTK.Graphics.OpenGL;
-using AWGL.Managers;
-using AWGL.States;
-
 namespace Game
@@ -21,13 +18,2 @@ namespace Game
 
-        private void Setup2DGraphics(double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -100, 100);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-        }
-
         public override void Initialise()
@@ -45,5 +31,7 @@ namespace Game
             stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
-            stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
+            //stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
+            stateManager.AddState("Assimp-state", new AssimpImportedState(stateManager, shaderManager));
 
-            stateManager.ChangeState("VboState");
+            stateManager.ChangeState("Assimp-state");
+            //stateManager.ChangeState("VboState");
         }
diff --git a/Game/Program.cs b/Game/Program.cs
index c87f0aa..a9832fc 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(30, 60); }
+            using (Game game = new Game(1024, 600, 3, 2)) { game.Run(60, 0); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e40d399153d51e446e709b684bf4ea65aba2a4b8">Adding 3D models for testing purposes.</a>  -  e40d399</p><p>authored by Anthony Woodward, 9 weeks ago</p></div><pre>
 1 file changed, 59 insertions(+), 55 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 8529615..bf69ca1 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -3,3 +3,2 @@ using Assimp.Configs;
 using AWGL.Managers;
-using AWGL.Nodes;
 using AWGL.Utilities;
@@ -11,3 +10,2 @@ using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Drawing;
@@ -15,7 +13,4 @@ using System.Drawing.Imaging;
 using System.IO;
-using System.Linq;
 using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
+using System.Windows.Forms;
 
@@ -50,3 +45,3 @@ namespace AWGL
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 8, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            : base(height, width, new GraphicsMode(32, 24, 8, 8), AWEngineWindow.AppName, GameWindowFlags.Default, 
             DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
@@ -68,4 +63,4 @@ namespace AWGL
             //CreateShaders();
-
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+                                                                                                            //"Content/Models/Characters/bunny/reconstruction/bun_zipper.ply"
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");
 
@@ -78,3 +73,3 @@ namespace AWGL
             GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(Color.Black); 
+            GL.ClearColor(.1f, 0f, .1f, 0f);
            
@@ -99,3 +94,3 @@ namespace AWGL
             SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
-            SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+            SetModelviewMatrix(Matrix4.CreateTranslation(0, 0, 5));
         }
@@ -126,12 +121,12 @@ namespace AWGL
             #region input
-            //if (focused)
-            //{
-            //    point center = new point(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2);
-            //    point delta = new point(center.x - system.windows.forms.cursor.position.x, center.y - system.windows.forms.cursor.position.y);
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
 
-            //    camera.addrotation(delta.x, delta.y);
-            //    resetcursor();
-            //}
+                camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
 
-            //movecamera();
+            MoveCamera();
 
@@ -175,6 +170,6 @@ namespace AWGL
             GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            Matrix4 lookat = camera.GetViewMatrix();
             GL.LoadMatrix(ref lookat);
 
-            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
 
@@ -184,3 +179,3 @@ namespace AWGL
             tmp = 1.0f / tmp;
-            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+            GL.Scale(tmp * 20, tmp * 20, tmp * 20);
 
@@ -245,37 +240,46 @@ namespace AWGL
         {
-            foreach (Key key in keyList)
+            if (keyList.Count > 0) 
             {
-
-                switch (key)
+                foreach (Key key in keyList)
                 {
-                    case Key.Escape:
-                        Exit();
-                        break;
-
-                    case Key.W:
-                        camera.Move(0f, 0.1f, 0f);
-                        break;
 
-                    case Key.A:
-                        camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    default:
-                        break;
+                    switch (key)
+                    {
+                        case Key.Escape:
+                            Exit();
+                            break;
+
+                        case Key.W:
+                            camera.Move(0f, 0.1f, 0f);
+                            break;
+
+                        case Key.A:
+                            camera.Move(-0.1f, 0f, 0f);
+                            break;
+
+                        case Key.S:
+                            camera.Move(0f, -0.1f, 0f);
+                            break;
+
+                        case Key.D:
+                            camera.Move(0.1f, 0f, 0f);
+                            break;
+
+                        case Key.Q:
+                            camera.Move(0f, 0f, 0.1f);
+                            break;
+
+                        case Key.E:
+                            camera.Move(0f, 0f, -0.1f);
+                            break;
+
+                        case Key.F11:
+                            if (this.WindowState == OpenTK.WindowState.Normal)
+                                this.WindowState = OpenTK.WindowState.Fullscreen;
+                            else
+                                this.WindowState = OpenTK.WindowState.Normal;
+                            break;
+                        default:
+                            break;
+                    }
                 }
@@ -469,3 +473,3 @@ namespace AWGL
             {
-                // color = FromColor(mat.ColorDiffuse);
+                color = FromColor(mat.ColorDiffuse);
             }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/56b219d6513cada51642a3698baa468e4ead0b3f">More resources.</a>  -  56b219d</p><p>authored by Anthony Woodward, 9 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index bf69ca1..62f659c 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -63,3 +63,3 @@ namespace AWGL
             //CreateShaders();
-                                                                                                            //"Content/Models/Characters/bunny/reconstruction/bun_zipper.ply"
+                                                                                                            //"Content/Models/Vehicles/Jupiter2/jupe2/Jupiter 2 Plus.obj"
             String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/219a36c845c2058bda2f48385dcecf8c59a1caa8">disabled full screen switching for now. too buggy.</a>  -  219a36c</p><p>authored by Anthony Woodward, 9 weeks ago</p></div><pre>
 1 file changed, 6 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 62f659c..7bcc546 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -275,8 +275,2 @@ namespace AWGL
 
-                        case Key.F11:
-                            if (this.WindowState == OpenTK.WindowState.Normal)
-                                this.WindowState = OpenTK.WindowState.Fullscreen;
-                            else
-                                this.WindowState = OpenTK.WindowState.Normal;
-                            break;
                         default:

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/75a695d4fd593d49cc65fb401a15604bbcfe0c96">Squashed commit of the following:</a>  -  75a695d</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 32 files changed, 905 insertions(+), 1055 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index 7bcc546..ee38827 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -3,2 +3,3 @@ using Assimp.Configs;
 using AWGL.Managers;
+using AWGL.Nodes;
 using AWGL.Utilities;
@@ -10,2 +11,3 @@ using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Drawing;
@@ -13,3 +15,7 @@ using System.Drawing.Imaging;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
 using System.Windows.Forms;
@@ -33,6 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected ShaderManager shaderManager;
         protected PreciseTimer m_Timer;
-        protected AWGL.Utilities.Camera camera;
-        protected List<Key> keyList;
 
@@ -45,4 +48,4 @@ namespace AWGL
         public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 24, 8, 8), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, 0, 0, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
         { }
@@ -52,29 +55,3 @@ namespace AWGL
         {
-            m_Timer = new PreciseTimer();
-
-            //CameraManager
-            camera = new AWGL.Utilities.Camera();
-            
-            // InputManager
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //CreateShaders();
-                                                                                                            //"Content/Models/Vehicles/Jupiter2/jupe2/Jupiter 2 Plus.obj"
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content/Models/Characters/bunny/reconstruction/bun_zipper.ply");
-
-            AssimpContext importer = new AssimpContext();
-            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
-            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
-            ComputeBoundingBox();
-
-            //// Other state
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearColor(.1f, 0f, .1f, 0f);
-           
-
-#if Debug
-            AWLogger.WriteLine("...Exiting OnLoad"); 
-#endif      
+            BaseInitialisation();
             Initialise();
@@ -82,35 +59,57 @@ namespace AWGL
 
-        public abstract void Initialise();
-        
-
-        private void CreateShaders()
+        private void BaseInitialisation()
         {
-            shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-            GL.UseProgram(shaderManager.ProgramHandle);
-            QueryMatrixLocations();
-
-            float aspectRatio = ScreenWidth / (float)(ScreenHeight);
-            SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 64));
-            SetModelviewMatrix(Matrix4.CreateTranslation(0, 0, 5));
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
         }
 
-        protected void QueryMatrixLocations()
+        private void InitialiseInput()
         {
-            projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-            modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
         }
 
-        public void SetModelviewMatrix(Matrix4 matrix)
+        private void InitialiseTimer()
         {
-            modelviewMatrix = matrix;
-            GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+            m_Timer = new PreciseTimer();
         }
 
-        protected void SetProjectionMatrix(Matrix4 matrix)
+        private void InitialiseStockShaders()
         {
-            projectionMatrix = matrix;
-            GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+            ShaderManager.LoadDefaultShaderProgram();
         }
 
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
         #endregion
@@ -126,3 +125,3 @@ namespace AWGL
 
-                camera.AddRotation(delta.X, delta.Y);
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
                 ResetCursor();
@@ -130,4 +129,2 @@ namespace AWGL
 
-            MoveCamera();
-
             //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
@@ -135,8 +132,2 @@ namespace AWGL
 
-            m_angle += 25f * (float)e.Time;
-            if (m_angle > 360)
-            {
-                m_angle = 0.0f;
-            }
-
             UpdateFrame(m_Timer.GetElapsedTime());
@@ -157,17 +148,22 @@ namespace AWGL
                 " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-            
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
             // Single call to StateRenderer to take place here.
-            
-            GL.Enable(EnableCap.Texture2D);
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.Normalize);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = camera.GetViewMatrix();
-            GL.LoadMatrix(ref lookat);
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
 
@@ -175,19 +171,20 @@ namespace AWGL
 
-            float tmp = m_sceneMax.X - m_sceneMin.X;
-            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            tmp = 1.0f / tmp;
-            GL.Scale(tmp * 20, tmp * 20, tmp * 20);
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
 
-            GL.Translate(-m_sceneCenter);
+            //GL.Translate(-m_sceneCenter);
 
-            if (m_displayList == 0)
-            {
-                m_displayList = GL.GenLists(1);
-                GL.NewList(m_displayList, ListMode.Compile);
-                RecursiveRender(m_model, m_model.RootNode);
-                GL.EndList();
-            }
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
 
-            GL.CallList(m_displayList);
+            //GL.CallList(m_displayList); 
+            #endregion
 
@@ -205,8 +202,12 @@ namespace AWGL
 
-            float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-        }
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
 
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
         #endregion
@@ -216,4 +217,3 @@ namespace AWGL
         {
-            base.Dispose();
-            //shaderManager.Dispose();
+            
         } 
@@ -222,5 +222,8 @@ namespace AWGL
         #region Input Control
+        
         private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
         {
-            keyList.Add(e.Key);
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
         }
@@ -229,7 +232,7 @@ namespace AWGL
         {
-            for (int count = 0; count < keyList.Count; count++)
+            for (int count = 0; count < InputManager.keyList.Count; count++)
             {
-                if (keyList[count] == e.Key)
+                if (InputManager.keyList[count] == e.Key)
                 {
-                    keyList.Remove(keyList[count]);
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
                 }
@@ -238,47 +241,3 @@ namespace AWGL
 
-        private void MoveCamera()
-        {
-            if (keyList.Count > 0) 
-            {
-                foreach (Key key in keyList)
-                {
-
-                    switch (key)
-                    {
-                        case Key.Escape:
-                            Exit();
-                            break;
-
-                        case Key.W:
-                            camera.Move(0f, 0.1f, 0f);
-                            break;
-
-                        case Key.A:
-                            camera.Move(-0.1f, 0f, 0f);
-                            break;
-
-                        case Key.S:
-                            camera.Move(0f, -0.1f, 0f);
-                            break;
-
-                        case Key.D:
-                            camera.Move(0.1f, 0f, 0f);
-                            break;
-
-                        case Key.Q:
-                            camera.Move(0f, 0f, 0.1f);
-                            break;
-
-                        case Key.E:
-                            camera.Move(0f, 0f, -0.1f);
-                            break;
-
-                        default:
-                            break;
-                    }
-                }
-            }
-        }
-
-        private void ResetCursor()
+        public void ResetCursor()
         {
@@ -296,4 +255,7 @@ namespace AWGL
         } 
+        
         #endregion
 
+        #region Assimp example code
+
         private void ComputeBoundingBox()
@@ -467,3 +429,3 @@ namespace AWGL
             {
-                color = FromColor(mat.ColorDiffuse);
+                // color = FromColor(mat.ColorDiffuse);
             }
@@ -547,2 +509,4 @@ namespace AWGL
 
+        #endregion
+
         protected override void OnUnload(EventArgs e)
diff --git a/AWGL/AWOldEngineWindow.cs b/AWGL/AWOldEngineWindow.cs
deleted file mode 100644
index 8b85c34..0000000
--- a/AWGL/AWOldEngineWindow.cs
+++ /dev/null
@@ -1,253 +0,0 @@
-﻿using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Shapes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Controls Main Window functions and sets up OpenGL
-    /// </summary>
-    public class AWOldEngineWindow : GameWindow
-    {
-        #region Constructor
-
-        public AWOldEngineWindow() //, GraphicsContextFlags.ForwardCompatible | GraphicsContextFlags.Debug | 
-            : base(1024, 700, new GraphicsMode(32, 24, 0, 4), "", GameWindowFlags.Default, DisplayDevice.Default, 3, 3, GraphicsContextFlags.Debug | GraphicsContextFlags.ForwardCompatible
-            )// DisplayDevice.Default, 3, 3, GraphicsContextFlags.Default)
-        {
-            //set context
-            //this.WindowState = WindowState.Fullscreen;
-            m_backgroundColor= new Color4(.1f, 0f, .1f, 0f);
-            
-            //create player camera
-            playerView = new Camera();
-
-            //register key list
-            keyList = new List<Key>();
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-
-            //InitialiseNodes
-            worldRoot = new AWGroupNode();
-            landRoot = new AWGroupNode();
-            graph = new AWGraphLines(20); ;
-            cube = new AWCube();
-            knot = new TorusKnot( 256, 32, 0.1, 3, 4, 1, true );
-
-            //create scenegraph
-            worldRoot.AddChild(graph);
-            worldRoot.AddChild(landRoot);
-
-            landRoot.SetTranslation(0, .5, -10);
-            landRoot.AddChild(cube);
-
-            m_sceneGraph = worldRoot;
-
-            m_hook1 = landRoot;
-
-            cubePosY = 1.5f;
-            playerView.Move(0f, 0f, 0.1f);
-
-            //shaderManager = new AWShaderManager();
-            //GL.UseProgram(shaderManager.ProgramID);
-        }
-
-        #endregion
-
-        #region Fields
-
-        protected Camera playerView;
-
-        private Color4 m_backgroundColor;
-        private List<Key> keyList;
-
-        //scenegraph
-        private AWNode m_sceneGraph;
-        private AWGroupNode worldRoot, landRoot;
-        private AWGraphLines graph;
-        private AWCube cube;
-        private TorusKnot knot;
-        private AWGroupNode m_hook1;
-
-        private const float m_rotationspeed = 180.0f;
-        private float m_spinangle, cubePosY;
-
-        private ShaderManager shaderManager;
-
-        #endregion
-
-        #region OnLoad
-        /// <summary>
-        /// Setup OpenGL and load resources here.
-        /// </summary>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            //Title = AWUtils.PrintOpenGLInfo();
-
-            GL.ClearColor(m_backgroundColor);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Respond to resize events here.
-        /// </summary>
-        /// <param name="e">Contains information on the new GameWindow size.</param>
-        /// <remarks>There is no need to call the base implementation.</remarks>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            GL.Viewport(0, 0, Width, Height);
-            float aspect_ratio = Width / (float)Height;
-            Matrix4 perpective = playerView.GetViewMatrix() * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-        }
-        #endregion
-
-        #region OnFocusChanged
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnUpdateFrame
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            base.OnUpdateFrame(e);
-
-            if (Focused)
-            {
-                MoveCamera();
-
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - System.Windows.Forms.Cursor.Position.X, center.Y - System.Windows.Forms.Cursor.Position.Y);
-
-                playerView.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            m_spinangle += m_rotationspeed * (float)e.Time;
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 lookat = playerView.GetViewMatrix();
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            m_hook1.SetRotation(m_spinangle, 0, 1, 0);
-
-            m_sceneGraph.Render();
-
-            SwapBuffers();
-        }
-
-        #endregion
-
-        #region Input & Camera
-
-        void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            keyList.Add(e.Key);
-        }
-
-        void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < keyList.Count; count++)
-            {
-                if (keyList[count] == e.Key)
-                {
-                    keyList.Remove(keyList[count]);
-                }
-            }
-        }
-
-        private void MoveCamera()
-        {
-            foreach (OpenTK.Input.Key key in keyList)
-            {
-
-                switch (key)
-                {
-                    case OpenTK.Input.Key.Escape:
-                        Exit();
-                        break;
-
-                    case OpenTK.Input.Key.W:
-                        playerView.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.A:
-                        playerView.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.S:
-                        playerView.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.D:
-                        playerView.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case OpenTK.Input.Key.Q:
-                        playerView.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.E:
-                        playerView.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case OpenTK.Input.Key.Up:
-                        landRoot.SetTranslation(0, cubePosY += .1f, -10);
-                        break;
-
-                    case OpenTK.Input.Key.Down:
-                        landRoot.SetTranslation(0, cubePosY += -.1f, -10);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        }
-        
-        private void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/AWSceneManager.cs b/AWGL/AWSceneManager.cs
deleted file mode 100644
index adf29da..0000000
--- a/AWGL/AWSceneManager.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace AWGL
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    class AWSceneManager
-    {
-
-    }
-}
diff --git a/AWGL/AWUtils.cs b/AWGL/AWUtils.cs
deleted file mode 100644
index 66624c7..0000000
--- a/AWGL/AWUtils.cs
+++ /dev/null
@@ -1,192 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.IO;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Utility functions
-    /// </summary>
-    public class AWUtils
-    {
-        /// <summary>
-        /// Helper Funtion for loading shaders. Returns Shader Source from file.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <returns>Shader Source Code</returns>
-        public static string LoadShader(String filename)
-        {
-            string dataPath = "Data/Shaders/";
-            string shaderSource;
-
-            using (StreamReader sr = new StreamReader(dataPath + filename))
-            {
-                shaderSource = sr.ReadToEnd();
-            }
-
-            return shaderSource;
-        }     
-        
-        /// <summary>
-        /// Load the shader file, creates an OpenGL shader object, compiles the 
-        /// source code and returns the handle to the internal shader object. 
-        /// If the compilation fails, the application will exit.
-        /// </summary>
-        /// <param name="filename">Filename of GLSL Shader</param>
-        /// <param name="type">Type of GLSL Shader to load</param>
-        /// <returns>Shader Handle</returns>
-        public static int BuildShader(string filename, ShaderType shaderType)
-        {
-            string shaderSource = LoadShader(filename);
-
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, shaderSource);
-            GL.CompileShader(shaderHandle);
-
-            // Check compile success
-            int compileStatus;
-            GL.GetShader(shaderHandle, ShaderParameter.CompileStatus, out compileStatus);
-
-            if (compileStatus == 0)
-            {
-                String message;
-                GL.GetShaderInfoLog(shaderHandle, out message);
-                Debug.WriteLine("BuildShader failed to compile " + shaderType.ToString() + ": " + message);
-                return -1;
-            }
-
-            return shaderHandle;
-        }
-
-        /// <summary>
-        /// Creates a program object, attaches the shaders, links them and 
-        /// returns the OpenGL handle of the program.
-        /// </summary>
-        /// <param name="vertexShaderId">Shader Handle</param>
-        /// <param name="fragmentShaderId">Shader Handle</param>
-        /// <returns>Shader Program Handle</returns>
-        public static int BuildProgram(int vertexShaderId, int fragmentShaderId)
-        {
-            int programHandle = GL.CreateProgram();
-            GL.AttachShader(programHandle, vertexShaderId);
-            GL.AttachShader(programHandle, fragmentShaderId);
-            GL.LinkProgram(programHandle);
-
-            // Check linker success
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess);
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program link failed: " + message);
-            }
-
-            // Validate program
-            int validateSuccess;
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess);
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Debug.WriteLine("Program validation failed", message);
-            }
-
-            return programHandle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <typeparam name="TVertex"></typeparam>
-        /// <param name="vertices"></param>
-        /// <param name="elements"></param>
-        /// <param name="elementSize"></param>
-        /// <param name="typeSize"></param>
-        /// <param name="bufferUsageTypeGL"></param>
-        /// <returns></returns>
-        public static Vbo LoadVBO<TVertex>(TVertex[] vertices,
-                                           short[] elements, 
-                                           int elementSize, 
-                                           int typeSize, 
-                                           BufferUsageHint bufferUsageTypeGL) 
-            where TVertex : struct
-        {
-            Vbo vboHandle = new Vbo();
-
-            vboHandle.NumElements = elements.Length;
-
-            // Determine size of Buffer
-            int vbo_Size = vertices.Length * BlittableValueType.StrideOf(vertices);
-            int ebo_Size = elements.Length * sizeof(short);
-
-            #region
-            // To create a VBO:
-            // 1) Generate the buffer handles for the vertex and element buffers.
-            // 2) Bind the vertex buffer handle and upload your vertex data. 
-            //    Check that the buffer was uploaded correctly.
-            // 3) Bind the element buffer handle and upload your element data. 
-            //    Check that the buffer was uploaded correctly.
-            #endregion
-
-            //Generate Buffer ID
-            GL.GenBuffers(1, out vboHandle.VboID);
-
-            // Binds the buffer that is used next
-            GL.BindBuffer(BufferTarget.ArrayBuffer, vboHandle.VboID);
-
-            // Copy data to the VBO on the GPU.
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)vbo_Size, vertices, bufferUsageTypeGL);
-
-            int getBufferSize;
-            GL.GetBufferParameter(BufferTarget.ArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != vbo_Size)
-                throw new Exception("Vertex data not uploaded correctly");
-
-            GL.GenBuffers(1, out vboHandle.EboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vboHandle.EboID);
-
-            GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)ebo_Size, elements, bufferUsageTypeGL);
-
-            GL.GetBufferParameter(BufferTarget.ElementArrayBuffer, BufferParameterName.BufferSize, out getBufferSize);
-            if (getBufferSize != ebo_Size)
-                throw new Exception("Element data not uploaded correctly");
-
-            return vboHandle;
-        }
-
-        #region TestOpenGLVersion
-        /// <summary>
-        /// Get OpenGL Version Information and check system meets requirements
-        /// </summary>
-        public static void TestOpenGLVersion()
-        {
-            Version m_Version = new Version(GL.GetString(StringName.Version).Substring(0, 3));
-            Version m_TargetLow = new Version(3, 0);
-            Version m_TargetHigh = new Version(4, 1);
-            if (m_Version < m_TargetLow)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetLow, m_Version));
-            }
-            else if (m_Version > m_TargetHigh)
-            {
-                throw new NotSupportedException(String.Format(
-                    "OpenGL {0} is required (you only have {1}).", m_TargetHigh, m_Version));
-            }
-        }
-        #endregion
-
-        public static string PrintOpenGLInfo()
-        {
-            
-            TestOpenGLVersion();
-
-            return "AWGL Engine Prototype - " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")";
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
index f80f0ec..f890462 100644
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ b/AWGL/Data/Shaders/opentk-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 140
+#version 410 core
 
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
index 8c9d031..1cd8777 100644
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ b/AWGL/Data/Shaders/opentk-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 140
+#version 410 core
 
@@ -22,3 +22,3 @@ void main(void)
   //works only for orthogonal modelview
-  normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
   
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
new file mode 100644
index 0000000..fa93cee
--- /dev/null
+++ b/AWGL/Data/Shaders/render-fs.glsl
@@ -0,0 +1,21 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} fs_in;
+
+out vec4 color;
+
+void main(void)
+{
+    // Reflect view vector about the plane defined by the normal
+    // at the fragment
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+
+    // Sample from scaled using reflection vector
+     color = texture(tex_cubemap, r);
+}
diff --git a/AWGL/Data/Shaders/render-vs.glsl b/AWGL/Data/Shaders/render-vs.glsl
new file mode 100644
index 0000000..4f89dba
--- /dev/null
+++ b/AWGL/Data/Shaders/render-vs.glsl
@@ -0,0 +1,23 @@
+#version 410 core
+
+uniform mat4 mv_matrix;
+uniform mat4 proj_matrix;
+
+layout (location = 0) in vec4 in_position;
+layout (location = 1) in vec3 in_normal;
+
+out VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} vs_out;
+
+void main(void)
+{
+    vec4 pos_vs = mv_matrix * in_position;
+
+    vs_out.normal = mat3(mv_matrix) * in_normal;
+    vs_out.view = pos_vs.xyz;
+
+    gl_Position = proj_matrix * pos_vs;
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-fs.glsl b/AWGL/Data/Shaders/skybox-fs.glsl
new file mode 100644
index 0000000..f996bf4
--- /dev/null
+++ b/AWGL/Data/Shaders/skybox-fs.glsl
@@ -0,0 +1,15 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+	vec3 tc;
+}fs_in;
+
+layout(location = 0) out vec4 color;
+
+void main(void)
+{
+	color = texture(tex_cubemap, fs_in.tc);
+}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
new file mode 100644
index 0000000..6ef7af2
--- /dev/null
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -0,0 +1,18 @@
+﻿#version 410 core
+ 
+ out VS_OUT
+ {
+	vec3 tc;
+ }vs_out;
+
+uniform vec3 eye_position;
+uniform mat4 mv_matrix;
+uniform mat4 mvp_matrix;
+
+in lowp vec3 in_position;
+
+ void main(void)
+ {
+	vs_out.tc = in_position;
+	gl_Position = mvp_matrix * vec4(in_position, 1.0);
+ }
\ No newline at end of file
diff --git a/AWGL/Managers/BufferManager.cs b/AWGL/Managers/BufferManager.cs
deleted file mode 100644
index f3719c4..0000000
--- a/AWGL/Managers/BufferManager.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL.Managers
-{
-    /// <summary>
-    /// 
-    /// </summary>
-    public sealed class BufferManager : IDisposable
-    {
-        #region Singleton Pattern - Thread Safe
-        private static volatile BufferManager instance = new BufferManager();
-        private static object syncRoot = new Object();
-
-        private BufferManager() { }
-
-        public static BufferManager Instance
-        {
-            get
-            {
-                if (instance == null)
-                {
-                    lock (syncRoot)
-                    {
-                        if (instance == null)
-                            instance = new BufferManager();
-                    }
-                }
-
-                return instance;
-            }
-        } 
-        #endregion
-
-        #region Set up Vertex Buffer Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            Vector3[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData<Vector3>(
-                bufferTarget, new IntPtr(data.Length * Vector3.SizeInBytes),
-                data, bufferUsageHint
-                );
-            return handle;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="data"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="bufferUsageHint"></param>
-        /// <returns></returns>
-        internal static int SetupBuffer(
-            int[] data, BufferTarget bufferTarget, BufferUsageHint bufferUsageHint)
-        {
-            int handle;
-            GL.GenBuffers(1, out handle);
-            GL.BindBuffer(bufferTarget, handle);
-            GL.BufferData(
-                bufferTarget, new IntPtr(sizeof(uint) * data.Length),
-                data, bufferUsageHint
-                );
-            return handle;
-        } 
-        #endregion
-
-        #region Set up Vertex Array Objects
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="bufferHandle"></param>
-        /// <param name="ProgramHandle"></param>
-        /// <param name="index"></param>
-        /// <param name="size"></param>
-        /// <param name="attributeName"></param>
-        /// <param name="bufferTarget"></param>
-        /// <param name="vertexAttribPointerType"></param>
-        internal static void SetupVaoBuffer(
-            int bufferHandle, int ProgramHandle, int index, int size, string attributeName,
-            BufferTarget bufferTarget, VertexAttribPointerType vertexAttribPointerType)
-        {
-            GL.EnableVertexAttribArray(index);
-            GL.BindBuffer(bufferTarget, bufferHandle);
-            GL.VertexAttribPointer(
-                index, size, vertexAttribPointerType,
-                true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(ProgramHandle, 0, attributeName);
-        }
-
-        internal static int GenerateVaoBuffer()
-        {
-            int handle;
-            GL.GenVertexArrays(1, out handle);
-            GL.BindVertexArray(handle);
-            return handle;
-        } 
-        #endregion
-
-        void IDisposable.Dispose()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 885620e..497ce1e 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -76,3 +76,3 @@ namespace AWGL.Managers
 
-                bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
             GL.EnableVertexAttribArray(bufferHandle);
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 3cecb80..4985b5d 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -1,2 +1,3 @@
-﻿using System;
+﻿using OpenTK.Input;
+using System;
 using System.Collections.Generic;
@@ -9,2 +10,5 @@ namespace AWGL.Managers
     {
+        public static List<Key> keyList = new List<Key>();
+
+
     }
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 7899c0e..1de11cf 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -17,29 +17,45 @@ namespace AWGL.Managers
     /// </summary>
-    public class ShaderManager : IDisposable
+    public static class ShaderManager
     {
-        #region Private Members
+        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+
         // Handles
-        private int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
 
-        private string defaultDataPath = "Data/Shaders/";
-        private string m_vertexShaderPath = "Simple_VS";
-        private string m_fragmentShaderPath = "Simple_FS";
-        #endregion
+        private static string defaultDataPath = "Data/Shaders/";
+        private static string m_vertexShaderFile = "opentk-vs";
+        private static string m_fragmentShaderFile = "opentk-fs";
 
-        #region Contructors
-        public ShaderManager() 
-        { 
-            m_programHandle = BuildProgram(); 
+        internal static void LoadDefaultShaderProgram()
+        {
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("default", new Shader(m_programHandle));
         }
 
-        public ShaderManager(string vertexShaderPath, string fragmentShaderPath)
+        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
         {
-            m_vertexShaderPath = vertexShaderPath;
-            m_fragmentShaderPath = fragmentShaderPath;
+            m_vertexShaderFile = vertexShaderPath;
+            m_fragmentShaderFile = fragmentShaderPath;
             m_programHandle = BuildProgram();
+
+            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
+        }
+
+        public static Shader DefaultShader
+        {
+            get
+            {
+                return m_shaderStorage["default"];
+            }
+        }
+
+        public static Shader Get(string shaderID)
+        {
+            return m_shaderStorage[shaderID];
         }
-        #endregion
 
         #region Shader and Program Contruction Methods
-        internal string LoadShader(string shaderSourcePath)
+        internal static string LoadShader(string shaderSourcePath)
         {
@@ -51,3 +67,3 @@ namespace AWGL.Managers
 
-        internal int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
         {
@@ -65,6 +81,6 @@ namespace AWGL.Managers
 
-        internal int BuildProgram()
+        internal static int BuildProgram()
         {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderPath, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderPath, ShaderType.FragmentShader);
+            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
 
@@ -78,12 +94,5 @@ namespace AWGL.Managers
             #region Check linker success
-
-            int linkSuccess;
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out linkSuccess); // update to use OpenGL4
-            if (linkSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Logger.WriteLine("Program link failed: " + message);
-            }
-
+            int[] temp = new int[1];
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
+            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
             #endregion
@@ -91,12 +100,18 @@ namespace AWGL.Managers
             #region Validate Program
-
-            int validateSuccess;
             GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out validateSuccess); // update to use OpenGL4
-            if (validateSuccess == 0)
-            {
-                String message;
-                GL.GetProgramInfoLog(programHandle, out message);
-                Logger.WriteLine("Program validation failed" + message);
-            }
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
+            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            //if (validateSuccess == 0)
+            //{
+            //    String message;
+            //    GL.GetProgramInfoLog(programHandle, out message);
+            //    Logger.WriteLine("Program validation failed" + message);
+            //}
+            #endregion
+
+            #region Registered Attributes
+            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
+            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
+
+            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
             #endregion
@@ -111,33 +126,18 @@ namespace AWGL.Managers
 
-        #region IDisposable
-        public void Dispose()
-        {
-            GL.DeleteProgram(m_programHandle);
-        }
-        #endregion
-
         #region Public Methods
 
-        public int ProgramHandle
-        {
-            get
-            {
-                return m_programHandle;
-            }
-        }
-
-        public void SetUniforms(
-            out int projMatrixHandle, out int mvMatrixHandle,
-            out Matrix4 projMatrix, Matrix4 mvMatrix,
-            Size dimensions, ref Camera camera)
-        {
-            projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-            mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+        //public void SetUniforms(
+        //    out int projMatrixHandle, out int mvMatrixHandle,
+        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
+        //    Size dimensions, ref Camera camera)
+        //{
+        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
 
-            float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-            Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
 
-            GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-            GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        } 
+        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        //} 
         #endregion
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index f839772..81cdad1 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -34,3 +34,3 @@ namespace AWGL.Managers
 
-        public void ChangeState(string stateName)
+        public void SetState(string stateName)
         {
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index 22add0d..f58a674 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -20,2 +20,3 @@ namespace AWGL.Managers
 
+        private int textureGpuHandle;
         private Bitmap bitmap;
@@ -23,4 +24,2 @@ namespace AWGL.Managers
 
-        private int textureGpuHandle;
-
         public void LoadTexture(string textureId, string path)
@@ -32,20 +31,10 @@ namespace AWGL.Managers
             GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-            
-            try
-            {
-                bitmap = new Bitmap(path);
-                bitmap.Save("test.bmp", ImageFormat.Bmp);
-                bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                    ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            }
-            catch (Exception e)
-            {
-                Logger.WriteLine("Error loading texture. " + e.Message);
-            }
 
+            OpenImageFile(path);
 
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+            GL.TexImage2D(TextureTarget.Texture2D, 
+                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
                 OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
 
-            bitmap.UnlockBits(bitmapData);
+            CloseImageFile();
 
@@ -53,3 +42,3 @@ namespace AWGL.Managers
             GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            
+
             m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
@@ -57,5 +46,48 @@ namespace AWGL.Managers
 
-        #region MyRegion
+        public void LoadSkyTexture(string textureId, string[] path)
+        {
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
+
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+
+            for (int face = 0; face < 6; face++)
+            {
+                OpenImageFile(path[face]);
+                bitmap.Save(face + ".bmp");
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
+                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+                GL.Finish();
+                CloseImageFile();
+            }
 
-        #endregion
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        private void OpenImageFile(string path)
+        {
+            bitmap = new Bitmap(path);
+
+            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+        }
+
+        private void CloseImageFile()
+        {
+            bitmap.UnlockBits(bitmapData);
+
+            CleanUp();
+        }
+
+        private void CleanUp()
+        {
+            bitmap.Dispose();
+        }
 
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index ca93718..ebd2cf8 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -11,3 +11,3 @@ namespace AWGL.Nodes
     {
-        protected BufferManager m_BufferManager;
+        protected BufferObjectManager m_BufferManager;
 
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index d9fb493..da559ff 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -13,3 +13,4 @@ namespace AWGL.Shapes
     {
-        public Cube()
+
+        public Cube(int x, int y, int z)
         {
@@ -17,10 +18,10 @@ namespace AWGL.Shapes
             {
-                new Vector3(-1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f, -1.0f, -1.0f), 
-                new Vector3( 1.0f,  1.0f, -1.0f),
-                new Vector3(-1.0f,  1.0f, -1.0f)
+                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f, y-1.0f, z-1.0f),
+                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
+                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
+                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
             };
@@ -68,2 +69,3 @@ namespace AWGL.Shapes
 
+
         /// <summary>
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index 9005258..b93645e 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -25,10 +25,6 @@ namespace AWGL.States
         StateManager m_stateManager;
-        ShaderManager m_shaderManager;
 
-        
-
-        public AssimpImportedState(StateManager stateManager, ShaderManager shaderManager)
+        public AssimpImportedState(StateManager stateManager)
         {
             m_stateManager = stateManager;
-            m_shaderManager = shaderManager;
         }
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
new file mode 100644
index 0000000..a35e38b
--- /dev/null
+++ b/AWGL/States/Skyboxstate.cs
@@ -0,0 +1,218 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.States
+{
+    public class Skyboxstate : IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        Cube cube;
+        BufferObject cubeObject;
+
+        // Data layout for each line below is:
+        // position{XYZ},			    normal{XYZ},
+        float[] vertexData = new float[] {
+            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
+  
+            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
+  
+            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
+  
+            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
+  
+            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
+  
+            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
+        };
+
+        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        Matrix3 modelMatrix3, normalMatrix;
+        Vector3 eyeObjectSpace;
+        Vector3 trans;
+
+        
+        int eye_handle, skybox_vao;
+
+        float aspect = 1024 / (float)600;
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            LoadCubeMap();
+            CreateShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+            trans = new Vector3(0f, 0f, -10f);
+
+            LoadTestObject();
+        }
+
+        private void CreateShaders()
+        {
+            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
+
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
+            eye_handle = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+            GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            GL.GenVertexArrays(1, out skybox_vao);
+            GL.BindVertexArray(skybox_vao);
+
+            GL.DepthFunc(DepthFunction.Lequal);
+            //GL.GenBuffers(1, out cubevbo);
+            //GL.BindBuffer(BufferTarget.ArrayBuffer, cubevbo);
+            //GL.BufferData(BufferTarget.ArrayBuffer, new IntPtr(sizeof(float) * vertexData.Length), vertexData, BufferUsageHint.StaticDraw);
+
+            //GL.EnableVertexAttribArray(vertexAttribPosition);
+            //GL.VertexAttribPointer(vertexAttribPosition, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(0));
+            //GL.EnableVertexAttribArray(vertexAttribNormal);
+            //GL.VertexAttribPointer(vertexAttribNormal, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(12));
+
+            //cubeindexCount = 36;
+        }
+
+        private void LoadTestObject()
+        {
+            cube = new Cube(0, 0, 0);
+            cubeObject = new BufferObject();
+            cubeObject.PositionData = cube.Vertices;
+            cubeObject.NormalsData = cube.Normals;
+            cubeObject.IndicesData = cube.Indices;
+            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
+
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Skybox").ID);
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            MoveCamera();
+            _rotation += elapsedTime * 0.1f;
+
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
+            Renderer.modelViewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            eyeObjectSpace = new Vector3(0.0f, 0.0f, 1.0f);
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Camera.GetViewMatrix());
+        }
+
+        public void Render()
+        {
+            Renderer.DrawSkyBox(m_textureManager, cubeObject);
+        }
+
+        #region Input Control
+        private void MoveCamera()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+
+            }
+        #endregion
+        }
+    }
+}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index 7477640..8507938 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
                 delay = 3;
-                m_stateManager.ChangeState("Default");
+                m_stateManager.SetState("Voxels");
             }
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index 6b2ac74..daf98d4 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -19,14 +19,10 @@ namespace AWGL.States
         BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
         BufferObject m_bufferObject;
         StateManager m_stateManager;
-        ShaderManager m_shaderManager;
-        Cube cube;
+        Cube cube = new Cube(0, 0, 0);
 
-        public VboState(StateManager stateManager, ShaderManager shaderManager)
+        public VboState(StateManager stateManager)
         {
             m_stateManager = stateManager;
-            this.m_stateManager = stateManager;
-            this.m_shaderManager = shaderManager;
-
-            cube = new Cube();
 
@@ -37,3 +33,2 @@ namespace AWGL.States
         {
-            // this buffer object will take care of VAO generation temporarily - stored in bufferObject.VaoId
             BufferObject tempVBO = new BufferObject();
@@ -44,5 +39,4 @@ namespace AWGL.States
 
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, m_shaderManager.ProgramHandle);
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
             m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-
         }
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
new file mode 100644
index 0000000..bc8d310
--- /dev/null
+++ b/AWGL/States/VoxelState.cs
@@ -0,0 +1,108 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Shapes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace AWGL.States
+{
+    public class VoxelState : IGameObject
+    {
+        double currentRotation = 0;
+        public float length = 1f, height = 1f, width = 1f;
+
+        StateManager m_stateManager = new StateManager();
+
+        BufferObjectManager m_bufferObjectManager;
+        BufferObject m_bufferObject;
+
+        TextureManager m_textureManager = new TextureManager();
+
+        Cube[][][] m_blocks;
+
+        public VoxelState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            m_bufferObjectManager = new BufferObjectManager();
+
+            //LoadSkyBox();
+
+            GenerateChunk();
+        }
+
+        private void LoadSkyBox()
+        {
+            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+            m_textureManager.LoadSkyTexture("skybox", 
+                new string[] 
+                {
+                    skyboxTexturePath + "jajlands1_ft.jpg",
+                    skyboxTexturePath + "jajlands1_bk.jpg",
+                    skyboxTexturePath + "jajlands1_lf.jpg",
+                    skyboxTexturePath + "jajlands1_rt.jpg",
+                    skyboxTexturePath + "jajlands1_up.jpg",
+                    skyboxTexturePath + "jajlands1_dn.jpg"
+                }
+            );
+
+        }
+
+        private void GenerateChunk()
+        {
+            BufferObject tmpVBO = new BufferObject();
+            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+            
+            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+            {
+                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+                {
+                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+                    {
+                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+                        if (x == 0 && y == 0 && z == 0) 
+                        { 
+                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+                        }
+                        else
+                        { 
+                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+                        }
+                    }
+                }
+            }
+
+            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 100 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+        }
+    }
+}
diff --git a/AWGL/TextRenderer.cs b/AWGL/TextRenderer.cs
deleted file mode 100644
index cc94917..0000000
--- a/AWGL/TextRenderer.cs
+++ /dev/null
@@ -1,155 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using OpenTK;
-using System.Drawing;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Uses System.Drawing for 2d text rendering.
-    /// </summary>
-    public class TextRenderer : IDisposable
-    {
-        Bitmap bmp;
-        Graphics gfx;
-        int texture;
-        Rectangle dirty_region;
-        bool disposed;
-
-        #region Constructors
-
-        /// <summary>
-        /// Constructs a new instance.
-        /// </summary>
-        /// <param name="width">The width of the backing store in pixels.</param>
-        /// <param name="height">The height of the backing store in pixels.</param>
-        public TextRenderer(int width, int height)
-        {
-            if (width <= 0)
-                throw new ArgumentOutOfRangeException("width");
-            if (height <= 0)
-                throw new ArgumentOutOfRangeException("height ");
-            if (GraphicsContext.CurrentContext == null)
-                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
-
-            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            gfx = Graphics.FromImage(bmp);
-            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
-
-            texture = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
-                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-        }
-
-        #endregion
-
-        #region Public Members
-
-        /// <summary>
-        /// Clears the backing store to the specified color.
-        /// </summary>
-        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
-        public void Clear(Color color)
-        {
-            gfx.Clear(color);
-            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
-        }
-
-        /// <summary>
-        /// Draws the specified string to the backing store.
-        /// </summary>
-        /// <param name="text">The <see cref="System.String"/> to draw.</param>
-        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
-        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
-        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
-        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
-        public void DrawString(string text, Font font, Brush brush, PointF point)
-        {
-            gfx.DrawString(text, font, brush, point);
-
-            SizeF size = gfx.MeasureString(text, font);
-            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
-            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
-        }
-
-        /// <summary>
-        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
-        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
-        /// in order to render the drawn text on screen.
-        /// </summary>
-        public int Texture
-        {
-            get
-            {
-                UploadBitmap();
-                return texture;
-            }
-        }
-
-        #endregion
-
-        #region Private Members
-
-        // Uploads the dirty regions of the backing store to the OpenGL texture.
-        void UploadBitmap()
-        {
-            if (dirty_region != RectangleF.Empty)
-            {
-                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
-                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-                GL.BindTexture(TextureTarget.Texture2D, texture);
-                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
-                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
-                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-                bmp.UnlockBits(data);
-
-                dirty_region = Rectangle.Empty;
-            }
-        }
-
-        #endregion
-
-        #region IDisposable Members
-
-        void Dispose(bool manual)
-        {
-            if (!disposed)
-            {
-                if (manual)
-                {
-                    bmp.Dispose();
-                    gfx.Dispose();
-                    if (GraphicsContext.CurrentContext != null)
-                        GL.DeleteTexture(texture);
-                }
-
-                disposed = true;
-            }
-        }
-
-        public void Dispose()
-        {
-            Dispose(true);
-            GC.SuppressFinalize(this);
-        }
-
-        ~TextRenderer()
-        {
-            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
-        }
-
-        #endregion
-    }
-
-}
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
new file mode 100644
index 0000000..80a21e8
--- /dev/null
+++ b/AWGL/Utilities/Block.cs
@@ -0,0 +1,29 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public class Block
+    {
+        enum BlockType
+        {
+            BlockType_Default = 0,
+
+            BlockType_Grass,
+            BlockType_Dirt,
+            BlockType_Water,
+            BlockType_Stone,
+            BlockType_Wood,
+            BlockType_Sand,
+
+            BlockType_NumTypes,
+        };
+
+        public bool IsActive { get; set; }
+        private bool m_active;
+        private BlockType type;
+    }
+}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index 014da3d..be2ebfc 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -12,10 +12,10 @@ namespace AWGL.Utilities
     /// </summary>
-    public class Camera
+    public static class Camera
     {
-        public Vector3 Position = new Vector3(0f, 5f, 5f);
-        public Vector3 Orientation = new Vector3(0f, 0f, 0f);
-        public float MoveSpeed = 0.2f;
-        public float MouseSensitivity = 0.01f;
+        public static Vector3 Position = new Vector3(0f, 0f, 0f);
+        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static float MoveSpeed = 0.2f;
+        public static float MouseSensitivity = 0.01f;
 
-        public Matrix4 LookAtMatrix
+        public static Matrix4 LookAtMatrix
         {
@@ -26,3 +26,4 @@ namespace AWGL.Utilities
         }
-        public Matrix4 GetViewMatrix()
+
+        public static Matrix4 GetViewMatrix()
         {
@@ -37,3 +38,3 @@ namespace AWGL.Utilities
 
-        public void Move(float x, float y, float z)
+        public static void Move(float x, float y, float z)
         {
@@ -56,3 +57,3 @@ namespace AWGL.Utilities
 
-        public void AddRotation(float x, float y)
+        public static void AddRotation(float x, float y)
         {
@@ -63,4 +64,2 @@ namespace AWGL.Utilities
             Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-
-            Logger.WriteLine("Camera Orientation = " + Orientation);
         }
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
new file mode 100644
index 0000000..1daf90b
--- /dev/null
+++ b/AWGL/Utilities/Chunk.cs
@@ -0,0 +1,91 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+namespace AWGL.Utilities
+{
+    public class Chunk : IDisposable
+    {
+        public const int CHUNK_SIZE = 16;
+        private Block[][][] m_blocks;
+        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+
+        public Chunk()
+        {
+            //Create Blocks
+            m_blocks = new Block[CHUNK_SIZE][][];
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                m_blocks[i] = new Block[CHUNK_SIZE][];
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+                }
+            }
+        }
+
+        public void Update(float dt) { }
+
+        public void Render() { }
+
+        public void Dispose()
+        {
+            // Delete blocks
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = null;
+                }
+                m_blocks[i] = null;
+            }
+            m_blocks = null;
+        }
+
+        public void CreateMesh()
+        {
+            for (int x = 0; x < CHUNK_SIZE; x++)
+            {
+                for (int y = 0; y < CHUNK_SIZE; y++)
+                {
+                    for (int z = 0; z < CHUNK_SIZE; z++)
+                    {
+                        if (m_blocks[x][y][z].IsActive == false)
+                        {
+                            // Don't create triangle data for inactive blocks
+                            continue;
+                        }
+
+                        CreateCube(x, y, z);
+                    }
+                }
+            }
+        }
+
+        private void CreateCube(int x, int y, int z)
+        {
+            float blockSize = 1f;
+
+            
+            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+
+            Vector3 n1;
+
+
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
new file mode 100644
index 0000000..bc2853d
--- /dev/null
+++ b/AWGL/Utilities/Extensions.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public static class Extensions
+    {
+        // http://stackoverflow.com/a/1547282/1090268
+        public static T[] Concat<T>(this T[] x, T[] y)
+        {
+            if (x == null) throw new ArgumentNullException("x");
+            if (y == null) throw new ArgumentNullException("y");
+            int oldLen = x.Length;
+            Array.Resize<T>(ref x, x.Length + y.Length);
+            Array.Copy(y, 0, x, oldLen, y.Length);
+            return x;
+        }
+    }
+}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 22d380d..780768e 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK;
+﻿using AWGL.Managers;
+using OpenTK;
 using OpenTK.Graphics;
@@ -10,12 +11,8 @@ namespace AWGL.Utilities
 {
-    class Renderer
+    public static class Renderer
     {
-        public Renderer()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            //GL.Enable(EnableCap.Blend);
-            //GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
-        }
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix;
 
-        public void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
         {
@@ -26,3 +23,3 @@ namespace AWGL.Utilities
 
-        public void DrawSprite(Sprite sprite)
+        public static void DrawSprite(Sprite sprite)
         {
@@ -36,3 +33,2 @@ namespace AWGL.Utilities
                     sprite.VertexUVs[i]);
-
             }
@@ -41,5 +37,43 @@ namespace AWGL.Utilities
 
-        public void DrawSkyBox()
+        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        {
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+
+            GL.Disable(EnableCap.DepthTest);
+            int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
+            GL.Uniform1(temploc, 0);
+
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            //GL.Uniform3(eye_handle, ref eyeObjectSpace);
+            GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);
+
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public static void DrawWireframeVoxel(float length, float height, float width)
+        {
+            
+        }
+
+        public static void DrawChunk(Chunk chunk)
+        {
+
+        }
+
+        internal static void ToggleWireframeOn()
         {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
 
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
         }
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
new file mode 100644
index 0000000..fe0bd98
--- /dev/null
+++ b/AWGL/Utilities/Shader.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace AWGL.Utilities
+{
+    public struct Shader
+    {
+        public int ID { get; set; }
+
+        public Shader(int id)
+            : this()
+        {
+            ID = id;
+        }
+    }
+}
diff --git a/Game/Game.cs b/Game/Game.cs
index 3fac302..ff2e880 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -13,4 +13,3 @@ namespace Game
     {
-        public StateManager stateManager;
-        public TextureManager texManager;
+        public StateManager stateManager = new StateManager();
 
@@ -20,18 +19,15 @@ namespace Game
         {
+            SetupStates();
+            stateManager.SetState("skybox");
+        }
 
-            texManager = new TextureManager();
-
-            texManager.LoadTexture("sprite1", "Data/Textures/logo.jpg");
-            texManager.LoadTexture("sprite2", "Data/Textures/metal.jpg");
-
-            stateManager = new StateManager();
-            stateManager.AddState("Splash", new SplashScreenState(stateManager));
-            stateManager.AddState("Default", new DefaultState(stateManager));
-            stateManager.AddState("Drawing", new DrawSpriteState(stateManager, texManager));
-            stateManager.AddState("TestTexture", new TestSpriteClassState(texManager));
-            //stateManager.AddState("VboState", new VboState(stateManager, shaderManager));
-            stateManager.AddState("Assimp-state", new AssimpImportedState(stateManager, shaderManager));
+        private void SetupStates()
+        {
+            stateManager.AddState("skybox", new Skyboxstate(stateManager));
+            stateManager.AddState("vbo", new VboState(stateManager));
+        }
 
-            stateManager.ChangeState("Assimp-state");
-            //stateManager.ChangeState("VboState");
+        private void SetState(string stateToLoad)
+        {
+            stateManager.SetState(stateToLoad);
         }
diff --git a/Game/Program.cs b/Game/Program.cs
index a9832fc..0e40c51 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -1,17 +1,17 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace Game
-{
-    static class Program
-    {
-        [STAThread]
-        static void Main()
-        {
-            using (Game game = new Game(1024, 600, 3, 2)) { game.Run(60, 0); }
-        }
-    }
-}
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Game
+{
+    static class Program
+    {
+        [STAThread]
+        static void Main()
+        {
+            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(60, 0); }
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5b2e825fc4418672a624382e08ebde5dae4f6903">Clean Out #1</a>  -  5b2e825</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 22 files changed, 56 insertions(+), 144 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index ee38827..cac9e9d 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,3 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
+        protected AnimationTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace AWGL
         {
-            m_Timer = new PreciseTimer();
+            m_Timer = new AnimationTimer();
         }
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
index f0656a9..4ae5676 100644
--- a/AWGL/Interfaces/IGameObject.cs
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -1,6 +1,2 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 namespace AWGL.Interfaces
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 497ce1e..6c22cee 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -1,11 +1,6 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using AWGL.Utilities;
-using AWGL.Shapes;
+﻿using AWGL.Utilities;
 using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using OpenTK.Graphics;
-using System.Runtime.InteropServices;
+using System;
+using System.Collections.Generic;
 
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 4985b5d..033aac7 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -1,6 +1,3 @@
 ﻿using OpenTK.Input;
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
index 0ad1daa..379e697 100644
--- a/AWGL/Managers/ModelManager.cs
+++ b/AWGL/Managers/ModelManager.cs
@@ -1,6 +1,2 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 namespace AWGL.Managers
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index 1de11cf..d7ed991 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -1,12 +1,5 @@
-﻿using System;
+﻿using AWGL.Utilities;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.IO;
-using OpenTK.Graphics.OpenGL;
-using System.Diagnostics;
-using OpenTK;
-using System.Drawing;
-using AWGL.Utilities;
 
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index 81cdad1..2e7bffb 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -1,7 +1,4 @@
 ﻿using AWGL.Interfaces;
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 
@@ -34,3 +31,3 @@ namespace AWGL.Managers
 
-        public void SetState(string stateName)
+        public void ChangeState(string stateName)
         {
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
index b5ee17a..cd2b473 100644
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -1,8 +1,4 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-using NUnit.Framework;
+﻿
 using AWGL.States;
+using NUnit.Framework;
 
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 83a2473..91135bd 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -1,8 +1,3 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
+﻿
 using NUnit.Framework;
-using AWGL.Utilities;
 
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index f58a674..ca2af2d 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -6,4 +6,2 @@ using System.Drawing;
 using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index b93645e..cee39bb 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -3,16 +3,2 @@ using AWGL.Managers;
 using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Assimp.Configs;
-using Assimp;
-using System.IO;
-using System.Reflection;
-using System.Drawing;
-using System.Drawing.Imaging;
 
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
index 70930e5..2c2bc68 100644
--- a/AWGL/States/DefaultState.cs
+++ b/AWGL/States/DefaultState.cs
@@ -5,7 +5,3 @@ using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index 3588115..d806653 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -5,7 +5,3 @@ using OpenTK;
 using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
 using System.Drawing;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index a35e38b..31502dc 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -5,3 +5,2 @@ using AWGL.Utilities;
 using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
@@ -9,8 +8,2 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index 8507938..d1d3fcc 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -30,3 +30,3 @@ namespace AWGL.States
                 delay = 3;
-                m_stateManager.SetState("Voxels");
+                m_stateManager.ChangeState("Voxels");
             }
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index daf98d4..bb1b9f0 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -1,14 +1,7 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using AWGL.Interfaces;
+﻿using AWGL.Interfaces;
 using AWGL.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
 using AWGL.Shapes;
 using AWGL.Utilities;
-using System.Drawing;
-using System.Diagnostics;
+using OpenTK.Graphics.OpenGL;
+using System;
 
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
index bc8d310..7f887b8 100644
--- a/AWGL/States/VoxelState.cs
+++ b/AWGL/States/VoxelState.cs
@@ -4,12 +4,4 @@ using AWGL.Shapes;
 using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
 using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading;
-using System.Threading.Tasks;
 
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
new file mode 100644
index 0000000..99ffa7a
--- /dev/null
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -0,0 +1,39 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.Utilities
+{
+    public class AnimationTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public AnimationTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public float GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 2a71e55..892f8fd 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -2,6 +2,3 @@
 using System;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 
diff --git a/AWGL/Utilities/Point.cs b/AWGL/Utilities/Point.cs
deleted file mode 100644
index 5f28270..0000000
--- a/AWGL/Utilities/Point.cs
+++ /dev/null
@@ -1 +0,0 @@
-﻿
\ No newline at end of file
diff --git a/AWGL/Utilities/PreciseTimer.cs b/AWGL/Utilities/PreciseTimer.cs
deleted file mode 100644
index 6fe09fc..0000000
--- a/AWGL/Utilities/PreciseTimer.cs
+++ /dev/null
@@ -1,39 +0,0 @@
-﻿
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.Utilities
-{
-    public class PreciseTimer
-    {
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
-
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
-
-        long m_ticksPerSecond = 0;
-        long m_previouslyElapsedTime = 0;
-
-        public PreciseTimer()
-        {
-            QueryPerformanceFrequency(ref m_ticksPerSecond);
-            GetElapsedTime();
-        }
-
-        public float GetElapsedTime()
-        {
-            long time = 0;
-            QueryPerformanceCounter(ref time);
-
-            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
-
-            return elapsedTime;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 780768e..5a6fa86 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -5,5 +5,2 @@ using OpenTK.Graphics.OpenGL;
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8d1a2af6e728f7092fcfd3d1c2313b3dcc0499ee">sorting out dependencies after todays fiasco on the lab machines. .Net4.5.1->.Net4.5</a>  -  8d1a2af</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index ff2e880..8eda708 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -20,3 +20,3 @@ namespace Game
             SetupStates();
-            stateManager.SetState("skybox");
+            stateManager.ChangeState("skybox");
         }
@@ -26,3 +26,2 @@ namespace Game
             stateManager.AddState("skybox", new Skyboxstate(stateManager));
-            stateManager.AddState("vbo", new VboState(stateManager));
         }
@@ -31,3 +30,3 @@ namespace Game
         {
-            stateManager.SetState(stateToLoad);
+            stateManager.ChangeState(stateToLoad);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/96d5be68daa6d803b5c170bbc58faa22ea28844a">Dependency change again, Nuget didn't act as trouble free as it first seemed to be. .</a>  -  96d5be6</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 22 files changed, 504 insertions(+)

diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/22c79083a6f717525e2dda4372c728aa635534f1">Refactor</a>  -  22c7908</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
index 99ffa7a..6fe09fc 100644
--- a/AWGL/Utilities/AnimationTimer.cs
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -8,3 +8,3 @@ namespace AWGL.Utilities
 {
-    public class AnimationTimer
+    public class PreciseTimer
     {
@@ -21,3 +21,3 @@ namespace AWGL.Utilities
 
-        public AnimationTimer()
+        public PreciseTimer()
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c48b6c163f867044b460ca6d433c593cdf10fefd">Refactor.</a>  -  c48b6c1</p><p>authored by Anthony Woodward, 8 weeks ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
index cac9e9d..ee38827 100644
--- a/AWGL/AWEngineWindow.cs
+++ b/AWGL/AWEngineWindow.cs
@@ -39,3 +39,3 @@ namespace AWGL
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected AnimationTimer m_Timer;
+        protected PreciseTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace AWGL
         {
-            m_Timer = new AnimationTimer();
+            m_Timer = new PreciseTimer();
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/4fcfdc865df36a6b5dd9022a99d806ac42d5f6b5">Sticking with 3.3 Core Profile.</a>  -  4fcfdc8</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Game/Program.cs b/Game/Program.cs
index 0e40c51..c1a111c 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 4, 1)) { game.Run(60, 0); }
+            using (Game game = new Game(1024, 600, 3, 3)) { game.Run(60, 0); }
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/89c0d8a67a723abc4cebadd0db0d5bed869c2e3f">Switching logger to output to the console.</a>  -  89c0d8a</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 892f8fd..3e4bbb7 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Debug.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fc5b094184cf8456bc085c27715341d4c8fee528">Hooked up eye_position in the shader. Definately just made some progress.</a>  -  fc5b094</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index 6ef7af2..b5d3304 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -15,4 +15,4 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = in_position;
-	gl_Position = mvp_matrix * vec4(in_position, 1.0);
+	vs_out.tc = in_position.xyz;
+	gl_Position = mvp_matrix * vec4(in_position.xyz - eye_position, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index 31502dc..c56ad6c 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -106,5 +106,5 @@ namespace AWGL.States
 
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
             Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
-            eye_handle = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
         }
@@ -151,5 +151,5 @@ namespace AWGL.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
-            Renderer.modelViewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
-            eyeObjectSpace = new Vector3(0.0f, 0.0f, 1.0f);
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Camera.GetViewMatrix());
+            Renderer.modelViewMatrix = Matrix4.Identity;
+            Renderer.eyePosition = Camera.Position;
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 5a6fa86..ffca12c 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -11,3 +11,4 @@ namespace AWGL.Utilities
         internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix;
+        internal static Vector3 eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition;
 
@@ -48,3 +49,3 @@ namespace AWGL.Utilities
             GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
-            //GL.Uniform3(eye_handle, ref eyeObjectSpace);
+            GL.Uniform3(handle_eyePosition, ref eyePosition);
             GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d205aa68f1f58037be852ae9ea7363801e58a120">slight mods, nothing major</a>  -  d205aa6</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index c56ad6c..19187da 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -150,6 +150,6 @@ namespace AWGL.States
 
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(65.0f), aspect, 0.1f, 100.0f);
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
             Renderer.modelViewMatrix = Matrix4.Identity;
             Renderer.eyePosition = Camera.Position;
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index ffca12c..a932714 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -48,3 +48,3 @@ namespace AWGL.Utilities
 
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            
             GL.Uniform3(handle_eyePosition, ref eyePosition);
@@ -56,2 +56,5 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.DepthTest);
+
+            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/afb87106e17f139803c3a0363d73fcb37b7bc510">KAOS name change, needs a clean eye checkover.</a>  -  afb8710</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 4 files changed, 439 insertions(+), 520 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
deleted file mode 100644
index ee38827..0000000
--- a/AWGL/AWEngineWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class AWEngineWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = AWEngineWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/KAOSEngine.cs b/AWGL/KAOSEngine.cs
new file mode 100644
index 0000000..9465ea2
--- /dev/null
+++ b/AWGL/KAOSEngine.cs
@@ -0,0 +1,437 @@
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+
+        /// Loop Area
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 3e4bbb7..dfdaff8 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index 8eda708..6ec5f44 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : AWEngineWindow
+    class Game : KAOSEngine
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8a3fada5f1891333c5afec1487ea67cb0a15fb29">Skybox rotation now works. Movement not so much.</a>  -  8a3fada</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 4 files changed, 25 insertions(+), 21 deletions(-)

diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index b5d3304..f341e57 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -8,4 +8,3 @@
 uniform vec3 eye_position;
-uniform mat4 mv_matrix;
-uniform mat4 mvp_matrix;
+uniform mat4 view_matrix;
 
@@ -15,4 +14,4 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = in_position.xyz;
-	gl_Position = mvp_matrix * vec4(in_position.xyz - eye_position, 1.0);
+	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	gl_Position = vec4(in_position.xyz - eye_position, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index 19187da..eb36378 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -107,4 +107,9 @@ namespace AWGL.States
             Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_modelViewProjectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mvp_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "mv_matrix");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
+
+            Logger.WriteLine("Render Shader");
+            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
         }
@@ -151,3 +156,6 @@ namespace AWGL.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            Renderer.modelViewMatrix = Matrix4.Identity;
+            
+            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(new Vector3(0f, -4f, 0f)));
             Renderer.eyePosition = Camera.Position;
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index be2ebfc..3cb02fc 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -19,10 +19,2 @@ namespace AWGL.Utilities
 
-        public static Matrix4 LookAtMatrix
-        {
-            get
-            {
-                return GetViewMatrix();
-            }
-        }
-
         public static Matrix4 GetViewMatrix()
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index a932714..4101369 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -10,5 +10,5 @@ namespace AWGL.Utilities
     {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix;
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
         internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
 
@@ -44,3 +44,2 @@ namespace AWGL.Utilities
 
-            GL.Disable(EnableCap.DepthTest);
             int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
@@ -48,7 +47,10 @@ namespace AWGL.Utilities
 
-            
+            eyePosition = Camera.Position;
             GL.Uniform3(handle_eyePosition, ref eyePosition);
-            GL.UniformMatrix4(handle_modelViewProjectionMatrix, false, ref modelViewProjectionMatrix);
 
             GL.BindVertexArray(cubeObject.VaoID);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+
             GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
@@ -57,4 +59,7 @@ namespace AWGL.Utilities
 
-            Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            //Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
             GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7273c137d69cf891f6a7601f14a8a3133d464916">Tidying everything up.</a>  -  7273c13</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 6 files changed, 31 insertions(+), 38 deletions(-)

diff --git a/AWGL/Data/Interfaces/IGameObject.cs b/AWGL/Data/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..4ae5676
--- /dev/null
+++ b/AWGL/Data/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
index fa93cee..b9c351c 100644
--- a/AWGL/Data/Shaders/render-fs.glsl
+++ b/AWGL/Data/Shaders/render-fs.glsl
@@ -4,2 +4,6 @@ uniform samplerCube tex_cubemap;
 
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
 in VS_OUT
@@ -20,2 +24,6 @@ void main(void)
      color = texture(tex_cubemap, r);
+
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
 }
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
index f341e57..c433716 100644
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ b/AWGL/Data/Shaders/skybox-vs.glsl
@@ -7,3 +7,2 @@
 
-uniform vec3 eye_position;
 uniform mat4 view_matrix;
@@ -15,3 +14,3 @@ in lowp vec3 in_position;
 	vs_out.tc = mat3(view_matrix) * in_position.xyz;
-	gl_Position = vec4(in_position.xyz - eye_position, 1.0);
+	gl_Position = vec4(in_position.xyz, 1.0);
  }
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
deleted file mode 100644
index 4ae5676..0000000
--- a/AWGL/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace AWGL.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index eb36378..b07d87f 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -125,12 +125,2 @@ namespace AWGL.States
             GL.DepthFunc(DepthFunction.Lequal);
-            //GL.GenBuffers(1, out cubevbo);
-            //GL.BindBuffer(BufferTarget.ArrayBuffer, cubevbo);
-            //GL.BufferData(BufferTarget.ArrayBuffer, new IntPtr(sizeof(float) * vertexData.Length), vertexData, BufferUsageHint.StaticDraw);
-
-            //GL.EnableVertexAttribArray(vertexAttribPosition);
-            //GL.VertexAttribPointer(vertexAttribPosition, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(0));
-            //GL.EnableVertexAttribArray(vertexAttribNormal);
-            //GL.VertexAttribPointer(vertexAttribNormal, 3, VertexAttribPointerType.Float, false, 24, BUFFER_OFFSET(12));
-
-            //cubeindexCount = 36;
         }
@@ -146,4 +136,4 @@ namespace AWGL.States
 
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Skybox").ID);
-            cubeObject = m_bufferManager.GetBuffer("Cube");
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
         }
@@ -153,3 +143,2 @@ namespace AWGL.States
             MoveCamera();
-            _rotation += elapsedTime * 0.1f;
 
@@ -159,5 +148,4 @@ namespace AWGL.States
 
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(new Vector3(0f, -4f, 0f)));
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
-            
         }
@@ -166,3 +154,13 @@ namespace AWGL.States
         {
+            cubeObject = m_bufferManager.GetBuffer("SkyCube");
             Renderer.DrawSkyBox(m_textureManager, cubeObject);
+            
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 4101369..4067c1a 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -44,8 +44,2 @@ namespace AWGL.Utilities
 
-            int temploc = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "tex_cubemap");
-            GL.Uniform1(temploc, 0);
-
-            eyePosition = Camera.Position;
-            GL.Uniform3(handle_eyePosition, ref eyePosition);
-
             GL.BindVertexArray(cubeObject.VaoID);
@@ -58,8 +52,2 @@ namespace AWGL.Utilities
             GL.Enable(EnableCap.DepthTest);
-
-            GL.UseProgram(ShaderManager.Get("Render").ID);
-
-            //Renderer.modelViewProjectionMatrix = Matrix4.Mult(Renderer.projectionMatrix, Renderer.modelViewMatrix);
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
-            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/949673c06a50ae435abcc33c1b05e27f8fe1a9f3">Revert "KAOS name change, needs a clean eye checkover."</a>  -  949673c</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 4 files changed, 520 insertions(+), 439 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
new file mode 100644
index 0000000..ee38827
--- /dev/null
+++ b/AWGL/AWEngineWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using AWGL.Managers;
+using AWGL.Nodes;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace AWGL
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class AWEngineWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public AWEngineWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = AWEngineWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/KAOSEngine.cs b/AWGL/KAOSEngine.cs
deleted file mode 100644
index 9465ea2..0000000
--- a/AWGL/KAOSEngine.cs
+++ /dev/null
@@ -1,437 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSEngine : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "KAOS"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public KAOSEngine(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-
-        /// Loop Area
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSEngine.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index dfdaff8..3e4bbb7 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
         }
diff --git a/Game/Game.cs b/Game/Game.cs
index 6ec5f44..8eda708 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : KAOSEngine
+    class Game : AWEngineWindow
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/efa5e8c11eb765f83d8bcdfdc88d58a76fcf126a">Fixing Project</a>  -  efa5e8c</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/AWGL/Data/Interfaces/IGameObject.cs b/AWGL/Data/Interfaces/IGameObject.cs
deleted file mode 100644
index 4ae5676..0000000
--- a/AWGL/Data/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace AWGL.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..4ae5676
--- /dev/null
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace AWGL.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/aeb7175143d35b3534776ad7ed1c34df589c483d">Renaming project.</a>  -  aeb7175</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 59 files changed, 611 insertions(+), 611 deletions(-)

diff --git a/AWGL/AWEngineWindow.cs b/AWGL/AWEngineWindow.cs
deleted file mode 100644
index ee38827..0000000
--- a/AWGL/AWEngineWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using AWGL.Managers;
-using AWGL.Nodes;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace AWGL
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class AWEngineWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public AWEngineWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), AWEngineWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = AWEngineWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
index 4ae5676..b2da157 100644
--- a/AWGL/Interfaces/IGameObject.cs
+++ b/AWGL/Interfaces/IGameObject.cs
@@ -1,3 +1,3 @@
 ﻿
-namespace AWGL.Interfaces
+namespace KAOS.Interfaces
 {
diff --git a/AWGL/KAOSWindow.cs b/AWGL/KAOSWindow.cs
new file mode 100644
index 0000000..8751f33
--- /dev/null
+++ b/AWGL/KAOSWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Managers;
+using KAOS.Nodes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
index 6c22cee..5ad5904 100644
--- a/AWGL/Managers/BufferObjectManager.cs
+++ b/AWGL/Managers/BufferObjectManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK;
@@ -6,3 +6,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
index 033aac7..83ddedd 100644
--- a/AWGL/Managers/InputManager.cs
+++ b/AWGL/Managers/InputManager.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
index 379e697..c118589 100644
--- a/AWGL/Managers/ModelManager.cs
+++ b/AWGL/Managers/ModelManager.cs
@@ -1,3 +1,3 @@
 ﻿
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
index d7ed991..ab00068 100644
--- a/AWGL/Managers/ShaderManager.cs
+++ b/AWGL/Managers/ShaderManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -5,3 +5,3 @@ using System.IO;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
index 2e7bffb..8a00128 100644
--- a/AWGL/Managers/StateManager.cs
+++ b/AWGL/Managers/StateManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Interfaces;
+﻿using KAOS.Interfaces;
 using System.Collections.Generic;
@@ -4,3 +4,3 @@ using System.Diagnostics;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
index cd2b473..fc92063 100644
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ b/AWGL/Managers/Tests/StateManagerTest.cs
@@ -1,6 +1,6 @@
 ﻿
-using AWGL.States;
+using KAOS.States;
 using NUnit.Framework;
 
-namespace AWGL.Managers.Tests
+namespace KAOS.Managers.Tests
 {
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
index 91135bd..007e120 100644
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ b/AWGL/Managers/Tests/TextureManagerTest.cs
@@ -3,3 +3,3 @@ using NUnit.Framework;
 
-namespace AWGL.Managers.Tests
+namespace KAOS.Managers.Tests
 {
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
index ca2af2d..0970750 100644
--- a/AWGL/Managers/TextureManager.cs
+++ b/AWGL/Managers/TextureManager.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Utilities;
+﻿using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System.Drawing.Imaging;
 
-namespace AWGL.Managers
+namespace KAOS.Managers
 {
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
index 536eeeb..58875a5 100644
--- a/AWGL/Nodes/AWCube.cs
+++ b/AWGL/Nodes/AWCube.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Shapes;
-using AWGL.Tutorial;
+﻿using KAOS.Shapes;
+using KAOS.Tutorial;
 using OpenTK;
@@ -11,3 +11,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
index e9d9de0..1e65c18 100644
--- a/AWGL/Nodes/AWGraphLines.cs
+++ b/AWGL/Nodes/AWGraphLines.cs
@@ -10,3 +10,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
index 2190c34..0fb12d0 100644
--- a/AWGL/Nodes/AWGroupNode.cs
+++ b/AWGL/Nodes/AWGroupNode.cs
@@ -8,3 +8,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
index 6c266a2..d5f77a0 100644
--- a/AWGL/Nodes/AWMesh.cs
+++ b/AWGL/Nodes/AWMesh.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
index ebd2cf8..d0dddca 100644
--- a/AWGL/Nodes/AWNode.cs
+++ b/AWGL/Nodes/AWNode.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Managers;
+﻿using KAOS.Managers;
 using System;
@@ -7,3 +7,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
index 6d0c8ca..44911f9 100644
--- a/AWGL/Nodes/AWParticles.cs
+++ b/AWGL/Nodes/AWParticles.cs
@@ -8,3 +8,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
index fddd1ad..85afb1d 100644
--- a/AWGL/Nodes/AWPolygon.cs
+++ b/AWGL/Nodes/AWPolygon.cs
@@ -9,3 +9,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
index abfbd48..888793f 100644
--- a/AWGL/Nodes/IGroupNode.cs
+++ b/AWGL/Nodes/IGroupNode.cs
@@ -5,3 +5,3 @@ using System.Text;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
index b1e3f51..0924346 100644
--- a/AWGL/Nodes/ISceneNode.cs
+++ b/AWGL/Nodes/ISceneNode.cs
@@ -6,3 +6,3 @@ using System.Text;
 
-namespace AWGL.Nodes
+namespace KAOS.Nodes
 {
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
index 908685b..0f9cd8a 100644
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ b/AWGL/Shapes/Base/DrawableShape.cs
@@ -10,3 +10,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
index a83299f..0f64155 100644
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ b/AWGL/Shapes/Base/VertexStructs.cs
@@ -3,3 +3,3 @@ using System.Runtime.InteropServices;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
index be7248a..cd6f7e6 100644
--- a/AWGL/Shapes/Capsule.cs
+++ b/AWGL/Shapes/Capsule.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
index e72266a..1c340a1 100644
--- a/AWGL/Shapes/ChamferCube.cs
+++ b/AWGL/Shapes/ChamferCube.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
index 1d029c9..ebac329 100644
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ b/AWGL/Shapes/Helpers/Chunk.cs
@@ -2,3 +2,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
index 96d04a5..2dc56fc 100644
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ b/AWGL/Shapes/Helpers/MengerCube.cs
@@ -4,3 +4,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
index b6dd18e..5b4e4cc 100644
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ b/AWGL/Shapes/Helpers/TetrahedronFace.cs
@@ -2,3 +2,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
index 935452e..62d5462 100644
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ b/AWGL/Shapes/Helpers/VboShape.cs
@@ -1,2 +1,2 @@
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
index b83ee64..a662cfe 100644
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ b/AWGL/Shapes/KochTetrahedron.cs
@@ -2,3 +2,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
index a7821e3..c1d54c6 100644
--- a/AWGL/Shapes/MengerSponge.cs
+++ b/AWGL/Shapes/MengerSponge.cs
@@ -4,3 +4,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
index da559ff..99c2d1b 100644
--- a/AWGL/Shapes/Old/Cube.cs
+++ b/AWGL/Shapes/Old/Cube.cs
@@ -9,3 +9,3 @@ using System.Drawing;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
index dea9734..4b2ae9f 100644
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ b/AWGL/Shapes/Old/IsoSphere.cs
@@ -9,3 +9,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
index 6c4801c..df9a78e 100644
--- a/AWGL/Shapes/Old/Plane.cs
+++ b/AWGL/Shapes/Old/Plane.cs
@@ -12,3 +12,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
index 18ba007..c5315af 100644
--- a/AWGL/Shapes/Old/Shape.cs
+++ b/AWGL/Shapes/Old/Shape.cs
@@ -10,3 +10,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
index 4d7db8e..fcb493d 100644
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
@@ -3,3 +3,3 @@ using System;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
index 3718073..8a744ca 100644
--- a/AWGL/Shapes/SlicedHose.cs
+++ b/AWGL/Shapes/SlicedHose.cs
@@ -2,3 +2,3 @@ using OpenTK;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
index 0562c49..7c5ee4f 100644
--- a/AWGL/Shapes/SlicedSphere.cs
+++ b/AWGL/Shapes/SlicedSphere.cs
@@ -3,3 +3,3 @@ using System.Collections.Generic;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
index e8953f0..898c314 100644
--- a/AWGL/Shapes/TorusKnot.cs
+++ b/AWGL/Shapes/TorusKnot.cs
@@ -3,3 +3,3 @@ using System.Diagnostics;
 
-namespace AWGL.Shapes
+namespace KAOS.Shapes
 {
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
index e194506..2576afe 100644
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ b/AWGL/Shapes/VertexPositionColor.cs
@@ -31,3 +31,3 @@ using System.Runtime.InteropServices;
 
-namespace AWGL.Tutorial
+namespace KAOS.Tutorial
 {
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
index cee39bb..40dbc84 100644
--- a/AWGL/States/AssimpImportedState.cs
+++ b/AWGL/States/AssimpImportedState.cs
@@ -1,6 +1,6 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
index 2c2bc68..e26345e 100644
--- a/AWGL/States/DefaultState.cs
+++ b/AWGL/States/DefaultState.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Drawing;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
index d806653..f83dcda 100644
--- a/AWGL/States/DrawSpriteState.cs
+++ b/AWGL/States/DrawSpriteState.cs
@@ -1,4 +1,4 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Drawing;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
index b07d87f..59095f9 100644
--- a/AWGL/States/Skyboxstate.cs
+++ b/AWGL/States/Skyboxstate.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK;
@@ -9,3 +9,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
index d1d3fcc..c18d9ec 100644
--- a/AWGL/States/SplashScreenState.cs
+++ b/AWGL/States/SplashScreenState.cs
@@ -1,3 +1,3 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
 using OpenTK;
@@ -12,3 +12,3 @@ using System.Timers;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
index bb1b9f0..917dae0 100644
--- a/AWGL/States/VboState.cs
+++ b/AWGL/States/VboState.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
index 7f887b8..e8b82e2 100644
--- a/AWGL/States/VoxelState.cs
+++ b/AWGL/States/VoxelState.cs
@@ -1,5 +1,5 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Shapes;
-using AWGL.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK.Graphics.OpenGL;
@@ -7,3 +7,3 @@ using System;
 
-namespace AWGL.States
+namespace KAOS.States
 {
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
index 6fe09fc..9d28a68 100644
--- a/AWGL/Utilities/AnimationTimer.cs
+++ b/AWGL/Utilities/AnimationTimer.cs
@@ -6,3 +6,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
index 80a21e8..4d80ab9 100644
--- a/AWGL/Utilities/Block.cs
+++ b/AWGL/Utilities/Block.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
index 7b917da..18a1ea1 100644
--- a/AWGL/Utilities/BufferObject.cs
+++ b/AWGL/Utilities/BufferObject.cs
@@ -8,3 +8,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
index 3cb02fc..59ace7e 100644
--- a/AWGL/Utilities/Camera.cs
+++ b/AWGL/Utilities/Camera.cs
@@ -7,3 +7,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
index 1daf90b..26681e0 100644
--- a/AWGL/Utilities/Chunk.cs
+++ b/AWGL/Utilities/Chunk.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Shapes;
+﻿using KAOS.Shapes;
 using OpenTK;
@@ -7,3 +7,3 @@ using System.Text;
 using System.Threading.Tasks;
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
index 2876ecc..e3d3585 100644
--- a/AWGL/Utilities/CustomVertexStruct.cs
+++ b/AWGL/Utilities/CustomVertexStruct.cs
@@ -7,3 +7,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
index bc2853d..759ed2a 100644
--- a/AWGL/Utilities/Extensions.cs
+++ b/AWGL/Utilities/Extensions.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
index 3e4bbb7..6e15e05 100644
--- a/AWGL/Utilities/Logger.cs
+++ b/AWGL/Utilities/Logger.cs
@@ -4,3 +4,3 @@ using System.Diagnostics;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
@@ -14,3 +14,3 @@ namespace AWGL.Utilities
         {
-            Console.WriteLine(AWEngineWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
         }
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
index 4067c1a..903fe15 100644
--- a/AWGL/Utilities/Renderer.cs
+++ b/AWGL/Utilities/Renderer.cs
@@ -1,2 +1,2 @@
-﻿using AWGL.Managers;
+﻿using KAOS.Managers;
 using OpenTK;
@@ -6,3 +6,3 @@ using System;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
index fe0bd98..2b5cda0 100644
--- a/AWGL/Utilities/Shader.cs
+++ b/AWGL/Utilities/Shader.cs
@@ -6,3 +6,3 @@ using System.Threading.Tasks;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
index 6cf4b1f..8ce0c32 100644
--- a/AWGL/Utilities/Sprite.cs
+++ b/AWGL/Utilities/Sprite.cs
@@ -7,3 +7,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
index 604d0d5..fffdeb7 100644
--- a/AWGL/Utilities/Texture.cs
+++ b/AWGL/Utilities/Texture.cs
@@ -5,3 +5,3 @@ using System.Text;
 
-namespace AWGL.Utilities
+namespace KAOS.Utilities
 {
diff --git a/Game/Game.cs b/Game/Game.cs
index 8eda708..e284cc0 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -1,4 +1,4 @@
-﻿using AWGL;
-using AWGL.Managers;
-using AWGL.States;
+﻿using KAOS;
+using KAOS.Managers;
+using KAOS.States;
 using System;
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : AWEngineWindow
+    class Game : KAOSWindow
     {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0191c42c4f400843f35291d0a3366b203c4864f5">RENAMING PROJECT</a>  -  0191c42</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 174 files changed, 6653 insertions(+), 6653 deletions(-)

diff --git a/AWGL/Data/Shaders/CH02_FS.glsl b/AWGL/Data/Shaders/CH02_FS.glsl
deleted file mode 100644
index dff573e..0000000
--- a/AWGL/Data/Shaders/CH02_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-#version 140 core
-
-out vec4 color;
-
-void main(void)
-{
-	color = vec4(0.0, 0.8, 0.0, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CH02_VS.glsl b/AWGL/Data/Shaders/CH02_VS.glsl
deleted file mode 100644
index 6a17ae4..0000000
--- a/AWGL/Data/Shaders/CH02_VS.glsl
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿#version 140 core
-
-void main(void)
-{
-	const vec4 vertices[3] = vec4[3](
-		vec4(0.25, -0.25, 0.5, 1.0),
-		vec4(-0.25, 0.25, 0.5, 1.0),
-		vec4(0.25, 0.25, 0.5, 1.0)
-		);
-	// Index into our array using gl_VertexID
-	gl_Position = vertices[gl_VertexID];
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_FS.glsl b/AWGL/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/AWGL/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/CubeMap_VS.glsl b/AWGL/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/AWGL/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/FS.glsl b/AWGL/Data/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/AWGL/Data/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/AWGL/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl b/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/AWGL/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/JuliaSet_VS.glsl b/AWGL/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/AWGL/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_FS.glsl b/AWGL/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/AWGL/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Parallax_VS.glsl b/AWGL/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/AWGL/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_FS.glsl b/AWGL/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/AWGL/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Picking_VS.glsl b/AWGL/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/AWGL/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_FS.glsl b/AWGL/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/AWGL/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/Simple_VS.glsl b/AWGL/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/AWGL/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/VS.glsl b/AWGL/Data/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/AWGL/Data/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-fs.glsl b/AWGL/Data/Shaders/opentk-fs.glsl
deleted file mode 100644
index f890462..0000000
--- a/AWGL/Data/Shaders/opentk-fs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in vec3 normal;
-
-out vec4 out_frag_color;
-
-void main(void)
-{
-  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
-  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/opentk-vs.glsl b/AWGL/Data/Shaders/opentk-vs.glsl
deleted file mode 100644
index 1cd8777..0000000
--- a/AWGL/Data/Shaders/opentk-vs.glsl
+++ /dev/null
@@ -1,26 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-// object space to camera space transformation
-uniform mat4 modelview_matrix;
- 
-// camera space to clip coordinates
-uniform mat4 projection_matrix;
- 
-// incoming vertex position
-in vec3 in_position;
- 
-// incoming vertex normal
-in vec3 in_normal;
- 
-// transformed vertex normal
-out vec3 normal;
-
-void main(void)
-{
-  //works only for orthogonal modelview
-  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
-  
-  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/render-fs.glsl b/AWGL/Data/Shaders/render-fs.glsl
deleted file mode 100644
index b9c351c..0000000
--- a/AWGL/Data/Shaders/render-fs.glsl
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿#version 410 core
-
-uniform samplerCube tex_cubemap;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in VS_OUT
-{
-    vec3 normal;
-    vec3 view;
-} fs_in;
-
-out vec4 color;
-
-void main(void)
-{
-    // Reflect view vector about the plane defined by the normal
-    // at the fragment
-    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
-
-    // Sample from scaled using reflection vector
-     color = texture(tex_cubemap, r);
-
-	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
-
-	color = color * vec4(ambient + diffuse * lightColor, 1.0);
-}
diff --git a/AWGL/Data/Shaders/render-vs.glsl b/AWGL/Data/Shaders/render-vs.glsl
deleted file mode 100644
index 4f89dba..0000000
--- a/AWGL/Data/Shaders/render-vs.glsl
+++ /dev/null
@@ -1,23 +0,0 @@
-#version 410 core
-
-uniform mat4 mv_matrix;
-uniform mat4 proj_matrix;
-
-layout (location = 0) in vec4 in_position;
-layout (location = 1) in vec3 in_normal;
-
-out VS_OUT
-{
-    vec3 normal;
-    vec3 view;
-} vs_out;
-
-void main(void)
-{
-    vec4 pos_vs = mv_matrix * in_position;
-
-    vs_out.normal = mat3(mv_matrix) * in_normal;
-    vs_out.view = pos_vs.xyz;
-
-    gl_Position = proj_matrix * pos_vs;
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-fs.glsl b/AWGL/Data/Shaders/skybox-fs.glsl
deleted file mode 100644
index f996bf4..0000000
--- a/AWGL/Data/Shaders/skybox-fs.glsl
+++ /dev/null
@@ -1,15 +0,0 @@
-﻿#version 410 core
-
-uniform samplerCube tex_cubemap;
-
-in VS_OUT
-{
-	vec3 tc;
-}fs_in;
-
-layout(location = 0) out vec4 color;
-
-void main(void)
-{
-	color = texture(tex_cubemap, fs_in.tc);
-}
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/skybox-vs.glsl b/AWGL/Data/Shaders/skybox-vs.glsl
deleted file mode 100644
index c433716..0000000
--- a/AWGL/Data/Shaders/skybox-vs.glsl
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿#version 410 core
- 
- out VS_OUT
- {
-	vec3 tc;
- }vs_out;
-
-uniform mat4 view_matrix;
-
-in lowp vec3 in_position;
-
- void main(void)
- {
-	vs_out.tc = mat3(view_matrix) * in_position.xyz;
-	gl_Position = vec4(in_position.xyz, 1.0);
- }
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-fs.glsl b/AWGL/Data/Shaders/spincube-fs.glsl
deleted file mode 100644
index a8d60b9..0000000
--- a/AWGL/Data/Shaders/spincube-fs.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-#version 330 core                                                  
-                                                                               
-out vec4 color;                                                    
-                                                                               
-in VS_OUT                                                          
-{                                                                  
-    vec4 color;                                                    
-} fs_in;                                                           
-                                                                               
-void main(void)                                                    
-{                                                                  
-    color = fs_in.color;                                           
-}    
\ No newline at end of file
diff --git a/AWGL/Data/Shaders/spincube-vs.glsl b/AWGL/Data/Shaders/spincube-vs.glsl
deleted file mode 100644
index 9de1ae1..0000000
--- a/AWGL/Data/Shaders/spincube-vs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 330 core                                                   
-                                                                                
-in vec4 position;                                                   
-                                                                                
-out VS_OUT                                                          
-{                                                                   
-    vec4 color;                                                     
-} vs_out;                                                           
-                                                                                
-uniform mat4 mv_matrix;                                             
-uniform mat4 proj_matrix;                                           
-                                                                                
-void main(void)                                                     
-{                                                                   
-    gl_Position = proj_matrix * mv_matrix * position;               
-    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
-}   
\ No newline at end of file
diff --git a/AWGL/Interfaces/IGameObject.cs b/AWGL/Interfaces/IGameObject.cs
deleted file mode 100644
index b2da157..0000000
--- a/AWGL/Interfaces/IGameObject.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿
-namespace KAOS.Interfaces
-{
-    public interface IGameObject
-    {
-        void Update(float elapsedTime);
-        void Render();
-    }
-}
diff --git a/AWGL/KAOSWindow.cs b/AWGL/KAOSWindow.cs
deleted file mode 100644
index 8751f33..0000000
--- a/AWGL/KAOSWindow.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-﻿using Assimp;
-using Assimp.Configs;
-using KAOS.Managers;
-using KAOS.Nodes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-        
-        public KAOSWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new PreciseTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultShaderProgram();
-        }
-
-        public abstract void Initialise();
-
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
-        #endregion
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region input
-            if (Focused)
-            {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
-                ResetCursor();
-            }
-
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
-        }
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Managers/BufferObjectManager.cs b/AWGL/Managers/BufferObjectManager.cs
deleted file mode 100644
index 5ad5904..0000000
--- a/AWGL/Managers/BufferObjectManager.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    public class BufferObjectManager
-    {
-        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
-
-        public void AddBufferObject(string name, BufferObject bufferObject, int program)
-        {
-            int bufferHandle;
-
-            #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
-            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
-            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
-            IntPtr noOffset = new IntPtr(0);
-            #endregion
-
-            // Generate Vertex Buffer Object and bind it so it is current.
-            GL.GenBuffers(1, out bufferHandle);         
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
-
-            #region Save pointers generated by OpenGL here so i dont forget.
-            bufferObject.VboID = bufferHandle; 
-            #endregion
-            
-            #region Send all data to the Vertex Buffer
-            // Initialise storage space for the Vertex Buffer.
-            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
-            // Send Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
-                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
-            // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
-                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
-            
-            GL.GenBuffers(1, out bufferHandle);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, 
-                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
-                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
-
-            bufferObject.IboID = bufferHandle;
-
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
-            #endregion
-
-            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
-            // This means we do not have to re-issue VertexAttribPointer calls
-            // every time we try to use a different vertex layout - these calls are
-            // stored in the VAO so we simply need to bind the correct VAO.
-
-            // Generate Vertex Array Object and bind it so it is current.
-            GL.GenVertexArrays(1, out bufferHandle);
-            GL.BindVertexArray(bufferHandle);
-
-            bufferObject.VaoID = bufferHandle;
-
-            bufferHandle = GL.GetAttribLocation(program, "in_position");
-            GL.EnableVertexAttribArray(bufferHandle); 
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
-            GL.BindAttribLocation(program, bufferHandle, "in_position");
-
-            bufferHandle = GL.GetAttribLocation(program, "in_normal");
-            GL.EnableVertexAttribArray(bufferHandle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
-            GL.BindAttribLocation(program, bufferHandle, "in_normal");
-
-            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
-
-            GL.BindVertexArray(bufferObject.VaoID);
-
-            m_bufferStore.Add(name, bufferObject);
-        }
-
-        public BufferObject GetBuffer(string name)
-        {
-            return m_bufferStore[name];
-        }
-    }
-}
diff --git a/AWGL/Managers/InputManager.cs b/AWGL/Managers/InputManager.cs
deleted file mode 100644
index 83ddedd..0000000
--- a/AWGL/Managers/InputManager.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿using OpenTK.Input;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    public static class InputManager
-    {
-        public static List<Key> keyList = new List<Key>();
-
-
-    }
-}
diff --git a/AWGL/Managers/ModelManager.cs b/AWGL/Managers/ModelManager.cs
deleted file mode 100644
index c118589..0000000
--- a/AWGL/Managers/ModelManager.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿
-namespace KAOS.Managers
-{
-    class ModelManager
-    {
-    }
-}
diff --git a/AWGL/Managers/ShaderManager.cs b/AWGL/Managers/ShaderManager.cs
deleted file mode 100644
index ab00068..0000000
--- a/AWGL/Managers/ShaderManager.cs
+++ /dev/null
@@ -1,139 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System.Collections.Generic;
-using System.IO;
-
-namespace KAOS.Managers
-{
-    /// <summary>
-    /// Responsible for building individual shaders and linking them to the main program.
-    /// </summary>
-    public static class ShaderManager
-    {
-        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
-
-        // Handles
-        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
-
-        private static string defaultDataPath = "Data/Shaders/";
-        private static string m_vertexShaderFile = "opentk-vs";
-        private static string m_fragmentShaderFile = "opentk-fs";
-
-        internal static void LoadDefaultShaderProgram()
-        {
-            if (m_shaderStorage == null)
-                m_shaderStorage = new Dictionary<string, Shader>();
-            m_programHandle = BuildProgram();
-            m_shaderStorage.Add("default", new Shader(m_programHandle));
-        }
-
-        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
-        {
-            m_vertexShaderFile = vertexShaderPath;
-            m_fragmentShaderFile = fragmentShaderPath;
-            m_programHandle = BuildProgram();
-
-            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
-        }
-
-        public static Shader DefaultShader
-        {
-            get
-            {
-                return m_shaderStorage["default"];
-            }
-        }
-
-        public static Shader Get(string shaderID)
-        {
-            return m_shaderStorage[shaderID];
-        }
-
-        #region Shader and Program Contruction Methods
-        internal static string LoadShader(string shaderSourcePath)
-        {
-            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
-            {
-                return sr.ReadToEnd();
-            }
-        }
-
-        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
-        {
-            // Create space in memory for the shader
-            int shaderHandle = GL.CreateShader(shaderType);
-            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
-
-            // Compile
-            GL.CompileShader(shaderHandle);
-
-            Logger.ShaderInfo(shaderHandle);
-
-            return shaderHandle;
-        }
-
-        internal static int BuildProgram()
-        {
-            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
-            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
-
-            int programHandle = GL.CreateProgram();
-
-            GL.AttachShader(programHandle, m_vertexShaderHandle);
-            GL.AttachShader(programHandle, m_fragmentShaderHandle);
-
-            GL.LinkProgram(programHandle);
-
-            #region Check linker success
-            int[] temp = new int[1];
-            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
-            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
-            #endregion
-
-            #region Validate Program
-            GL.ValidateProgram(programHandle);
-            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
-            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
-            //if (validateSuccess == 0)
-            //{
-            //    String message;
-            //    GL.GetProgramInfoLog(programHandle, out message);
-            //    Logger.WriteLine("Program validation failed" + message);
-            //}
-            #endregion
-
-            #region Registered Attributes
-            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
-            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
-
-            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
-            #endregion
-
-            // Delete the shaders as the program has them now
-            GL.DeleteShader(m_vertexShaderHandle);
-            GL.DeleteShader(m_fragmentShaderHandle);
-
-            return programHandle;
-        }
-        #endregion
-
-        #region Public Methods
-
-        //public void SetUniforms(
-        //    out int projMatrixHandle, out int mvMatrixHandle,
-        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
-        //    Size dimensions, ref Camera camera)
-        //{
-        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        //} 
-        #endregion
-
-    }
-}
diff --git a/AWGL/Managers/StateManager.cs b/AWGL/Managers/StateManager.cs
deleted file mode 100644
index 8a00128..0000000
--- a/AWGL/Managers/StateManager.cs
+++ /dev/null
@@ -1,43 +0,0 @@
-﻿using KAOS.Interfaces;
-using System.Collections.Generic;
-using System.Diagnostics;
-
-namespace KAOS.Managers
-{
-    public class StateManager
-    {
-        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
-        IGameObject currentState = null;
-
-        public void Update(float elapsedTime)
-        {
-            if (currentState == null)
-                return;
-            currentState.Update(elapsedTime);
-        }
-
-        public void Render()
-        {
-            if (currentState == null)
-                return;
-            currentState.Render();
-        }
-
-        public void AddState(string stateName, IGameObject state)
-        {
-            Debug.Assert( Exists(stateName) == false );
-            stateStore.Add(stateName, state);
-        }
-
-        public void ChangeState(string stateName)
-        {
-            Debug.Assert( Exists(stateName) );
-            currentState = stateStore[stateName];
-        }
-
-        public bool Exists(string stateName)
-        {
-            return stateStore.ContainsKey(stateName);
-        }
-    }
-}
diff --git a/AWGL/Managers/Tests/StateManagerTest.cs b/AWGL/Managers/Tests/StateManagerTest.cs
deleted file mode 100644
index fc92063..0000000
--- a/AWGL/Managers/Tests/StateManagerTest.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿
-using KAOS.States;
-using NUnit.Framework;
-
-namespace KAOS.Managers.Tests
-{
-    [TestFixture]
-    public class StateManagerTest
-    {
-        [Test]
-        public void TestAddStateExists()
-        {
-            StateManager stateManager = new StateManager();
-            stateManager.AddState("test-state", new SplashScreenState(stateManager));
-
-            Assert.IsTrue(stateManager.Exists("test-state"));
-        }
-    }
-}
diff --git a/AWGL/Managers/Tests/TextureManagerTest.cs b/AWGL/Managers/Tests/TextureManagerTest.cs
deleted file mode 100644
index 007e120..0000000
--- a/AWGL/Managers/Tests/TextureManagerTest.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-﻿
-using NUnit.Framework;
-
-namespace KAOS.Managers.Tests
-{
-    [TestFixture]
-    public class TextureManagerTest
-    {
-        [Test]
-        public void TestLoadTexture()
-        {
-            //string textureid = "test-texture";
-            //Texture t = new Texture();
-            //TextureManager manager = new TextureManager();
-            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
-
-            Assert.IsTrue(true);
-        }
-    }
-}
diff --git a/AWGL/Managers/TextureManager.cs b/AWGL/Managers/TextureManager.cs
deleted file mode 100644
index 0970750..0000000
--- a/AWGL/Managers/TextureManager.cs
+++ /dev/null
@@ -1,102 +0,0 @@
-﻿using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace KAOS.Managers
-{
-    public class TextureManager : IDisposable
-    {
-        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
-
-        public Texture Get(string textureId)
-        {
-            return m_textureDatabase[textureId];
-        }
-
-        private int textureGpuHandle;
-        private Bitmap bitmap;
-        private BitmapData bitmapData;
-
-        public void LoadTexture(string textureId, string path)
-        {
-            if (string.IsNullOrEmpty(path))
-                throw new ArgumentException(path);
-
-            GL.GenTextures(1, out textureGpuHandle);
-            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
-
-            OpenImageFile(path);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 
-                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
-
-            CloseImageFile();
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
-        }
-
-        public void LoadSkyTexture(string textureId, string[] path)
-        {
-            GL.ActiveTexture(TextureUnit.Texture0);
-            GL.GenTextures(1, out textureGpuHandle);
-            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
-
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-
-            for (int face = 0; face < 6; face++)
-            {
-                OpenImageFile(path[face]);
-                bitmap.Save(face + ".bmp");
-                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
-                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
-
-                GL.Finish();
-                CloseImageFile();
-            }
-
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
-        }
-
-        private void OpenImageFile(string path)
-        {
-            bitmap = new Bitmap(path);
-
-            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-        }
-
-        private void CloseImageFile()
-        {
-            bitmap.UnlockBits(bitmapData);
-
-            CleanUp();
-        }
-
-        private void CleanUp()
-        {
-            bitmap.Dispose();
-        }
-
-
-        public void Dispose()
-        {
-            foreach (Texture t in m_textureDatabase.Values)
-            {
-                GL.DeleteTextures(1, new int[] { t.ID });
-            }
-            bitmap.Dispose();
-        }
-    }
-}
diff --git a/AWGL/Nodes/AWCube.cs b/AWGL/Nodes/AWCube.cs
deleted file mode 100644
index 58875a5..0000000
--- a/AWGL/Nodes/AWCube.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿using KAOS.Shapes;
-using KAOS.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    public class AWCube : AWNode, ISceneNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public Vector3[] Vertices
-        {
-            get { return CubeVertices; }
-        }
-
-        public int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/AWGraphLines.cs b/AWGL/Nodes/AWGraphLines.cs
deleted file mode 100644
index 1e65c18..0000000
--- a/AWGL/Nodes/AWGraphLines.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWGraphLines : AWNode, ISceneNode
-    {
-        private int m_gridSize = 20;
-
-        public Vector3[] Vertices
-        {
-            get { return m_vertices; }
-        }
-
-        private static Vector3[] m_vertices;
-
-        public AWGraphLines(int gridSize)
-        {
-            m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize * 2];
-            BuildVertices();
-        }
-
-        private void BuildVertices()
-        {
-            for (int i = 0; i < m_gridSize *2; i += 4)
-            {
-                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
-                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
-                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
-                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
-            }
-        }
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/AWGroupNode.cs b/AWGL/Nodes/AWGroupNode.cs
deleted file mode 100644
index 0fb12d0..0000000
--- a/AWGL/Nodes/AWGroupNode.cs
+++ /dev/null
@@ -1,99 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
-    {
-        double m_angle, m_rx, m_ry, m_rz;
-        double m_tx, m_ty, m_tz;
-
-        private IList<ISceneNode> m_children = new List<ISceneNode>();
-        
-        public AWGroupNode()
-        {
-            this.m_angle = 0;
-            this.m_rx = 1;   //!!
-            this.m_ry = 0;
-            this.m_rz = 0;
-
-            this.m_tx = 0;
-            this.m_ty = 0;
-            this.m_tz = 0;
-        }
-
-        public void SetRotation(double angle, double rx, double ry, double rz)
-        {
-            this.m_angle = angle;
-            this.m_rx = rx;
-            this.m_ry = ry;
-            this.m_rz = rz;
-        }
-
-        public void SetTranslation(double tx, double ty, double tz)
-        {
-            this.m_tx = tx;
-            this.m_ty = ty;
-            this.m_tz = tz;
-        }
-
-        public override void Render()
-        {
-            GL.PushMatrix();
-            GL.Translate(m_tx, m_ty, m_tz);
-            if (m_angle != 0)
-            {
-                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
-            }
-
-            foreach (ISceneNode child in m_children)
-            {
-                child.Render();
-            }
-            GL.PopMatrix();
-        }
-
-        #region IEnumerator Implementation
-        public IEnumerator<ISceneNode> GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return m_children.GetEnumerator();
-        }
-        #endregion ISceneNode Implementation
-
-        #region IGroupNode Implementation
-
-        public void AddChild(ISceneNode child)
-        {
-            m_children.Add(child);
-        }
-
-        public void RemoveChild(ISceneNode child)
-        {
-            m_children.Remove(child);
-        }
-
-        #endregion IGroupNode Implementation
-
-
-
-        public OpenTK.Vector3[] Vertices
-        {
-            get { throw new NotImplementedException(); }
-        }
-
-        public int[] Indices
-        {
-            get { throw new NotImplementedException(); }
-        }
-    } 
-}
diff --git a/AWGL/Nodes/AWMesh.cs b/AWGL/Nodes/AWMesh.cs
deleted file mode 100644
index d5f77a0..0000000
--- a/AWGL/Nodes/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Nodes/AWNode.cs b/AWGL/Nodes/AWNode.cs
deleted file mode 100644
index d0dddca..0000000
--- a/AWGL/Nodes/AWNode.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using KAOS.Managers;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public abstract class AWNode
-    {
-        protected BufferObjectManager m_BufferManager;
-
-        protected AWNode()
-        {
-            //m_BufferManager = new AWBufferManager();
-        }
-
-        public abstract void Render();
-    }
-
-}
diff --git a/AWGL/Nodes/AWParticles.cs b/AWGL/Nodes/AWParticles.cs
deleted file mode 100644
index 44911f9..0000000
--- a/AWGL/Nodes/AWParticles.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWParticles : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-
-}
-/*
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
-        */
\ No newline at end of file
diff --git a/AWGL/Nodes/AWPolygon.cs b/AWGL/Nodes/AWPolygon.cs
deleted file mode 100644
index 85afb1d..0000000
--- a/AWGL/Nodes/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/AWGL/Nodes/IGroupNode.cs b/AWGL/Nodes/IGroupNode.cs
deleted file mode 100644
index 888793f..0000000
--- a/AWGL/Nodes/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface IGroupNode : IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/AWGL/Nodes/ISceneNode.cs b/AWGL/Nodes/ISceneNode.cs
deleted file mode 100644
index 0924346..0000000
--- a/AWGL/Nodes/ISceneNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
deleted file mode 100644
index 9623e06..0000000
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("AWGL")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Hewlett-Packard")]
-[assembly: AssemblyProduct("AWGL")]
-[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers 
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/AWGL/Scene/FBOScene.cs b/AWGL/Scene/FBOScene.cs
deleted file mode 100644
index ee33056..0000000
--- a/AWGL/Scene/FBOScene.cs
+++ /dev/null
@@ -1,246 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class FBOScene : DefaultScene
-    {
-        #region Private Member Variables
-        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
-
-        private uint ColorTexture;
-        private uint DepthTexture;
-        private uint FBOHandle;
-
-        private const int TextureSize = 512;
-
-        private DrawableShape Object;
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
-            {
-                throw new NotSupportedException(
-                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
-                Exit();
-            }
-
-            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearDepth(1.0);
-            GL.DepthFunc(DepthFunction.Lequal);
-
-            GL.Enable(EnableCap.CullFace);
-
-            // Create Color Tex
-            GL.GenTextures(1, out ColorTexture);
-            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create Depth Tex
-            GL.GenTextures(1, out DepthTexture);
-            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
-            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create a FBO and attach the textures
-            GL.Ext.GenFramebuffers(1, out FBOHandle);
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
-
-            #region Test for Error
-
-            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
-            {
-                case FramebufferErrorCode.FramebufferCompleteExt:
-                    {
-                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: There are no attachments.");
-                        break;
-                    }
-                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
-                     {
-                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
-                         break;
-                     }*/
-                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
-                    {
-                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
-                    {
-                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
-                    {
-                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
-                    {
-                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferUnsupportedExt:
-                    {
-                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
-                        break;
-                    }
-                default:
-                    {
-                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
-                        break;
-                    }
-            }
-
-            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
-            int[] queryinfo = new int[6];
-            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
-            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
-            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
-            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
-            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
-            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
-            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
-                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
-
-            Console.WriteLine("Last GL Error: " + GL.GetError());
-
-            #endregion Test for Error
-
-            GL.PushAttrib(AttribMask.ViewportBit);
-            {
-                GL.Viewport(0, 0, TextureSize, TextureSize);
-
-                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
-                GL.ClearColor(1f, 0f, 0f, 0f);
-                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
-                GL.MatrixMode(MatrixMode.Projection);
-                GL.LoadMatrix(ref perspective);
-
-                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
-                GL.MatrixMode(MatrixMode.Modelview);
-                GL.LoadMatrix(ref lookat);
-
-                // draw some complex object into the FBO's textures
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.Light0);
-                GL.Enable(EnableCap.ColorMaterial);
-                GL.Color3(0f, 1f, 0f);
-                Object.Draw();
-                GL.Disable(EnableCap.ColorMaterial);
-                GL.Disable(EnableCap.Light0);
-                GL.Disable(EnableCap.Lighting);
-
-            }
-            GL.PopAttrib();
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
-
-            GL.ClearColor(.1f, .2f, .3f, 0f);
-            GL.Color3(1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
-            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            double aspect_ratio = Width / (double)Height;
-
-            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-        }
-    }
-}
diff --git a/AWGL/Scene/PickerScene.cs b/AWGL/Scene/PickerScene.cs
deleted file mode 100644
index 3aca921..0000000
--- a/AWGL/Scene/PickerScene.cs
+++ /dev/null
@@ -1,204 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
-    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
-    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
-    /// </summary>
-    public class PickerScene : DefaultScene
-    {
-        public PickerScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Member variable
-        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
-        private float angle;
-        private BeginMode VBO_PrimMode;
-        private Vertex[] VBO_Array;
-        uint VBO_Handle;
-
-        private uint SelectedTriangle;
-
-        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
-        #endregion
-
-        #region OnLoad
-        /// <summary>Load resources here.</summary>
-        /// <param name="e">Not used.</param>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.CullFace);
-
-            #region prepare data for VBO from procedural object
-            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
-            VertexT2fN3fV3f[] temp_VBO;
-            uint[] temp_IBO;
-            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
-            temp_obj.Dispose();
-            if (temp_IBO != null)
-                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
-
-            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
-            VBO_Array = new Vertex[temp_VBO.Length];
-            int TriangleCounter = -1;
-            for (int i = 0; i < temp_VBO.Length; i++)
-            {
-                // Position
-                VBO_Array[i].Position = temp_VBO[i].Position;
-
-                // Index
-                if (i % 3 == 0)
-                    TriangleCounter++;
-                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
-            }
-            #endregion prepare data for VBO from procedural object
-
-            #region Setup VBO for drawing
-            GL.GenBuffers(1, out VBO_Handle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
-            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
-            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
-            #endregion Setup VBO for drawing
-
-            #region Shader
-
-            //create and compile shaders
-            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
-
-            //create program object, attach shaders and link
-            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
-
-            // flag ShaderObjects for delete when not used anymore
-            GL.DeleteShader(VertexShaderObject);
-            GL.DeleteShader(FragmentShaderObject);
-
-            GL.UseProgram(0);
-
-            #endregion Shader
-
-        }
-        #endregion
-
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.DeleteBuffers(1, ref VBO_Handle);
-
-            base.OnUnload(e);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Called when your window is resized. Set your viewport here. It is also
-        /// a good place to set up your projection matrix (which probably changes
-        /// along when the aspect ratio of your window).
-        /// </summary>
-        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref projection);
-        }
-        #endregion
-
-        #region OnRenderFrame
-        /// <summary>
-        /// Called when it is time to render the next frame. Add your rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Color3(Color.White);
-            GL.EnableClientState(EnableCap.ColorArray);
-
-            #region Pass 1: Draw Object and pick Triangle
-            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref modelview);
-            GL.Translate(0f, 0f, -3f);
-            GL.Rotate(angle, Vector3.UnitX);
-            GL.Rotate(angle, Vector3.UnitY);
-            angle += (float)e.Time * 3.0f;
-
-            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
-             GL.UseProgram(ProgramObject);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            // GL.UseProgram(0);
-
-            // Read Pixel under mouse cursor
-            Byte4 Pixel = new Byte4();
-            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
-            SelectedTriangle = Pixel.ToUInt32();
-            #endregion Pass 1: Draw Object and pick Triangle
-
-            GL.Color3(Color.White);
-            GL.DisableClientState(EnableCap.ColorArray);
-
-            #region Pass 2: Draw Shape
-            if (SelectedTriangle == uint.MaxValue)
-                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
-            else
-                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.Color3(1f, 1f, 1f);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-            GL.Color3(Color.Red);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-
-            if (SelectedTriangle != uint.MaxValue)
-            {
-                GL.Disable(EnableCap.DepthTest);
-                GL.Color3(Color.Green);
-                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
-                GL.Enable(EnableCap.DepthTest);
-            }
-            #endregion Pass 2: Draw Shape
-
-            this.SwapBuffers();
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Error at Swapbuffers: " + err);
-        }
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Scene/StencilCSGScene.cs b/AWGL/Scene/StencilCSGScene.cs
deleted file mode 100644
index 8acb843..0000000
--- a/AWGL/Scene/StencilCSGScene.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class StencilCSGScene : DefaultScene
-    {
-        #region Model Related
-        private DrawableShape OperandB;
-        private DrawableShape OperandA;
-        private float MySphereZOffset = 0f;
-        private float MySphereXOffset = 0f;
-
-        private int Texture;
-        #endregion Model Related
-
-        private bool ShowDebugWireFrame = true;
-
-        private float CameraZoom;
-        private float CameraRotX;
-        private float CameraRotY;
-        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
-
-        #region Window
-        public StencilCSGScene()
-        {
-            base.VSync = VSyncMode.Off;
-            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
-            {
-                switch (e.Key)
-                {
-                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
-                }
-            };
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
-            GL.LoadMatrix(ref p);
-        }
-        #endregion Window
-
-        public override void Setup(EventArgs e)
-        {
-            #region Abort on platforms which will not be able to execute the ops properly
-            /*
-            if (!GL.SupportsExtension("VERSION_1_2"))
-            {
-                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
-                this.Exit();
-            }
-
-            int[] t = new int[2];
-            GL.GetInteger(GetPName.MajorVersion, out t[0]);
-            GL.GetInteger(GetPName.MinorVersion, out t[1]);
-            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
-
-            GL.GetInteger(GetPName.DepthBits, out t[0]);
-            Trace.WriteLine("Depth Bits: " + t[0]);
-            GL.GetInteger(GetPName.StencilBits, out t[1]);
-            Trace.WriteLine("Stencil Bits: " + t[1]);
-
-            if (t[0] < 16)
-            {
-                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
-                this.Exit();
-            }
-
-            if (t[1] < 1)
-            {
-                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
-                this.Exit();
-            }
-            */
-            #endregion Abort on platforms which will not be able to execute the ops properly
-
-            #region GL States
-            GL.ClearColor(.08f, .12f, .16f, 1f);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Less);
-            GL.ClearDepth(1.0);
-
-            GL.Enable(EnableCap.StencilTest);
-            GL.ClearStencil(0);
-            GL.StencilMask(0xFFFFFFFF); // read&write
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-            GL.CullFace(CullFaceMode.Back);
-
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-
-            GL.Color4(1f, 1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.ShadeModel(ShadingModel.Smooth);
-
-            #endregion GL States
-
-            #region Load Texture
-            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
-            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
-
-            GL.GenTextures(1, out Texture);
-            GL.BindTexture(TextureTarget.Texture2D, Texture);
-
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.Finish();
-            bitmap.UnlockBits(data);
-            #endregion Load Texture
-
-            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
-            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
-                                           SlicedSphere.eSubdivisions.Three,
-                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
-                                           true);
-
-            #region Invert Operand B's Normals
-            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
-            BeginMode tempPrimMode;
-            VertexT2dN3dV3d[] tempVertices;
-            uint[] tempIndices;
-
-            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
-            OperandB.Dispose();
-
-            for (int i = 0; i < tempVertices.Length; i++)
-            {
-                tempVertices[i].Normal *= -1.0;
-                tempVertices[i].Normal.Normalize();
-            }
-
-            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
-            #endregion Invert Operand B's Normals
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref Texture);
-
-            OperandA.Dispose();
-            OperandB.Dispose();
-
-            base.OnUnload(e);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Magic numbers for camera
-            CameraRotX = -Mouse.X * .5f;
-            CameraRotY = Mouse.Y * .5f;
-            CameraZoom = Mouse.Wheel * .2f;
-            #endregion Magic numbers for camera
-        }
-
-        public void DrawOperandB()
-        {
-            GL.PushMatrix();
-            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
-            OperandB.Draw();
-            GL.PopMatrix();
-        }
-
-        public void DrawOperandA()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            OperandA.Draw();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        public void RenderCsg()
-        {
-            // first pass
-            GL.Disable(EnableCap.StencilTest);
-
-            GL.ColorMask(false, false, false, false);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB();// draw front-faces into depth buffer
-
-            // use stencil plane to find parts of b in a 
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // increment the stencil where the front face of a is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
-            DrawOperandB(); // draw the part of b that's in a
-
-            // fix depth
-            GL.ColorMask(false, false, false, false);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Disable(EnableCap.StencilTest);
-            GL.DepthFunc(DepthFunction.Always);
-            DrawOperandA();
-            GL.DepthFunc(DepthFunction.Less);
-
-            // second pass
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA();
-
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            DrawOperandB(); // increment the stencil where the front face of b is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Equal, 0, 1);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // draw the part of a that's in b
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
-
-            MySphereZOffset += (float)(e.Time * 3.1);
-            MySphereXOffset += (float)(e.Time * 4.2);
-
-            #region Transform setup
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
-
-            // Camera
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-
-            GL.Translate(0f, 0f, CameraZoom);
-            GL.Rotate(CameraRotX, Vector3.UnitY);
-            GL.Rotate(CameraRotY, Vector3.UnitX);
-            #endregion Transform setup
-
-            RenderCsg();
-
-            // ---------------------------------
-
-            if (ShowDebugWireFrame)
-            {
-                GL.Color3(System.Drawing.Color.LightGray);
-                GL.Disable(EnableCap.StencilTest);
-                GL.Disable(EnableCap.Lighting);
-                //GL.Disable( EnableCap.DepthTest );
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-                DrawOperandB();
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-                GL.Enable(EnableCap.DepthTest);
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.StencilTest);
-            }
-            SwapBuffers();
-        }
-
-    }
-}
diff --git a/AWGL/Scene/StereoVisionScene.cs b/AWGL/Scene/StereoVisionScene.cs
deleted file mode 100644
index 2b84210..0000000
--- a/AWGL/Scene/StereoVisionScene.cs
+++ /dev/null
@@ -1,164 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVisionScene : DefaultScene
-    {
-        public StereoVisionScene()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            Angle += (float)(e.Time * 20.0);
-
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    
-    }
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/AWGL/Scene/Texture2DScene.cs b/AWGL/Scene/Texture2DScene.cs
deleted file mode 100644
index ec53ee7..0000000
--- a/AWGL/Scene/Texture2DScene.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class Texture2DScene : DefaultScene
-    {
-        #region Private Members
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.Texture2D);
-
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            bitmap.UnlockBits(data);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
-        }
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref texture);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.Begin(BeginMode.Quads);
-
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            GL.End();
-
-            SwapBuffers();
-        }
-        #endregion
-
-    }
-}
diff --git a/AWGL/Shapes/Base/DrawableShape.cs b/AWGL/Shapes/Base/DrawableShape.cs
deleted file mode 100644
index 0f9cd8a..0000000
--- a/AWGL/Shapes/Base/DrawableShape.cs
+++ /dev/null
@@ -1,182 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.Shapes
-{
-    // Abstract base class for procedurally generated geometry
-    // 
-    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
-    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
-    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
-    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
-    // Can use a Display List to prevent repeated immediate mode draws.
-    //
-
-    public abstract class DrawableShape: IDisposable
-    {
-        protected BeginMode PrimitiveMode;
-        protected VertexT2dN3dV3d[] VertexArray;
-        protected uint[] IndexArray;
-
-        public int GetTriangleCount
-        {
-            get
-            {
-                switch ( PrimitiveMode )
-                { 
-                case BeginMode.Triangles:
-                    if ( IndexArray != null )
-                    {
-                        return IndexArray.Length / 3;
-                    } else
-                    {
-                        return VertexArray.Length / 3;
-                    }
-                  //  break;
-                default: throw new NotImplementedException("Unknown primitive type.");
-                }
-            }
-        }
-
-        #region Display List
-
-        private bool UseDisplayList;
-        private int DisplayListHandle = 0;
-
-        #endregion Display List
-
-        public DrawableShape( bool useDisplayList )
-        {
-            UseDisplayList = useDisplayList;
-            PrimitiveMode = BeginMode.Triangles;
-            VertexArray = null;
-            IndexArray = null;
-        }
-
-        #region Convert to VBO
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2dN3dV3d[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = VertexArray[i].TexCoord;
-                vertices[i].Normal = VertexArray[i].Normal;
-                vertices[i].Position = VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2fN3fV3f[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
-                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
-                vertices[i].Position = (Vector3)VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
-        {
-            primitives = PrimitiveMode;
-
-            vertices = new VertexT2hN3hV3h[VertexArray.Length];
-            for (uint i = 0; i < VertexArray.Length; i++)
-            {
-                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
-                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
-                vertices[i].Position = (Vector3h)VertexArray[i].Position;
-            }
-
-            indices = IndexArray;
-        }
-
-        #endregion Convert to VBO
-
-        private void DrawImmediateMode()
-        {
-            GL.Begin( PrimitiveMode );
-            {
-                if ( IndexArray == null )
-                    foreach ( VertexT2dN3dV3d v in VertexArray )
-                    {
-                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
-                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
-                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
-                    } else
-                {
-                    for ( uint i = 0; i < IndexArray.Length; i++ )
-                    {
-                        uint index = IndexArray[i];
-                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
-                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
-                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
-                    }
-                }
-            }
-            GL.End();
-        }
-
-        /// <summary>
-        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
-        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
-        /// </summary>
-        public void Draw()
-        {
-            if ( !UseDisplayList )
-                DrawImmediateMode();
-            else
-                if ( DisplayListHandle == 0 )
-                {
-                    if ( VertexArray == null )
-                        throw new Exception("Cannot draw null Vertex Array.");
-                    DisplayListHandle = GL.GenLists( 1 );
-                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
-                    DrawImmediateMode();
-                    GL.EndList();
-                } else
-                    GL.CallList( DisplayListHandle );
-        }
-
-        
-
-        #region IDisposable Members
-
-        /// <summary>
-        /// Removes reference to VertexArray and IndexArray.
-        /// Deletes the Display List, so it requires an OpenGL context.
-        /// The instance is effectively destroyed.
-        /// </summary>
-        public void Dispose()
-        {
-            if ( VertexArray != null )
-                VertexArray = null;
-            if ( IndexArray != null )
-                IndexArray = null;
-            if ( DisplayListHandle != 0 )
-            {
-                GL.DeleteLists( DisplayListHandle, 1 );
-                DisplayListHandle = 0;
-            }
-        }
-
-        #endregion
-    }
-
-}
diff --git a/AWGL/Shapes/Base/VertexStructs.cs b/AWGL/Shapes/Base/VertexStructs.cs
deleted file mode 100644
index 0f64155..0000000
--- a/AWGL/Shapes/Base/VertexStructs.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-using OpenTK;
-using System.Runtime.InteropServices;
-
-namespace KAOS.Shapes
-{
-    public struct VertexT2dN3dV3d
-    {
-        public Vector2d TexCoord;
-        public Vector3d Normal;
-        public Vector3d Position;
-
-        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
-        {
-            TexCoord = texcoord;
-            Normal = normal;
-            Position = position;
-        }
-    }
-
-    public struct VertexT2fN3fV3f
-    {
-        public Vector2 TexCoord;
-        public Vector3 Normal;
-        public Vector3 Position;
-    }
-
-    public struct VertexT2hN3hV3h
-    {
-        public Vector2h TexCoord;
-        public Vector3h Normal;
-        public Vector3h Position;
-    }
-
-   
-}
diff --git a/AWGL/Shapes/Capsule.cs b/AWGL/Shapes/Capsule.cs
deleted file mode 100644
index cd6f7e6..0000000
--- a/AWGL/Shapes/Capsule.cs
+++ /dev/null
@@ -1,108 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class Capsule: DrawableShape
-    {
-        public enum eSubdivisions
-        {
-            None = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-        }
-
-
-        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            uint HoseSubDivs = 0;
-            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.None:
-                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
-                HoseSubDivs = 0;
-                break;
-            case eSubdivisions.One:
-                spheresubdivs = SlicedSphere.eSubdivisions.One;
-                HoseSubDivs = 1;
-                break;
-            case eSubdivisions.Two:
-                spheresubdivs = SlicedSphere.eSubdivisions.Two;
-                HoseSubDivs = 3;
-                break;
-            case eSubdivisions.Three:
-                spheresubdivs = SlicedSphere.eSubdivisions.Three;
-                HoseSubDivs = 7;
-                break;
-            case eSubdivisions.Four:
-                spheresubdivs = SlicedSphere.eSubdivisions.Four;
-                HoseSubDivs = 15;
-                break;
-            }
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
-            VertexT2dN3dV3d[] TemporaryVBO;
-            uint[] TemporaryIBO;
-
-            List<Chunk> AllChunks = new List<Chunk>();
-            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
-                     offset2 = new Vector3d( 0.0, 0.0, -height );
-            for ( int i = 0; i < 4; i++ )
-            {
-                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
-                switch ( i )
-                {
-                case 0:
-                    tempSide = SlicedHose.eSide.FrontBottom;
-                    break;
-                case 1:
-                    tempSide = SlicedHose.eSide.BackBottom;
-                    break;
-                case 2:
-                    tempSide = SlicedHose.eSide.BackTop;
-                    break;
-                case 3:
-                    tempSide = SlicedHose.eSide.FrontTop;
-                    break;
-                }
-                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
-                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempHose.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-
-            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
-                                                       new SlicedSphere.eDir[] {
-                                                           SlicedSphere.eDir.BackBottomRight,
-                                                           SlicedSphere.eDir.FrontTopRight,
-                                                           SlicedSphere.eDir.BackTopRight,
-                                                           SlicedSphere.eDir.FrontBottomRight, 
-                                                          },
-                                                       false );
-
-            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            front.Dispose();
-
-            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
-                                                      new SlicedSphere.eDir[] { 
-                                                          SlicedSphere.eDir.FrontBottomLeft,
-                                                          SlicedSphere.eDir.FrontTopLeft, 
-                                                          SlicedSphere.eDir.BackTopLeft,
-                                                          SlicedSphere.eDir.BackBottomLeft },
-                                                      false );
-            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            back.Dispose();
-
-            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-            AllChunks.Clear();
-        }
-    }
-}
diff --git a/AWGL/Shapes/ChamferCube.cs b/AWGL/Shapes/ChamferCube.cs
deleted file mode 100644
index 1c340a1..0000000
--- a/AWGL/Shapes/ChamferCube.cs
+++ /dev/null
@@ -1,278 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class ChamferCube: DrawableShape
-    {
-
-        public enum SubDivs: byte
-        {
-            Zero,
-            One,
-            Two,
-            Three,
-            Four,
-        }
-
-        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
-            : base( useDL )
-        {   
-            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
-            uint hoseSubDivs = 0;
-
-            switch ( subdivs )
-            {
-            case SubDivs.Zero:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
-                hoseSubDivs = 0;
-                break;
-            case SubDivs.One:
-                sphereSubDivs = SlicedSphere.eSubdivisions.One;
-                hoseSubDivs = 1;
-                break;
-            case SubDivs.Two:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
-                hoseSubDivs = 3;
-                break;
-            case SubDivs.Three:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
-                hoseSubDivs = 7;
-                break;
-            case SubDivs.Four:
-                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
-                hoseSubDivs = 15;
-                break;
-            }
-
-            #region Temporary Storage
-
-            List<Chunk> AllChunks = new List<Chunk>();
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
-            VertexT2dN3dV3d[] TemporaryVBO;
-            uint[] TemporaryIBO;
-
-            #endregion Temporary Storage
-
-            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
-            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
-            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
-            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
-            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
-            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
-            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
-            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
-
-            #region 8 sliced Spheres
-            SlicedSphere tempSphere;
-            Vector3d tempVector = Vector3d.Zero;
-            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
-
-            for ( int i = 0; i < 8; i++ )
-            {
-                switch ( i )
-                {
-                case 0:
-                    tempVector = FrontTopRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
-                    break;
-                case 1:
-                    tempVector = FrontTopLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
-                    break;
-                case 2:
-                    tempVector = FrontBottomRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
-                    break;
-                case 3:
-                    tempVector = FrontBottomLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
-                    break;
-                case 4:
-                    tempVector = BackBottomRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
-                    break;
-                case 5:
-                    tempVector = BackBottomLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
-                    break;
-                case 6:
-                    tempVector = BackTopRightEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
-                    break;
-                case 7:
-                    tempVector = BackTopLeftEdge;
-                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
-                    break;
-                }
-                tempSphere = new SlicedSphere( radius,
-                                                 tempVector,
-                                                 sphereSubDivs,
-                                                 tempEdge,
-                                                 false );
-                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempSphere.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-            #endregion 8 sliced Spheres
-
-            #region 12 sliced Hoses
-
-            SlicedHose tempHose;
-            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
-            Vector3d tempHoseStart = Vector3d.Zero;
-            Vector3d tempHoseEnd = Vector3d.Zero;
-
-            for ( int i = 0; i < 12; i++ )
-            {
-                switch ( i )
-                {
-                #region Around X Axis
-                case 0:
-                    tempSide = SlicedHose.eSide.BottomRight;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = FrontBottomRightEdge;
-                    break;
-                case 1:
-                    tempSide = SlicedHose.eSide.TopRight;
-                    tempHoseStart = BackTopRightEdge;
-                    tempHoseEnd = FrontTopRightEdge;
-                    break;
-                case 2:
-                    tempSide = SlicedHose.eSide.TopLeft;
-                    tempHoseStart = BackTopLeftEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                case 3:
-                    tempSide = SlicedHose.eSide.BottomLeft;
-                    tempHoseStart = BackBottomLeftEdge;
-                    tempHoseEnd = FrontBottomLeftEdge;
-                    break;
-                #endregion Around X Axis
-                #region Around Y Axis
-                case 4:
-                    tempSide = SlicedHose.eSide.FrontRight;
-                    tempHoseStart = FrontBottomRightEdge;
-                    tempHoseEnd = FrontTopRightEdge;
-                    break;
-                case 5:
-                    tempSide = SlicedHose.eSide.BackRight;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = BackTopRightEdge;
-                    break;
-                case 6:
-                    tempSide = SlicedHose.eSide.BackLeft;
-                    tempHoseStart = BackBottomLeftEdge;
-                    tempHoseEnd = BackTopLeftEdge;
-                    break;
-                case 7:
-                    tempSide = SlicedHose.eSide.FrontLeft;
-                    tempHoseStart = FrontBottomLeftEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                #endregion Around Y Axis
-                #region Around Z Axis
-                case 8:
-                    tempSide = SlicedHose.eSide.FrontTop;
-                    tempHoseStart = FrontTopRightEdge;
-                    tempHoseEnd = FrontTopLeftEdge;
-                    break;
-                case 9:
-                    tempSide = SlicedHose.eSide.BackTop;
-                    tempHoseStart = BackTopRightEdge;
-                    tempHoseEnd = BackTopLeftEdge;
-                    break;
-                case 10:
-                    tempSide = SlicedHose.eSide.BackBottom;
-                    tempHoseStart = BackBottomRightEdge;
-                    tempHoseEnd = BackBottomLeftEdge;
-                    break;
-                case 11:
-                    tempSide = SlicedHose.eSide.FrontBottom;
-                    tempHoseStart = FrontBottomRightEdge;
-                    tempHoseEnd = FrontBottomLeftEdge;
-                    break;
-                #endregion Around Z Axis
-                }
-                tempHose = new SlicedHose( tempSide,
-                                             hoseSubDivs,
-                                             radius,
-                                             tempHoseStart,
-                                             tempHoseEnd,
-                                             false );
-                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
-                tempHose.Dispose();
-                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
-            }
-            #endregion 12 sliced Hoses
-
-            #region 6 quads for the sides
-
-            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
-            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
-
-            // all quads use the same texcoords
-            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
-            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
-            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
-            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
-
-            // front face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
-            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // back face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
-            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
-            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // top face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
-            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // bottom face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
-            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
-            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // right face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
-            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
-            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-            // left face
-            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
-            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
-            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
-
-
-            #endregion 6 quads for the sides
-
-            #region Final Assembly of Chunks
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-            AllChunks.Clear();
-            #endregion Final Assembly of Chunks
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/Chunk.cs b/AWGL/Shapes/Helpers/Chunk.cs
deleted file mode 100644
index ebac329..0000000
--- a/AWGL/Shapes/Helpers/Chunk.cs
+++ /dev/null
@@ -1,80 +0,0 @@
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public class Chunk
-    {
-        public VertexT2dN3dV3d[] Vertices;
-        public uint[] Indices;
-
-        public uint VertexCount
-        {
-            get
-            {
-                return (uint)Vertices.Length;
-            }
-        }
-        public uint IndexCount
-        {
-            get
-            {
-                return (uint)Indices.Length;
-            }
-        }
-
-        public Chunk( uint vertexcount, uint indexcount )
-        {
-            Vertices = new VertexT2dN3dV3d[vertexcount];
-            Indices = new uint[indexcount];
-        }
-
-        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
-        {
-            Vertices = new VertexT2dN3dV3d[vbo.Length];
-            for ( int i = 0; i < Vertices.Length; i++ )
-            {
-                Vertices[i] = vbo[i];
-            } 
-            Indices = new uint[ibo.Length];
-            for ( int i = 0; i < Indices.Length; i++ )
-            {
-                Indices[i] = ibo[i];
-            }
-        }
-
-        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
-        {
-
-            uint VertexCounter = 0;
-            uint IndexCounter = 0;
-
-            foreach ( Chunk ch in c )
-            {
-                VertexCounter += ch.VertexCount;
-                IndexCounter += ch.IndexCount;
-            }
-
-            vbo = new VertexT2dN3dV3d[VertexCounter];
-            ibo = new uint[IndexCounter];
-
-            VertexCounter = 0;
-            IndexCounter = 0;
-
-            foreach ( Chunk ch in c )
-            {
-                for ( int i = 0; i < ch.Vertices.Length; i++ )
-                {
-                    vbo[VertexCounter + i] = ch.Vertices[i];
-                }
-
-                for ( int i = 0; i < ch.Indices.Length; i++ )
-                {
-                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
-                }
-
-                VertexCounter += (uint)ch.VertexCount;
-                IndexCounter += (uint)ch.IndexCount;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Helpers/MengerCube.cs b/AWGL/Shapes/Helpers/MengerCube.cs
deleted file mode 100644
index 2dc56fc..0000000
--- a/AWGL/Shapes/Helpers/MengerCube.cs
+++ /dev/null
@@ -1,421 +0,0 @@
-using OpenTK;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class MengerSponge
-    {
-        private struct MengerCube
-        {
-            private Vector3d Center;
-            private double SideLength;
-            private eSides[] VisibleSides;
-            private eSides[] VisibilityToInherit;
-
-            public void GetArraySizes( out uint vertexcount, out uint indexcount )
-            {
-                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
-                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
-            }
-
-            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
-            {
-                Center = center;
-                SideLength = sidelength;
-
-                /*  List<eSides> Sides = new List<eSides>();
-                  foreach ( eSides s in visibleSides )
-                  {
-                      bool isVisible = false;
-                      foreach ( eSides p in parentsVisibility )
-                      {
-                          if ( (int)p == (int)s )
-                          {
-                              isVisible = true;
-                              break;
-                          }
-                      }
-                      if ( isVisible )
-                      {
-                          Sides.Add( s );
-                      }
-                  }
-                  VisibleSides = Sides.ToArray();*/
-                VisibleSides = visibleSides;
-                VisibilityToInherit = visibleSides;
-            }
-
-            public void Subdivide( out MengerCube[] cubes )
-            {
-                cubes = new MengerCube[20]; // 8 + 4 + 8
-
-                double NewLength = this.SideLength / 3.0;
-                double six = this.SideLength * 2.0 / 3.0;
-                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
-
-                // front
-                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
-                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
-                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
-
-                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
-                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
-                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
-
-                // center
-                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
-
-                // back
-                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
-                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
-                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
-
-                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
-                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
-
-                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
-                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
-                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
-
-            }
-
-            public enum eSides: byte
-            {
-                Front,
-                Back,
-                Right,
-                Left,
-                Top,
-                Bottom
-            }
-
-            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
-
-            public void GetVboAndIbo( ref List<Chunk> chunks )
-            {
-                foreach ( eSides s in AllSides )
-                {
-                    DrawSide( s, ref chunks );
-                }
-            }
-
-            private void DrawSide( eSides side, ref List<Chunk> chunks )
-            {
-                #region Setup constants for current direction
-
-                double _Zero = 0.0; // 0/3
-                double _Three = 0.3333333333333; // 1/3
-                double _Six = 0.66666666666666; // 2/3
-                double _One = 1.0; // 3/3 
-
-                double ThirdLength = SideLength / 3f;
-
-                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
-                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
-                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
-                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
-
-                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
-                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
-                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
-                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
-
-                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
-
-                switch ( side )
-                {
-                case eSides.Front:
-                    P0 = C0;
-                    P1 = C1;
-                    P2 = C2;
-                    P3 = C3;
-
-                    P4 = C4;
-                    P5 = C5;
-                    P6 = C6;
-                    P7 = C7;
-                    break;
-                case eSides.Back:
-                    P0 = C5;
-                    P1 = C4;
-                    P2 = C7;
-                    P3 = C6;
-
-                    P4 = C1;
-                    P5 = C0;
-                    P6 = C3;
-                    P7 = C2;
-                    break;
-                case eSides.Right:
-                    P0 = C1;
-                    P1 = C5;
-                    P2 = C6;
-                    P3 = C2;
-
-                    P4 = C0;
-                    P5 = C4;
-                    P6 = C7;
-                    P7 = C3;
-                    break;
-                case eSides.Left:
-                    P0 = C4;
-                    P1 = C0;
-                    P2 = C3;
-                    P3 = C7;
-
-                    P4 = C5;
-                    P5 = C1;
-                    P6 = C2;
-                    P7 = C6;
-                    break;
-                case eSides.Top:
-                    P0 = C3;
-                    P1 = C2;
-                    P2 = C6;
-                    P3 = C7;
-
-                    P4 = C0;
-                    P5 = C1;
-                    P6 = C5;
-                    P7 = C4;
-                    break;
-                case eSides.Bottom:
-                    P0 = C1;
-                    P1 = C0;
-                    P2 = C4;
-                    P3 = C5;
-
-                    P4 = C2;
-                    P5 = C3;
-                    P6 = C7;
-                    P7 = C6;
-                    break;
-                default:
-                    throw new NotImplementedException( "Unknown enum value: " + side );
-                }
-
-                #endregion Setup constants for current direction
-
-                #region Set Normal
-
-                Vector3d FaceNormal;
-
-                switch ( side )
-                {
-                case eSides.Front:
-                    FaceNormal = Vector3d.UnitZ;
-                    break;
-                case eSides.Back:
-                    FaceNormal = -Vector3d.UnitZ;
-                    break;
-                case eSides.Right:
-                    FaceNormal = Vector3d.UnitX;
-                    break;
-                case eSides.Left:
-                    FaceNormal = -Vector3d.UnitX;
-                    break;
-                case eSides.Top:
-                    FaceNormal = Vector3d.UnitY;
-                    break;
-                case eSides.Bottom:
-                    FaceNormal = -Vector3d.UnitY;
-                    break;
-                default:
-                    throw new NotImplementedException( "Unknown enum value: " + side );
-                }
-                #endregion Set Normal
-
-                bool FaceIsVisible = false;
-                foreach ( eSides s in VisibleSides )
-                {
-                    if ( s == side )
-                    {
-                        FaceIsVisible = true;
-                        break;
-                    }
-                }
-
-                if ( FaceIsVisible )
-                {
-                    #region Define Layer1 Vertices
-                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
-
-                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
-                    Layer1.Vertices[0].Normal = FaceNormal;
-                    Layer1.Vertices[0].Position = P0;
-
-                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
-                    Layer1.Vertices[1].Normal = FaceNormal;
-                    Layer1.Vertices[1].Position = P1;
-
-                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
-                    Layer1.Vertices[2].Normal = FaceNormal;
-                    Layer1.Vertices[2].Position = P2;
-
-                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
-                    Layer1.Vertices[3].Normal = FaceNormal;
-                    Layer1.Vertices[3].Position = P3;
-
-                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
-                    Layer1.Vertices[4].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
-
-                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
-                    Layer1.Vertices[5].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
-
-                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
-                    Layer1.Vertices[6].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
-
-                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
-                    Layer1.Vertices[7].Normal = FaceNormal;
-                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
-                    #endregion Define Layer1 Vertices
-
-                    #region Define Layer1 Indices
-                    Layer1.Indices[0] = 0;
-                    Layer1.Indices[1] = 5;
-                    Layer1.Indices[2] = 4;
-
-                    Layer1.Indices[3] = 0;
-                    Layer1.Indices[4] = 1;
-                    Layer1.Indices[5] = 5;
-
-                    Layer1.Indices[6] = 5;
-                    Layer1.Indices[7] = 1;
-                    Layer1.Indices[8] = 2;
-
-                    Layer1.Indices[9] = 6;
-                    Layer1.Indices[10] = 5;
-                    Layer1.Indices[11] = 2;
-
-                    Layer1.Indices[12] = 7;
-                    Layer1.Indices[13] = 6;
-                    Layer1.Indices[14] = 2;
-
-                    Layer1.Indices[15] = 3;
-                    Layer1.Indices[16] = 7;
-                    Layer1.Indices[17] = 2;
-
-                    Layer1.Indices[18] = 0;
-                    Layer1.Indices[19] = 7;
-                    Layer1.Indices[20] = 3;
-
-                    Layer1.Indices[21] = 0;
-                    Layer1.Indices[22] = 4;
-                    Layer1.Indices[23] = 7;
-
-                    chunks.Add( Layer1 );
-                    #endregion Define Layer1 Indices
-                }
-
-                #region Define Layer2 Vertices
-                Chunk Layer2 = new Chunk( 12, 8 * 3 );
-
-                Vector3d T0, T1, T2, T3;
-                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
-                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
-                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
-                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
-
-                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
-                Layer2.Vertices[0].Normal = FaceNormal;
-                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
-
-                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
-                Layer2.Vertices[1].Normal = FaceNormal;
-                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
-
-                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
-                Layer2.Vertices[3].Normal = FaceNormal;
-                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
-
-                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
-                Layer2.Vertices[4].Normal = FaceNormal;
-                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
-
-                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
-                Layer2.Vertices[6].Normal = FaceNormal;
-                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
-
-                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
-                Layer2.Vertices[7].Normal = FaceNormal;
-                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
-
-                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
-                Layer2.Vertices[9].Normal = FaceNormal;
-                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
-
-                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
-                Layer2.Vertices[10].Normal = FaceNormal;
-                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
-
-                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
-                Layer2.Vertices[2].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
-
-                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
-                Layer2.Vertices[5].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
-
-                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
-                Layer2.Vertices[8].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
-
-                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
-                Layer2.Vertices[11].Normal = FaceNormal;
-                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
-                #endregion Define Layer2 Vertices
-
-                #region Define Layer2 Indices
-                Layer2.Indices[0] = 0;
-                Layer2.Indices[1] = 2;
-                Layer2.Indices[2] = 11;
-
-                Layer2.Indices[3] = 0;
-                Layer2.Indices[4] = 1;
-                Layer2.Indices[5] = 2;
-
-                Layer2.Indices[6] = 2;
-                Layer2.Indices[7] = 3;
-                Layer2.Indices[8] = 4;
-
-                Layer2.Indices[9] = 2;
-                Layer2.Indices[10] = 4;
-                Layer2.Indices[11] = 5;
-
-                Layer2.Indices[12] = 5;
-                Layer2.Indices[13] = 6;
-                Layer2.Indices[14] = 8;
-
-                Layer2.Indices[15] = 8;
-                Layer2.Indices[16] = 6;
-                Layer2.Indices[17] = 7;
-
-                Layer2.Indices[18] = 11;
-                Layer2.Indices[19] = 8;
-                Layer2.Indices[20] = 10;
-
-                Layer2.Indices[21] = 10;
-                Layer2.Indices[22] = 8;
-                Layer2.Indices[23] = 9;
-
-                chunks.Add( Layer2 );
-                #endregion Define Layer2 Indices
-            }
-        }
-    }
-
-   
-}
diff --git a/AWGL/Shapes/Helpers/TetrahedronFace.cs b/AWGL/Shapes/Helpers/TetrahedronFace.cs
deleted file mode 100644
index 5b4e4cc..0000000
--- a/AWGL/Shapes/Helpers/TetrahedronFace.cs
+++ /dev/null
@@ -1,228 +0,0 @@
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-
-    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
-    internal struct TetrahedronFace
-    {
-        private Vector3d APosition, BPosition, CPosition;
-        private Vector3d DPosition, Normal;
-        private Vector2d ATexCoord, BTexCoord, CTexCoord;
-
-        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
-                                   ref Vector3d bpos, ref Vector2d btc,
-                                   ref Vector3d cpos, ref Vector2d ctc,
-                                   ref Vector3d dpos,
-                                   ref Vector3d normal )
-        {
-            APosition = apos; ATexCoord = atc;
-            BPosition = bpos; BTexCoord = btc;
-            CPosition = cpos; CTexCoord = ctc;
-            DPosition = dpos;
-            Normal = normal;
-        }
-
-        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
-        /// <param name="first">1st output Triangle</param>
-        /// <param name="second">2nd output Triangle</param>
-        /// <param name="third">3rd output Triangle</param>
-        /// <param name="fourth">4th output Triangle</param>
-        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
-        {
-            Vector3d temp;
-
-            // find the 3 points AB, BC, CA 
-            Vector3d CenterAB;
-            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
-
-            Vector3d CenterBC;
-            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
-
-            Vector3d CenterCA;
-            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
-            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
-
-            // find the 3 points AD, BD, CD 
-            Vector3d CenterAD;
-            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
-
-            Vector3d CenterBD;
-            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
-
-            Vector3d CenterCD;
-            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
-
-            // emit 4 new CCW triangles
-            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
-                              ref CenterAB, ref this.BTexCoord,
-                              ref CenterCA, ref this.CTexCoord,
-                              ref CenterAD,
-                              ref this.Normal );
-
-            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
-                               ref this.BPosition, ref this.BTexCoord,
-                               ref CenterBC, ref this.CTexCoord,
-                               ref CenterBD,
-                               ref this.Normal );
-
-            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
-                              ref CenterBC, ref this.BTexCoord,
-                              ref this.CPosition, ref this.CTexCoord,
-                              ref CenterCD,
-                              ref this.Normal );
-
-            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
-                               ref CenterBD, ref this.BTexCoord,
-                               ref CenterCD, ref this.CTexCoord,
-                               ref this.DPosition,
-                               ref this.Normal );
-        }
-
-
-        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
-        {
-            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
-            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
-
-            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
-            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
-            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
-            CenterD = CenterAB;
-            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
-            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
-            CenterD /= 3.0;
-            Vector3d E = CenterD + ( this.Normal * 0.5 );
-            Vector3d temp = this.Normal;
-            temp *= height;
-            Vector3d.Add(ref CenterD, ref temp, out CenterD);
-
-            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
-            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
-            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
-            TexCoordD = TexCoordAB;
-            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
-            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
-            TexCoordD /= 3.0;
-            #region 1
-            first.APosition = this.APosition;
-            first.ATexCoord = this.ATexCoord;
-
-            first.BPosition = CenterAB;
-            first.BTexCoord = TexCoordAB;
-
-            first.CPosition = CenterCA;
-            first.CTexCoord = TexCoordCA;
-
-            first.Normal = this.Normal;
-            temp = ( this.APosition + CenterAB + CenterCA );
-            temp /= 3.0;
-            temp += this.Normal * -1.0;
-            first.DPosition = temp;
-            #endregion 1
-            #region 2
-            second.APosition = CenterAB;
-            second.ATexCoord = TexCoordAB;
-
-            second.BPosition = this.BPosition;
-            second.BTexCoord = this.BTexCoord;
-
-            second.CPosition = CenterBC;
-            second.CTexCoord = TexCoordBC;
-
-            second.Normal = this.Normal;
-
-            temp = CenterAB + this.BPosition + CenterBC;
-            temp /=  3.0;
-            temp += this.Normal * -1.0;
-            second.DPosition = temp;
-
-            #endregion 2
-            #region 3
-            third.APosition = CenterBC;
-            third.ATexCoord = TexCoordBC;
-
-            third.BPosition = this.CPosition;
-            third.BTexCoord = this.CTexCoord;
-
-            third.CPosition = CenterCA;
-            third.CTexCoord = TexCoordCA;
-
-            third.Normal = this.Normal;
-            temp = CenterBC + this.CPosition + CenterCA;
-            temp /= 3.0;
-            temp += this.Normal * -1.0;
-            third.DPosition = temp;
-            #endregion 3
-            #region 4
-            fourth.APosition = CenterAB;
-            fourth.ATexCoord = TexCoordAB;
-
-            fourth.BPosition = CenterD;
-            fourth.BTexCoord = TexCoordD;
-
-            fourth.CPosition = CenterCA;
-            fourth.CTexCoord = TexCoordCA;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
-            fourth.DPosition = E;
-            #endregion 4
-            #region 5
-            fifth.APosition = CenterAB;
-            fifth.ATexCoord = TexCoordAB;
-
-            fifth.BPosition = CenterBC;
-            fifth.BTexCoord = TexCoordBC;
-
-            fifth.CPosition = CenterD;
-            fifth.CTexCoord = TexCoordD;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
-            fifth.DPosition = E;
-
-            #endregion 5
-            #region 6
-            sixth.APosition = CenterBC;
-            sixth.ATexCoord = TexCoordBC;
-
-            sixth.BPosition = CenterCA;
-            sixth.BTexCoord = TexCoordCA;
-
-            sixth.CPosition = CenterD;
-            sixth.CTexCoord = TexCoordD;
-
-            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
-            sixth.DPosition = E;
-            #endregion 6
-        }
-
-        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
-        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
-        {
-            first.TexCoord = this.ATexCoord;
-            first.Normal = this.Normal;
-            first.Position = this.APosition;
-
-            second.TexCoord = this.BTexCoord;
-            second.Normal = this.Normal;
-            second.Position = this.BPosition;
-
-            third.TexCoord = this.CTexCoord;
-            third.Normal = this.Normal;
-            third.Position = this.CPosition;
-        }
-
-        /// <summary>Debugging Aid, no real purpose</summary>
-        public override string ToString()
-        {
-            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
-                   "Normal= " + this.Normal.ToString();
-        }
-    }
-
-
-}
diff --git a/AWGL/Shapes/Helpers/VboShape.cs b/AWGL/Shapes/Helpers/VboShape.cs
deleted file mode 100644
index 62d5462..0000000
--- a/AWGL/Shapes/Helpers/VboShape.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-namespace KAOS.Shapes
-{
-    public sealed class VboShape: DrawableShape
-    {
-        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
-            : base( useDL )
-        {
-            PrimitiveMode = primitives;
-
-            VertexArray = new VertexT2dN3dV3d[vertices.Length];
-            for ( uint i = 0; i < vertices.Length; i++ )
-            {
-                VertexArray[i] = vertices[i];
-            }
-
-            IndexArray = new uint[indices.Length];
-            for ( uint i = 0; i < indices.Length; i++ )
-            {
-                IndexArray[i] = indices[i];
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/KochTetrahedron.cs b/AWGL/Shapes/KochTetrahedron.cs
deleted file mode 100644
index a662cfe..0000000
--- a/AWGL/Shapes/KochTetrahedron.cs
+++ /dev/null
@@ -1,70 +0,0 @@
-using System;
-
-namespace KAOS.Shapes
-{
-    public sealed class KochTetrahedron: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            Zero = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-            Five=5,
-            Six=6,
-            Seven=7,
-            Eight=8,
-        }
-
-        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            TetrahedronFace[] Triangles;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.Zero:
-                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-            case eSubdivisions.Four:
-            case eSubdivisions.Five:
-            case eSubdivisions.Six:
-            case eSubdivisions.Seven:
-            case eSubdivisions.Eight:
-                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    TetrahedronFace[] temp;
-                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
-                    Triangles = temp;
-                    extrusionHeight *= extrusionMultiplier;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
-            IndexArray = null;
-        }
-
-        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
-        {
-            output = new TetrahedronFace[input.Length * 6];
-
-            int counter = 0;
-            for ( int i = 0; i < input.Length; i++ )
-            {
-                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
-                counter += 6; // every source triangle emits 6 new triangles
-            }
-
-        }
-    }
-}
diff --git a/AWGL/Shapes/MengerSponge.cs b/AWGL/Shapes/MengerSponge.cs
deleted file mode 100644
index c1d54c6..0000000
--- a/AWGL/Shapes/MengerSponge.cs
+++ /dev/null
@@ -1,115 +0,0 @@
-using OpenTK;
-using System;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class MengerSponge: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            None = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-        }
-
-        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            List<MengerCube> Cubes;
-            switch ( subdivs )
-            {
-            case eSubdivisions.None:
-                CreateDefaultMengerSponge( scale, out Cubes );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-                CreateDefaultMengerSponge( scale, out Cubes );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    List<MengerCube> temp;
-                    SubdivideMengerSponge( ref Cubes, out temp );
-                    Cubes = temp;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            #region Get Array Dimensions
-            uint
-                VertexCount = 0,
-                IndexCount = 0;
-
-            foreach ( MengerCube c in Cubes )
-            {
-                uint t1, t2;
-                c.GetArraySizes( out t1, out t2 );
-                VertexCount += t1;
-                IndexCount += t2;
-            }
-
-            VertexArray = new VertexT2dN3dV3d[VertexCount];
-            IndexArray = new uint[IndexCount];
-            #endregion Get Array Dimensions
-
-            List<Chunk> AllChunks = new List<Chunk>();
-
-            #region Build a temporary List of all loose pieces
-            foreach ( MengerCube c in Cubes )
-            {
-                c.GetVboAndIbo( ref AllChunks );
-            }
-            #endregion Build a temporary List of all loose pieces
-
-            #region Assemble pieces into a single VBO and IBO
-            VertexCount = 0;
-            IndexCount = 0;
-
-            foreach ( Chunk ch in AllChunks )
-            {
-                for ( int i = 0; i < ch.Vertices.Length; i++ )
-                {
-                    VertexArray[VertexCount + i] = ch.Vertices[i];
-                }
-
-                for ( int i = 0; i < ch.Indices.Length; i++ )
-                {
-                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
-                }
-
-                VertexCount += (uint)ch.Vertices.Length;
-                IndexCount += (uint)ch.Indices.Length;
-            }
-
-            #endregion Assemble pieces into a single VBO and IBO
-
-            AllChunks.Clear();
-        }
-
-        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
-        {
-            output = new List<MengerCube>( 1 );
-            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
-        }
-
-        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
-        {
-            output = new List<MengerCube>( input.Count * 20 );
-            foreach ( MengerCube InputCube in input )
-            {
-                MengerCube[] SubdividedCubes;
-                InputCube.Subdivide( out SubdividedCubes );
-                for ( int i = 0; i < SubdividedCubes.Length; i++ )
-                {
-                    output.Add( SubdividedCubes[i] );
-                }
-            }
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/Old/Cube.cs b/AWGL/Shapes/Old/Cube.cs
deleted file mode 100644
index 99c2d1b..0000000
--- a/AWGL/Shapes/Old/Cube.cs
+++ /dev/null
@@ -1,85 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using System.Drawing;
-
-namespace KAOS.Shapes
-{
-    public class Cube : Shape
-    {
-
-        public Cube(int x, int y, int z)
-        {
-            Vertices = new Vector3[]
-            {
-                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
-                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
-                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
-                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
-                new Vector3(x-1.0f, y-1.0f, z-1.0f),
-                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
-                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
-                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
-            };
-
-            Indices = new int[]
-            {
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1,
-            };
-
-            Normals = new Vector3[]
-            {
-                new Vector3(-1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f, -1.0f,  1.0f),
-                new Vector3( 1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f,  1.0f,  1.0f),
-                new Vector3(-1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f, -1.0f, -1.0f),
-                new Vector3( 1.0f,  1.0f, -1.0f),
-                new Vector3(-1.0f,  1.0f, -1.0f),
-            };
-
-            Colors = new int[]
-            {
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.DarkRed),
-                ColorToRgba32(Color.Gold),
-                ColorToRgba32(Color.Gold),
-            };
-        }
-
-
-        /// <summary>
-        /// Converts a Color instance into an int representation
-        /// </summary>
-        /// <param name="c">
-        /// A <see cref="Color"/> instance to be converted
-        /// </param>
-        /// <returns>
-        /// A <see cref="System.Int32"/>
-        /// </returns>
-        public static int ColorToRgba32(Color c)
-        {
-            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/IsoSphere.cs b/AWGL/Shapes/Old/IsoSphere.cs
deleted file mode 100644
index 4b2ae9f..0000000
--- a/AWGL/Shapes/Old/IsoSphere.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using OpenTK;
-using System;
-
-namespace KAOS.Shapes
-{
-    class IsoSphere : Shape
-    {
-        const double DoublePI = System.Math.PI * 2.0;
-
-        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
-        {
-            int count = 4 * s_steps * t_steps ;
-            
-            Vertices = new Vector3[count];
-            Normals = new Vector3[count];
-            Texcoords = new Vector2[count];
-            Indices = new int[6 * count / 4];
-
-            int i = 0;
-            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
-            {
-                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
-                {
-                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
-                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
-                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
-                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
-                    Normals[i] = Vector3.Normalize(Vertices[i]);
-
-                    ++i;
-                }
-            }
-            
-            for (i = 0; i < 6*count/4; i+=6)
-            {
-                Indices[i] = i;
-                Indices[i + 1] = i + 1;
-                Indices[i + 2] = i + 2 * s_steps + 1;
-                Indices[i + 3] = i + 2 * s_steps;
-                Indices[i + 4] = i;
-                Indices[i + 5] = i + 2 * s_steps + 1;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/Plane.cs b/AWGL/Shapes/Old/Plane.cs
deleted file mode 100644
index df9a78e..0000000
--- a/AWGL/Shapes/Old/Plane.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-    public class Plane : Shape
-    {
-        public Plane(int x_res, int y_res, float x_scale, float y_scale)
-        {
-            Vertices = new Vector3[x_res * y_res];
-            Normals = new Vector3[x_res * y_res];
-            Indices = new int[6 * x_res * y_res];
-            Texcoords = new Vector2[x_res * y_res];
-
-            int i = 0;
-            for (int y = -y_res / 2; y < y_res / 2; y++)
-            {
-                for (int x = -x_res / 2; x < x_res / 2; x++)
-                {
-                    Vertices[i].X = x_scale * (float)x / (float)x_res;
-                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
-                    Vertices[i].Z = 0;
-                    Normals[i].X = Normals[i].Y = 0;
-                    Normals[i].Z = 1;
-                    i++;
-                }
-            }
-
-            i = 0;
-            for (int y = 0; y < y_res - 1; y++)
-            {
-                for (int x = 0; x < x_res - 1; x++)
-                {
-                    Indices[i++] = (y + 0) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x + 1;
-                }
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/Shape.cs b/AWGL/Shapes/Old/Shape.cs
deleted file mode 100644
index c5315af..0000000
--- a/AWGL/Shapes/Old/Shape.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿#region --- License ---
-/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
- * See license.txt for license info
- */
-#endregion
-
-
-
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-    public abstract class Shape
-    {
-        private Vector3[] vertices, normals;
-        private Vector2[] texcoords;
-        private int[] indices;
-        private int[] colors;
-
-        public Vector3[] Vertices
-        {
-            get { return vertices; }
-            protected set
-            {
-                vertices = value;
-            }
-        }
-
-        public Vector3[] Normals
-        {
-            get { return normals; }
-            protected set
-            {
-                normals = value;
-            }
-        }
-
-        public Vector2[] Texcoords
-        {
-            get { return texcoords; }
-            protected set
-            {
-                texcoords = value;
-            }
-        }
-
-        public int[] Indices
-        {
-            get { return indices; }
-            protected set
-            {
-                indices = value;
-            }
-        }
-
-        public int[] Colors
-        {
-            get { return colors; }
-            protected set
-            {
-                colors = value;
-            }
-        }
-    }
-}
diff --git a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs b/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
deleted file mode 100644
index fcb493d..0000000
--- a/AWGL/Shapes/Old/SierpinskiTetrahedron.cs
+++ /dev/null
@@ -1,171 +0,0 @@
-using OpenTK;
-using System;
-
-namespace KAOS.Shapes
-{
-    public sealed partial class SierpinskiTetrahedron: DrawableShape
-    {
-
-        public enum eSubdivisions
-        {
-            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
-            Zero = 0,
-            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
-            One = 1,
-            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
-            Two = 2,
-            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
-            Three = 3,
-            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
-            Four = 4,
-            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
-            Five = 5,
-            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
-            Six = 6,
-            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
-            Seven = 7,
-            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
-            Eight = 8,
-            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
-            Nine = 9,
-        }
-
-        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
-        /// <param name="scale">Default: 1f.</param>
-        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
-        /// <param name="useDL"></param>
-        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
-            : base( useDL )
-        {
-            TetrahedronFace[] Triangles;
-
-            switch ( subdivs )
-            {
-            case eSubdivisions.Zero:
-                CreateDefaultTetrahedron( scale, out Triangles );
-                break;
-            case eSubdivisions.One:
-            case eSubdivisions.Two:
-            case eSubdivisions.Three:
-            case eSubdivisions.Four:
-            case eSubdivisions.Five:
-            case eSubdivisions.Six:
-            case eSubdivisions.Seven:
-            case eSubdivisions.Eight:
-            case eSubdivisions.Nine:
-                CreateDefaultTetrahedron( scale, out Triangles );
-                for ( int i = 0; i < (int)subdivs; i++ )
-                {
-                    TetrahedronFace[] temp;
-                    SubdivideTetrahedron( ref Triangles, out temp );
-                    Triangles = temp;
-                }
-                break;
-            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
-            }
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
-            IndexArray = null;
-        }
-
-        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
-        {
-            output = new VertexT2dN3dV3d[input.Length * 3];
-            int counter = 0;
-            for ( int i = 0; i < input.Length; i++ )
-            {
-                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
-                counter += 3;
-            }
-        }
-
-        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
-        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
-        {
-            Vector3d[] Points = new Vector3d[4];
-            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
-            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
-            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
-            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
-
-            Vector2d[] TexCoords = new Vector2d[4];
-            TexCoords[0] = new Vector2d( 0.0, 0.0 );
-            TexCoords[1] = new Vector2d( 1.0, 0.0 );
-            TexCoords[2] = new Vector2d( 0.0, 1.0 );
-            TexCoords[3] = new Vector2d( 1.0, 1.0 );
-
-            Vector3d Normal;
-            array = new TetrahedronFace[4];
-
-            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
-            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
-                                                   ref Points[2], ref TexCoords[0],
-                                                   ref Points[1], ref TexCoords[1],
-                                                   ref Points[3],
-                                                   ref Normal );
-
-            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
-            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
-                                                   ref Points[3], ref TexCoords[1],
-                                                   ref Points[2], ref TexCoords[2],
-                                                   ref Points[1],
-                                                   ref Normal );
-
-            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
-            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
-                                                   ref Points[1], ref TexCoords[1],
-                                                   ref Points[3], ref TexCoords[3],
-                                                   ref Points[2],
-                                                   ref Normal );
-
-            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
-            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
-                                                   ref Points[2], ref TexCoords[2],
-                                                   ref Points[3], ref TexCoords[1],
-                                                   ref Points[0],
-                                                   ref Normal );
-        }
-
-        /// <summary>Subdivides each triangle into 4 new ones.</summary>
-        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
-        {
-
-            output = new TetrahedronFace[source.Length * 4];
-
-            int counter = 0;
-            for ( int i = 0; i < source.Length; i++ )
-            {
-                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
-                counter += 4; // every source triangle emits 4 new triangles
-            }
-        }
-
-        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
-        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
-        {
-            Vector3d temp1, temp2, temp3;
-
-            Vector3d.Subtract( ref A, ref D, out temp1 );
-            Vector3d.Subtract( ref B, ref D, out temp2 );
-            Vector3d.Subtract( ref C, ref D, out temp3 );
-
-            Vector3d.Add( ref temp1, ref temp2, out result );
-            Vector3d.Add(ref result, ref temp3, out result);
-            result.Normalize();
-        }
-
-        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
-        {
-            Vector3d temp1, temp2;
-            Vector3d.Subtract( ref A, ref B, out temp1 );
-            temp1.Normalize();
-            Vector3d.Subtract(ref C, ref B, out temp2);
-            temp2.Normalize();
-            Vector3d.Cross( ref temp1, ref temp2, out result );
-            result *=  -1.0;
-            result.Normalize();
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/SlicedHose.cs b/AWGL/Shapes/SlicedHose.cs
deleted file mode 100644
index 8a744ca..0000000
--- a/AWGL/Shapes/SlicedHose.cs
+++ /dev/null
@@ -1,192 +0,0 @@
-using OpenTK;
-
-namespace KAOS.Shapes
-{
-	public sealed class SlicedHose : DrawableShape
-	{
-
-        public enum eSide:byte
-        {
-            // Around X Axis
-            BottomRight,
-            TopRight,
-            TopLeft,
-            BottomLeft,
-
-            // Around Y Axis
-
-            FrontRight,
-            BackRight,
-            BackLeft,
-            FrontLeft,
-
-            // Around Z Axis
-            FrontBottom,
-            BackBottom,
-            BackTop,
-            FrontTop,
-        }
-
-        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
-            : base( useDL )
-        {
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            Vector3d start = Vector3d.Zero,
-                     end = Vector3d.Zero;
-            double TexCoordStart=0f, TexCoordEnd=0f;
-
-            switch ( side )
-            {
-            #region Around X Axis
-            case eSide.BottomRight:
-                start = -Vector3d.UnitY;
-                end = Vector3d.UnitZ;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.TopRight:
-                start = Vector3d.UnitZ;
-                end = Vector3d.UnitY;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.TopLeft:
-                start = Vector3d.UnitY;
-                end = -Vector3d.UnitZ;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.BottomLeft:
-                start = -Vector3d.UnitZ;
-                end = -Vector3d.UnitY;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-            #endregion Around X Axis
-            #region Around Y Axis
-            case eSide.FrontRight:
-                start = Vector3d.UnitX;
-                end = Vector3d.UnitZ;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.BackRight:
-                start = Vector3d.UnitZ;
-                end = -Vector3d.UnitX;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.BackLeft:
-                start = -Vector3d.UnitX;
-                end = -Vector3d.UnitZ;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.FrontLeft:
-                start = -Vector3d.UnitZ;
-                end = Vector3d.UnitX;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-#endregion Around Y Axis
-            #region Around Z Axis
-            case eSide.FrontBottom:
-                start = -Vector3d.UnitY;
-                end = Vector3d.UnitX;
-                TexCoordStart = 0.0;
-                TexCoordEnd = 0.25;
-                break;
-            case eSide.BackBottom:
-                start = -Vector3d.UnitX;
-                end = -Vector3d.UnitY;
-                TexCoordStart = 0.25;
-                TexCoordEnd = 0.5;
-                break;
-            case eSide.BackTop:
-                start = Vector3d.UnitY;
-                end = -Vector3d.UnitX;
-                TexCoordStart = 0.5;
-                TexCoordEnd = 0.75;
-                break;
-            case eSide.FrontTop:
-                start = Vector3d.UnitX;
-                end = Vector3d.UnitY;
-                TexCoordStart = 0.75;
-                TexCoordEnd = 1.0;
-                break;
-#endregion Around Z Axis
-
-            }
-
-            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
-
-            double divisor = 1.0/ ((double)temp.Length-1.0);
-            for ( int i = 0; i < temp.Length; i++ )
-            {
-                float Multiplier = (float)( i * divisor );
-
-                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
-
-                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
-                temp[i].Normal.Normalize();
-                temp[i].Position = temp[i].Normal;
-                temp[i].Position *= scale;
-            }
-
-            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
-            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
-
-            uint VertexCounter = 0,
-                 IndexCounter = 0,
-                 QuadCounter = 0;
-
-            for ( int i = 0; i < temp.Length; i++ )
-            {
-                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
-                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
-                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
-                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
-
-
-                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
-                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
-                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
-                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
-                VertexCounter += 2;
-
-                if ( i < temp.Length - 1 )
-                {
-                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
-                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
-                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
-
-                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
-                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
-                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
-
-                    IndexCounter += 6;
-                    QuadCounter += 2;
-                }
-            }
-
-        }
- 
-    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
-    {
-        double t1;
-        Vector3d.Dot( ref a, ref b, out t1 );
-        double theta = System.Math.Acos( t1 );
-
-        double temp = 1.0 / System.Math.Sin( theta );
-        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
-        double t3 = System.Math.Sin( factor * theta ) * temp;
-
-        Vector3d v1 = Vector3d.Multiply( a, t2);
-        Vector3d v2 = Vector3d.Multiply( b, t3 );
-        result = Vector3d.Add( v1, v2 );
-    }
-
-
-    }
-}
diff --git a/AWGL/Shapes/SlicedSphere.cs b/AWGL/Shapes/SlicedSphere.cs
deleted file mode 100644
index 7c5ee4f..0000000
--- a/AWGL/Shapes/SlicedSphere.cs
+++ /dev/null
@@ -1,193 +0,0 @@
-using OpenTK;
-using System.Collections.Generic;
-
-namespace KAOS.Shapes
-{
-    public sealed class SlicedSphere: DrawableShape
-    {
-        public enum eSubdivisions
-        {
-            Zero = 0,
-            One = 1,
-            Two = 2,
-            Three = 3,
-            Four = 4,
-            Five=5,
-            Six=6,
-            Seven=7,
-            Eight=8,
-        }
-
-        public enum eDir
-        {
-            All,
-            FrontTopRight,
-            FrontBottomRight,
-            FrontBottomLeft,
-            FrontTopLeft,
-            BackTopRight,
-            BackBottomRight,
-            BackBottomLeft,
-            BackTopLeft,
-
-        }
-
-        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
-            : base( useDL )
-        {
-            double Diameter = radius;
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
-
-            if ( sides[0] == eDir.All )
-            {
-                sides = new eDir[] {  eDir.FrontTopRight,
-            eDir.FrontBottomRight,
-            eDir.FrontBottomLeft,
-            eDir.FrontTopLeft,
-            eDir.BackTopRight,
-            eDir.BackBottomRight,
-            eDir.BackBottomLeft,
-            eDir.BackTopLeft,};
-            }
-
-            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
-            IndexArray = new uint[sides.Length * 3];
-
-            uint counter = 0;
-            foreach ( eDir s in sides )
-            {
-                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
-                IndexArray[counter + 0] = counter + 0;
-                IndexArray[counter + 1] = counter + 1;
-                IndexArray[counter + 2] = counter + 2;
-                counter += 3;
-            }
-
-            if ( subdivs != eSubdivisions.Zero )
-            {
-
-                for ( int s = 0; s < (int)subdivs; s++ )
-                {
-                    #region Assemble Chunks and convert to Arrays
-                    List<Chunk> AllChunks = new List<Chunk>();
-                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
-                    {
-                        Chunk chu;
-                        Subdivide( Diameter,
-                                   ref VertexArray[IndexArray[i + 0]],
-                                   ref VertexArray[IndexArray[i + 1]],
-                                   ref VertexArray[IndexArray[i + 2]],
-                                   out chu );
-                        AllChunks.Add( chu );
-                    }
-
-                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
-                    AllChunks.Clear();
-                    #endregion Assemble Chunks and convert to Arrays
-                }
-            }
-
-            for (int i=0; i<VertexArray.Length;i++)
-            {
-                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
-            }
-        }
-
-        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
-        {
-            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
-                            t2 = new VertexT2dN3dV3d(),
-                            t3 = new VertexT2dN3dV3d();
-            switch ( s )
-            {
-            case eDir.FrontTopRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                break;
-            case eDir.FrontBottomRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                break;
-            case eDir.FrontBottomLeft: 
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                break;
-            case eDir.FrontTopLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
-                break;
-            case eDir.BackTopRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                break;
-            case eDir.BackBottomRight:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                break;
-            case eDir.BackBottomLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                break;
-            case eDir.BackTopLeft:
-                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
-                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
-                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
-                break;
-            }
-            first = t1;
-            second = t2;
-            third = t3;
-        }
-
-
-        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
-        {
-            c = new Chunk(6, 12);
-
-            c.Vertices[0] = first;
-            
-            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
-            c.Vertices[1].Normal.Normalize();
-            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
-            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
-
-            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
-            c.Vertices[2].Normal.Normalize();
-            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
-            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
-
-            c.Vertices[3] = second;
-    
-            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
-            c.Vertices[4].Normal.Normalize();
-            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
-            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
-
-            c.Vertices[5] = third;
-
-            #region Indices
-            c.Indices[0]=0;
-            c.Indices[1]=1;
-            c.Indices[2]=2;
-            c.Indices[3]=2;
-            c.Indices[4]=1;
-            c.Indices[5]=4;
-            c.Indices[6]=1;
-            c.Indices[7]=3;
-            c.Indices[8]=4;
-            c.Indices[9]=2;
-            c.Indices[10]=4;
-            c.Indices[11]=5;
-            #endregion Indices
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/TorusKnot.cs b/AWGL/Shapes/TorusKnot.cs
deleted file mode 100644
index 898c314..0000000
--- a/AWGL/Shapes/TorusKnot.cs
+++ /dev/null
@@ -1,126 +0,0 @@
-﻿using OpenTK;
-using System.Diagnostics;
-
-namespace KAOS.Shapes
-{
-    public sealed class TorusKnot: DrawableShape
-    {
-        #region Constants
-        // hard minimums to make sure the created Torusknot is 3D
-        private const int MINShapeVertices = 3;
-        private const int MINPathSteps = 32;
-        private const double TwoPi = ( 2.0 * System.Math.PI );
-        #endregion Constants
-
-        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
-            : base( useDL )
-        {
-            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
-            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
-            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
-
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
-
-            Vector3d[] PathPositions = new Vector3d[pathsteps];
-
-            #region Find the center Points for each step on the path
-
-            for ( int i = 0; i < pathsteps; i++ )
-            {
-                double Angle = ( i / (double)pathsteps ) * TwoPi;
-                double AngleTimesP = Angle * p;
-                double AngleTimesQ = Angle * q;
-                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
-
-                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
-                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
-                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
-
-            }
-            #endregion Find the center Points for each step on the path
-
-            #region Find the Torus length
-            Vector3d result;
-            double[] Lengths = new double[pathsteps];
-            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
-            Lengths[0] = result.Length;
-            double TotalLength = result.Length;
-            for ( int i = 1; i < pathsteps; i++ ) // skipping 
-            {
-                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
-                Lengths[i] = result.Length;
-                TotalLength += result.Length;
-            }
-            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
-            #endregion Find the Torus length
-
-            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
-
-            #region Loft a circle Shape along the path
-            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
-            for ( uint i = 0; i < pathsteps; i++ )
-            {
-                Vector3d last, next, normal, tangent;
-                if ( i == pathsteps - 1 )
-                    next = PathPositions[0];
-                else
-                    next = PathPositions[i + 1];
-                if ( i == 0 )
-                    last = PathPositions[pathsteps - 1];
-                else
-                    last = PathPositions[i - 1];
-
-                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
-                tangent.Normalize();
-
-                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
-                normal.Normalize();
-                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
-
-                for ( uint j = 0; j < shapevertices; j++ )
-                {
-                    uint index = i * (uint)shapevertices + j;
-
-                    // Create a point on the plane and rotate it
-                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
-                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
-                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
-                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
-                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
-                    VertexArray[index].Normal.Normalize();
-                    // just generate some semi-useful UVs to fill blanks
-                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
-                }
-            }
-            #endregion Loft a circle Shape along the path
-
-            PathPositions = null; // not needed anymore
-
-            uint currentindex = 0;
-
-            #region Build a Triangle strip from the Vertices
-            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
-            for ( uint i = 0; i < pathsteps; i++ )
-            {
-                uint RowCurrent = i * (uint)shapevertices;
-                uint RowBelow;
-                if ( i == pathsteps - 1 )
-                    RowBelow = 0; // for the last row, the first row is the following
-                else
-                    RowBelow = ( i + 1 ) * (uint)shapevertices;
-
-                // new ring begins here
-                for ( uint j = 0; j < shapevertices; j++ )
-                {
-                    IndexArray[currentindex++] = RowCurrent + j;
-                    IndexArray[currentindex++] = RowBelow + j;
-                }
-                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
-                IndexArray[currentindex++] = RowCurrent;
-                IndexArray[currentindex++] = RowBelow;
-            }
-            #endregion Build a Triangle strip from the Vertices
-        }
-
-    }
-}
diff --git a/AWGL/Shapes/VertexPositionColor.cs b/AWGL/Shapes/VertexPositionColor.cs
deleted file mode 100644
index 2576afe..0000000
--- a/AWGL/Shapes/VertexPositionColor.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿#region License
-//
-// The Open Toolkit Library License
-//
-// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights to 
-// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-// the Software, and to permit persons to whom the Software is furnished to do
-// so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in all
-// copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-// OTHER DEALINGS IN THE SOFTWARE.
-//
-#endregion
-
-using OpenTK;
-using System.Drawing;
-using System.Runtime.InteropServices;
-
-namespace KAOS.Tutorial
-{
-    [StructLayout(LayoutKind.Sequential, Pack = 1)]
-    struct VertexPositionColor
-    {
-        public Vector3 Position;
-        public uint Color;
-
-        public VertexPositionColor(float x, float y, float z, Color color)
-        {
-            Position = new Vector3(x, y, z);
-            Color = ToRgba(color);
-        }
-
-        static uint ToRgba(Color color)
-        {
-            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
-        }
-    }
-}
diff --git a/AWGL/States/AssimpImportedState.cs b/AWGL/States/AssimpImportedState.cs
deleted file mode 100644
index 40dbc84..0000000
--- a/AWGL/States/AssimpImportedState.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-
-namespace KAOS.States
-{
-    public class AssimpImportedState :IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-
-        public AssimpImportedState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Render()
-        {
-
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-    }
-}
diff --git a/AWGL/States/DefaultState.cs b/AWGL/States/DefaultState.cs
deleted file mode 100644
index e26345e..0000000
--- a/AWGL/States/DefaultState.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DefaultState : IGameObject
-    {
-        double currentRotation = 0;
-
-        StateManager m_stateManager;
-        public DefaultState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.Black);
-            GL.PointSize(5f);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.TriangleStrip);
-
-            GL.Color4(new Color4(1f, 0f, 0f, .5f));
-            GL.Vertex3(new Vector3(-50f, 0f, 0f));
-            GL.Color3(new Vector3(0f, 1f, 0f));
-            GL.Vertex3(new Vector3(50f, 0, 0));
-            GL.Color3(new Vector3(0f, 0f, 1f));
-            GL.Vertex3(new Vector3(0f, 50f, 0));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/DrawSpriteState.cs b/AWGL/States/DrawSpriteState.cs
deleted file mode 100644
index f83dcda..0000000
--- a/AWGL/States/DrawSpriteState.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DrawSpriteState : IGameObject
-    {
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        double height, width, halfHeight, halfWidth, x, y, z;
-        float topUV, bottomUV, leftUV, rightUV;
-
-        #region IGameObject States
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            Texture texture = m_textureManager.Get("sprite1");
-            GL.Enable(EnableCap.Texture2D);
-            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-            GL.ClearColor(Color.Black);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.End();
-
-        } 
-        #endregion
-
-        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-        {
-            m_stateManager = stateManager;
-            m_textureManager = texturManager;
-            Initialise();
-        }
-
-        private void Initialise()
-        {
-            this.height = 200;
-            this.width = 200;
-
-            this.halfHeight = this.height / 2;
-            this.halfWidth = this.width / 2;
-
-            this.x = 0;
-            this.y = 0;
-            this.z = 2;
-
-            this.topUV = 0;
-            this.bottomUV = 1;
-            this.leftUV = 0;
-            this.rightUV = 1;
-        }
-    }
-}
diff --git a/AWGL/States/Skyboxstate.cs b/AWGL/States/Skyboxstate.cs
deleted file mode 100644
index 59095f9..0000000
--- a/AWGL/States/Skyboxstate.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-
-namespace KAOS.States
-{
-    public class Skyboxstate : IGameObject
-    {
-        private BufferObjectManager m_bufferManager;
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        Cube cube;
-        BufferObject cubeObject;
-
-        // Data layout for each line below is:
-        // position{XYZ},			    normal{XYZ},
-        float[] vertexData = new float[] {
-            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
-  
-            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
-  
-            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
-  
-            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
-  
-            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
-  
-            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
-        };
-
-        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
-        string[] skyboxFaces = new String[]
-        {
-            defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
-            defaultSkyboxPath + "pos_y.bmp",
-            defaultSkyboxPath + "neg_y.bmp",
-            defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
-        };
-
-        Matrix3 modelMatrix3, normalMatrix;
-        Vector3 eyeObjectSpace;
-        Vector3 trans;
-
-        
-        int eye_handle, skybox_vao;
-
-        float aspect = 1024 / (float)600;
-        float _rotation;
-
-        public Skyboxstate(StateManager stateManager)
-        {
-            m_bufferManager = new BufferObjectManager();
-            m_stateManager = stateManager;
-            m_textureManager = new TextureManager();
-
-            LoadCubeMap();
-            CreateShaders();
-
-            _rotation = MathHelper.DegreesToRadians(90);
-            trans = new Vector3(0f, 0f, -10f);
-
-            LoadTestObject();
-        }
-
-        private void CreateShaders()
-        {
-            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
-
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
-
-            Logger.WriteLine("Render Shader");
-            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
-
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
-        }
-
-        private void LoadCubeMap()
-        {
-            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-            GL.Enable(EnableCap.TextureCubeMapSeamless);
-
-            GL.GenVertexArrays(1, out skybox_vao);
-            GL.BindVertexArray(skybox_vao);
-
-            GL.DepthFunc(DepthFunction.Lequal);
-        }
-
-        private void LoadTestObject()
-        {
-            cube = new Cube(0, 0, 0);
-            cubeObject = new BufferObject();
-            cubeObject.PositionData = cube.Vertices;
-            cubeObject.NormalsData = cube.Normals;
-            cubeObject.IndicesData = cube.Indices;
-            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
-
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
-        }
-
-        public void Update(float elapsedTime)
-        {
-            MoveCamera();
-
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            
-            Renderer.viewMatrix = Camera.GetViewMatrix();
-
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
-            Renderer.eyePosition = Camera.Position;
-        }
-
-        public void Render()
-        {
-            cubeObject = m_bufferManager.GetBuffer("SkyCube");
-            Renderer.DrawSkyBox(m_textureManager, cubeObject);
-            
-            cubeObject = m_bufferManager.GetBuffer("Cube");
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Get("Render").ID);
-
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
-
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
-        }
-
-        #region Input Control
-        private void MoveCamera()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-
-            }
-        #endregion
-        }
-    }
-}
diff --git a/AWGL/States/SplashScreenState.cs b/AWGL/States/SplashScreenState.cs
deleted file mode 100644
index c18d9ec..0000000
--- a/AWGL/States/SplashScreenState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Timers;
-
-namespace KAOS.States
-{
-    public class SplashScreenState : IGameObject
-    {
-        double currentRotation = 0;
-        double delay = 300;
-
-        StateManager m_stateManager;
-        public SplashScreenState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            delay--;
-            if (delay <= 0){
-                delay = 3;
-                m_stateManager.ChangeState("Voxels");
-            }
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.MidnightBlue);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
-            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
-            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/TestSpriteClassState.cs b/AWGL/States/TestSpriteClassState.cs
deleted file mode 100644
index 814b797..0000000
--- a/AWGL/States/TestSpriteClassState.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.States
-{
-    public class TestSpriteClassState : IGameObject
-    {
-        Renderer m_renderer = new Renderer();
-        TextureManager m_textureManager = new TextureManager();
-        Sprite sprite1 = new Sprite();
-        Sprite sprite2 = new Sprite();
-
-        public TestSpriteClassState(TextureManager textureManager)
-        {
-            m_textureManager = textureManager;
-            sprite1.Texture = m_textureManager.Get("sprite1");
-            sprite1.SetHeight(256 * 0.5f);
-            sprite1.SetPosition(new Vector3d(100, 100, 0));
-            sprite1.SetColour(new Color4(256, 256, 256, 1));
-
-            sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetHeight(256 * .5f);
-            sprite2.SetPosition(new Vector3d(-100, -100, 0));
-            sprite2.SetColour(new Color4(256, 256, 256, 1));
-        }
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(1f, 1f, 1f, 1f);
-            m_renderer.DrawSprite(sprite1);
-            m_renderer.DrawSprite(sprite2);
-            GL.Finish();
-        }
-    }
-}
diff --git a/AWGL/States/VboState.cs b/AWGL/States/VboState.cs
deleted file mode 100644
index 917dae0..0000000
--- a/AWGL/States/VboState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VboState : IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-        Cube cube = new Cube(0, 0, 0);
-
-        public VboState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            CreateVBOs();
-        }
-
-        private void CreateVBOs()
-        {
-            BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;
-            tempVBO.NormalsData = cube.Normals;
-            tempVBO.IndicesData = cube.Indices;
-            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-
-        public void Render()
-        {
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType,
-                            m_bufferObject.IndicesData.Length,
-                            DrawElementsType.UnsignedInt,
-                            IntPtr.Zero);
-        }
-    }
-}
diff --git a/AWGL/States/VoxelState.cs b/AWGL/States/VoxelState.cs
deleted file mode 100644
index e8b82e2..0000000
--- a/AWGL/States/VoxelState.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VoxelState : IGameObject
-    {
-        double currentRotation = 0;
-        public float length = 1f, height = 1f, width = 1f;
-
-        StateManager m_stateManager = new StateManager();
-
-        BufferObjectManager m_bufferObjectManager;
-        BufferObject m_bufferObject;
-
-        TextureManager m_textureManager = new TextureManager();
-
-        Cube[][][] m_blocks;
-
-        public VoxelState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            m_bufferObjectManager = new BufferObjectManager();
-
-            //LoadSkyBox();
-
-            GenerateChunk();
-        }
-
-        private void LoadSkyBox()
-        {
-            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-            m_textureManager.LoadSkyTexture("skybox", 
-                new string[] 
-                {
-                    skyboxTexturePath + "jajlands1_ft.jpg",
-                    skyboxTexturePath + "jajlands1_bk.jpg",
-                    skyboxTexturePath + "jajlands1_lf.jpg",
-                    skyboxTexturePath + "jajlands1_rt.jpg",
-                    skyboxTexturePath + "jajlands1_up.jpg",
-                    skyboxTexturePath + "jajlands1_dn.jpg"
-                }
-            );
-
-        }
-
-        private void GenerateChunk()
-        {
-            BufferObject tmpVBO = new BufferObject();
-            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
-            
-            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-            {
-                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-                {
-                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-                    {
-                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-                        if (x == 0 && y == 0 && z == 0) 
-                        { 
-                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-                        }
-                        else
-                        { 
-                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-                        }
-                    }
-                }
-            }
-
-            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 100 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-        }
-    }
-}
diff --git a/AWGL/Utilities/AnimationTimer.cs b/AWGL/Utilities/AnimationTimer.cs
deleted file mode 100644
index 9d28a68..0000000
--- a/AWGL/Utilities/AnimationTimer.cs
+++ /dev/null
@@ -1,39 +0,0 @@
-﻿
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class PreciseTimer
-    {
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
-
-        [System.Security.SuppressUnmanagedCodeSecurity]
-        [System.Runtime.InteropServices.DllImport("kernel32")]
-        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
-
-        long m_ticksPerSecond = 0;
-        long m_previouslyElapsedTime = 0;
-
-        public PreciseTimer()
-        {
-            QueryPerformanceFrequency(ref m_ticksPerSecond);
-            GetElapsedTime();
-        }
-
-        public float GetElapsedTime()
-        {
-            long time = 0;
-            QueryPerformanceCounter(ref time);
-
-            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
-
-            return elapsedTime;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Block.cs b/AWGL/Utilities/Block.cs
deleted file mode 100644
index 4d80ab9..0000000
--- a/AWGL/Utilities/Block.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public class Block
-    {
-        enum BlockType
-        {
-            BlockType_Default = 0,
-
-            BlockType_Grass,
-            BlockType_Dirt,
-            BlockType_Water,
-            BlockType_Stone,
-            BlockType_Wood,
-            BlockType_Sand,
-
-            BlockType_NumTypes,
-        };
-
-        public bool IsActive { get; set; }
-        private bool m_active;
-        private BlockType type;
-    }
-}
diff --git a/AWGL/Utilities/BufferObject.cs b/AWGL/Utilities/BufferObject.cs
deleted file mode 100644
index 18a1ea1..0000000
--- a/AWGL/Utilities/BufferObject.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct BufferObject
-    {
-        public int VaoID { get; set; }
-
-        public int VboID { get; set; }
-
-        public int IboID { get; set; }
-
-        public PrimitiveType PrimitiveType { get; set; }
-
-        public Vector3[] PositionData { get; set; }
-
-        public Vector3[] NormalsData { get; set; }
-
-        public Color4[] ColorData { get; set; }
-
-        public int[] IndicesData { get; set; }
-
-        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
-        {
-            #region Buffer Pointer IDs
-            VaoID = vaoId;
-            VboID = vboId;
-            IboID = iboId;
-            #endregion
-            
-            PositionData = vPositionData;
-            NormalsData = vNormalsData;
-            ColorData = vColorData;
-            IndicesData = indicesData;
-        }
-
-    }
-}
diff --git a/AWGL/Utilities/Camera.cs b/AWGL/Utilities/Camera.cs
deleted file mode 100644
index 59ace7e..0000000
--- a/AWGL/Utilities/Camera.cs
+++ /dev/null
@@ -1,59 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    /// <summary>
-    /// Camera
-    /// </summary>
-    public static class Camera
-    {
-        public static Vector3 Position = new Vector3(0f, 0f, 0f);
-        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
-        public static float MoveSpeed = 0.2f;
-        public static float MouseSensitivity = 0.01f;
-
-        public static Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
-            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
-        }
-
-        public static void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
-            Position += offset;
-
-            Logger.WriteLine("Camera Position = " + Position);
-        }
-
-        public static void AddRotation(float x, float y)
-        {
-            x = x * MouseSensitivity;
-            y = y * MouseSensitivity;
-
-            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
-            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Chunk.cs b/AWGL/Utilities/Chunk.cs
deleted file mode 100644
index 26681e0..0000000
--- a/AWGL/Utilities/Chunk.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿using KAOS.Shapes;
-using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-namespace KAOS.Utilities
-{
-    public class Chunk : IDisposable
-    {
-        public const int CHUNK_SIZE = 16;
-        private Block[][][] m_blocks;
-        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
-
-        public Chunk()
-        {
-            //Create Blocks
-            m_blocks = new Block[CHUNK_SIZE][][];
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                m_blocks[i] = new Block[CHUNK_SIZE][];
-
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-                }
-            }
-        }
-
-        public void Update(float dt) { }
-
-        public void Render() { }
-
-        public void Dispose()
-        {
-            // Delete blocks
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                
-
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = null;
-                }
-                m_blocks[i] = null;
-            }
-            m_blocks = null;
-        }
-
-        public void CreateMesh()
-        {
-            for (int x = 0; x < CHUNK_SIZE; x++)
-            {
-                for (int y = 0; y < CHUNK_SIZE; y++)
-                {
-                    for (int z = 0; z < CHUNK_SIZE; z++)
-                    {
-                        if (m_blocks[x][y][z].IsActive == false)
-                        {
-                            // Don't create triangle data for inactive blocks
-                            continue;
-                        }
-
-                        CreateCube(x, y, z);
-                    }
-                }
-            }
-        }
-
-        private void CreateCube(int x, int y, int z)
-        {
-            float blockSize = 1f;
-
-            
-            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
-
-            Vector3 n1;
-
-
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/AWGL/Utilities/CustomVertexStruct.cs b/AWGL/Utilities/CustomVertexStruct.cs
deleted file mode 100644
index e3d3585..0000000
--- a/AWGL/Utilities/CustomVertexStruct.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.InteropServices;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct AWVertex
-    {
-        /// <summary>
-        /// Defines the size of the AWVertex struct in bytes.
-        /// </summary>
-        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
-        private Vector3[] vector31;
-        private Vector3[] vector32;
-        private int[] p;
-
-        public Vector3[] Postions { get; set; }
-
-        public Vector3[] Normals {get; set;}
-
-        public int[] Colors {get; set;}
-
-        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
-        {
-            Postions = positions;
-            Normals = nomarls;
-            Colors = colors;
-        }
-
-            
-    }
-}
diff --git a/AWGL/Utilities/Extensions.cs b/AWGL/Utilities/Extensions.cs
deleted file mode 100644
index 759ed2a..0000000
--- a/AWGL/Utilities/Extensions.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public static class Extensions
-    {
-        // http://stackoverflow.com/a/1547282/1090268
-        public static T[] Concat<T>(this T[] x, T[] y)
-        {
-            if (x == null) throw new ArgumentNullException("x");
-            if (y == null) throw new ArgumentNullException("y");
-            int oldLen = x.Length;
-            Array.Resize<T>(ref x, x.Length + y.Length);
-            Array.Copy(y, 0, x, oldLen, y.Length);
-            return x;
-        }
-    }
-}
diff --git a/AWGL/Utilities/Logger.cs b/AWGL/Utilities/Logger.cs
deleted file mode 100644
index 6e15e05..0000000
--- a/AWGL/Utilities/Logger.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-﻿using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-
-namespace KAOS.Utilities
-{
-    /// <summary>
-    /// AWLogger
-    /// </summary>
-    internal static class Logger
-    {
-       
-        internal static void WriteLine(string output)
-        {
-            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
-        }
-
-        internal static void PlatformInfo()
-        {
-            WriteLine("Starting Logger. . .");
-            WriteLine("Getting Platform Information. . .");
-            WriteLine(GL.GetString(StringName.Vendor));
-            WriteLine(GL.GetString(StringName.Renderer));
-            WriteLine(GL.GetString(StringName.Version));
-            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
-        }
-
-        internal static void ShaderInfo(int shaderHandle)
-        {
-            String infoLog;
-            GL.GetShaderInfoLog(shaderHandle, out infoLog);
-            WriteLine(infoLog);
-        }
-
-        internal static void ProgramInfo(int programHandle)
-        {
-            String infoLog;
-            GL.GetProgramInfoLog(programHandle, out infoLog);
-            WriteLine(infoLog);
-            ShadersAttached(programHandle);
-        }
-
-        internal static void ShadersAttached(int programHandle)
-        {
-            int attachedShaders;
-            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
-            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
-            WriteLine(attachedShaders + temp + " Attached");
-        }
-    }
-
-}
diff --git a/AWGL/Utilities/Renderer.cs b/AWGL/Utilities/Renderer.cs
deleted file mode 100644
index 903fe15..0000000
--- a/AWGL/Utilities/Renderer.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-﻿using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.Utilities
-{
-    public static class Renderer
-    {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
-
-        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
-        {
-            GL.Color4(color);
-            GL.TexCoord2(uvs);
-            GL.Vertex3(position);
-        }
-
-        public static void DrawSprite(Sprite sprite)
-        {
-            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(PrimitiveType.Triangles);
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                DrawImmediateModeVertex(
-                    sprite.VertexPositions[i],
-                    sprite.VertexColours[i],
-                    sprite.VertexUVs[i]);
-            }
-            GL.End();
-        }
-
-        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
-        {
-            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
-            GL.UseProgram(ShaderManager.Get("Skybox").ID);
-            GL.ActiveTexture(TextureUnit.Texture0);
-            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
-
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
-
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        public static void DrawWireframeVoxel(float length, float height, float width)
-        {
-            
-        }
-
-        public static void DrawChunk(Chunk chunk)
-        {
-
-        }
-
-        internal static void ToggleWireframeOn()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-        }
-
-        internal static void ToggleWireframeOff()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Shader.cs b/AWGL/Utilities/Shader.cs
deleted file mode 100644
index 2b5cda0..0000000
--- a/AWGL/Utilities/Shader.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    public struct Shader
-    {
-        public int ID { get; set; }
-
-        public Shader(int id)
-            : this()
-        {
-            ID = id;
-        }
-    }
-}
diff --git a/AWGL/Utilities/Sprite.cs b/AWGL/Utilities/Sprite.cs
deleted file mode 100644
index 8ce0c32..0000000
--- a/AWGL/Utilities/Sprite.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class Sprite
-    {
-        internal const int VertexAmount = 6;
-        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
-        Color4[] vertexColours = new Color4[VertexAmount];
-        Vector2[] vertexUVs = new Vector2[VertexAmount];
-        Texture texture = new Texture();
-
-        public Texture Texture
-        {
-            get { return texture; }
-            set
-            {
-                texture = value;
-
-                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
-            }
-        }
-        public Vector3d[] VertexPositions { get { return vertexPositions; } }
-
-        public Color4[] VertexColours { get { return vertexColours; } }
-
-        public Vector2[] VertexUVs { get { return vertexUVs; } }
-
-        public Sprite()
-        {
-            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            //SetColour(new Color4(1, 1, 1, 1));
-            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
-        }
-
-        private Vector3d GetCentre()
-        {
-            double halfWidth = GetWidth() / 2;
-            double halfHeight = GetHeight() / 2;
-
-            return new Vector3d(
-                vertexPositions[0].X + halfWidth,
-                vertexPositions[0].Y - halfHeight,
-                vertexPositions[0].Z);
-        }
-
-        private void InitVertexPositions(Vector3d position, double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-
-            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-
-            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-        }
-
-        public double GetWidth()
-        {
-            //top right -> top left
-            return vertexPositions[1].X - vertexPositions[0].X;
-        }
-
-        public double GetHeight()
-        {
-            //top left -> bottom left
-            return vertexPositions[0].Y - vertexPositions[2].Y;
-        }
-
-        public void SetWidth(double width)
-        {
-            InitVertexPositions(GetCentre(), width, GetHeight());
-        }
-
-        public void SetHeight(double height)
-        {
-            InitVertexPositions(GetCentre(), GetWidth(), height);
-        }
-
-        public void SetPosition(double x, double y)
-        {
-            SetPosition(new Vector3d(x, y, 0));
-        }
-
-        public void SetPosition(Vector3d position)
-        {
-            InitVertexPositions(position, GetWidth(), GetHeight());
-        }
-
-        public void SetColour(Color4 color4)
-        {
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                vertexColours[i] = color4;
-            }
-        }
-
-        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
-        {
-            vertexUVs[0] = topLeft;
-            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
-
-            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[4] = bottomRight;
-            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
-        }
-    }
-}
diff --git a/AWGL/Utilities/Texture.cs b/AWGL/Utilities/Texture.cs
deleted file mode 100644
index fffdeb7..0000000
--- a/AWGL/Utilities/Texture.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct Texture
-    {
-        public int ID { get; set; }
-        public int Width { get; set; }
-        public int Height { get; set; }
-
-        public Texture(int id, int width, int height) :this()
-        {
-            ID = id;
-            Width = width;
-            Height = Height;
-        }
-    }
-}
diff --git a/KAOS/Data/Shaders/CH02_FS.glsl b/KAOS/Data/Shaders/CH02_FS.glsl
new file mode 100644
index 0000000..dff573e
--- /dev/null
+++ b/KAOS/Data/Shaders/CH02_FS.glsl
@@ -0,0 +1,8 @@
+#version 140 core
+
+out vec4 color;
+
+void main(void)
+{
+	color = vec4(0.0, 0.8, 0.0, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CH02_VS.glsl b/KAOS/Data/Shaders/CH02_VS.glsl
new file mode 100644
index 0000000..6a17ae4
--- /dev/null
+++ b/KAOS/Data/Shaders/CH02_VS.glsl
@@ -0,0 +1,12 @@
+﻿#version 140 core
+
+void main(void)
+{
+	const vec4 vertices[3] = vec4[3](
+		vec4(0.25, -0.25, 0.5, 1.0),
+		vec4(-0.25, 0.25, 0.5, 1.0),
+		vec4(0.25, 0.25, 0.5, 1.0)
+		);
+	// Index into our array using gl_VertexID
+	gl_Position = vertices[gl_VertexID];
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_FS.glsl b/KAOS/Data/Shaders/CubeMap_FS.glsl
new file mode 100644
index 0000000..2376923
--- /dev/null
+++ b/KAOS/Data/Shaders/CubeMap_FS.glsl
@@ -0,0 +1,9 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+uniform samplerCube Earth;
+varying vec3 Normal;
+
+void main()
+{ 
+  gl_FragColor = textureCube( Earth, Normal.xyz ); 
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_VS.glsl b/KAOS/Data/Shaders/CubeMap_VS.glsl
new file mode 100644
index 0000000..21b3c99
--- /dev/null
+++ b/KAOS/Data/Shaders/CubeMap_VS.glsl
@@ -0,0 +1,10 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// MUST be written to for FS
+varying vec3 Normal;
+
+void main()
+{
+  gl_Position = ftransform();
+  Normal = /*gl_NormalMatrix * */ gl_Normal ;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/FS.glsl b/KAOS/Data/Shaders/FS.glsl
new file mode 100644
index 0000000..5525234
--- /dev/null
+++ b/KAOS/Data/Shaders/FS.glsl
@@ -0,0 +1,9 @@
+﻿#version 330
+ 
+in vec4 color;
+out vec4 outputColor;
+ 
+void main()
+{
+    outputColor = color;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
new file mode 100644
index 0000000..10fe5cd
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
@@ -0,0 +1,66 @@
+#version 110
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+// uniforms from OpenGL
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+// GLSL internal variables. 
+const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
+float XPos;
+float YPos;
+float XQuad;
+float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
+int TableIndex;
+int LoopCount;
+
+// this function reduces duplicate code
+void Iterate(void)
+{
+  YPos = 2.0 * XPos * YPos + CETY;
+  XPos = XQuad - YQuad + CETX;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex++;
+  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
+  LoopCount++;
+}
+
+// Shader entry point, this is executed per Pixel
+void main(void)
+{
+  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  XQuad = pow(XPos, 2.0);
+  YQuad = pow(YPos, 2.0);
+  TableIndex = -1;
+  LoopCount = 0;
+  // the loop is unrolled for SM 2.0 compatibility
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
+  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); 
+  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+ 
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
new file mode 100644
index 0000000..003068b
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
@@ -0,0 +1,41 @@
+#version 120
+// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
+
+uniform sampler1D COLORTABLE;
+uniform float CETX;
+uniform float CETY;
+uniform float SCALINGX;
+uniform float SCALINGY;
+uniform float OFFSETX;
+uniform float OFFSETY;
+
+const int MAXIterations = 32; // *must* be > 0
+
+void main(void)
+{
+  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
+  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
+  float XQuad = pow( XPos, 2.0 );
+  float YQuad = pow( YPos, 2.0 );
+  int TableIndex = -1;
+  int LoopCount = 0;
+  while ( LoopCount <= MAXIterations )
+    {
+      YPos = 2.0 * XPos * YPos + CETY;
+      XPos = XQuad - YQuad + CETX;
+      XQuad = pow( XPos, 2.0 );
+      YQuad = pow( YPos, 2.0 );
+      TableIndex++;
+      if ( (XQuad + YQuad) > 4.0 )
+      { 
+         if (TableIndex == 0)
+           discard;
+         LoopCount = MAXIterations;
+      }
+      LoopCount++;
+    }
+  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
+
+  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
+  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_VS.glsl b/KAOS/Data/Shaders/JuliaSet_VS.glsl
new file mode 100644
index 0000000..cbee942
--- /dev/null
+++ b/KAOS/Data/Shaders/JuliaSet_VS.glsl
@@ -0,0 +1,4 @@
+void main(void)
+{
+  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_FS.glsl b/KAOS/Data/Shaders/Parallax_FS.glsl
new file mode 100644
index 0000000..ea259a4
--- /dev/null
+++ b/KAOS/Data/Shaders/Parallax_FS.glsl
@@ -0,0 +1,57 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// Material uniforms
+uniform sampler2D Material_DiffuseAndHeight;
+uniform sampler2D Material_NormalAndGloss;
+uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
+
+// Light uniforms
+uniform vec3 Light_DiffuseColor;
+uniform vec3 Light_SpecularColor;
+
+// from VS
+varying vec3 VaryingLightVector;
+varying vec3 VaryingEyeVector;
+
+vec3 normal;
+
+void main()
+{ 
+  vec3 lightVector = normalize( VaryingLightVector );
+  vec3 eyeVector = normalize( VaryingEyeVector );
+
+  // first, find the parallax displacement by reading only the height map
+  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
+                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
+  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
+
+  // knowing the displacement, read RGB, Normal and Gloss
+  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
+  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
+  
+  // build a usable normal vector
+  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
+  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
+  
+  // move other properties to be better readable
+  float gloss = temp.r;
+  
+//  float alpha = temp.b;
+//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
+//    discard;
+  
+  // tweaked phong lighting
+  float lambert = max( dot( lightVector, normal ), 0.0 );
+
+  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
+                 lambert;
+
+  if ( lambert > 0.0 )
+  {
+    float specular = pow(
+                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
+                         Material_ScaleBiasShininess.z );
+
+    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
+  }
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_VS.glsl b/KAOS/Data/Shaders/Parallax_VS.glsl
new file mode 100644
index 0000000..49268be
--- /dev/null
+++ b/KAOS/Data/Shaders/Parallax_VS.glsl
@@ -0,0 +1,35 @@
+// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
+
+// custom vertex attribute
+attribute vec3 AttributeTangent; 
+
+// world uniforms
+uniform vec3 Light_Position;
+uniform vec3 Camera_Position;
+
+// MUST be written to for FS
+varying vec3 VaryingLightVector; 
+varying vec3 VaryingEyeVector;
+
+void main()
+{
+  gl_Position = ftransform();
+  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
+
+  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
+  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
+  vec3 bi = cross(nor, tan);
+  
+  // need positions in tangent space
+  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
+
+  vec3 temp = Light_Position - vertex;
+  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
+  VaryingLightVector.y = dot(temp, bi);
+  VaryingLightVector.z = dot(temp, nor);
+
+  temp = Camera_Position - vertex;
+  VaryingEyeVector.x = dot(temp, tan);
+  VaryingEyeVector.y = dot(temp, bi);
+  VaryingEyeVector.z = dot(temp, nor);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_FS.glsl b/KAOS/Data/Shaders/Picking_FS.glsl
new file mode 100644
index 0000000..f4e2af6
--- /dev/null
+++ b/KAOS/Data/Shaders/Picking_FS.glsl
@@ -0,0 +1,8 @@
+﻿#version 120
+
+flat varying vec4 vColor;
+
+void main(void)
+{
+  gl_FragColor = vColor;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_VS.glsl b/KAOS/Data/Shaders/Picking_VS.glsl
new file mode 100644
index 0000000..0deb532
--- /dev/null
+++ b/KAOS/Data/Shaders/Picking_VS.glsl
@@ -0,0 +1,9 @@
+﻿#version 120
+
+flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
+
+void main(void)
+{
+  vColor = gl_Color;
+  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_FS.glsl b/KAOS/Data/Shaders/Simple_FS.glsl
new file mode 100644
index 0000000..85e2a85
--- /dev/null
+++ b/KAOS/Data/Shaders/Simple_FS.glsl
@@ -0,0 +1,5 @@
+/* Copies incoming fragment color without change. */
+void main()
+{
+    gl_FragColor = gl_Color;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_VS.glsl b/KAOS/Data/Shaders/Simple_VS.glsl
new file mode 100644
index 0000000..b0fc2a6
--- /dev/null
+++ b/KAOS/Data/Shaders/Simple_VS.glsl
@@ -0,0 +1,8 @@
+/* Copies incoming vertex color without change.
+ * Applies the transformation matrix to vertex position.
+ */
+void main()
+{
+    gl_FrontColor = gl_Color;
+    gl_Position = ftransform();
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/VS.glsl b/KAOS/Data/Shaders/VS.glsl
new file mode 100644
index 0000000..687408f
--- /dev/null
+++ b/KAOS/Data/Shaders/VS.glsl
@@ -0,0 +1,13 @@
+﻿#version 330
+ 
+in vec3 vPosition;
+in  vec3 vColor;
+out vec4 color;
+uniform mat4 modelview;
+ 
+void main()
+{
+    gl_Position = modelview * vec4(vPosition, 1.0);
+ 
+    color = vec4( vColor, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-fs.glsl b/KAOS/Data/Shaders/opentk-fs.glsl
new file mode 100644
index 0000000..f890462
--- /dev/null
+++ b/KAOS/Data/Shaders/opentk-fs.glsl
@@ -0,0 +1,17 @@
+#version 410 core
+
+precision highp float;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
+in vec3 normal;
+
+out vec4 out_frag_color;
+
+void main(void)
+{
+  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
+  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-vs.glsl b/KAOS/Data/Shaders/opentk-vs.glsl
new file mode 100644
index 0000000..1cd8777
--- /dev/null
+++ b/KAOS/Data/Shaders/opentk-vs.glsl
@@ -0,0 +1,26 @@
+#version 410 core
+
+precision highp float;
+
+// object space to camera space transformation
+uniform mat4 modelview_matrix;
+ 
+// camera space to clip coordinates
+uniform mat4 projection_matrix;
+ 
+// incoming vertex position
+in vec3 in_position;
+ 
+// incoming vertex normal
+in vec3 in_normal;
+ 
+// transformed vertex normal
+out vec3 normal;
+
+void main(void)
+{
+  //works only for orthogonal modelview
+  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
+  
+  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
new file mode 100644
index 0000000..b9c351c
--- /dev/null
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -0,0 +1,29 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+const vec3 ambient = vec3(0.1, 0.1, 0.1);
+const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
+const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+
+in VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} fs_in;
+
+out vec4 color;
+
+void main(void)
+{
+    // Reflect view vector about the plane defined by the normal
+    // at the fragment
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+
+    // Sample from scaled using reflection vector
+     color = texture(tex_cubemap, r);
+
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
+}
diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
new file mode 100644
index 0000000..4f89dba
--- /dev/null
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -0,0 +1,23 @@
+#version 410 core
+
+uniform mat4 mv_matrix;
+uniform mat4 proj_matrix;
+
+layout (location = 0) in vec4 in_position;
+layout (location = 1) in vec3 in_normal;
+
+out VS_OUT
+{
+    vec3 normal;
+    vec3 view;
+} vs_out;
+
+void main(void)
+{
+    vec4 pos_vs = mv_matrix * in_position;
+
+    vs_out.normal = mat3(mv_matrix) * in_normal;
+    vs_out.view = pos_vs.xyz;
+
+    gl_Position = proj_matrix * pos_vs;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/skybox-fs.glsl b/KAOS/Data/Shaders/skybox-fs.glsl
new file mode 100644
index 0000000..f996bf4
--- /dev/null
+++ b/KAOS/Data/Shaders/skybox-fs.glsl
@@ -0,0 +1,15 @@
+﻿#version 410 core
+
+uniform samplerCube tex_cubemap;
+
+in VS_OUT
+{
+	vec3 tc;
+}fs_in;
+
+layout(location = 0) out vec4 color;
+
+void main(void)
+{
+	color = texture(tex_cubemap, fs_in.tc);
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
new file mode 100644
index 0000000..c433716
--- /dev/null
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -0,0 +1,16 @@
+﻿#version 410 core
+ 
+ out VS_OUT
+ {
+	vec3 tc;
+ }vs_out;
+
+uniform mat4 view_matrix;
+
+in lowp vec3 in_position;
+
+ void main(void)
+ {
+	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	gl_Position = vec4(in_position.xyz, 1.0);
+ }
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-fs.glsl b/KAOS/Data/Shaders/spincube-fs.glsl
new file mode 100644
index 0000000..a8d60b9
--- /dev/null
+++ b/KAOS/Data/Shaders/spincube-fs.glsl
@@ -0,0 +1,13 @@
+#version 330 core                                                  
+                                                                               
+out vec4 color;                                                    
+                                                                               
+in VS_OUT                                                          
+{                                                                  
+    vec4 color;                                                    
+} fs_in;                                                           
+                                                                               
+void main(void)                                                    
+{                                                                  
+    color = fs_in.color;                                           
+}    
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-vs.glsl b/KAOS/Data/Shaders/spincube-vs.glsl
new file mode 100644
index 0000000..9de1ae1
--- /dev/null
+++ b/KAOS/Data/Shaders/spincube-vs.glsl
@@ -0,0 +1,17 @@
+#version 330 core                                                   
+                                                                                
+in vec4 position;                                                   
+                                                                                
+out VS_OUT                                                          
+{                                                                   
+    vec4 color;                                                     
+} vs_out;                                                           
+                                                                                
+uniform mat4 mv_matrix;                                             
+uniform mat4 proj_matrix;                                           
+                                                                                
+void main(void)                                                     
+{                                                                   
+    gl_Position = proj_matrix * mv_matrix * position;               
+    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
+}   
\ No newline at end of file
diff --git a/KAOS/Interfaces/IGameObject.cs b/KAOS/Interfaces/IGameObject.cs
new file mode 100644
index 0000000..b2da157
--- /dev/null
+++ b/KAOS/Interfaces/IGameObject.cs
@@ -0,0 +1,9 @@
+﻿
+namespace KAOS.Interfaces
+{
+    public interface IGameObject
+    {
+        void Update(float elapsedTime);
+        void Render();
+    }
+}
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
new file mode 100644
index 0000000..8751f33
--- /dev/null
+++ b/KAOS/KAOSWindow.cs
@@ -0,0 +1,518 @@
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Managers;
+using KAOS.Nodes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using System.Timers;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// Inherit from here to get started.
+    /// This is the main interface to the system.
+    /// </summary>
+    public abstract class KAOSWindow : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "AWEngine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        
+        int modelviewMatrixLocation, projectionMatrixLocation;
+
+        protected Matrix4 projectionMatrix, modelviewMatrix;
+        protected PreciseTimer m_Timer;
+
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private Scene m_model;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+        
+        public KAOSWindow(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new PreciseTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultShaderProgram();
+        }
+
+        public abstract void Initialise();
+
+        //private void CreateShaders()
+        //{
+        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
+
+        //    GL.UseProgram(shaderManager.ProgramHandle);
+        //    QueryMatrixLocations();
+
+        //    float aspect = ScreenWidth / (float)(ScreenHeight);
+        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
+        //}
+
+        //protected void QueryMatrixLocations()
+        //{
+        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
+        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
+        //}
+
+        //protected void SetModelviewMatrix(Matrix4 matrix)
+        //{
+        //    modelviewMatrix = matrix;
+        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
+        //}
+
+        //protected void SetProjectionMatrix(Matrix4 matrix)
+        //{
+        //    projectionMatrix = matrix;
+        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
+        //}
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region input
+            if (Focused)
+            {
+                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
+
+                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSWindow.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+
+            //SetModelviewMatrix(camera.GetViewMatrix());
+
+            // Single call to StateRenderer to take place here.
+
+            #region Assimp Example Code
+            //GL.Enable(EnableCap.Texture2D);
+            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            //GL.Enable(EnableCap.Lighting);
+            //GL.Enable(EnableCap.Light0);
+            //GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.Normalize);
+            //GL.FrontFace(FrontFaceDirection.Ccw);
+
+            //GL.MatrixMode(MatrixMode.Modelview);
+            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            //GL.LoadMatrix(ref lookat);
+
+            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            //float tmp = m_sceneMax.X - m_sceneMin.X;
+            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            //tmp = 1.0f / tmp;
+            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            //GL.Translate(-m_sceneCenter);
+
+            //if (m_displayList == 0)
+            //{
+            //    m_displayList = GL.GenLists(1);
+            //    GL.NewList(m_displayList, ListMode.Compile);
+            //    RecursiveRender(m_model, m_model.RootNode);
+            //    GL.EndList();
+            //}
+
+            //GL.CallList(m_displayList); 
+            #endregion
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region GameWindow.Dispose
+        public override void Dispose()
+        {
+            
+        } 
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        #region Assimp example code
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            GL.DeleteTexture(m_texId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
new file mode 100644
index 0000000..5ad5904
--- /dev/null
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -0,0 +1,90 @@
+﻿using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    public class BufferObjectManager
+    {
+        Dictionary<string, BufferObject> m_bufferStore = new Dictionary<string, BufferObject>();
+
+        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        {
+            int bufferHandle;
+
+            #region Get sizes of buffer stores
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
+            IntPtr bufferSize = new IntPtr (sizeOfPositionData + sizeOfNormalsData);
+            IntPtr noOffset = new IntPtr(0);
+            #endregion
+
+            // Generate Vertex Buffer Object and bind it so it is current.
+            GL.GenBuffers(1, out bufferHandle);         
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferHandle);
+
+            #region Save pointers generated by OpenGL here so i dont forget.
+            bufferObject.VboID = bufferHandle; 
+            #endregion
+            
+            #region Send all data to the Vertex Buffer
+            // Initialise storage space for the Vertex Buffer.
+            GL.BufferData(BufferTarget.ArrayBuffer, bufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
+            // Send Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            // Send Normals data, offset by size of Position data.
+            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            
+            GL.GenBuffers(1, out bufferHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
+            GL.BufferData(BufferTarget.ElementArrayBuffer, 
+                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
+                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+
+            bufferObject.IboID = bufferHandle;
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+            #endregion
+
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+
+            // Generate Vertex Array Object and bind it so it is current.
+            GL.GenVertexArrays(1, out bufferHandle);
+            GL.BindVertexArray(bufferHandle);
+
+            bufferObject.VaoID = bufferHandle;
+
+            bufferHandle = GL.GetAttribLocation(program, "in_position");
+            GL.EnableVertexAttribArray(bufferHandle); 
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(program, bufferHandle, "in_position");
+
+            bufferHandle = GL.GetAttribLocation(program, "in_normal");
+            GL.EnableVertexAttribArray(bufferHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.BindAttribLocation(program, bufferHandle, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferObject.IboID);
+
+            GL.BindVertexArray(bufferObject.VaoID);
+
+            m_bufferStore.Add(name, bufferObject);
+        }
+
+        public BufferObject GetBuffer(string name)
+        {
+            return m_bufferStore[name];
+        }
+    }
+}
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
new file mode 100644
index 0000000..83ddedd
--- /dev/null
+++ b/KAOS/Managers/InputManager.cs
@@ -0,0 +1,12 @@
+﻿using OpenTK.Input;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    public static class InputManager
+    {
+        public static List<Key> keyList = new List<Key>();
+
+
+    }
+}
diff --git a/KAOS/Managers/ModelManager.cs b/KAOS/Managers/ModelManager.cs
new file mode 100644
index 0000000..c118589
--- /dev/null
+++ b/KAOS/Managers/ModelManager.cs
@@ -0,0 +1,7 @@
+﻿
+namespace KAOS.Managers
+{
+    class ModelManager
+    {
+    }
+}
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
new file mode 100644
index 0000000..ab00068
--- /dev/null
+++ b/KAOS/Managers/ShaderManager.cs
@@ -0,0 +1,139 @@
+﻿using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System.Collections.Generic;
+using System.IO;
+
+namespace KAOS.Managers
+{
+    /// <summary>
+    /// Responsible for building individual shaders and linking them to the main program.
+    /// </summary>
+    public static class ShaderManager
+    {
+        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+
+        // Handles
+        private static int m_vertexShaderHandle, m_fragmentShaderHandle, m_programHandle;
+
+        private static string defaultDataPath = "Data/Shaders/";
+        private static string m_vertexShaderFile = "opentk-vs";
+        private static string m_fragmentShaderFile = "opentk-fs";
+
+        internal static void LoadDefaultShaderProgram()
+        {
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("default", new Shader(m_programHandle));
+        }
+
+        public static void LoadCustomProgram(string shaderID, string vertexShaderPath, string fragmentShaderPath)
+        {
+            m_vertexShaderFile = vertexShaderPath;
+            m_fragmentShaderFile = fragmentShaderPath;
+            m_programHandle = BuildProgram();
+
+            m_shaderStorage.Add(shaderID, new Shader(m_programHandle));
+        }
+
+        public static Shader DefaultShader
+        {
+            get
+            {
+                return m_shaderStorage["default"];
+            }
+        }
+
+        public static Shader Get(string shaderID)
+        {
+            return m_shaderStorage[shaderID];
+        }
+
+        #region Shader and Program Contruction Methods
+        internal static string LoadShader(string shaderSourcePath)
+        {
+            using (StreamReader sr = new StreamReader(defaultDataPath + shaderSourcePath + ".glsl"))
+            {
+                return sr.ReadToEnd();
+            }
+        }
+
+        internal static int BuildShader(string shaderSourcePath, ShaderType shaderType)
+        {
+            // Create space in memory for the shader
+            int shaderHandle = GL.CreateShader(shaderType);
+            GL.ShaderSource(shaderHandle, LoadShader(shaderSourcePath));
+
+            // Compile
+            GL.CompileShader(shaderHandle);
+
+            Logger.ShaderInfo(shaderHandle);
+
+            return shaderHandle;
+        }
+
+        internal static int BuildProgram()
+        {
+            m_vertexShaderHandle = BuildShader(m_vertexShaderFile, ShaderType.VertexShader);
+            m_fragmentShaderHandle = BuildShader(m_fragmentShaderFile, ShaderType.FragmentShader);
+
+            int programHandle = GL.CreateProgram();
+
+            GL.AttachShader(programHandle, m_vertexShaderHandle);
+            GL.AttachShader(programHandle, m_fragmentShaderHandle);
+
+            GL.LinkProgram(programHandle);
+
+            #region Check linker success
+            int[] temp = new int[1];
+            GL.GetProgram(programHandle, GetProgramParameterName.LinkStatus, out temp[0]);
+            Logger.WriteLine("Linking Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            #endregion
+
+            #region Validate Program
+            GL.ValidateProgram(programHandle);
+            GL.GetProgram(programHandle, GetProgramParameterName.ValidateStatus, out temp[0]); // update to use OpenGL4
+            Logger.WriteLine("Validating Program (" + programHandle + ") " + ((temp[0] == 1) ? "succeeded." : "FAILED!"));
+            //if (validateSuccess == 0)
+            //{
+            //    String message;
+            //    GL.GetProgramInfoLog(programHandle, out message);
+            //    Logger.WriteLine("Program validation failed" + message);
+            //}
+            #endregion
+
+            #region Registered Attributes
+            GL.GetProgram(programHandle, GetProgramParameterName.ActiveAttributes, out temp[0]);
+            Logger.WriteLine("Program registered " + temp[0] + " Attributes.");
+
+            Logger.WriteLine("End of Shader build. GL Error: " + GL.GetError());
+            #endregion
+
+            // Delete the shaders as the program has them now
+            GL.DeleteShader(m_vertexShaderHandle);
+            GL.DeleteShader(m_fragmentShaderHandle);
+
+            return programHandle;
+        }
+        #endregion
+
+        #region Public Methods
+
+        //public void SetUniforms(
+        //    out int projMatrixHandle, out int mvMatrixHandle,
+        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
+        //    Size dimensions, ref Camera camera)
+        //{
+        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
+        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
+
+        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
+        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
+
+        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
+        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
+        //} 
+        #endregion
+
+    }
+}
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
new file mode 100644
index 0000000..8a00128
--- /dev/null
+++ b/KAOS/Managers/StateManager.cs
@@ -0,0 +1,43 @@
+﻿using KAOS.Interfaces;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace KAOS.Managers
+{
+    public class StateManager
+    {
+        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        IGameObject currentState = null;
+
+        public void Update(float elapsedTime)
+        {
+            if (currentState == null)
+                return;
+            currentState.Update(elapsedTime);
+        }
+
+        public void Render()
+        {
+            if (currentState == null)
+                return;
+            currentState.Render();
+        }
+
+        public void AddState(string stateName, IGameObject state)
+        {
+            Debug.Assert( Exists(stateName) == false );
+            stateStore.Add(stateName, state);
+        }
+
+        public void ChangeState(string stateName)
+        {
+            Debug.Assert( Exists(stateName) );
+            currentState = stateStore[stateName];
+        }
+
+        public bool Exists(string stateName)
+        {
+            return stateStore.ContainsKey(stateName);
+        }
+    }
+}
diff --git a/KAOS/Managers/Tests/StateManagerTest.cs b/KAOS/Managers/Tests/StateManagerTest.cs
new file mode 100644
index 0000000..fc92063
--- /dev/null
+++ b/KAOS/Managers/Tests/StateManagerTest.cs
@@ -0,0 +1,19 @@
+﻿
+using KAOS.States;
+using NUnit.Framework;
+
+namespace KAOS.Managers.Tests
+{
+    [TestFixture]
+    public class StateManagerTest
+    {
+        [Test]
+        public void TestAddStateExists()
+        {
+            StateManager stateManager = new StateManager();
+            stateManager.AddState("test-state", new SplashScreenState(stateManager));
+
+            Assert.IsTrue(stateManager.Exists("test-state"));
+        }
+    }
+}
diff --git a/KAOS/Managers/Tests/TextureManagerTest.cs b/KAOS/Managers/Tests/TextureManagerTest.cs
new file mode 100644
index 0000000..007e120
--- /dev/null
+++ b/KAOS/Managers/Tests/TextureManagerTest.cs
@@ -0,0 +1,20 @@
+﻿
+using NUnit.Framework;
+
+namespace KAOS.Managers.Tests
+{
+    [TestFixture]
+    public class TextureManagerTest
+    {
+        [Test]
+        public void TestLoadTexture()
+        {
+            //string textureid = "test-texture";
+            //Texture t = new Texture();
+            //TextureManager manager = new TextureManager();
+            //manager.LoadTexture(textureid, "Data/Textures/logo.jpg");
+
+            Assert.IsTrue(true);
+        }
+    }
+}
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
new file mode 100644
index 0000000..0970750
--- /dev/null
+++ b/KAOS/Managers/TextureManager.cs
@@ -0,0 +1,102 @@
+﻿using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace KAOS.Managers
+{
+    public class TextureManager : IDisposable
+    {
+        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+
+        public Texture Get(string textureId)
+        {
+            return m_textureDatabase[textureId];
+        }
+
+        private int textureGpuHandle;
+        private Bitmap bitmap;
+        private BitmapData bitmapData;
+
+        public void LoadTexture(string textureId, string path)
+        {
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture2D, textureGpuHandle);
+
+            OpenImageFile(path);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 
+                0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+            CloseImageFile();
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        public void LoadSkyTexture(string textureId, string[] path)
+        {
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureGpuHandle);
+
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+
+            for (int face = 0; face < 6; face++)
+            {
+                OpenImageFile(path[face]);
+                bitmap.Save(face + ".bmp");
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX + face, 
+                    0, PixelInternalFormat.Rgba, bitmapData.Width, bitmapData.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+                GL.Finish();
+                CloseImageFile();
+            }
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
+        private void OpenImageFile(string path)
+        {
+            bitmap = new Bitmap(path);
+
+            bitmapData = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+        }
+
+        private void CloseImageFile()
+        {
+            bitmap.UnlockBits(bitmapData);
+
+            CleanUp();
+        }
+
+        private void CleanUp()
+        {
+            bitmap.Dispose();
+        }
+
+
+        public void Dispose()
+        {
+            foreach (Texture t in m_textureDatabase.Values)
+            {
+                GL.DeleteTextures(1, new int[] { t.ID });
+            }
+            bitmap.Dispose();
+        }
+    }
+}
diff --git a/KAOS/Nodes/AWCube.cs b/KAOS/Nodes/AWCube.cs
new file mode 100644
index 0000000..58875a5
--- /dev/null
+++ b/KAOS/Nodes/AWCube.cs
@@ -0,0 +1,69 @@
+﻿using KAOS.Shapes;
+using KAOS.Tutorial;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    /// <summary>
+    /// Cube Node
+    /// </summary>
+    public class AWCube : AWNode, ISceneNode
+    {
+        #region Private Members
+        
+        private static Vector3[] CubeVertices = new Vector3[]{
+            new Vector3(-1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f, -1.0f,  1.0f),
+            new Vector3( 1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f,  1.0f,  1.0f),
+            new Vector3(-1.0f, -1.0f, -1.0f),
+            new Vector3( 1.0f, -1.0f, -1.0f), 
+            new Vector3( 1.0f,  1.0f, -1.0f),
+            new Vector3(-1.0f,  1.0f, -1.0f) 
+        };
+
+        private static int[] CubeElements = new int[]{
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1, 
+        };
+
+        #endregion
+
+        public Vector3[] Vertices
+        {
+            get { return CubeVertices; }
+        }
+
+        public int[] Indices
+        {
+            get { return CubeElements; }
+        }
+
+        public AWCube()
+        {
+        }
+
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/AWGraphLines.cs b/KAOS/Nodes/AWGraphLines.cs
new file mode 100644
index 0000000..1e65c18
--- /dev/null
+++ b/KAOS/Nodes/AWGraphLines.cs
@@ -0,0 +1,58 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWGraphLines : AWNode, ISceneNode
+    {
+        private int m_gridSize = 20;
+
+        public Vector3[] Vertices
+        {
+            get { return m_vertices; }
+        }
+
+        private static Vector3[] m_vertices;
+
+        public AWGraphLines(int gridSize)
+        {
+            m_gridSize = gridSize;
+            m_vertices = new Vector3[m_gridSize * 2];
+            BuildVertices();
+        }
+
+        private void BuildVertices()
+        {
+            for (int i = 0; i < m_gridSize *2; i += 4)
+            {
+                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
+                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
+                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
+                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
+            }
+        }
+
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Lines);
+            for (int i = -m_gridSize; i <= m_gridSize; i++)
+            {
+                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
+                GL.Vertex3((float)i, .0f, (float)m_gridSize);
+                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
+                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
+                GL.Vertex3((float)m_gridSize, .0f, (float)i);
+            }
+            GL.End();
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/AWGroupNode.cs b/KAOS/Nodes/AWGroupNode.cs
new file mode 100644
index 0000000..0fb12d0
--- /dev/null
+++ b/KAOS/Nodes/AWGroupNode.cs
@@ -0,0 +1,99 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public class AWGroupNode : AWNode, ISceneNode, IGroupNode, IEnumerable<ISceneNode>
+    {
+        double m_angle, m_rx, m_ry, m_rz;
+        double m_tx, m_ty, m_tz;
+
+        private IList<ISceneNode> m_children = new List<ISceneNode>();
+        
+        public AWGroupNode()
+        {
+            this.m_angle = 0;
+            this.m_rx = 1;   //!!
+            this.m_ry = 0;
+            this.m_rz = 0;
+
+            this.m_tx = 0;
+            this.m_ty = 0;
+            this.m_tz = 0;
+        }
+
+        public void SetRotation(double angle, double rx, double ry, double rz)
+        {
+            this.m_angle = angle;
+            this.m_rx = rx;
+            this.m_ry = ry;
+            this.m_rz = rz;
+        }
+
+        public void SetTranslation(double tx, double ty, double tz)
+        {
+            this.m_tx = tx;
+            this.m_ty = ty;
+            this.m_tz = tz;
+        }
+
+        public override void Render()
+        {
+            GL.PushMatrix();
+            GL.Translate(m_tx, m_ty, m_tz);
+            if (m_angle != 0)
+            {
+                //GL.Rotate(m_angle, m_rx, m_ry, m_rz);
+            }
+
+            foreach (ISceneNode child in m_children)
+            {
+                child.Render();
+            }
+            GL.PopMatrix();
+        }
+
+        #region IEnumerator Implementation
+        public IEnumerator<ISceneNode> GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return m_children.GetEnumerator();
+        }
+        #endregion ISceneNode Implementation
+
+        #region IGroupNode Implementation
+
+        public void AddChild(ISceneNode child)
+        {
+            m_children.Add(child);
+        }
+
+        public void RemoveChild(ISceneNode child)
+        {
+            m_children.Remove(child);
+        }
+
+        #endregion IGroupNode Implementation
+
+
+
+        public OpenTK.Vector3[] Vertices
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        public int[] Indices
+        {
+            get { throw new NotImplementedException(); }
+        }
+    } 
+}
diff --git a/KAOS/Nodes/AWMesh.cs b/KAOS/Nodes/AWMesh.cs
new file mode 100644
index 0000000..d5f77a0
--- /dev/null
+++ b/KAOS/Nodes/AWMesh.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWMesh : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Nodes/AWNode.cs b/KAOS/Nodes/AWNode.cs
new file mode 100644
index 0000000..d0dddca
--- /dev/null
+++ b/KAOS/Nodes/AWNode.cs
@@ -0,0 +1,22 @@
+﻿using KAOS.Managers;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public abstract class AWNode
+    {
+        protected BufferObjectManager m_BufferManager;
+
+        protected AWNode()
+        {
+            //m_BufferManager = new AWBufferManager();
+        }
+
+        public abstract void Render();
+    }
+
+}
diff --git a/KAOS/Nodes/AWParticles.cs b/KAOS/Nodes/AWParticles.cs
new file mode 100644
index 0000000..44911f9
--- /dev/null
+++ b/KAOS/Nodes/AWParticles.cs
@@ -0,0 +1,121 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    class AWParticles : AWNode
+    {
+        public override void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+}
+/*
+        #region Private Members
+        protected static int m_MaxParticleCount = 2000;
+        public int m_VisibleParticleCount;
+        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
+        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
+
+        private uint VBOHandle;
+
+        private float xPos = 0.1f;
+        private float yPos = 0.1f;
+        #endregion Private Members
+
+        public AWParticles()
+        {
+            // Setup parameters for Points
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.PointSmooth);
+            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
+
+            // set up vbo state - depreceted as of 3.0>> (?)
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.VertexArray);
+
+            // Generate the buffers
+            GL.GenBuffers(1, out VBOHandle);
+
+            // Set it up
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
+            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
+
+            Random rndNum = new Random();
+            Vector3 tmp = Vector3.Zero;
+
+            // generate some random stuff for the particle system
+            for (uint i = 0; i < m_MaxParticleCount; i++)
+            {
+                m_VBO[i].R = (byte)rndNum.Next(0, 256);
+                m_VBO[i].G = (byte)rndNum.Next(0, 256);
+                m_VBO[i].B = (byte)rndNum.Next(0, 256);
+                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
+                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
+
+                // generate direction vector in the range [-0.25f...+0.25f] 
+                // that's slow enough so you can see particles 'disappear' when they are respawned
+                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
+                m_ParticleAttributes[i].Direction = tmp; // copy 
+                m_ParticleAttributes[i].Age = 0;
+            }
+
+            m_VisibleParticleCount = 0;
+        }
+
+        public void Update()
+        {
+            // will update particles here. When using a Physics SDK, it's update rate is much higher than
+            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
+            if (m_VisibleParticleCount < m_MaxParticleCount)
+            {
+                m_VisibleParticleCount++;
+            }
+
+            Vector3 temp;
+
+            Random rand = new Random();
+
+            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
+            {
+                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
+                {
+                    // reset particle
+                    m_ParticleAttributes[i].Age = 0;
+                    m_VBO[i].Position = Vector3.Zero;
+                }
+                else
+                {
+                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
+                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
+                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
+                }
+            }
+        }
+
+        public override void Render()
+        {
+            Update();
+
+            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
+            // without this, GL would wait until draw operations on old VBO are complete before writing to it
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
+            // Fill newly allocated buffer
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
+            // Only draw particles that are alive
+            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
+
+        }
+    }
+}
+        */
\ No newline at end of file
diff --git a/KAOS/Nodes/AWPolygon.cs b/KAOS/Nodes/AWPolygon.cs
new file mode 100644
index 0000000..85afb1d
--- /dev/null
+++ b/KAOS/Nodes/AWPolygon.cs
@@ -0,0 +1,54 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Nodes
+{
+    public class AWPolygon : AWNode
+    {
+        Vector3[] m_Verticies;
+        Vector3 m_Normals, m_TexCoords;
+
+        public AWPolygon()
+        {
+            m_Verticies = new Vector3[3];
+            m_Normals = new Vector3();
+        }
+        public override void Render()
+        {
+            GL.Begin(PrimitiveType.Polygon);
+            GL.Color3(Color.NavajoWhite);
+            for (int i = 0; i < m_Verticies.Length; i++)
+            {
+                if (i < 1)
+                {
+                    GL.Normal3(m_Normals);
+                }
+
+                GL.Vertex3(m_Verticies[i]);
+            }
+            GL.End();
+        }
+
+        public void AddVertex(int index, Vector3 v) 
+        {
+            m_Verticies[index] = v;
+        }
+
+        public void AddNormal(Vector3 n)
+        {
+            m_Normals = n;
+        }
+
+        public void AddTexCoord(Vector3 t)
+        {
+
+        }
+
+    }
+}
diff --git a/KAOS/Nodes/IGroupNode.cs b/KAOS/Nodes/IGroupNode.cs
new file mode 100644
index 0000000..888793f
--- /dev/null
+++ b/KAOS/Nodes/IGroupNode.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Nodes
+{
+    public interface IGroupNode : IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Nodes/ISceneNode.cs b/KAOS/Nodes/ISceneNode.cs
new file mode 100644
index 0000000..0924346
--- /dev/null
+++ b/KAOS/Nodes/ISceneNode.cs
@@ -0,0 +1,13 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Nodes
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
new file mode 100644
index 0000000..9623e06
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("AWGL")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Hewlett-Packard")]
+[assembly: AssemblyProduct("AWGL")]
+[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("9ba7d755-a9b8-44fe-bf48-32c674da1c75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/KAOS/Scene/FBOScene.cs b/KAOS/Scene/FBOScene.cs
new file mode 100644
index 0000000..ee33056
--- /dev/null
+++ b/KAOS/Scene/FBOScene.cs
@@ -0,0 +1,246 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    public class FBOScene : DefaultScene
+    {
+        #region Private Member Variables
+        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
+
+        private uint ColorTexture;
+        private uint DepthTexture;
+        private uint FBOHandle;
+
+        private const int TextureSize = 512;
+
+        private DrawableShape Object;
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            Object.Dispose();
+
+            // Clean up what we allocated before exiting
+            if (ColorTexture != 0)
+                GL.DeleteTextures(1, ref ColorTexture);
+
+            if (DepthTexture != 0)
+                GL.DeleteTextures(1, ref DepthTexture);
+
+            if (FBOHandle != 0)
+                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.PushMatrix();
+            {
+                // Draw the Color Texture
+                GL.Translate(-1.1f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+
+                // Draw the Depth Texture
+                GL.Translate(+2.2f, 0f, 0f);
+                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+                GL.Begin(BeginMode.Quads);
+                {
+                    GL.TexCoord2(0f, 1f);
+                    GL.Vertex2(-1.0f, 1.0f);
+                    GL.TexCoord2(0.0f, 0.0f);
+                    GL.Vertex2(-1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 0.0f);
+                    GL.Vertex2(1.0f, -1.0f);
+                    GL.TexCoord2(1.0f, 1.0f);
+                    GL.Vertex2(1.0f, 1.0f);
+                }
+                GL.End();
+            }
+            GL.PopMatrix();
+
+            SwapBuffers();
+        }
+
+        public override void Setup(EventArgs e)
+        {
+            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
+            {
+                throw new NotSupportedException(
+                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
+                Exit();
+            }
+
+            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.ClearDepth(1.0);
+            GL.DepthFunc(DepthFunction.Lequal);
+
+            GL.Enable(EnableCap.CullFace);
+
+            // Create Color Tex
+            GL.GenTextures(1, out ColorTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create Depth Tex
+            GL.GenTextures(1, out DepthTexture);
+            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
+            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
+            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
+
+            // Create a FBO and attach the textures
+            GL.Ext.GenFramebuffers(1, out FBOHandle);
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
+            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
+
+            #region Test for Error
+
+            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
+            {
+                case FramebufferErrorCode.FramebufferCompleteExt:
+                    {
+                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
+                    {
+                        Console.WriteLine("FBO: There are no attachments.");
+                        break;
+                    }
+                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
+                     {
+                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
+                         break;
+                     }*/
+                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
+                    {
+                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
+                    {
+                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
+                    {
+                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
+                    {
+                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
+                        break;
+                    }
+                case FramebufferErrorCode.FramebufferUnsupportedExt:
+                    {
+                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
+                        break;
+                    }
+                default:
+                    {
+                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
+                        break;
+                    }
+            }
+
+            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
+            int[] queryinfo = new int[6];
+            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
+            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
+            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
+            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
+            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
+            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
+            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
+                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
+
+            Console.WriteLine("Last GL Error: " + GL.GetError());
+
+            #endregion Test for Error
+
+            GL.PushAttrib(AttribMask.ViewportBit);
+            {
+                GL.Viewport(0, 0, TextureSize, TextureSize);
+
+                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
+                GL.ClearColor(1f, 0f, 0f, 0f);
+                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
+                GL.MatrixMode(MatrixMode.Projection);
+                GL.LoadMatrix(ref perspective);
+
+                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
+                GL.MatrixMode(MatrixMode.Modelview);
+                GL.LoadMatrix(ref lookat);
+
+                // draw some complex object into the FBO's textures
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.Light0);
+                GL.Enable(EnableCap.ColorMaterial);
+                GL.Color3(0f, 1f, 0f);
+                Object.Draw();
+                GL.Disable(EnableCap.ColorMaterial);
+                GL.Disable(EnableCap.Light0);
+                GL.Disable(EnableCap.Lighting);
+
+            }
+            GL.PopAttrib();
+            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
+
+            GL.ClearColor(.1f, .2f, .3f, 0f);
+            GL.Color3(1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
+            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            double aspect_ratio = Width / (double)Height;
+
+            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+        }
+    }
+}
diff --git a/KAOS/Scene/PickerScene.cs b/KAOS/Scene/PickerScene.cs
new file mode 100644
index 0000000..3aca921
--- /dev/null
+++ b/KAOS/Scene/PickerScene.cs
@@ -0,0 +1,204 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Diagnostics;
+using System.Drawing;
+
+namespace AWGL.Scene
+{
+    /// <summary>
+    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
+    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
+    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
+    /// </summary>
+    public class PickerScene : DefaultScene
+    {
+        public PickerScene()
+        {
+            this.VSync = VSyncMode.Off;
+        }
+
+        #region Private Member variable
+        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
+        private float angle;
+        private BeginMode VBO_PrimMode;
+        private Vertex[] VBO_Array;
+        uint VBO_Handle;
+
+        private uint SelectedTriangle;
+
+        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
+        #endregion
+
+        #region OnLoad
+        /// <summary>Load resources here.</summary>
+        /// <param name="e">Not used.</param>
+        protected override void OnLoad(EventArgs e)
+        {
+            base.OnLoad(e);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.CullFace);
+
+            #region prepare data for VBO from procedural object
+            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
+            VertexT2fN3fV3f[] temp_VBO;
+            uint[] temp_IBO;
+            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
+            temp_obj.Dispose();
+            if (temp_IBO != null)
+                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
+
+            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
+            VBO_Array = new Vertex[temp_VBO.Length];
+            int TriangleCounter = -1;
+            for (int i = 0; i < temp_VBO.Length; i++)
+            {
+                // Position
+                VBO_Array[i].Position = temp_VBO[i].Position;
+
+                // Index
+                if (i % 3 == 0)
+                    TriangleCounter++;
+                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
+            }
+            #endregion prepare data for VBO from procedural object
+
+            #region Setup VBO for drawing
+            GL.GenBuffers(1, out VBO_Handle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
+            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
+            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
+            #endregion Setup VBO for drawing
+
+            #region Shader
+
+            //create and compile shaders
+            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
+            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
+
+            //create program object, attach shaders and link
+            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
+
+            // flag ShaderObjects for delete when not used anymore
+            GL.DeleteShader(VertexShaderObject);
+            GL.DeleteShader(FragmentShaderObject);
+
+            GL.UseProgram(0);
+
+            #endregion Shader
+
+        }
+        #endregion
+
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DeleteBuffers(1, ref VBO_Handle);
+
+            base.OnUnload(e);
+        }
+        #endregion
+
+        #region OnResize
+        /// <summary>
+        /// Called when your window is resized. Set your viewport here. It is also
+        /// a good place to set up your projection matrix (which probably changes
+        /// along when the aspect ratio of your window).
+        /// </summary>
+        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+
+            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref projection);
+        }
+        #endregion
+
+        #region OnRenderFrame
+        /// <summary>
+        /// Called when it is time to render the next frame. Add your rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            GL.Color3(Color.White);
+            GL.EnableClientState(EnableCap.ColorArray);
+
+            #region Pass 1: Draw Object and pick Triangle
+            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref modelview);
+            GL.Translate(0f, 0f, -3f);
+            GL.Rotate(angle, Vector3.UnitX);
+            GL.Rotate(angle, Vector3.UnitY);
+            angle += (float)e.Time * 3.0f;
+
+            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
+             GL.UseProgram(ProgramObject);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            // GL.UseProgram(0);
+
+            // Read Pixel under mouse cursor
+            Byte4 Pixel = new Byte4();
+            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
+            SelectedTriangle = Pixel.ToUInt32();
+            #endregion Pass 1: Draw Object and pick Triangle
+
+            GL.Color3(Color.White);
+            GL.DisableClientState(EnableCap.ColorArray);
+
+            #region Pass 2: Draw Shape
+            if (SelectedTriangle == uint.MaxValue)
+                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
+            else
+                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.Color3(1f, 1f, 1f);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+            GL.Color3(Color.Red);
+            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
+            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+
+            if (SelectedTriangle != uint.MaxValue)
+            {
+                GL.Disable(EnableCap.DepthTest);
+                GL.Color3(Color.Green);
+                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
+                GL.Enable(EnableCap.DepthTest);
+            }
+            #endregion Pass 2: Draw Shape
+
+            this.SwapBuffers();
+
+            ErrorCode err = GL.GetError();
+            if (err != ErrorCode.NoError)
+                Trace.WriteLine("Error at Swapbuffers: " + err);
+        }
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Scene/StencilCSGScene.cs b/KAOS/Scene/StencilCSGScene.cs
new file mode 100644
index 0000000..8acb843
--- /dev/null
+++ b/KAOS/Scene/StencilCSGScene.cs
@@ -0,0 +1,293 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class StencilCSGScene : DefaultScene
+    {
+        #region Model Related
+        private DrawableShape OperandB;
+        private DrawableShape OperandA;
+        private float MySphereZOffset = 0f;
+        private float MySphereXOffset = 0f;
+
+        private int Texture;
+        #endregion Model Related
+
+        private bool ShowDebugWireFrame = true;
+
+        private float CameraZoom;
+        private float CameraRotX;
+        private float CameraRotY;
+        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
+
+        #region Window
+        public StencilCSGScene()
+        {
+            base.VSync = VSyncMode.Off;
+            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
+            {
+                switch (e.Key)
+                {
+                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
+                }
+            };
+        }
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.MatrixMode(MatrixMode.Projection);
+            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
+            GL.LoadMatrix(ref p);
+        }
+        #endregion Window
+
+        public override void Setup(EventArgs e)
+        {
+            #region Abort on platforms which will not be able to execute the ops properly
+            /*
+            if (!GL.SupportsExtension("VERSION_1_2"))
+            {
+                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
+                this.Exit();
+            }
+
+            int[] t = new int[2];
+            GL.GetInteger(GetPName.MajorVersion, out t[0]);
+            GL.GetInteger(GetPName.MinorVersion, out t[1]);
+            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
+
+            GL.GetInteger(GetPName.DepthBits, out t[0]);
+            Trace.WriteLine("Depth Bits: " + t[0]);
+            GL.GetInteger(GetPName.StencilBits, out t[1]);
+            Trace.WriteLine("Stencil Bits: " + t[1]);
+
+            if (t[0] < 16)
+            {
+                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
+                this.Exit();
+            }
+
+            if (t[1] < 1)
+            {
+                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
+                this.Exit();
+            }
+            */
+            #endregion Abort on platforms which will not be able to execute the ops properly
+
+            #region GL States
+            GL.ClearColor(.08f, .12f, .16f, 1f);
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthFunc(DepthFunction.Less);
+            GL.ClearDepth(1.0);
+
+            GL.Enable(EnableCap.StencilTest);
+            GL.ClearStencil(0);
+            GL.StencilMask(0xFFFFFFFF); // read&write
+
+            GL.Enable(EnableCap.CullFace);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+            GL.CullFace(CullFaceMode.Back);
+
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+
+            GL.Color4(1f, 1f, 1f, 1f);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.ShadeModel(ShadingModel.Smooth);
+
+            #endregion GL States
+
+            #region Load Texture
+            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
+            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
+
+            GL.GenTextures(1, out Texture);
+            GL.BindTexture(TextureTarget.Texture2D, Texture);
+
+            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.Finish();
+            bitmap.UnlockBits(data);
+            #endregion Load Texture
+
+            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
+            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
+                                           SlicedSphere.eSubdivisions.Three,
+                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
+                                           true);
+
+            #region Invert Operand B's Normals
+            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
+            BeginMode tempPrimMode;
+            VertexT2dN3dV3d[] tempVertices;
+            uint[] tempIndices;
+
+            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
+            OperandB.Dispose();
+
+            for (int i = 0; i < tempVertices.Length; i++)
+            {
+                tempVertices[i].Normal *= -1.0;
+                tempVertices[i].Normal.Normalize();
+            }
+
+            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
+            #endregion Invert Operand B's Normals
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref Texture);
+
+            OperandA.Dispose();
+            OperandB.Dispose();
+
+            base.OnUnload(e);
+        }
+
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Magic numbers for camera
+            CameraRotX = -Mouse.X * .5f;
+            CameraRotY = Mouse.Y * .5f;
+            CameraZoom = Mouse.Wheel * .2f;
+            #endregion Magic numbers for camera
+        }
+
+        public void DrawOperandB()
+        {
+            GL.PushMatrix();
+            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
+            OperandB.Draw();
+            GL.PopMatrix();
+        }
+
+        public void DrawOperandA()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            OperandA.Draw();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        public void RenderCsg()
+        {
+            // first pass
+            GL.Disable(EnableCap.StencilTest);
+
+            GL.ColorMask(false, false, false, false);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB();// draw front-faces into depth buffer
+
+            // use stencil plane to find parts of b in a 
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // increment the stencil where the front face of a is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
+            DrawOperandB(); // draw the part of b that's in a
+
+            // fix depth
+            GL.ColorMask(false, false, false, false);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Disable(EnableCap.StencilTest);
+            GL.DepthFunc(DepthFunction.Always);
+            DrawOperandA();
+            GL.DepthFunc(DepthFunction.Less);
+
+            // second pass
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA();
+
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.StencilTest);
+
+            GL.StencilFunc(StencilFunction.Always, 0, 0);
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
+            DrawOperandB(); // increment the stencil where the front face of b is drawn
+
+            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
+            GL.CullFace(CullFaceMode.Front);
+            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
+
+            GL.DepthMask(true);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.ColorMask(true, true, true, true);
+            GL.StencilFunc(StencilFunction.Equal, 0, 1);
+            GL.CullFace(CullFaceMode.Back);
+            DrawOperandA(); // draw the part of a that's in b
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
+
+            MySphereZOffset += (float)(e.Time * 3.1);
+            MySphereXOffset += (float)(e.Time * 4.2);
+
+            #region Transform setup
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
+
+            // Camera
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
+            GL.LoadMatrix(ref mv);
+
+            GL.Translate(0f, 0f, CameraZoom);
+            GL.Rotate(CameraRotX, Vector3.UnitY);
+            GL.Rotate(CameraRotY, Vector3.UnitX);
+            #endregion Transform setup
+
+            RenderCsg();
+
+            // ---------------------------------
+
+            if (ShowDebugWireFrame)
+            {
+                GL.Color3(System.Drawing.Color.LightGray);
+                GL.Disable(EnableCap.StencilTest);
+                GL.Disable(EnableCap.Lighting);
+                //GL.Disable( EnableCap.DepthTest );
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
+                DrawOperandB();
+                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
+                GL.Enable(EnableCap.DepthTest);
+                GL.Enable(EnableCap.Lighting);
+                GL.Enable(EnableCap.StencilTest);
+            }
+            SwapBuffers();
+        }
+
+    }
+}
diff --git a/KAOS/Scene/StereoVisionScene.cs b/KAOS/Scene/StereoVisionScene.cs
new file mode 100644
index 0000000..2b84210
--- /dev/null
+++ b/KAOS/Scene/StereoVisionScene.cs
@@ -0,0 +1,164 @@
+﻿using AWGL.Shapes;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace AWGL.Scene
+{
+    public class StereoVisionScene : DefaultScene
+    {
+        public StereoVisionScene()
+        {
+            this.VSync = VSyncMode.On;
+        }
+
+        #region Private Fields
+        private TorusKnot obj;
+        private float Angle;
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            GL.Enable(EnableCap.DepthTest);
+
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+
+            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            //throw new NotImplementedException();
+        }
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            Angle += (float)(e.Time * 20.0);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
+
+            SetupCamera(Eye.right);
+            GL.ColorMask(true, false, false, true);
+            Draw();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit); // 
+            SetupCamera(Eye.left);
+            GL.ColorMask(false, true, true, true);
+            Draw();
+
+            GL.ColorMask(true, true, true, true);
+
+            SwapBuffers();
+        }
+        #endregion
+    
+        #region OnUnload
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+            obj.Dispose();
+        }
+        #endregion
+
+        #region Setup Camera(Eye eye)
+        private void SetupCamera(Eye eye)
+        {
+            Camera camera;
+
+            camera.Position = Vector3.UnitZ;
+            camera.Up = Vector3.UnitY;
+            camera.Direction = -Vector3.UnitZ;
+            camera.NearPlane = 1.0;
+            camera.FarPlane = 5.0;
+            camera.FocalLength = 2.0;
+            camera.EyeSeparation = camera.FocalLength / 30.0;
+            camera.Aperture = 75.0;
+
+            double left, right,
+                   bottom, top;
+
+            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
+            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
+            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
+
+            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
+            Right.Normalize();
+
+            Right.X *= (float)(camera.EyeSeparation / 2.0);
+            Right.Y *= (float)(camera.EyeSeparation / 2.0);
+            Right.Z *= (float)(camera.EyeSeparation / 2.0);
+
+            // Projection Matrix
+            top = widthdiv2;
+            bottom = -widthdiv2;
+            if (eye == Eye.right)
+            {
+                left = -precalc1 - precalc2;
+                right = precalc1 - precalc2;
+            }
+            else
+            {
+                left = -precalc1 + precalc2;
+                right = precalc1 + precalc2;
+            }
+
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
+
+            // Modelview Matrix
+            Matrix4 modelview;
+            if (eye == Eye.right)
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
+                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            else
+            {
+                modelview = Matrix4.LookAt(
+                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
+                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
+                    camera.Up);
+            }
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.MultMatrix(ref modelview);
+        }
+        #endregion
+
+        #region Draw
+        private void Draw()
+        {
+            GL.Translate(0f, 0f, -2f);
+            GL.Rotate(Angle, Vector3.UnitY);
+            obj.Draw();
+        }
+        #endregion
+    
+    }
+    #region StereoVison Structs
+    public struct Camera
+    {
+        public Vector3 Position, Direction, Up;
+        public double NearPlane, FarPlane;
+        public double EyeSeparation;
+        public double Aperture; // FOV in degrees
+        public double FocalLength;
+    }
+
+    public enum Eye
+    {
+        left,
+        right,
+    }
+    #endregion
+}
diff --git a/KAOS/Scene/Texture2DScene.cs b/KAOS/Scene/Texture2DScene.cs
new file mode 100644
index 0000000..ec53ee7
--- /dev/null
+++ b/KAOS/Scene/Texture2DScene.cs
@@ -0,0 +1,86 @@
+﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+
+namespace AWGL.Scene
+{
+    public class Texture2DScene : DefaultScene
+    {
+        #region Private Members
+
+        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
+        private int texture;
+
+        #endregion
+
+        public override void Setup(EventArgs e)
+        {
+            GL.PointSize(5f);
+            GL.Enable(EnableCap.Texture2D);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out texture);
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
+
+            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
+                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+            bitmap.UnlockBits(data);
+        }
+
+        public override void Resize(EventArgs e)
+        {
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
+        }
+
+        #region OnUnload
+
+        protected override void OnUnload(EventArgs e)
+        {
+            GL.DeleteTextures(1, ref texture);
+        }
+
+        #endregion
+
+        #region OnRenderFrame
+
+        /// <summary>
+        /// Add your game rendering code here.
+        /// </summary>
+        /// <param name="e">Contains timing information.</param>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+
+            GL.Begin(BeginMode.Quads);
+
+            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
+            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
+            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
+
+            GL.End();
+
+            SwapBuffers();
+        }
+        #endregion
+
+    }
+}
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
new file mode 100644
index 0000000..0f9cd8a
--- /dev/null
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -0,0 +1,182 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.Shapes
+{
+    // Abstract base class for procedurally generated geometry
+    // 
+    // All classes derived from it must produce Counter-Clockwise (CCW) primitives.
+    // Derived classes must create a single VBO and IBO, without primitive restarts for strips. 
+    // Uses an double-precision all-possible-attributes VertexT2dN3dV3d Array internally.
+    // Cannot directly use VBO, but has Get-methods to retrieve VBO-friendly data.
+    // Can use a Display List to prevent repeated immediate mode draws.
+    //
+
+    public abstract class DrawableShape: IDisposable
+    {
+        protected BeginMode PrimitiveMode;
+        protected VertexT2dN3dV3d[] VertexArray;
+        protected uint[] IndexArray;
+
+        public int GetTriangleCount
+        {
+            get
+            {
+                switch ( PrimitiveMode )
+                { 
+                case BeginMode.Triangles:
+                    if ( IndexArray != null )
+                    {
+                        return IndexArray.Length / 3;
+                    } else
+                    {
+                        return VertexArray.Length / 3;
+                    }
+                  //  break;
+                default: throw new NotImplementedException("Unknown primitive type.");
+                }
+            }
+        }
+
+        #region Display List
+
+        private bool UseDisplayList;
+        private int DisplayListHandle = 0;
+
+        #endregion Display List
+
+        public DrawableShape( bool useDisplayList )
+        {
+            UseDisplayList = useDisplayList;
+            PrimitiveMode = BeginMode.Triangles;
+            VertexArray = null;
+            IndexArray = null;
+        }
+
+        #region Convert to VBO
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2dN3dV3d[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = VertexArray[i].TexCoord;
+                vertices[i].Normal = VertexArray[i].Normal;
+                vertices[i].Position = VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2fN3fV3f[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = PrimitiveMode;
+
+            vertices = new VertexT2hN3hV3h[VertexArray.Length];
+            for (uint i = 0; i < VertexArray.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)VertexArray[i].TexCoord;
+                vertices[i].Normal = (Vector3h)VertexArray[i].Normal;
+                vertices[i].Position = (Vector3h)VertexArray[i].Position;
+            }
+
+            indices = IndexArray;
+        }
+
+        #endregion Convert to VBO
+
+        private void DrawImmediateMode()
+        {
+            GL.Begin( PrimitiveMode );
+            {
+                if ( IndexArray == null )
+                    foreach ( VertexT2dN3dV3d v in VertexArray )
+                    {
+                        GL.TexCoord2( v.TexCoord.X, v.TexCoord.Y );
+                        GL.Normal3( v.Normal.X, v.Normal.Y, v.Normal.Z );
+                        GL.Vertex3( v.Position.X, v.Position.Y, v.Position.Z );
+                    } else
+                {
+                    for ( uint i = 0; i < IndexArray.Length; i++ )
+                    {
+                        uint index = IndexArray[i];
+                        GL.TexCoord2( VertexArray[index].TexCoord.X, VertexArray[index].TexCoord.Y );
+                        GL.Normal3( VertexArray[index].Normal.X, VertexArray[index].Normal.Y, VertexArray[index].Normal.Z );
+                        GL.Vertex3( VertexArray[index].Position.X, VertexArray[index].Position.Y, VertexArray[index].Position.Z );
+                    }
+                }
+            }
+            GL.End();
+        }
+
+        /// <summary>
+        /// Does not touch any state/matrices. Does call Begin/End and Vertex&Co.
+        /// Creates and compiles a display list if not present yet. Requires an OpenGL context.
+        /// </summary>
+        public void Draw()
+        {
+            if ( !UseDisplayList )
+                DrawImmediateMode();
+            else
+                if ( DisplayListHandle == 0 )
+                {
+                    if ( VertexArray == null )
+                        throw new Exception("Cannot draw null Vertex Array.");
+                    DisplayListHandle = GL.GenLists( 1 );
+                    GL.NewList( DisplayListHandle, ListMode.CompileAndExecute );
+                    DrawImmediateMode();
+                    GL.EndList();
+                } else
+                    GL.CallList( DisplayListHandle );
+        }
+
+        
+
+        #region IDisposable Members
+
+        /// <summary>
+        /// Removes reference to VertexArray and IndexArray.
+        /// Deletes the Display List, so it requires an OpenGL context.
+        /// The instance is effectively destroyed.
+        /// </summary>
+        public void Dispose()
+        {
+            if ( VertexArray != null )
+                VertexArray = null;
+            if ( IndexArray != null )
+                IndexArray = null;
+            if ( DisplayListHandle != 0 )
+            {
+                GL.DeleteLists( DisplayListHandle, 1 );
+                DisplayListHandle = 0;
+            }
+        }
+
+        #endregion
+    }
+
+}
diff --git a/KAOS/Shapes/Base/VertexStructs.cs b/KAOS/Shapes/Base/VertexStructs.cs
new file mode 100644
index 0000000..0f64155
--- /dev/null
+++ b/KAOS/Shapes/Base/VertexStructs.cs
@@ -0,0 +1,35 @@
+using OpenTK;
+using System.Runtime.InteropServices;
+
+namespace KAOS.Shapes
+{
+    public struct VertexT2dN3dV3d
+    {
+        public Vector2d TexCoord;
+        public Vector3d Normal;
+        public Vector3d Position;
+
+        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        {
+            TexCoord = texcoord;
+            Normal = normal;
+            Position = position;
+        }
+    }
+
+    public struct VertexT2fN3fV3f
+    {
+        public Vector2 TexCoord;
+        public Vector3 Normal;
+        public Vector3 Position;
+    }
+
+    public struct VertexT2hN3hV3h
+    {
+        public Vector2h TexCoord;
+        public Vector3h Normal;
+        public Vector3h Position;
+    }
+
+   
+}
diff --git a/KAOS/Shapes/Capsule.cs b/KAOS/Shapes/Capsule.cs
new file mode 100644
index 0000000..cd6f7e6
--- /dev/null
+++ b/KAOS/Shapes/Capsule.cs
@@ -0,0 +1,108 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class Capsule: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+        }
+
+
+        public Capsule( double radius, double height, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            uint HoseSubDivs = 0;
+            SlicedSphere.eSubdivisions spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                spheresubdivs = SlicedSphere.eSubdivisions.Zero;
+                HoseSubDivs = 0;
+                break;
+            case eSubdivisions.One:
+                spheresubdivs = SlicedSphere.eSubdivisions.One;
+                HoseSubDivs = 1;
+                break;
+            case eSubdivisions.Two:
+                spheresubdivs = SlicedSphere.eSubdivisions.Two;
+                HoseSubDivs = 3;
+                break;
+            case eSubdivisions.Three:
+                spheresubdivs = SlicedSphere.eSubdivisions.Three;
+                HoseSubDivs = 7;
+                break;
+            case eSubdivisions.Four:
+                spheresubdivs = SlicedSphere.eSubdivisions.Four;
+                HoseSubDivs = 15;
+                break;
+            }
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            Vector3d offset1 = new Vector3d( 0.0, 0.0, height ),
+                     offset2 = new Vector3d( 0.0, 0.0, -height );
+            for ( int i = 0; i < 4; i++ )
+            {
+                SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;
+                switch ( i )
+                {
+                case 0:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    break;
+                }
+                SlicedHose tempHose = new SlicedHose( tempSide, HoseSubDivs, radius, offset1, offset2, false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+
+            SlicedSphere front = new SlicedSphere( radius, offset1, spheresubdivs,
+                                                       new SlicedSphere.eDir[] {
+                                                           SlicedSphere.eDir.BackBottomRight,
+                                                           SlicedSphere.eDir.FrontTopRight,
+                                                           SlicedSphere.eDir.BackTopRight,
+                                                           SlicedSphere.eDir.FrontBottomRight, 
+                                                          },
+                                                       false );
+
+            front.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            front.Dispose();
+
+            SlicedSphere back = new SlicedSphere( radius, offset2, spheresubdivs,
+                                                      new SlicedSphere.eDir[] { 
+                                                          SlicedSphere.eDir.FrontBottomLeft,
+                                                          SlicedSphere.eDir.FrontTopLeft, 
+                                                          SlicedSphere.eDir.BackTopLeft,
+                                                          SlicedSphere.eDir.BackBottomLeft },
+                                                      false );
+            back.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+            AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            back.Dispose();
+
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+        }
+    }
+}
diff --git a/KAOS/Shapes/ChamferCube.cs b/KAOS/Shapes/ChamferCube.cs
new file mode 100644
index 0000000..1c340a1
--- /dev/null
+++ b/KAOS/Shapes/ChamferCube.cs
@@ -0,0 +1,278 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class ChamferCube: DrawableShape
+    {
+
+        public enum SubDivs: byte
+        {
+            Zero,
+            One,
+            Two,
+            Three,
+            Four,
+        }
+
+        public ChamferCube( double Width, double Height, double Length, SubDivs subdivs, double radius, bool useDL )
+            : base( useDL )
+        {   
+            SlicedSphere.eSubdivisions sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+            uint hoseSubDivs = 0;
+
+            switch ( subdivs )
+            {
+            case SubDivs.Zero:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Zero;
+                hoseSubDivs = 0;
+                break;
+            case SubDivs.One:
+                sphereSubDivs = SlicedSphere.eSubdivisions.One;
+                hoseSubDivs = 1;
+                break;
+            case SubDivs.Two:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Two;
+                hoseSubDivs = 3;
+                break;
+            case SubDivs.Three:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Three;
+                hoseSubDivs = 7;
+                break;
+            case SubDivs.Four:
+                sphereSubDivs = SlicedSphere.eSubdivisions.Four;
+                hoseSubDivs = 15;
+                break;
+            }
+
+            #region Temporary Storage
+
+            List<Chunk> AllChunks = new List<Chunk>();
+            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            VertexT2dN3dV3d[] TemporaryVBO;
+            uint[] TemporaryIBO;
+
+            #endregion Temporary Storage
+
+            Vector3d FrontTopRightEdge = new Vector3d( +Width - radius, +Height - radius, +Length - radius );
+            Vector3d FrontTopLeftEdge = new Vector3d( +Width - radius, +Height - radius, -Length + radius );
+            Vector3d FrontBottomRightEdge = new Vector3d( +Width - radius, -Height + radius, +Length - radius );
+            Vector3d FrontBottomLeftEdge = new Vector3d( +Width - radius, -Height + radius, -Length + radius );
+            Vector3d BackTopRightEdge = new Vector3d( -Width + radius, +Height - radius, +Length - radius );
+            Vector3d BackTopLeftEdge = new Vector3d( -Width + radius, +Height - radius, -Length + radius );
+            Vector3d BackBottomRightEdge = new Vector3d( -Width + radius, -Height + radius, +Length - radius );
+            Vector3d BackBottomLeftEdge = new Vector3d( -Width + radius, -Height + radius, -Length + radius );
+
+            #region 8 sliced Spheres
+            SlicedSphere tempSphere;
+            Vector3d tempVector = Vector3d.Zero;
+            SlicedSphere.eDir[] tempEdge = new SlicedSphere.eDir[1];
+
+            for ( int i = 0; i < 8; i++ )
+            {
+                switch ( i )
+                {
+                case 0:
+                    tempVector = FrontTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };
+                    break;
+                case 1:
+                    tempVector = FrontTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };
+                    break;
+                case 2:
+                    tempVector = FrontBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };
+                    break;
+                case 3:
+                    tempVector = FrontBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };
+                    break;
+                case 4:
+                    tempVector = BackBottomRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };
+                    break;
+                case 5:
+                    tempVector = BackBottomLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };
+                    break;
+                case 6:
+                    tempVector = BackTopRightEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };
+                    break;
+                case 7:
+                    tempVector = BackTopLeftEdge;
+                    tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };
+                    break;
+                }
+                tempSphere = new SlicedSphere( radius,
+                                                 tempVector,
+                                                 sphereSubDivs,
+                                                 tempEdge,
+                                                 false );
+                tempSphere.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempSphere.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 8 sliced Spheres
+
+            #region 12 sliced Hoses
+
+            SlicedHose tempHose;
+            SlicedHose.eSide tempSide = SlicedHose.eSide.BackBottom;
+            Vector3d tempHoseStart = Vector3d.Zero;
+            Vector3d tempHoseEnd = Vector3d.Zero;
+
+            for ( int i = 0; i < 12; i++ )
+            {
+                switch ( i )
+                {
+                #region Around X Axis
+                case 0:
+                    tempSide = SlicedHose.eSide.BottomRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = FrontBottomRightEdge;
+                    break;
+                case 1:
+                    tempSide = SlicedHose.eSide.TopRight;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 2:
+                    tempSide = SlicedHose.eSide.TopLeft;
+                    tempHoseStart = BackTopLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 3:
+                    tempSide = SlicedHose.eSide.BottomLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around X Axis
+                #region Around Y Axis
+                case 4:
+                    tempSide = SlicedHose.eSide.FrontRight;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontTopRightEdge;
+                    break;
+                case 5:
+                    tempSide = SlicedHose.eSide.BackRight;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackTopRightEdge;
+                    break;
+                case 6:
+                    tempSide = SlicedHose.eSide.BackLeft;
+                    tempHoseStart = BackBottomLeftEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 7:
+                    tempSide = SlicedHose.eSide.FrontLeft;
+                    tempHoseStart = FrontBottomLeftEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                #endregion Around Y Axis
+                #region Around Z Axis
+                case 8:
+                    tempSide = SlicedHose.eSide.FrontTop;
+                    tempHoseStart = FrontTopRightEdge;
+                    tempHoseEnd = FrontTopLeftEdge;
+                    break;
+                case 9:
+                    tempSide = SlicedHose.eSide.BackTop;
+                    tempHoseStart = BackTopRightEdge;
+                    tempHoseEnd = BackTopLeftEdge;
+                    break;
+                case 10:
+                    tempSide = SlicedHose.eSide.BackBottom;
+                    tempHoseStart = BackBottomRightEdge;
+                    tempHoseEnd = BackBottomLeftEdge;
+                    break;
+                case 11:
+                    tempSide = SlicedHose.eSide.FrontBottom;
+                    tempHoseStart = FrontBottomRightEdge;
+                    tempHoseEnd = FrontBottomLeftEdge;
+                    break;
+                #endregion Around Z Axis
+                }
+                tempHose = new SlicedHose( tempSide,
+                                             hoseSubDivs,
+                                             radius,
+                                             tempHoseStart,
+                                             tempHoseEnd,
+                                             false );
+                tempHose.GetArraysforVBO( out TemporaryMode, out TemporaryVBO, out TemporaryIBO );
+                tempHose.Dispose();
+                AllChunks.Add( new Chunk( ref TemporaryVBO, ref TemporaryIBO ) );
+            }
+            #endregion 12 sliced Hoses
+
+            #region 6 quads for the sides
+
+            VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
+            uint[] tempIBO = new uint[6] { 0, 1, 2, 0, 2, 3 }; // all quads share this IBO
+
+            // all quads use the same texcoords
+            tempVBO[0].TexCoord = new Vector2d( 0.0, 1.0 );
+            tempVBO[1].TexCoord = new Vector2d( 0.0, 0.0 );
+            tempVBO[2].TexCoord = new Vector2d( 1.0, 0.0 );
+            tempVBO[3].TexCoord = new Vector2d( 1.0, 1.0 );
+
+            // front face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
+            tempVBO[0].Position = FrontTopRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = FrontBottomRightEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // back face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
+            tempVBO[0].Position = BackTopLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[1].Position = BackBottomLeftEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius, 0.0, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // top face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontTopRightEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // bottom face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
+            tempVBO[0].Position = BackBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0, radius, 0.0 );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // right face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
+            tempVBO[0].Position = BackTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = BackBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+            // left face
+            tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
+            tempVBO[0].Position = FrontTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[1].Position = FrontBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0, 0.0, radius );
+            AllChunks.Add( new Chunk( ref tempVBO, ref tempIBO ) );
+
+
+            #endregion 6 quads for the sides
+
+            #region Final Assembly of Chunks
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+            AllChunks.Clear();
+            #endregion Final Assembly of Chunks
+        }
+    }
+}
diff --git a/KAOS/Shapes/Helpers/Chunk.cs b/KAOS/Shapes/Helpers/Chunk.cs
new file mode 100644
index 0000000..ebac329
--- /dev/null
+++ b/KAOS/Shapes/Helpers/Chunk.cs
@@ -0,0 +1,80 @@
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public class Chunk
+    {
+        public VertexT2dN3dV3d[] Vertices;
+        public uint[] Indices;
+
+        public uint VertexCount
+        {
+            get
+            {
+                return (uint)Vertices.Length;
+            }
+        }
+        public uint IndexCount
+        {
+            get
+            {
+                return (uint)Indices.Length;
+            }
+        }
+
+        public Chunk( uint vertexcount, uint indexcount )
+        {
+            Vertices = new VertexT2dN3dV3d[vertexcount];
+            Indices = new uint[indexcount];
+        }
+
+        public Chunk( ref VertexT2dN3dV3d[] vbo, ref uint[] ibo )
+        {
+            Vertices = new VertexT2dN3dV3d[vbo.Length];
+            for ( int i = 0; i < Vertices.Length; i++ )
+            {
+                Vertices[i] = vbo[i];
+            } 
+            Indices = new uint[ibo.Length];
+            for ( int i = 0; i < Indices.Length; i++ )
+            {
+                Indices[i] = ibo[i];
+            }
+        }
+
+        public static void GetArray( ref List<Chunk> c, out VertexT2dN3dV3d[] vbo, out uint[] ibo )
+        {
+
+            uint VertexCounter = 0;
+            uint IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                VertexCounter += ch.VertexCount;
+                IndexCounter += ch.IndexCount;
+            }
+
+            vbo = new VertexT2dN3dV3d[VertexCounter];
+            ibo = new uint[IndexCounter];
+
+            VertexCounter = 0;
+            IndexCounter = 0;
+
+            foreach ( Chunk ch in c )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    vbo[VertexCounter + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    ibo[IndexCounter + i] = ch.Indices[i] + VertexCounter;
+                }
+
+                VertexCounter += (uint)ch.VertexCount;
+                IndexCounter += (uint)ch.IndexCount;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Helpers/MengerCube.cs b/KAOS/Shapes/Helpers/MengerCube.cs
new file mode 100644
index 0000000..2dc56fc
--- /dev/null
+++ b/KAOS/Shapes/Helpers/MengerCube.cs
@@ -0,0 +1,421 @@
+using OpenTK;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class MengerSponge
+    {
+        private struct MengerCube
+        {
+            private Vector3d Center;
+            private double SideLength;
+            private eSides[] VisibleSides;
+            private eSides[] VisibilityToInherit;
+
+            public void GetArraySizes( out uint vertexcount, out uint indexcount )
+            {
+                vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
+                indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
+            }
+
+            public MengerCube( Vector3d center, double sidelength, eSides[] visibleSides, eSides[] parentsVisibility )
+            {
+                Center = center;
+                SideLength = sidelength;
+
+                /*  List<eSides> Sides = new List<eSides>();
+                  foreach ( eSides s in visibleSides )
+                  {
+                      bool isVisible = false;
+                      foreach ( eSides p in parentsVisibility )
+                      {
+                          if ( (int)p == (int)s )
+                          {
+                              isVisible = true;
+                              break;
+                          }
+                      }
+                      if ( isVisible )
+                      {
+                          Sides.Add( s );
+                      }
+                  }
+                  VisibleSides = Sides.ToArray();*/
+                VisibleSides = visibleSides;
+                VisibilityToInherit = visibleSides;
+            }
+
+            public void Subdivide( out MengerCube[] cubes )
+            {
+                cubes = new MengerCube[20]; // 8 + 4 + 8
+
+                double NewLength = this.SideLength / 3.0;
+                double six = this.SideLength * 2.0 / 3.0;
+                // we got 3x3x3 cubes. All center cubes who touch the XYZ-Axis are removed.
+
+                // front
+                cubes[0] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Top }, this.VisibilityToInherit );
+                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Bottom, eSides.Back, eSides.Top }, this.VisibilityToInherit );
+                cubes[2] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Top }, this.VisibilityToInherit );
+
+                cubes[3] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[4] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[5] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Left, eSides.Bottom } , this.VisibilityToInherit );
+                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Top, eSides.Back, eSides.Bottom }, this.VisibilityToInherit );
+                cubes[7] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Bottom }, this.VisibilityToInherit );
+
+                // center
+                cubes[8] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[9] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[10] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                cubes[11] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z + 0.0 ), NewLength, new eSides[] { eSides.Top, eSides.Right, eSides.Bottom, eSides.Left }, this.VisibilityToInherit );
+
+                // back
+                cubes[12] = new MengerCube( new Vector3d( Center.X - six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Left }, this.VisibilityToInherit );
+                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[14] = new MengerCube( new Vector3d( Center.X + six, Center.Y + six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Right }, this.VisibilityToInherit );
+
+                cubes[15] = new MengerCube( new Vector3d( Center.X - six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+                cubes[16] = new MengerCube( new Vector3d( Center.X + six, Center.Y + 0.0, Center.Z - six ), NewLength, new eSides[] { eSides.Front, eSides.Right, eSides.Back, eSides.Left } , this.VisibilityToInherit );
+
+                cubes[17] = new MengerCube( new Vector3d( Center.X - six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Left } , this.VisibilityToInherit );
+                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Top, eSides.Back, eSides.Bottom, eSides.Front }, this.VisibilityToInherit );
+                cubes[19] = new MengerCube( new Vector3d( Center.X + six, Center.Y - six, Center.Z - six ), NewLength, new eSides[] { eSides.Back, eSides.Bottom, eSides.Right }, this.VisibilityToInherit );
+
+            }
+
+            public enum eSides: byte
+            {
+                Front,
+                Back,
+                Right,
+                Left,
+                Top,
+                Bottom
+            }
+
+            internal static readonly eSides[] AllSides = new eSides[] { eSides.Front, eSides.Back, eSides.Right, eSides.Left, eSides.Top, eSides.Bottom };
+
+            public void GetVboAndIbo( ref List<Chunk> chunks )
+            {
+                foreach ( eSides s in AllSides )
+                {
+                    DrawSide( s, ref chunks );
+                }
+            }
+
+            private void DrawSide( eSides side, ref List<Chunk> chunks )
+            {
+                #region Setup constants for current direction
+
+                double _Zero = 0.0; // 0/3
+                double _Three = 0.3333333333333; // 1/3
+                double _Six = 0.66666666666666; // 2/3
+                double _One = 1.0; // 3/3 
+
+                double ThirdLength = SideLength / 3f;
+
+                Vector3d C0 = Center + new Vector3d( -SideLength, -SideLength, +SideLength );
+                Vector3d C1 = Center + new Vector3d( +SideLength, -SideLength, +SideLength );
+                Vector3d C2 = Center + new Vector3d( +SideLength, +SideLength, +SideLength );
+                Vector3d C3 = Center + new Vector3d( -SideLength, +SideLength, +SideLength );
+
+                Vector3d C4 = Center + new Vector3d( -SideLength, -SideLength, -SideLength );
+                Vector3d C5 = Center + new Vector3d( +SideLength, -SideLength, -SideLength );
+                Vector3d C6 = Center + new Vector3d( +SideLength, +SideLength, -SideLength );
+                Vector3d C7 = Center + new Vector3d( -SideLength, +SideLength, -SideLength );
+
+                Vector3d P0, P1, P2, P3, P4, P5, P6, P7;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    P0 = C0;
+                    P1 = C1;
+                    P2 = C2;
+                    P3 = C3;
+
+                    P4 = C4;
+                    P5 = C5;
+                    P6 = C6;
+                    P7 = C7;
+                    break;
+                case eSides.Back:
+                    P0 = C5;
+                    P1 = C4;
+                    P2 = C7;
+                    P3 = C6;
+
+                    P4 = C1;
+                    P5 = C0;
+                    P6 = C3;
+                    P7 = C2;
+                    break;
+                case eSides.Right:
+                    P0 = C1;
+                    P1 = C5;
+                    P2 = C6;
+                    P3 = C2;
+
+                    P4 = C0;
+                    P5 = C4;
+                    P6 = C7;
+                    P7 = C3;
+                    break;
+                case eSides.Left:
+                    P0 = C4;
+                    P1 = C0;
+                    P2 = C3;
+                    P3 = C7;
+
+                    P4 = C5;
+                    P5 = C1;
+                    P6 = C2;
+                    P7 = C6;
+                    break;
+                case eSides.Top:
+                    P0 = C3;
+                    P1 = C2;
+                    P2 = C6;
+                    P3 = C7;
+
+                    P4 = C0;
+                    P5 = C1;
+                    P6 = C5;
+                    P7 = C4;
+                    break;
+                case eSides.Bottom:
+                    P0 = C1;
+                    P1 = C0;
+                    P2 = C4;
+                    P3 = C5;
+
+                    P4 = C2;
+                    P5 = C3;
+                    P6 = C7;
+                    P7 = C6;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+
+                #endregion Setup constants for current direction
+
+                #region Set Normal
+
+                Vector3d FaceNormal;
+
+                switch ( side )
+                {
+                case eSides.Front:
+                    FaceNormal = Vector3d.UnitZ;
+                    break;
+                case eSides.Back:
+                    FaceNormal = -Vector3d.UnitZ;
+                    break;
+                case eSides.Right:
+                    FaceNormal = Vector3d.UnitX;
+                    break;
+                case eSides.Left:
+                    FaceNormal = -Vector3d.UnitX;
+                    break;
+                case eSides.Top:
+                    FaceNormal = Vector3d.UnitY;
+                    break;
+                case eSides.Bottom:
+                    FaceNormal = -Vector3d.UnitY;
+                    break;
+                default:
+                    throw new NotImplementedException( "Unknown enum value: " + side );
+                }
+                #endregion Set Normal
+
+                bool FaceIsVisible = false;
+                foreach ( eSides s in VisibleSides )
+                {
+                    if ( s == side )
+                    {
+                        FaceIsVisible = true;
+                        break;
+                    }
+                }
+
+                if ( FaceIsVisible )
+                {
+                    #region Define Layer1 Vertices
+                    Chunk Layer1 = new Chunk( 8, 8 * 3 );
+
+                    Layer1.Vertices[0].TexCoord = new Vector2d( _Zero, _Zero );
+                    Layer1.Vertices[0].Normal = FaceNormal;
+                    Layer1.Vertices[0].Position = P0;
+
+                    Layer1.Vertices[1].TexCoord = new Vector2d( _One, _Zero );
+                    Layer1.Vertices[1].Normal = FaceNormal;
+                    Layer1.Vertices[1].Position = P1;
+
+                    Layer1.Vertices[2].TexCoord = new Vector2d( _One, _One );
+                    Layer1.Vertices[2].Normal = FaceNormal;
+                    Layer1.Vertices[2].Position = P2;
+
+                    Layer1.Vertices[3].TexCoord = new Vector2d( _Zero, _One );
+                    Layer1.Vertices[3].Normal = FaceNormal;
+                    Layer1.Vertices[3].Position = P3;
+
+                    Layer1.Vertices[4].TexCoord = new Vector2d( _Three, _Three );
+                    Layer1.Vertices[4].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Three, out Layer1.Vertices[4].Position );
+
+                    Layer1.Vertices[5].TexCoord = new Vector2d( _Six, _Three );
+                    Layer1.Vertices[5].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Three, out Layer1.Vertices[5].Position );
+
+                    Layer1.Vertices[6].TexCoord = new Vector2d( _Six, _Six );
+                    Layer1.Vertices[6].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P0, ref P2, _Six, out Layer1.Vertices[6].Position );
+
+                    Layer1.Vertices[7].TexCoord = new Vector2d( _Three, _Six );
+                    Layer1.Vertices[7].Normal = FaceNormal;
+                    Vector3d.Lerp( ref P1, ref P3, _Six, out Layer1.Vertices[7].Position );
+                    #endregion Define Layer1 Vertices
+
+                    #region Define Layer1 Indices
+                    Layer1.Indices[0] = 0;
+                    Layer1.Indices[1] = 5;
+                    Layer1.Indices[2] = 4;
+
+                    Layer1.Indices[3] = 0;
+                    Layer1.Indices[4] = 1;
+                    Layer1.Indices[5] = 5;
+
+                    Layer1.Indices[6] = 5;
+                    Layer1.Indices[7] = 1;
+                    Layer1.Indices[8] = 2;
+
+                    Layer1.Indices[9] = 6;
+                    Layer1.Indices[10] = 5;
+                    Layer1.Indices[11] = 2;
+
+                    Layer1.Indices[12] = 7;
+                    Layer1.Indices[13] = 6;
+                    Layer1.Indices[14] = 2;
+
+                    Layer1.Indices[15] = 3;
+                    Layer1.Indices[16] = 7;
+                    Layer1.Indices[17] = 2;
+
+                    Layer1.Indices[18] = 0;
+                    Layer1.Indices[19] = 7;
+                    Layer1.Indices[20] = 3;
+
+                    Layer1.Indices[21] = 0;
+                    Layer1.Indices[22] = 4;
+                    Layer1.Indices[23] = 7;
+
+                    chunks.Add( Layer1 );
+                    #endregion Define Layer1 Indices
+                }
+
+                #region Define Layer2 Vertices
+                Chunk Layer2 = new Chunk( 12, 8 * 3 );
+
+                Vector3d T0, T1, T2, T3;
+                Vector3d.Lerp( ref P0, ref P4, _Six, out T0 );
+                Vector3d.Lerp( ref P1, ref P5, _Six, out T1 );
+                Vector3d.Lerp( ref P2, ref P6, _Six, out T2 );
+                Vector3d.Lerp( ref P3, ref P7, _Six, out T3 );
+
+                Layer2.Vertices[0].TexCoord = new Vector2d( _Three, _Zero );
+                Layer2.Vertices[0].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Three, out Layer2.Vertices[0].Position );
+
+                Layer2.Vertices[1].TexCoord = new Vector2d( _Six, _Zero );
+                Layer2.Vertices[1].Normal = FaceNormal;
+                Vector3d.Lerp( ref T0, ref T1, _Six, out Layer2.Vertices[1].Position );
+
+                Layer2.Vertices[3].TexCoord = new Vector2d( _One, _Three );
+                Layer2.Vertices[3].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Three, out Layer2.Vertices[3].Position );
+
+                Layer2.Vertices[4].TexCoord = new Vector2d( _One, _Six );
+                Layer2.Vertices[4].Normal = FaceNormal;
+                Vector3d.Lerp( ref T1, ref  T2, _Six, out Layer2.Vertices[4].Position );
+
+                Layer2.Vertices[6].TexCoord = new Vector2d( _Six, _One );
+                Layer2.Vertices[6].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref T3, _Three, out Layer2.Vertices[6].Position );
+
+                Layer2.Vertices[7].TexCoord = new Vector2d( _Three, _One );
+                Layer2.Vertices[7].Normal = FaceNormal;
+                Vector3d.Lerp( ref T2, ref  T3, _Six, out Layer2.Vertices[7].Position );
+
+                Layer2.Vertices[9].TexCoord = new Vector2d( _Zero, _Six );
+                Layer2.Vertices[9].Normal = FaceNormal;
+                Vector3d.Lerp( ref T3, ref  T0, _Three, out Layer2.Vertices[9].Position );
+
+                Layer2.Vertices[10].TexCoord = new Vector2d( _Zero, _Three );
+                Layer2.Vertices[10].Normal = FaceNormal;
+                Vector3d.Lerp( ref  T3, ref  T0, _Six, out Layer2.Vertices[10].Position );
+
+                Layer2.Vertices[2].TexCoord = new Vector2d( _Six, _Three );
+                Layer2.Vertices[2].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Three, out Layer2.Vertices[2].Position );
+
+                Layer2.Vertices[5].TexCoord = new Vector2d( _Six, _Six );
+                Layer2.Vertices[5].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[1].Position, ref Layer2.Vertices[6].Position, _Six, out Layer2.Vertices[5].Position );
+
+                Layer2.Vertices[8].TexCoord = new Vector2d( _Three, _Six );
+                Layer2.Vertices[8].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Three, out Layer2.Vertices[8].Position );
+
+                Layer2.Vertices[11].TexCoord = new Vector2d( _Three, _Three );
+                Layer2.Vertices[11].Normal = FaceNormal;
+                Vector3d.Lerp( ref Layer2.Vertices[7].Position, ref Layer2.Vertices[0].Position, _Six, out Layer2.Vertices[11].Position );
+                #endregion Define Layer2 Vertices
+
+                #region Define Layer2 Indices
+                Layer2.Indices[0] = 0;
+                Layer2.Indices[1] = 2;
+                Layer2.Indices[2] = 11;
+
+                Layer2.Indices[3] = 0;
+                Layer2.Indices[4] = 1;
+                Layer2.Indices[5] = 2;
+
+                Layer2.Indices[6] = 2;
+                Layer2.Indices[7] = 3;
+                Layer2.Indices[8] = 4;
+
+                Layer2.Indices[9] = 2;
+                Layer2.Indices[10] = 4;
+                Layer2.Indices[11] = 5;
+
+                Layer2.Indices[12] = 5;
+                Layer2.Indices[13] = 6;
+                Layer2.Indices[14] = 8;
+
+                Layer2.Indices[15] = 8;
+                Layer2.Indices[16] = 6;
+                Layer2.Indices[17] = 7;
+
+                Layer2.Indices[18] = 11;
+                Layer2.Indices[19] = 8;
+                Layer2.Indices[20] = 10;
+
+                Layer2.Indices[21] = 10;
+                Layer2.Indices[22] = 8;
+                Layer2.Indices[23] = 9;
+
+                chunks.Add( Layer2 );
+                #endregion Define Layer2 Indices
+            }
+        }
+    }
+
+   
+}
diff --git a/KAOS/Shapes/Helpers/TetrahedronFace.cs b/KAOS/Shapes/Helpers/TetrahedronFace.cs
new file mode 100644
index 0000000..5b4e4cc
--- /dev/null
+++ b/KAOS/Shapes/Helpers/TetrahedronFace.cs
@@ -0,0 +1,228 @@
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+
+    /// <summary>winding always assumed CCW (Counter-ClockWise)</summary>
+    internal struct TetrahedronFace
+    {
+        private Vector3d APosition, BPosition, CPosition;
+        private Vector3d DPosition, Normal;
+        private Vector2d ATexCoord, BTexCoord, CTexCoord;
+
+        public TetrahedronFace( ref Vector3d apos, ref Vector2d atc,
+                                   ref Vector3d bpos, ref Vector2d btc,
+                                   ref Vector3d cpos, ref Vector2d ctc,
+                                   ref Vector3d dpos,
+                                   ref Vector3d normal )
+        {
+            APosition = apos; ATexCoord = atc;
+            BPosition = bpos; BTexCoord = btc;
+            CPosition = cpos; CTexCoord = ctc;
+            DPosition = dpos;
+            Normal = normal;
+        }
+
+        /// <summary>Expects CCW triangle order as input, emits 4 new CCW triangles.</summary>
+        /// <param name="first">1st output Triangle</param>
+        /// <param name="second">2nd output Triangle</param>
+        /// <param name="third">3rd output Triangle</param>
+        /// <param name="fourth">4th output Triangle</param>
+        public void SubdivideSierpinski( out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth )
+        {
+            Vector3d temp;
+
+            // find the 3 points AB, BC, CA 
+            Vector3d CenterAB;
+            Vector3d.Add( ref this.APosition, ref this.BPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterAB );
+
+            Vector3d CenterBC;
+            Vector3d.Add( ref this.BPosition, ref this.CPosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterBC );
+
+            Vector3d CenterCA;
+            Vector3d.Add( ref this.CPosition, ref this.APosition, out temp );
+            Vector3d.Multiply( ref temp, 0.5f, out CenterCA );
+
+            // find the 3 points AD, BD, CD 
+            Vector3d CenterAD;
+            Vector3d.Lerp( ref this.APosition, ref this.DPosition, 0.5, out CenterAD );
+
+            Vector3d CenterBD;
+            Vector3d.Lerp( ref this.BPosition, ref this.DPosition, 0.5, out CenterBD );
+
+            Vector3d CenterCD;
+            Vector3d.Lerp( ref this.CPosition, ref this.DPosition, 0.5, out CenterCD );
+
+            // emit 4 new CCW triangles
+            first = new TetrahedronFace( ref this.APosition, ref this.ATexCoord,
+                              ref CenterAB, ref this.BTexCoord,
+                              ref CenterCA, ref this.CTexCoord,
+                              ref CenterAD,
+                              ref this.Normal );
+
+            second = new TetrahedronFace( ref CenterAB, ref this.ATexCoord,
+                               ref this.BPosition, ref this.BTexCoord,
+                               ref CenterBC, ref this.CTexCoord,
+                               ref CenterBD,
+                               ref this.Normal );
+
+            third = new TetrahedronFace( ref CenterCA, ref this.ATexCoord,
+                              ref CenterBC, ref this.BTexCoord,
+                              ref this.CPosition, ref this.CTexCoord,
+                              ref CenterCD,
+                              ref this.Normal );
+
+            fourth = new TetrahedronFace( ref CenterAD, ref this.ATexCoord,
+                               ref CenterBD, ref this.BTexCoord,
+                               ref CenterCD, ref this.CTexCoord,
+                               ref this.DPosition,
+                               ref this.Normal );
+        }
+
+
+        internal void SubdivideKoch( double height, out TetrahedronFace first, out TetrahedronFace second, out TetrahedronFace third, out TetrahedronFace fourth, out TetrahedronFace fifth, out TetrahedronFace sixth )
+        {
+            Vector3d CenterAB, CenterBC, CenterCA, CenterD;
+            Vector2d TexCoordAB, TexCoordBC, TexCoordCA, TexCoordD;
+
+            Vector3d.Lerp( ref this.APosition, ref this.BPosition, 0.5, out CenterAB );
+            Vector3d.Lerp( ref this.BPosition, ref this.CPosition, 0.5, out CenterBC );
+            Vector3d.Lerp( ref this.CPosition, ref this.APosition, 0.5, out CenterCA );
+            CenterD = CenterAB;
+            Vector3d.Add(ref CenterD, ref CenterBC, out CenterD);
+            Vector3d.Add(ref CenterD, ref CenterCA, out CenterD);
+            CenterD /= 3.0;
+            Vector3d E = CenterD + ( this.Normal * 0.5 );
+            Vector3d temp = this.Normal;
+            temp *= height;
+            Vector3d.Add(ref CenterD, ref temp, out CenterD);
+
+            Vector2d.Lerp( ref this.ATexCoord, ref this.BTexCoord, 0.5, out TexCoordAB );
+            Vector2d.Lerp( ref this.BTexCoord, ref this.CTexCoord, 0.5, out TexCoordBC );
+            Vector2d.Lerp( ref this.CTexCoord, ref this.ATexCoord, 0.5, out TexCoordCA );
+            TexCoordD = TexCoordAB;
+            Vector2d.Add(ref TexCoordD, ref TexCoordBC, out TexCoordD);
+            Vector2d.Add(ref TexCoordD, ref TexCoordCA, out TexCoordD);
+            TexCoordD /= 3.0;
+            #region 1
+            first.APosition = this.APosition;
+            first.ATexCoord = this.ATexCoord;
+
+            first.BPosition = CenterAB;
+            first.BTexCoord = TexCoordAB;
+
+            first.CPosition = CenterCA;
+            first.CTexCoord = TexCoordCA;
+
+            first.Normal = this.Normal;
+            temp = ( this.APosition + CenterAB + CenterCA );
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            first.DPosition = temp;
+            #endregion 1
+            #region 2
+            second.APosition = CenterAB;
+            second.ATexCoord = TexCoordAB;
+
+            second.BPosition = this.BPosition;
+            second.BTexCoord = this.BTexCoord;
+
+            second.CPosition = CenterBC;
+            second.CTexCoord = TexCoordBC;
+
+            second.Normal = this.Normal;
+
+            temp = CenterAB + this.BPosition + CenterBC;
+            temp /=  3.0;
+            temp += this.Normal * -1.0;
+            second.DPosition = temp;
+
+            #endregion 2
+            #region 3
+            third.APosition = CenterBC;
+            third.ATexCoord = TexCoordBC;
+
+            third.BPosition = this.CPosition;
+            third.BTexCoord = this.CTexCoord;
+
+            third.CPosition = CenterCA;
+            third.CTexCoord = TexCoordCA;
+
+            third.Normal = this.Normal;
+            temp = CenterBC + this.CPosition + CenterCA;
+            temp /= 3.0;
+            temp += this.Normal * -1.0;
+            third.DPosition = temp;
+            #endregion 3
+            #region 4
+            fourth.APosition = CenterAB;
+            fourth.ATexCoord = TexCoordAB;
+
+            fourth.BPosition = CenterD;
+            fourth.BTexCoord = TexCoordD;
+
+            fourth.CPosition = CenterCA;
+            fourth.CTexCoord = TexCoordCA;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterD, ref CenterCA, out fourth.Normal );
+            fourth.DPosition = E;
+            #endregion 4
+            #region 5
+            fifth.APosition = CenterAB;
+            fifth.ATexCoord = TexCoordAB;
+
+            fifth.BPosition = CenterBC;
+            fifth.BTexCoord = TexCoordBC;
+
+            fifth.CPosition = CenterD;
+            fifth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterAB, ref CenterBC, ref CenterD, out fifth.Normal );
+            fifth.DPosition = E;
+
+            #endregion 5
+            #region 6
+            sixth.APosition = CenterBC;
+            sixth.ATexCoord = TexCoordBC;
+
+            sixth.BPosition = CenterCA;
+            sixth.BTexCoord = TexCoordCA;
+
+            sixth.CPosition = CenterD;
+            sixth.CTexCoord = TexCoordD;
+
+            SierpinskiTetrahedron.FindNormal( ref CenterBC, ref CenterCA, ref CenterD, out sixth.Normal );
+            sixth.DPosition = E;
+            #endregion 6
+        }
+
+        /// <summary>Returns 3 Vertices which form a CCW triangle.</summary>
+        public void GetVertices( out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            first.TexCoord = this.ATexCoord;
+            first.Normal = this.Normal;
+            first.Position = this.APosition;
+
+            second.TexCoord = this.BTexCoord;
+            second.Normal = this.Normal;
+            second.Position = this.BPosition;
+
+            third.TexCoord = this.CTexCoord;
+            third.Normal = this.Normal;
+            third.Position = this.CPosition;
+        }
+
+        /// <summary>Debugging Aid, no real purpose</summary>
+        public override string ToString()
+        {
+            return "A= " + this.APosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "B= " + this.BPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "C= " + this.CPosition.ToString() + " TexCoord: " + this.ATexCoord.ToString() + "\n" +
+                   "Normal= " + this.Normal.ToString();
+        }
+    }
+
+
+}
diff --git a/KAOS/Shapes/Helpers/VboShape.cs b/KAOS/Shapes/Helpers/VboShape.cs
new file mode 100644
index 0000000..62d5462
--- /dev/null
+++ b/KAOS/Shapes/Helpers/VboShape.cs
@@ -0,0 +1,23 @@
+namespace KAOS.Shapes
+{
+    public sealed class VboShape: DrawableShape
+    {
+        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = primitives;
+
+            VertexArray = new VertexT2dN3dV3d[vertices.Length];
+            for ( uint i = 0; i < vertices.Length; i++ )
+            {
+                VertexArray[i] = vertices[i];
+            }
+
+            IndexArray = new uint[indices.Length];
+            for ( uint i = 0; i < indices.Length; i++ )
+            {
+                IndexArray[i] = indices[i];
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/KochTetrahedron.cs b/KAOS/Shapes/KochTetrahedron.cs
new file mode 100644
index 0000000..a662cfe
--- /dev/null
+++ b/KAOS/Shapes/KochTetrahedron.cs
@@ -0,0 +1,70 @@
+using System;
+
+namespace KAOS.Shapes
+{
+    public sealed class KochTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public KochTetrahedron( double scale, double extrusionHeight, double extrusionMultiplier, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+                SierpinskiTetrahedron.CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    this.SubdivideKoch( extrusionHeight, ref Triangles, out temp );
+                    Triangles = temp;
+                    extrusionHeight *= extrusionMultiplier;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        private void SubdivideKoch( double height, ref TetrahedronFace[] input, out TetrahedronFace[] output )
+        {
+            output = new TetrahedronFace[input.Length * 6];
+
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].SubdivideKoch(height, out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3], out output[counter + 4], out output[counter + 5] );
+                counter += 6; // every source triangle emits 6 new triangles
+            }
+
+        }
+    }
+}
diff --git a/KAOS/Shapes/MengerSponge.cs b/KAOS/Shapes/MengerSponge.cs
new file mode 100644
index 0000000..c1d54c6
--- /dev/null
+++ b/KAOS/Shapes/MengerSponge.cs
@@ -0,0 +1,115 @@
+using OpenTK;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class MengerSponge: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            None = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+        }
+
+        public MengerSponge( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            List<MengerCube> Cubes;
+            switch ( subdivs )
+            {
+            case eSubdivisions.None:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+                CreateDefaultMengerSponge( scale, out Cubes );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    List<MengerCube> temp;
+                    SubdivideMengerSponge( ref Cubes, out temp );
+                    Cubes = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            #region Get Array Dimensions
+            uint
+                VertexCount = 0,
+                IndexCount = 0;
+
+            foreach ( MengerCube c in Cubes )
+            {
+                uint t1, t2;
+                c.GetArraySizes( out t1, out t2 );
+                VertexCount += t1;
+                IndexCount += t2;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[VertexCount];
+            IndexArray = new uint[IndexCount];
+            #endregion Get Array Dimensions
+
+            List<Chunk> AllChunks = new List<Chunk>();
+
+            #region Build a temporary List of all loose pieces
+            foreach ( MengerCube c in Cubes )
+            {
+                c.GetVboAndIbo( ref AllChunks );
+            }
+            #endregion Build a temporary List of all loose pieces
+
+            #region Assemble pieces into a single VBO and IBO
+            VertexCount = 0;
+            IndexCount = 0;
+
+            foreach ( Chunk ch in AllChunks )
+            {
+                for ( int i = 0; i < ch.Vertices.Length; i++ )
+                {
+                    VertexArray[VertexCount + i] = ch.Vertices[i];
+                }
+
+                for ( int i = 0; i < ch.Indices.Length; i++ )
+                {
+                    IndexArray[IndexCount + i] = ch.Indices[i] + VertexCount;
+                }
+
+                VertexCount += (uint)ch.Vertices.Length;
+                IndexCount += (uint)ch.Indices.Length;
+            }
+
+            #endregion Assemble pieces into a single VBO and IBO
+
+            AllChunks.Clear();
+        }
+
+        private void CreateDefaultMengerSponge( double halfwidth, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( 1 );
+            output.Add( new MengerCube( Vector3d.Zero, halfwidth, MengerCube.AllSides, MengerCube.AllSides ) );
+        }
+
+        private void SubdivideMengerSponge( ref List<MengerCube> input, out List<MengerCube> output )
+        {
+            output = new List<MengerCube>( input.Count * 20 );
+            foreach ( MengerCube InputCube in input )
+            {
+                MengerCube[] SubdividedCubes;
+                InputCube.Subdivide( out SubdividedCubes );
+                for ( int i = 0; i < SubdividedCubes.Length; i++ )
+                {
+                    output.Add( SubdividedCubes[i] );
+                }
+            }
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
new file mode 100644
index 0000000..99c2d1b
--- /dev/null
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -0,0 +1,85 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using System.Drawing;
+
+namespace KAOS.Shapes
+{
+    public class Cube : Shape
+    {
+
+        public Cube(int x, int y, int z)
+        {
+            Vertices = new Vector3[]
+            {
+                new Vector3(x-1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f, y-1.0f,  z+1.0f),
+                new Vector3(x+ 1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f,  y+1.0f,  z+1.0f),
+                new Vector3(x-1.0f, y-1.0f, z-1.0f),
+                new Vector3(x+ 1.0f, y-1.0f, z-1.0f), 
+                new Vector3(x+ 1.0f,  y+1.0f, z-1.0f),
+                new Vector3(x-1.0f,  y+1.0f, z-1.0f)
+            };
+
+            Indices = new int[]
+            {
+                // front face
+                0, 1, 2, 2, 3, 0,
+                // top face
+                3, 2, 6, 6, 7, 3,
+                // back face
+                7, 6, 5, 5, 4, 7,
+                // left face
+                4, 0, 3, 3, 7, 4,
+                // bottom face
+                0, 1, 5, 5, 4, 0,
+                // right face
+                1, 5, 6, 6, 2, 1,
+            };
+
+            Normals = new Vector3[]
+            {
+                new Vector3(-1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f, -1.0f,  1.0f),
+                new Vector3( 1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f,  1.0f,  1.0f),
+                new Vector3(-1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f, -1.0f, -1.0f),
+                new Vector3( 1.0f,  1.0f, -1.0f),
+                new Vector3(-1.0f,  1.0f, -1.0f),
+            };
+
+            Colors = new int[]
+            {
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.DarkRed),
+                ColorToRgba32(Color.Gold),
+                ColorToRgba32(Color.Gold),
+            };
+        }
+
+
+        /// <summary>
+        /// Converts a Color instance into an int representation
+        /// </summary>
+        /// <param name="c">
+        /// A <see cref="Color"/> instance to be converted
+        /// </param>
+        /// <returns>
+        /// A <see cref="System.Int32"/>
+        /// </returns>
+        public static int ColorToRgba32(Color c)
+        {
+            return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/IsoSphere.cs b/KAOS/Shapes/Old/IsoSphere.cs
new file mode 100644
index 0000000..4b2ae9f
--- /dev/null
+++ b/KAOS/Shapes/Old/IsoSphere.cs
@@ -0,0 +1,51 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using OpenTK;
+using System;
+
+namespace KAOS.Shapes
+{
+    class IsoSphere : Shape
+    {
+        const double DoublePI = System.Math.PI * 2.0;
+
+        public IsoSphere(int s_steps, int t_steps, float x_scale, float y_scale, float z_scale)
+        {
+            int count = 4 * s_steps * t_steps ;
+            
+            Vertices = new Vector3[count];
+            Normals = new Vector3[count];
+            Texcoords = new Vector2[count];
+            Indices = new int[6 * count / 4];
+
+            int i = 0;
+            for (double t = -System.Math.PI; (float)t < (float)System.Math.PI - Single.Epsilon; t += System.Math.PI / (double)t_steps)
+            {
+                for (double s = 0.0; (float)s < (float)DoublePI; s += System.Math.PI / (double)s_steps)
+                {
+                    Vertices[i].X = x_scale * (float)(System.Math.Cos(s) * System.Math.Sin(t));
+                    Vertices[i].Y = y_scale * (float)(System.Math.Sin(s) * System.Math.Sin(t));
+                    Vertices[i].Z = z_scale * (float)System.Math.Cos(t);
+                    //vertices[i] = vertices[i].Scale(x_scale, y_scale, z_scale);
+                    Normals[i] = Vector3.Normalize(Vertices[i]);
+
+                    ++i;
+                }
+            }
+            
+            for (i = 0; i < 6*count/4; i+=6)
+            {
+                Indices[i] = i;
+                Indices[i + 1] = i + 1;
+                Indices[i + 2] = i + 2 * s_steps + 1;
+                Indices[i + 3] = i + 2 * s_steps;
+                Indices[i + 4] = i;
+                Indices[i + 5] = i + 2 * s_steps + 1;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/Plane.cs b/KAOS/Shapes/Old/Plane.cs
new file mode 100644
index 0000000..df9a78e
--- /dev/null
+++ b/KAOS/Shapes/Old/Plane.cs
@@ -0,0 +1,54 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+    public class Plane : Shape
+    {
+        public Plane(int x_res, int y_res, float x_scale, float y_scale)
+        {
+            Vertices = new Vector3[x_res * y_res];
+            Normals = new Vector3[x_res * y_res];
+            Indices = new int[6 * x_res * y_res];
+            Texcoords = new Vector2[x_res * y_res];
+
+            int i = 0;
+            for (int y = -y_res / 2; y < y_res / 2; y++)
+            {
+                for (int x = -x_res / 2; x < x_res / 2; x++)
+                {
+                    Vertices[i].X = x_scale * (float)x / (float)x_res;
+                    Vertices[i].Y = y_scale * (float)y / (float)y_res;
+                    Vertices[i].Z = 0;
+                    Normals[i].X = Normals[i].Y = 0;
+                    Normals[i].Z = 1;
+                    i++;
+                }
+            }
+
+            i = 0;
+            for (int y = 0; y < y_res - 1; y++)
+            {
+                for (int x = 0; x < x_res - 1; x++)
+                {
+                    Indices[i++] = (y + 0) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+
+                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (y + 1) * x_res + x;
+                    Indices[i++] = (y + 1) * x_res + x + 1;
+                }
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
new file mode 100644
index 0000000..c5315af
--- /dev/null
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -0,0 +1,65 @@
+﻿#region --- License ---
+/* Copyright (c) 2006, 2007 Stefanos Apostolopoulos
+ * See license.txt for license info
+ */
+#endregion
+
+
+
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+    public abstract class Shape
+    {
+        private Vector3[] vertices, normals;
+        private Vector2[] texcoords;
+        private int[] indices;
+        private int[] colors;
+
+        public Vector3[] Vertices
+        {
+            get { return vertices; }
+            protected set
+            {
+                vertices = value;
+            }
+        }
+
+        public Vector3[] Normals
+        {
+            get { return normals; }
+            protected set
+            {
+                normals = value;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get { return texcoords; }
+            protected set
+            {
+                texcoords = value;
+            }
+        }
+
+        public int[] Indices
+        {
+            get { return indices; }
+            protected set
+            {
+                indices = value;
+            }
+        }
+
+        public int[] Colors
+        {
+            get { return colors; }
+            protected set
+            {
+                colors = value;
+            }
+        }
+    }
+}
diff --git a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
new file mode 100644
index 0000000..fcb493d
--- /dev/null
+++ b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
@@ -0,0 +1,171 @@
+using OpenTK;
+using System;
+
+namespace KAOS.Shapes
+{
+    public sealed partial class SierpinskiTetrahedron: DrawableShape
+    {
+
+        public enum eSubdivisions
+        {
+            /// <summary>Creates a Sierpinski Tetrahedron using 4 triangles.</summary>
+            Zero = 0,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16 triangles.</summary>
+            One = 1,
+            /// <summary>Creates a Sierpinski Tetrahedron using 64 triangles.</summary>
+            Two = 2,
+            /// <summary>Creates a Sierpinski Tetrahedron using 256 triangles.</summary>
+            Three = 3,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1024 triangles.</summary>
+            Four = 4,
+            /// <summary>Creates a Sierpinski Tetrahedron using 4096 triangles.</summary>
+            Five = 5,
+            /// <summary>Creates a Sierpinski Tetrahedron using 16384 triangles.</summary>
+            Six = 6,
+            /// <summary>Creates a Sierpinski Tetrahedron using 65536 triangles.</summary>
+            Seven = 7,
+            /// <summary>Creates a Sierpinski Tetrahedron using 262144 triangles.</summary>
+            Eight = 8,
+            /// <summary>Creates a Sierpinski Tetrahedron using 1048576 triangles.</summary>
+            Nine = 9,
+        }
+
+        /// <summary>Creates a Sierpinski Tetrahedron which is centered at (0,0,0) and fits into a sphere of radius 1f, or a diameter of 2f</summary>
+        /// <param name="scale">Default: 1f.</param>
+        /// <param name="subdivs">The number of subdivisions of the Tetrahedron.</param>
+        /// <param name="useDL"></param>
+        public SierpinskiTetrahedron( double scale, eSubdivisions subdivs, bool useDL )
+            : base( useDL )
+        {
+            TetrahedronFace[] Triangles;
+
+            switch ( subdivs )
+            {
+            case eSubdivisions.Zero:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                break;
+            case eSubdivisions.One:
+            case eSubdivisions.Two:
+            case eSubdivisions.Three:
+            case eSubdivisions.Four:
+            case eSubdivisions.Five:
+            case eSubdivisions.Six:
+            case eSubdivisions.Seven:
+            case eSubdivisions.Eight:
+            case eSubdivisions.Nine:
+                CreateDefaultTetrahedron( scale, out Triangles );
+                for ( int i = 0; i < (int)subdivs; i++ )
+                {
+                    TetrahedronFace[] temp;
+                    SubdivideTetrahedron( ref Triangles, out temp );
+                    Triangles = temp;
+                }
+                break;
+            default: throw new ArgumentOutOfRangeException( "Subdivisions other than contained in the enum cause overflows and are not allowed." );
+            }
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
+            IndexArray = null;
+        }
+
+        internal static void GetVertexArray( ref TetrahedronFace[] input, out VertexT2dN3dV3d[] output )
+        {
+            output = new VertexT2dN3dV3d[input.Length * 3];
+            int counter = 0;
+            for ( int i = 0; i < input.Length; i++ )
+            {
+                input[i].GetVertices( out output[counter + 0], out output[counter + 1], out output[counter + 2] );
+                counter += 3;
+            }
+        }
+
+        /// <summary>Generates the lowest subdivision mesh, which consists of 4 Triangles.</summary>
+        internal static void CreateDefaultTetrahedron( double scale, out TetrahedronFace[] array )
+        {
+            Vector3d[] Points = new Vector3d[4];
+            Points[0] = new Vector3d( 0.0 * scale, 0.0 * scale, 1.0 * scale );
+            Points[1] = new Vector3d( -0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[2] = new Vector3d( 0.816 * scale, 0.471 * scale, -0.333 * scale );
+            Points[3] = new Vector3d( 0.0 * scale, -0.943 * scale, -0.333 * scale );
+
+            Vector2d[] TexCoords = new Vector2d[4];
+            TexCoords[0] = new Vector2d( 0.0, 0.0 );
+            TexCoords[1] = new Vector2d( 1.0, 0.0 );
+            TexCoords[2] = new Vector2d( 0.0, 1.0 );
+            TexCoords[3] = new Vector2d( 1.0, 1.0 );
+
+            Vector3d Normal;
+            array = new TetrahedronFace[4];
+
+            FindNormal( ref Points[0], ref Points[2], ref Points[1], ref Points[3], out Normal );
+            array[0] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[2], ref TexCoords[0],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[3], ref Points[2], ref Points[1], out Normal );
+            array[1] = new TetrahedronFace( ref Points[0], ref TexCoords[0],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[1],
+                                                   ref Normal );
+
+            FindNormal( ref Points[0], ref Points[1], ref Points[3], ref Points[2], out Normal );
+            array[2] = new TetrahedronFace( ref Points[0], ref TexCoords[2],
+                                                   ref Points[1], ref TexCoords[1],
+                                                   ref Points[3], ref TexCoords[3],
+                                                   ref Points[2],
+                                                   ref Normal );
+
+            FindNormal( ref Points[1], ref Points[2], ref Points[3], ref Points[0], out Normal );
+            array[3] = new TetrahedronFace( ref Points[1], ref TexCoords[3],
+                                                   ref Points[2], ref TexCoords[2],
+                                                   ref Points[3], ref TexCoords[1],
+                                                   ref Points[0],
+                                                   ref Normal );
+        }
+
+        /// <summary>Subdivides each triangle into 4 new ones.</summary>
+        private void SubdivideTetrahedron( ref TetrahedronFace[] source, out TetrahedronFace[] output )
+        {
+
+            output = new TetrahedronFace[source.Length * 4];
+
+            int counter = 0;
+            for ( int i = 0; i < source.Length; i++ )
+            {
+                source[i].SubdivideSierpinski( out output[counter + 0], out output[counter + 1], out output[counter + 2], out output[counter + 3] );
+                counter += 4; // every source triangle emits 4 new triangles
+            }
+        }
+
+        /// <summary>A, B and C are the triangle whos normal is to be determined. D is the 4th Point in the Tetraeder which does not belong to the triangle.</summary>
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, ref Vector3d D, out Vector3d result )
+        {
+            Vector3d temp1, temp2, temp3;
+
+            Vector3d.Subtract( ref A, ref D, out temp1 );
+            Vector3d.Subtract( ref B, ref D, out temp2 );
+            Vector3d.Subtract( ref C, ref D, out temp3 );
+
+            Vector3d.Add( ref temp1, ref temp2, out result );
+            Vector3d.Add(ref result, ref temp3, out result);
+            result.Normalize();
+        }
+
+        internal static void FindNormal( ref Vector3d A, ref Vector3d B, ref Vector3d C, out Vector3d result )
+        {
+            Vector3d temp1, temp2;
+            Vector3d.Subtract( ref A, ref B, out temp1 );
+            temp1.Normalize();
+            Vector3d.Subtract(ref C, ref B, out temp2);
+            temp2.Normalize();
+            Vector3d.Cross( ref temp1, ref temp2, out result );
+            result *=  -1.0;
+            result.Normalize();
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/SlicedHose.cs b/KAOS/Shapes/SlicedHose.cs
new file mode 100644
index 0000000..8a744ca
--- /dev/null
+++ b/KAOS/Shapes/SlicedHose.cs
@@ -0,0 +1,192 @@
+using OpenTK;
+
+namespace KAOS.Shapes
+{
+	public sealed class SlicedHose : DrawableShape
+	{
+
+        public enum eSide:byte
+        {
+            // Around X Axis
+            BottomRight,
+            TopRight,
+            TopLeft,
+            BottomLeft,
+
+            // Around Y Axis
+
+            FrontRight,
+            BackRight,
+            BackLeft,
+            FrontLeft,
+
+            // Around Z Axis
+            FrontBottom,
+            BackBottom,
+            BackTop,
+            FrontTop,
+        }
+
+        public SlicedHose( eSide side, uint subdivs, double scale, Vector3d offset1, Vector3d offset2, bool useDL )
+            : base( useDL )
+        {
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            Vector3d start = Vector3d.Zero,
+                     end = Vector3d.Zero;
+            double TexCoordStart=0f, TexCoordEnd=0f;
+
+            switch ( side )
+            {
+            #region Around X Axis
+            case eSide.BottomRight:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.TopRight:
+                start = Vector3d.UnitZ;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.TopLeft:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.BottomLeft:
+                start = -Vector3d.UnitZ;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+            #endregion Around X Axis
+            #region Around Y Axis
+            case eSide.FrontRight:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitZ;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackRight:
+                start = Vector3d.UnitZ;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackLeft:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitZ;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontLeft:
+                start = -Vector3d.UnitZ;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Y Axis
+            #region Around Z Axis
+            case eSide.FrontBottom:
+                start = -Vector3d.UnitY;
+                end = Vector3d.UnitX;
+                TexCoordStart = 0.0;
+                TexCoordEnd = 0.25;
+                break;
+            case eSide.BackBottom:
+                start = -Vector3d.UnitX;
+                end = -Vector3d.UnitY;
+                TexCoordStart = 0.25;
+                TexCoordEnd = 0.5;
+                break;
+            case eSide.BackTop:
+                start = Vector3d.UnitY;
+                end = -Vector3d.UnitX;
+                TexCoordStart = 0.5;
+                TexCoordEnd = 0.75;
+                break;
+            case eSide.FrontTop:
+                start = Vector3d.UnitX;
+                end = Vector3d.UnitY;
+                TexCoordStart = 0.75;
+                TexCoordEnd = 1.0;
+                break;
+#endregion Around Z Axis
+
+            }
+
+            VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
+
+            double divisor = 1.0/ ((double)temp.Length-1.0);
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                float Multiplier = (float)( i * divisor );
+
+                temp[i].TexCoord.X = TexCoordStart * Multiplier + TexCoordEnd * ( 1.0f- Multiplier);
+
+                Slerp( ref start, ref end, Multiplier, out temp[i].Normal );
+                temp[i].Normal.Normalize();
+                temp[i].Position = temp[i].Normal;
+                temp[i].Position *= scale;
+            }
+
+            VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
+            IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
+
+            uint VertexCounter = 0,
+                 IndexCounter = 0,
+                 QuadCounter = 0;
+
+            for ( int i = 0; i < temp.Length; i++ )
+            {
+                VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;
+                VertexArray[VertexCounter + 0].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;
+
+
+                VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;
+                VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;
+                VertexArray[VertexCounter + 1].Normal = temp[i].Normal;
+                VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;
+                VertexCounter += 2;
+
+                if ( i < temp.Length - 1 )
+                {
+                    IndexArray[IndexCounter + 0] = QuadCounter + 0;
+                    IndexArray[IndexCounter + 1] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 2] = QuadCounter + 2;
+
+                    IndexArray[IndexCounter + 3] = QuadCounter + 2;
+                    IndexArray[IndexCounter + 4] = QuadCounter + 1;
+                    IndexArray[IndexCounter + 5] = QuadCounter + 3;
+
+                    IndexCounter += 6;
+                    QuadCounter += 2;
+                }
+            }
+
+        }
+ 
+    private void Slerp( ref Vector3d a, ref Vector3d b, double factor, out Vector3d result)
+    {
+        double t1;
+        Vector3d.Dot( ref a, ref b, out t1 );
+        double theta = System.Math.Acos( t1 );
+
+        double temp = 1.0 / System.Math.Sin( theta );
+        double t2 = System.Math.Sin( ( 1.0 - factor ) * theta ) * temp;
+        double t3 = System.Math.Sin( factor * theta ) * temp;
+
+        Vector3d v1 = Vector3d.Multiply( a, t2);
+        Vector3d v2 = Vector3d.Multiply( b, t3 );
+        result = Vector3d.Add( v1, v2 );
+    }
+
+
+    }
+}
diff --git a/KAOS/Shapes/SlicedSphere.cs b/KAOS/Shapes/SlicedSphere.cs
new file mode 100644
index 0000000..7c5ee4f
--- /dev/null
+++ b/KAOS/Shapes/SlicedSphere.cs
@@ -0,0 +1,193 @@
+using OpenTK;
+using System.Collections.Generic;
+
+namespace KAOS.Shapes
+{
+    public sealed class SlicedSphere: DrawableShape
+    {
+        public enum eSubdivisions
+        {
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3,
+            Four = 4,
+            Five=5,
+            Six=6,
+            Seven=7,
+            Eight=8,
+        }
+
+        public enum eDir
+        {
+            All,
+            FrontTopRight,
+            FrontBottomRight,
+            FrontBottomLeft,
+            FrontTopLeft,
+            BackTopRight,
+            BackBottomRight,
+            BackBottomLeft,
+            BackTopLeft,
+
+        }
+
+        public SlicedSphere( double radius, Vector3d offset, eSubdivisions subdivs, eDir[] sides, bool useDL )
+            : base( useDL )
+        {
+            double Diameter = radius;
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+
+            if ( sides[0] == eDir.All )
+            {
+                sides = new eDir[] {  eDir.FrontTopRight,
+            eDir.FrontBottomRight,
+            eDir.FrontBottomLeft,
+            eDir.FrontTopLeft,
+            eDir.BackTopRight,
+            eDir.BackBottomRight,
+            eDir.BackBottomLeft,
+            eDir.BackTopLeft,};
+            }
+
+            VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
+            IndexArray = new uint[sides.Length * 3];
+
+            uint counter = 0;
+            foreach ( eDir s in sides )
+            {
+                GetDefaultVertices( s, Diameter, out VertexArray[counter + 0], out VertexArray[counter + 1], out VertexArray[counter + 2] );
+                IndexArray[counter + 0] = counter + 0;
+                IndexArray[counter + 1] = counter + 1;
+                IndexArray[counter + 2] = counter + 2;
+                counter += 3;
+            }
+
+            if ( subdivs != eSubdivisions.Zero )
+            {
+
+                for ( int s = 0; s < (int)subdivs; s++ )
+                {
+                    #region Assemble Chunks and convert to Arrays
+                    List<Chunk> AllChunks = new List<Chunk>();
+                    for ( uint i = 0; i < IndexArray.Length; i += 3 )
+                    {
+                        Chunk chu;
+                        Subdivide( Diameter,
+                                   ref VertexArray[IndexArray[i + 0]],
+                                   ref VertexArray[IndexArray[i + 1]],
+                                   ref VertexArray[IndexArray[i + 2]],
+                                   out chu );
+                        AllChunks.Add( chu );
+                    }
+
+                    Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
+                    AllChunks.Clear();
+                    #endregion Assemble Chunks and convert to Arrays
+                }
+            }
+
+            for (int i=0; i<VertexArray.Length;i++)
+            {
+                Vector3d.Add(ref VertexArray[i].Position, ref offset, out VertexArray[i].Position);
+            }
+        }
+
+        private void GetDefaultVertices( eDir s, double scale, out VertexT2dN3dV3d first, out VertexT2dN3dV3d second, out VertexT2dN3dV3d third )
+        {
+            VertexT2dN3dV3d t1 = new VertexT2dN3dV3d(),
+                            t2 = new VertexT2dN3dV3d(),
+                            t3 = new VertexT2dN3dV3d();
+            switch ( s )
+            {
+            case eDir.FrontTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.FrontBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                break;
+            case eDir.FrontBottomLeft: 
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.FrontTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.5, 0.0 ), Vector3d.UnitX, Vector3d.UnitX * scale );
+                break;
+            case eDir.BackTopRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackBottomRight:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 0.0, 0.0 ), Vector3d.UnitZ, Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 0.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            case eDir.BackBottomLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), -Vector3d.UnitY, -Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                break;
+            case eDir.BackTopLeft:
+                t1 = new VertexT2dN3dV3d( new Vector2d( 0.5, 1.0 ), Vector3d.UnitY, Vector3d.UnitY * scale );
+                t2 = new VertexT2dN3dV3d( new Vector2d( 1.0, 0.0 ), -Vector3d.UnitZ, -Vector3d.UnitZ * scale );
+                t3 = new VertexT2dN3dV3d( new Vector2d( 1.0, 1.0 ), -Vector3d.UnitX, -Vector3d.UnitX * scale );
+                break;
+            }
+            first = t1;
+            second = t2;
+            third = t3;
+        }
+
+
+        private void Subdivide( double Scale, ref VertexT2dN3dV3d first, ref VertexT2dN3dV3d second, ref VertexT2dN3dV3d third, out Chunk c )
+        {
+            c = new Chunk(6, 12);
+
+            c.Vertices[0] = first;
+            
+            Vector3d.Lerp(ref first.Position, ref second.Position, 0.5,out c.Vertices[1].Normal );
+            c.Vertices[1].Normal.Normalize();
+            c.Vertices[1].Position = c.Vertices[1].Normal * Scale;
+            Vector2d.Lerp( ref first.TexCoord, ref second.TexCoord, 0.5, out c.Vertices[1].TexCoord );
+
+            Vector3d.Lerp( ref third.Position, ref first.Position, 0.5, out c.Vertices[2].Normal );
+            c.Vertices[2].Normal.Normalize();
+            c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
+            Vector2d.Lerp( ref third.TexCoord, ref first.TexCoord, 0.5, out c.Vertices[2].TexCoord );
+
+            c.Vertices[3] = second;
+    
+            Vector3d.Lerp( ref second.Position, ref third.Position, 0.5, out c.Vertices[4].Normal );
+            c.Vertices[4].Normal.Normalize();
+            c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
+            Vector2d.Lerp( ref second.TexCoord, ref third.TexCoord, 0.5, out c.Vertices[4].TexCoord );
+
+            c.Vertices[5] = third;
+
+            #region Indices
+            c.Indices[0]=0;
+            c.Indices[1]=1;
+            c.Indices[2]=2;
+            c.Indices[3]=2;
+            c.Indices[4]=1;
+            c.Indices[5]=4;
+            c.Indices[6]=1;
+            c.Indices[7]=3;
+            c.Indices[8]=4;
+            c.Indices[9]=2;
+            c.Indices[10]=4;
+            c.Indices[11]=5;
+            #endregion Indices
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/TorusKnot.cs b/KAOS/Shapes/TorusKnot.cs
new file mode 100644
index 0000000..898c314
--- /dev/null
+++ b/KAOS/Shapes/TorusKnot.cs
@@ -0,0 +1,126 @@
+﻿using OpenTK;
+using System.Diagnostics;
+
+namespace KAOS.Shapes
+{
+    public sealed class TorusKnot: DrawableShape
+    {
+        #region Constants
+        // hard minimums to make sure the created Torusknot is 3D
+        private const int MINShapeVertices = 3;
+        private const int MINPathSteps = 32;
+        private const double TwoPi = ( 2.0 * System.Math.PI );
+        #endregion Constants
+
+        public TorusKnot( int pathsteps, int shapevertices, double radius, int p, int q, int TexCount, bool useDL )
+            : base( useDL )
+        {
+            Trace.Assert( pathsteps >= MINPathSteps, "A Path must have at least " + MINPathSteps + " Steps to form a volume." );
+            Trace.Assert( shapevertices >= MINShapeVertices, "A Shape must contain at least " + MINShapeVertices + " Vertices to be considered valid and create a volume." );
+            Trace.Assert( TexCount >= 1, "at least 1 Texture set is required." );
+
+            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+
+            Vector3d[] PathPositions = new Vector3d[pathsteps];
+
+            #region Find the center Points for each step on the path
+
+            for ( int i = 0; i < pathsteps; i++ )
+            {
+                double Angle = ( i / (double)pathsteps ) * TwoPi;
+                double AngleTimesP = Angle * p;
+                double AngleTimesQ = Angle * q;
+                double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );
+
+                PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) ),
+                                                 ( r * System.Math.Cos( AngleTimesQ ) ),
+                                                 ( r * System.Math.Sin( AngleTimesP ) ) );
+
+            }
+            #endregion Find the center Points for each step on the path
+
+            #region Find the Torus length
+            Vector3d result;
+            double[] Lengths = new double[pathsteps];
+            Vector3d.Subtract( ref PathPositions[pathsteps - 1], ref PathPositions[0], out result );
+            Lengths[0] = result.Length;
+            double TotalLength = result.Length;
+            for ( int i = 1; i < pathsteps; i++ ) // skipping 
+            {
+                Vector3d.Subtract( ref PathPositions[i - 1], ref PathPositions[i], out result );
+                Lengths[i] = result.Length;
+                TotalLength += result.Length;
+            }
+            Trace.WriteLine( "the TorusKnot's length is: " + TotalLength + " " );
+            #endregion Find the Torus length
+
+            VertexArray = new VertexT2dN3dV3d[pathsteps * shapevertices];
+
+            #region Loft a circle Shape along the path
+            double TwoPiThroughVert = TwoPi / shapevertices; // precalc for reuse
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                Vector3d last, next, normal, tangent;
+                if ( i == pathsteps - 1 )
+                    next = PathPositions[0];
+                else
+                    next = PathPositions[i + 1];
+                if ( i == 0 )
+                    last = PathPositions[pathsteps - 1];
+                else
+                    last = PathPositions[i - 1];
+
+                Vector3d.Subtract( ref next, ref last, out tangent ); // Guesstimate tangent
+                tangent.Normalize();
+
+                Vector3d.Add( ref next, ref last, out normal ); // Approximate N
+                normal.Normalize();
+                Vector3d.Multiply( ref normal, radius, out normal );// scale the shape to desired radius
+
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    uint index = i * (uint)shapevertices + j;
+
+                    // Create a point on the plane and rotate it
+                    Matrix4d RotationMatrix = Matrix4d.Rotate( tangent, -( j * TwoPiThroughVert ) );
+                    Vector3d point = Vector3d.TransformVector( normal, RotationMatrix );
+                    Vector3d.Add( ref PathPositions[i], ref point, out VertexArray[index].Position );
+                    // Since the used shape is a circle, the Vertex normal's heading is easy to find
+                    Vector3d.Subtract( ref VertexArray[index].Position, ref PathPositions[i], out VertexArray[index].Normal );
+                    VertexArray[index].Normal.Normalize();
+                    // just generate some semi-useful UVs to fill blanks
+                    VertexArray[index].TexCoord = new Vector2d( (double)( i / TotalLength/ TexCount  ), j / ( shapevertices - 1.0 ) );
+                }
+            }
+            #endregion Loft a circle Shape along the path
+
+            PathPositions = null; // not needed anymore
+
+            uint currentindex = 0;
+
+            #region Build a Triangle strip from the Vertices
+            IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )]; // 2 triangles per vertex, +2 due to added degenerate triangles
+            for ( uint i = 0; i < pathsteps; i++ )
+            {
+                uint RowCurrent = i * (uint)shapevertices;
+                uint RowBelow;
+                if ( i == pathsteps - 1 )
+                    RowBelow = 0; // for the last row, the first row is the following
+                else
+                    RowBelow = ( i + 1 ) * (uint)shapevertices;
+
+                // new ring begins here
+                for ( uint j = 0; j < shapevertices; j++ )
+                {
+                    IndexArray[currentindex++] = RowCurrent + j;
+                    IndexArray[currentindex++] = RowBelow + j;
+                }
+                // ring ends here, repeat first 2 vertices to insert 2 degenerate triangles to reach following ring
+                IndexArray[currentindex++] = RowCurrent;
+                IndexArray[currentindex++] = RowBelow;
+            }
+            #endregion Build a Triangle strip from the Vertices
+        }
+
+    }
+}
diff --git a/KAOS/Shapes/VertexPositionColor.cs b/KAOS/Shapes/VertexPositionColor.cs
new file mode 100644
index 0000000..2576afe
--- /dev/null
+++ b/KAOS/Shapes/VertexPositionColor.cs
@@ -0,0 +1,51 @@
+﻿#region License
+//
+// The Open Toolkit Library License
+//
+// Copyright (c) 2006 - 2010 the Open Toolkit library, except where noted.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights to 
+// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software is furnished to do
+// so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+// OTHER DEALINGS IN THE SOFTWARE.
+//
+#endregion
+
+using OpenTK;
+using System.Drawing;
+using System.Runtime.InteropServices;
+
+namespace KAOS.Tutorial
+{
+    [StructLayout(LayoutKind.Sequential, Pack = 1)]
+    struct VertexPositionColor
+    {
+        public Vector3 Position;
+        public uint Color;
+
+        public VertexPositionColor(float x, float y, float z, Color color)
+        {
+            Position = new Vector3(x, y, z);
+            Color = ToRgba(color);
+        }
+
+        static uint ToRgba(Color color)
+        {
+            return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
+        }
+    }
+}
diff --git a/KAOS/States/AssimpImportedState.cs b/KAOS/States/AssimpImportedState.cs
new file mode 100644
index 0000000..40dbc84
--- /dev/null
+++ b/KAOS/States/AssimpImportedState.cs
@@ -0,0 +1,28 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
+
+namespace KAOS.States
+{
+    public class AssimpImportedState :IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+
+        public AssimpImportedState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Render()
+        {
+
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+    }
+}
diff --git a/KAOS/States/DefaultState.cs b/KAOS/States/DefaultState.cs
new file mode 100644
index 0000000..e26345e
--- /dev/null
+++ b/KAOS/States/DefaultState.cs
@@ -0,0 +1,44 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System.Drawing;
+
+namespace KAOS.States
+{
+    public class DefaultState : IGameObject
+    {
+        double currentRotation = 0;
+
+        StateManager m_stateManager;
+        public DefaultState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.Black);
+            GL.PointSize(5f);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.TriangleStrip);
+
+            GL.Color4(new Color4(1f, 0f, 0f, .5f));
+            GL.Vertex3(new Vector3(-50f, 0f, 0f));
+            GL.Color3(new Vector3(0f, 1f, 0f));
+            GL.Vertex3(new Vector3(50f, 0, 0));
+            GL.Color3(new Vector3(0f, 0f, 1f));
+            GL.Vertex3(new Vector3(0f, 50f, 0));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
new file mode 100644
index 0000000..f83dcda
--- /dev/null
+++ b/KAOS/States/DrawSpriteState.cs
@@ -0,0 +1,79 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System.Drawing;
+
+namespace KAOS.States
+{
+    public class DrawSpriteState : IGameObject
+    {
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        double height, width, halfHeight, halfWidth, x, y, z;
+        float topUV, bottomUV, leftUV, rightUV;
+
+        #region IGameObject States
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            Texture texture = m_textureManager.Get("sprite1");
+            GL.Enable(EnableCap.Texture2D);
+            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
+            GL.ClearColor(Color.Black);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.TexCoord2(new Vector2d(leftUV, topUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+            GL.TexCoord2(new Vector2d(rightUV, topUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
+            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+            GL.End();
+
+        } 
+        #endregion
+
+        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
+        {
+            m_stateManager = stateManager;
+            m_textureManager = texturManager;
+            Initialise();
+        }
+
+        private void Initialise()
+        {
+            this.height = 200;
+            this.width = 200;
+
+            this.halfHeight = this.height / 2;
+            this.halfWidth = this.width / 2;
+
+            this.x = 0;
+            this.y = 0;
+            this.z = 2;
+
+            this.topUV = 0;
+            this.bottomUV = 1;
+            this.leftUV = 0;
+            this.rightUV = 1;
+        }
+    }
+}
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
new file mode 100644
index 0000000..59095f9
--- /dev/null
+++ b/KAOS/States/Skyboxstate.cs
@@ -0,0 +1,217 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+
+namespace KAOS.States
+{
+    public class Skyboxstate : IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        Cube cube;
+        BufferObject cubeObject;
+
+        // Data layout for each line below is:
+        // position{XYZ},			    normal{XYZ},
+        float[] vertexData = new float[] {
+            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
+  
+            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
+  
+            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
+  
+            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
+  
+            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
+            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
+  
+            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
+            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
+            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
+        };
+
+        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        Matrix3 modelMatrix3, normalMatrix;
+        Vector3 eyeObjectSpace;
+        Vector3 trans;
+
+        
+        int eye_handle, skybox_vao;
+
+        float aspect = 1024 / (float)600;
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            LoadCubeMap();
+            CreateShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+            trans = new Vector3(0f, 0f, -10f);
+
+            LoadTestObject();
+        }
+
+        private void CreateShaders()
+        {
+            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
+
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
+
+            Logger.WriteLine("Render Shader");
+            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+            GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            GL.GenVertexArrays(1, out skybox_vao);
+            GL.BindVertexArray(skybox_vao);
+
+            GL.DepthFunc(DepthFunction.Lequal);
+        }
+
+        private void LoadTestObject()
+        {
+            cube = new Cube(0, 0, 0);
+            cubeObject = new BufferObject();
+            cubeObject.PositionData = cube.Vertices;
+            cubeObject.NormalsData = cube.Normals;
+            cubeObject.IndicesData = cube.Indices;
+            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
+
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
+        }
+
+        public void Update(float elapsedTime)
+        {
+            MoveCamera();
+
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
+            
+            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
+            Renderer.eyePosition = Camera.Position;
+        }
+
+        public void Render()
+        {
+            cubeObject = m_bufferManager.GetBuffer("SkyCube");
+            Renderer.DrawSkyBox(m_textureManager, cubeObject);
+            
+            cubeObject = m_bufferManager.GetBuffer("Cube");
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.UseProgram(ShaderManager.Get("Render").ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+        }
+
+        #region Input Control
+        private void MoveCamera()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+
+            }
+        #endregion
+        }
+    }
+}
diff --git a/KAOS/States/SplashScreenState.cs b/KAOS/States/SplashScreenState.cs
new file mode 100644
index 0000000..c18d9ec
--- /dev/null
+++ b/KAOS/States/SplashScreenState.cs
@@ -0,0 +1,51 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Timers;
+
+namespace KAOS.States
+{
+    public class SplashScreenState : IGameObject
+    {
+        double currentRotation = 0;
+        double delay = 300;
+
+        StateManager m_stateManager;
+        public SplashScreenState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime)
+        {
+            delay--;
+            if (delay <= 0){
+                delay = 3;
+                m_stateManager.ChangeState("Voxels");
+            }
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+
+            GL.Rotate(currentRotation, 0, 1, 0);
+            GL.Begin(PrimitiveType.Triangles);
+
+            GL.Vertex3(new OpenTK.Vector3(-0.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(.5f, 0f, 0f));
+            GL.Vertex3(new OpenTK.Vector3(0f, .5f, 0f));
+
+            GL.End();
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/TestSpriteClassState.cs b/KAOS/States/TestSpriteClassState.cs
new file mode 100644
index 0000000..814b797
--- /dev/null
+++ b/KAOS/States/TestSpriteClassState.cs
@@ -0,0 +1,48 @@
+﻿using AWGL.Interfaces;
+using AWGL.Managers;
+using AWGL.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace AWGL.States
+{
+    public class TestSpriteClassState : IGameObject
+    {
+        Renderer m_renderer = new Renderer();
+        TextureManager m_textureManager = new TextureManager();
+        Sprite sprite1 = new Sprite();
+        Sprite sprite2 = new Sprite();
+
+        public TestSpriteClassState(TextureManager textureManager)
+        {
+            m_textureManager = textureManager;
+            sprite1.Texture = m_textureManager.Get("sprite1");
+            sprite1.SetHeight(256 * 0.5f);
+            sprite1.SetPosition(new Vector3d(100, 100, 0));
+            sprite1.SetColour(new Color4(256, 256, 256, 1));
+
+            sprite2.Texture = m_textureManager.Get("sprite2");
+            sprite2.SetHeight(256 * .5f);
+            sprite2.SetPosition(new Vector3d(-100, -100, 0));
+            sprite2.SetColour(new Color4(256, 256, 256, 1));
+        }
+
+        public void Update(float elapsedTime)
+        {
+            //throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            GL.ClearColor(1f, 1f, 1f, 1f);
+            m_renderer.DrawSprite(sprite1);
+            m_renderer.DrawSprite(sprite2);
+            GL.Finish();
+        }
+    }
+}
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
new file mode 100644
index 0000000..917dae0
--- /dev/null
+++ b/KAOS/States/VboState.cs
@@ -0,0 +1,51 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.States
+{
+    public class VboState : IGameObject
+    {
+        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
+        BufferObject m_bufferObject;
+        StateManager m_stateManager;
+        Cube cube = new Cube(0, 0, 0);
+
+        public VboState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            CreateVBOs();
+        }
+
+        private void CreateVBOs()
+        {
+            BufferObject tempVBO = new BufferObject();
+            tempVBO.PositionData = cube.Vertices;
+            tempVBO.NormalsData = cube.Normals;
+            tempVBO.IndicesData = cube.Indices;
+            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+        }
+
+        public void Update(float elapsedTime)
+        {
+
+        }
+
+        public void Render()
+        {
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType,
+                            m_bufferObject.IndicesData.Length,
+                            DrawElementsType.UnsignedInt,
+                            IntPtr.Zero);
+        }
+    }
+}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
new file mode 100644
index 0000000..e8b82e2
--- /dev/null
+++ b/KAOS/States/VoxelState.cs
@@ -0,0 +1,100 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.States
+{
+    public class VoxelState : IGameObject
+    {
+        double currentRotation = 0;
+        public float length = 1f, height = 1f, width = 1f;
+
+        StateManager m_stateManager = new StateManager();
+
+        BufferObjectManager m_bufferObjectManager;
+        BufferObject m_bufferObject;
+
+        TextureManager m_textureManager = new TextureManager();
+
+        Cube[][][] m_blocks;
+
+        public VoxelState(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+
+            m_bufferObjectManager = new BufferObjectManager();
+
+            //LoadSkyBox();
+
+            GenerateChunk();
+        }
+
+        private void LoadSkyBox()
+        {
+            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+            m_textureManager.LoadSkyTexture("skybox", 
+                new string[] 
+                {
+                    skyboxTexturePath + "jajlands1_ft.jpg",
+                    skyboxTexturePath + "jajlands1_bk.jpg",
+                    skyboxTexturePath + "jajlands1_lf.jpg",
+                    skyboxTexturePath + "jajlands1_rt.jpg",
+                    skyboxTexturePath + "jajlands1_up.jpg",
+                    skyboxTexturePath + "jajlands1_dn.jpg"
+                }
+            );
+
+        }
+
+        private void GenerateChunk()
+        {
+            BufferObject tmpVBO = new BufferObject();
+            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+            
+            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+            {
+                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+                {
+                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+                    {
+                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+                        if (x == 0 && y == 0 && z == 0) 
+                        { 
+                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+                        }
+                        else
+                        { 
+                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+                        }
+                    }
+                }
+            }
+
+            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+        }
+
+        public void Update(float elapsedTime)
+        {
+            currentRotation = 100 * elapsedTime;
+        }
+
+        public void Render()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+            GL.BindVertexArray(m_bufferObject.VaoID);
+            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+        }
+    }
+}
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
new file mode 100644
index 0000000..9d28a68
--- /dev/null
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -0,0 +1,39 @@
+﻿
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public class PreciseTimer
+    {
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);
+
+        [System.Security.SuppressUnmanagedCodeSecurity]
+        [System.Runtime.InteropServices.DllImport("kernel32")]
+        private static extern bool QueryPerformanceCounter(ref long PerformanceCount);
+
+        long m_ticksPerSecond = 0;
+        long m_previouslyElapsedTime = 0;
+
+        public PreciseTimer()
+        {
+            QueryPerformanceFrequency(ref m_ticksPerSecond);
+            GetElapsedTime();
+        }
+
+        public float GetElapsedTime()
+        {
+            long time = 0;
+            QueryPerformanceCounter(ref time);
+
+            float elapsedTime = (float)(time - m_previouslyElapsedTime) / (float)m_ticksPerSecond;
+
+            return elapsedTime;
+        }
+
+    }
+}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
new file mode 100644
index 0000000..4d80ab9
--- /dev/null
+++ b/KAOS/Utilities/Block.cs
@@ -0,0 +1,29 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public class Block
+    {
+        enum BlockType
+        {
+            BlockType_Default = 0,
+
+            BlockType_Grass,
+            BlockType_Dirt,
+            BlockType_Water,
+            BlockType_Stone,
+            BlockType_Wood,
+            BlockType_Sand,
+
+            BlockType_NumTypes,
+        };
+
+        public bool IsActive { get; set; }
+        private bool m_active;
+        private BlockType type;
+    }
+}
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
new file mode 100644
index 0000000..18a1ea1
--- /dev/null
+++ b/KAOS/Utilities/BufferObject.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct BufferObject
+    {
+        public int VaoID { get; set; }
+
+        public int VboID { get; set; }
+
+        public int IboID { get; set; }
+
+        public PrimitiveType PrimitiveType { get; set; }
+
+        public Vector3[] PositionData { get; set; }
+
+        public Vector3[] NormalsData { get; set; }
+
+        public Color4[] ColorData { get; set; }
+
+        public int[] IndicesData { get; set; }
+
+        public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+        {
+            #region Buffer Pointer IDs
+            VaoID = vaoId;
+            VboID = vboId;
+            IboID = iboId;
+            #endregion
+            
+            PositionData = vPositionData;
+            NormalsData = vNormalsData;
+            ColorData = vColorData;
+            IndicesData = indicesData;
+        }
+
+    }
+}
diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
new file mode 100644
index 0000000..59ace7e
--- /dev/null
+++ b/KAOS/Utilities/Camera.cs
@@ -0,0 +1,59 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// Camera
+    /// </summary>
+    public static class Camera
+    {
+        public static Vector3 Position = new Vector3(0f, 0f, 0f);
+        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static float MoveSpeed = 0.2f;
+        public static float MouseSensitivity = 0.01f;
+
+        public static Matrix4 GetViewMatrix()
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public static void Move(float x, float y, float z)
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
+            Position += offset;
+
+            Logger.WriteLine("Camera Position = " + Position);
+        }
+
+        public static void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
new file mode 100644
index 0000000..26681e0
--- /dev/null
+++ b/KAOS/Utilities/Chunk.cs
@@ -0,0 +1,91 @@
+﻿using KAOS.Shapes;
+using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+namespace KAOS.Utilities
+{
+    public class Chunk : IDisposable
+    {
+        public const int CHUNK_SIZE = 16;
+        private Block[][][] m_blocks;
+        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+
+        public Chunk()
+        {
+            //Create Blocks
+            m_blocks = new Block[CHUNK_SIZE][][];
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                m_blocks[i] = new Block[CHUNK_SIZE][];
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+                }
+            }
+        }
+
+        public void Update(float dt) { }
+
+        public void Render() { }
+
+        public void Dispose()
+        {
+            // Delete blocks
+            for (int i = 0; i < CHUNK_SIZE; i++)
+            {
+                
+
+                for (int j = 0; j < CHUNK_SIZE; j++)
+                {
+                    m_blocks[i][j] = null;
+                }
+                m_blocks[i] = null;
+            }
+            m_blocks = null;
+        }
+
+        public void CreateMesh()
+        {
+            for (int x = 0; x < CHUNK_SIZE; x++)
+            {
+                for (int y = 0; y < CHUNK_SIZE; y++)
+                {
+                    for (int z = 0; z < CHUNK_SIZE; z++)
+                    {
+                        if (m_blocks[x][y][z].IsActive == false)
+                        {
+                            // Don't create triangle data for inactive blocks
+                            continue;
+                        }
+
+                        CreateCube(x, y, z);
+                    }
+                }
+            }
+        }
+
+        private void CreateCube(int x, int y, int z)
+        {
+            float blockSize = 1f;
+
+            
+            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+
+            Vector3 n1;
+
+
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/KAOS/Utilities/CustomVertexStruct.cs b/KAOS/Utilities/CustomVertexStruct.cs
new file mode 100644
index 0000000..e3d3585
--- /dev/null
+++ b/KAOS/Utilities/CustomVertexStruct.cs
@@ -0,0 +1,35 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.InteropServices;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct AWVertex
+    {
+        /// <summary>
+        /// Defines the size of the AWVertex struct in bytes.
+        /// </summary>
+        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
+        private Vector3[] vector31;
+        private Vector3[] vector32;
+        private int[] p;
+
+        public Vector3[] Postions { get; set; }
+
+        public Vector3[] Normals {get; set;}
+
+        public int[] Colors {get; set;}
+
+        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
+        {
+            Postions = positions;
+            Normals = nomarls;
+            Colors = colors;
+        }
+
+            
+    }
+}
diff --git a/KAOS/Utilities/Extensions.cs b/KAOS/Utilities/Extensions.cs
new file mode 100644
index 0000000..759ed2a
--- /dev/null
+++ b/KAOS/Utilities/Extensions.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public static class Extensions
+    {
+        // http://stackoverflow.com/a/1547282/1090268
+        public static T[] Concat<T>(this T[] x, T[] y)
+        {
+            if (x == null) throw new ArgumentNullException("x");
+            if (y == null) throw new ArgumentNullException("y");
+            int oldLen = x.Length;
+            Array.Resize<T>(ref x, x.Length + y.Length);
+            Array.Copy(y, 0, x, oldLen, y.Length);
+            return x;
+        }
+    }
+}
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
new file mode 100644
index 0000000..6e15e05
--- /dev/null
+++ b/KAOS/Utilities/Logger.cs
@@ -0,0 +1,52 @@
+﻿using OpenTK.Graphics.OpenGL;
+using System;
+using System.Diagnostics;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// AWLogger
+    /// </summary>
+    internal static class Logger
+    {
+       
+        internal static void WriteLine(string output)
+        {
+            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
+        }
+
+        internal static void PlatformInfo()
+        {
+            WriteLine("Starting Logger. . .");
+            WriteLine("Getting Platform Information. . .");
+            WriteLine(GL.GetString(StringName.Vendor));
+            WriteLine(GL.GetString(StringName.Renderer));
+            WriteLine(GL.GetString(StringName.Version));
+            WriteLine(GL.GetString(StringName.ShadingLanguageVersion));
+        }
+
+        internal static void ShaderInfo(int shaderHandle)
+        {
+            String infoLog;
+            GL.GetShaderInfoLog(shaderHandle, out infoLog);
+            WriteLine(infoLog);
+        }
+
+        internal static void ProgramInfo(int programHandle)
+        {
+            String infoLog;
+            GL.GetProgramInfoLog(programHandle, out infoLog);
+            WriteLine(infoLog);
+            ShadersAttached(programHandle);
+        }
+
+        internal static void ShadersAttached(int programHandle)
+        {
+            int attachedShaders;
+            GL.GetProgram(programHandle, GetProgramParameterName.AttachedShaders, out attachedShaders);
+            string temp = attachedShaders > 1 ? " Shaders" : " Shader";
+            WriteLine(attachedShaders + temp + " Attached");
+        }
+    }
+
+}
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
new file mode 100644
index 0000000..903fe15
--- /dev/null
+++ b/KAOS/Utilities/Renderer.cs
@@ -0,0 +1,75 @@
+﻿using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+
+namespace KAOS.Utilities
+{
+    public static class Renderer
+    {
+        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
+        internal static Vector3 eyePosition;
+        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
+
+        public static void DrawImmediateModeVertex(Vector3d position, Color4 color, Vector2 uvs)
+        {
+            GL.Color4(color);
+            GL.TexCoord2(uvs);
+            GL.Vertex3(position);
+        }
+
+        public static void DrawSprite(Sprite sprite)
+        {
+            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
+            GL.Begin(PrimitiveType.Triangles);
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                DrawImmediateModeVertex(
+                    sprite.VertexPositions[i],
+                    sprite.VertexColours[i],
+                    sprite.VertexUVs[i]);
+            }
+            GL.End();
+        }
+
+        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        {
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.ActiveTexture(TextureUnit.Texture0);
+            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+
+            GL.BindVertexArray(cubeObject.VaoID);
+            GL.Disable(EnableCap.DepthTest);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+
+            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public static void DrawWireframeVoxel(float length, float height, float width)
+        {
+            
+        }
+
+        public static void DrawChunk(Chunk chunk)
+        {
+
+        }
+
+        internal static void ToggleWireframeOn()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
+
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Shader.cs b/KAOS/Utilities/Shader.cs
new file mode 100644
index 0000000..2b5cda0
--- /dev/null
+++ b/KAOS/Utilities/Shader.cs
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    public struct Shader
+    {
+        public int ID { get; set; }
+
+        public Shader(int id)
+            : this()
+        {
+            ID = id;
+        }
+    }
+}
diff --git a/KAOS/Utilities/Sprite.cs b/KAOS/Utilities/Sprite.cs
new file mode 100644
index 0000000..8ce0c32
--- /dev/null
+++ b/KAOS/Utilities/Sprite.cs
@@ -0,0 +1,117 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public class Sprite
+    {
+        internal const int VertexAmount = 6;
+        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
+        Color4[] vertexColours = new Color4[VertexAmount];
+        Vector2[] vertexUVs = new Vector2[VertexAmount];
+        Texture texture = new Texture();
+
+        public Texture Texture
+        {
+            get { return texture; }
+            set
+            {
+                texture = value;
+
+                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
+            }
+        }
+        public Vector3d[] VertexPositions { get { return vertexPositions; } }
+
+        public Color4[] VertexColours { get { return vertexColours; } }
+
+        public Vector2[] VertexUVs { get { return vertexUVs; } }
+
+        public Sprite()
+        {
+            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
+            //SetColour(new Color4(1, 1, 1, 1));
+            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
+        }
+
+        private Vector3d GetCentre()
+        {
+            double halfWidth = GetWidth() / 2;
+            double halfHeight = GetHeight() / 2;
+
+            return new Vector3d(
+                vertexPositions[0].X + halfWidth,
+                vertexPositions[0].Y - halfHeight,
+                vertexPositions[0].Z);
+        }
+
+        private void InitVertexPositions(Vector3d position, double width, double height)
+        {
+            double halfWidth = width / 2;
+            double halfHeight = height / 2;
+
+            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
+            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+
+            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
+            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
+            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
+        }
+
+        public double GetWidth()
+        {
+            //top right -> top left
+            return vertexPositions[1].X - vertexPositions[0].X;
+        }
+
+        public double GetHeight()
+        {
+            //top left -> bottom left
+            return vertexPositions[0].Y - vertexPositions[2].Y;
+        }
+
+        public void SetWidth(double width)
+        {
+            InitVertexPositions(GetCentre(), width, GetHeight());
+        }
+
+        public void SetHeight(double height)
+        {
+            InitVertexPositions(GetCentre(), GetWidth(), height);
+        }
+
+        public void SetPosition(double x, double y)
+        {
+            SetPosition(new Vector3d(x, y, 0));
+        }
+
+        public void SetPosition(Vector3d position)
+        {
+            InitVertexPositions(position, GetWidth(), GetHeight());
+        }
+
+        public void SetColour(Color4 color4)
+        {
+            for (int i = 0; i < Sprite.VertexAmount; i++)
+            {
+                vertexColours[i] = color4;
+            }
+        }
+
+        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
+        {
+            vertexUVs[0] = topLeft;
+            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
+
+            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
+            vertexUVs[4] = bottomRight;
+            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
+        }
+    }
+}
diff --git a/KAOS/Utilities/Texture.cs b/KAOS/Utilities/Texture.cs
new file mode 100644
index 0000000..fffdeb7
--- /dev/null
+++ b/KAOS/Utilities/Texture.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct Texture
+    {
+        public int ID { get; set; }
+        public int Width { get; set; }
+        public int Height { get; set; }
+
+        public Texture(int id, int width, int height) :this()
+        {
+            ID = id;
+            Width = width;
+            Height = Height;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b08644818f581c545f87f31066efcf8bd41b8982">Removing unnecessary files.</a>  -  b086448</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 22 files changed, 504 deletions(-)

diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/Dependencies/OpenTK/1.1/Debug/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl b/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/Dependencies/OpenTK/1.1/Release/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d427122cbfb9b0ce19ce4b2de1676b20466c650c">Stock shaders.</a>  -  d427122</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 5 files changed, 37 insertions(+), 70 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 8751f33..c367b99 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -79,3 +79,4 @@ namespace KAOS
         {
-            ShaderManager.LoadDefaultShaderProgram();
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
         }
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
index ab00068..92525db 100644
--- a/KAOS/Managers/ShaderManager.cs
+++ b/KAOS/Managers/ShaderManager.cs
@@ -18,6 +18,6 @@ namespace KAOS.Managers
         private static string defaultDataPath = "Data/Shaders/";
-        private static string m_vertexShaderFile = "opentk-vs";
-        private static string m_fragmentShaderFile = "opentk-fs";
+        private static string m_vertexShaderFile = "skybox-vs";
+        private static string m_fragmentShaderFile = "skybox-fs";
 
-        internal static void LoadDefaultShaderProgram()
+        internal static void LoadDefaultSkyboxShader()
         {
@@ -26,3 +26,13 @@ namespace KAOS.Managers
             m_programHandle = BuildProgram();
-            m_shaderStorage.Add("default", new Shader(m_programHandle));
+            m_shaderStorage.Add("skybox", new Shader(m_programHandle));
+        }
+
+        internal static void LoadDefaultRenderShader()
+        {
+            m_vertexShaderFile = "render-vs";
+            m_fragmentShaderFile = "render-fs";
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("render", new Shader(m_programHandle));
         }
@@ -38,3 +48,11 @@ namespace KAOS.Managers
 
-        public static Shader DefaultShader
+        public static Shader Skybox
+        {
+            get
+            {
+                return Get("skybox");
+            }
+        }
+
+        public static Shader Render
         {
@@ -42,3 +60,3 @@ namespace KAOS.Managers
             {
-                return m_shaderStorage["default"];
+                return Get("render");
             }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 59095f9..f59dbb5 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -20,48 +20,2 @@ namespace KAOS.States
 
-        // Data layout for each line below is:
-        // position{XYZ},			    normal{XYZ},
-        float[] vertexData = new float[] {
-            0.5f, -0.5f, -0.5f,        -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, -0.5f,         -1.0f, 0.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          -1.0f, 0.0f, 0.0f,
-  
-            0.5f, 0.5f, -0.5f,         0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            0.5f, 0.5f, 0.5f,          0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, -1.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, -1.0f, 0.0f,
-  
-            -0.5f, 0.5f, -0.5f,        1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, 0.5f, 0.5f,         1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, -0.5f,       1.0f, 0.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        1.0f, 0.0f, 0.0f,
-  
-            -0.5f, -0.5f, -0.5f,       0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, -0.5f,        0.0f, 1.0f, 0.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 1.0f, 0.0f,
-  
-            0.5f, 0.5f, 0.5f,          0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            0.5f, -0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, 0.5f, 0.5f,         0.0f, 0.0f, -1.0f,
-            -0.5f, -0.5f, 0.5f,        0.0f, 0.0f, -1.0f,
-  
-            0.5f, -0.5f, -0.5f,        0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            0.5f, 0.5f, -0.5f,         0.0f, 0.0f, 1.0f,
-            -0.5f, -0.5f, -0.5f,       0.0f, 0.0f, 1.0f,
-            -0.5f, 0.5f, -0.5f,        0.0f, 0.0f, 1.0f
-        };
-
         static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
@@ -80,3 +34,2 @@ namespace KAOS.States
         Vector3 trans;
-
         
@@ -94,3 +47,3 @@ namespace KAOS.States
             LoadCubeMap();
-            CreateShaders();
+            QueryShaders();
 
@@ -102,14 +55,9 @@ namespace KAOS.States
 
-        private void CreateShaders()
+        private void QueryShaders()
         {
-            ShaderManager.LoadCustomProgram("Skybox", "skybox-vs", "skybox-fs");
-
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "eye_position");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Get("Skybox").ID, "view_matrix");
-
-            Logger.WriteLine("Render Shader");
-            ShaderManager.LoadCustomProgram("Render", "render-vs", "render-fs");
+            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Skybox.ID, "eye_position");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
 
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Get("Render").ID, "mv_matrix");
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
+            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
         }
@@ -136,4 +84,4 @@ namespace KAOS.States
 
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Get("Skybox").ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Get("Render").ID);
+            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
+            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
         }
@@ -159,3 +107,3 @@ namespace KAOS.States
             GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Get("Render").ID);
+            GL.UseProgram(ShaderManager.Render.ID);
 
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
index 917dae0..d65f97f 100644
--- a/KAOS/States/VboState.cs
+++ b/KAOS/States/VboState.cs
@@ -32,3 +32,3 @@ namespace KAOS.States
 
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.DefaultShader.ID);
+            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
             m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 903fe15..310a609 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -40,3 +40,3 @@ namespace KAOS.Utilities
 
-            GL.UseProgram(ShaderManager.Get("Skybox").ID);
+            GL.UseProgram(ShaderManager.Skybox.ID);
             GL.ActiveTexture(TextureUnit.Texture0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/14826e61341ecb93925284b683c889541c1102b2">Tidying up files.</a>  -  14826e6</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 3 files changed, 4 insertions(+), 39 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index c367b99..9b52faf 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -39,3 +39,3 @@ namespace KAOS
         protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected PreciseTimer m_Timer;
+        protected AnimationTimer m_Timer;
 
@@ -74,3 +74,3 @@ namespace KAOS
         {
-            m_Timer = new PreciseTimer();
+            m_Timer = new AnimationTimer();
         }
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
index 9d28a68..8de3bf5 100644
--- a/KAOS/Utilities/AnimationTimer.cs
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -8,3 +8,3 @@ namespace KAOS.Utilities
 {
-    public class PreciseTimer
+    public class AnimationTimer
     {
@@ -21,3 +21,3 @@ namespace KAOS.Utilities
 
-        public PreciseTimer()
+        public AnimationTimer()
         {
diff --git a/KAOS/Utilities/CustomVertexStruct.cs b/KAOS/Utilities/CustomVertexStruct.cs
deleted file mode 100644
index e3d3585..0000000
--- a/KAOS/Utilities/CustomVertexStruct.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.InteropServices;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public struct AWVertex
-    {
-        /// <summary>
-        /// Defines the size of the AWVertex struct in bytes.
-        /// </summary>
-        public static readonly int SizeInBytes = Marshal.SizeOf(new AWVertex());
-        private Vector3[] vector31;
-        private Vector3[] vector32;
-        private int[] p;
-
-        public Vector3[] Postions { get; set; }
-
-        public Vector3[] Normals {get; set;}
-
-        public int[] Colors {get; set;}
-
-        public AWVertex(Vector3[] positions, Vector3[] nomarls, int[] colors) :this()
-        {
-            Postions = positions;
-            Normals = nomarls;
-            Colors = colors;
-        }
-
-            
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7ee6581c87a87eaf90bf19b0b58eabfe138bee33">moved assimp example code out of main class</a>  -  7ee6581</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 2 files changed, 303 insertions(+), 358 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 9b52faf..428ad86 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -1,5 +1,2 @@
-﻿using Assimp;
-using Assimp.Configs;
-using KAOS.Managers;
-using KAOS.Nodes;
+﻿using KAOS.Managers;
 using KAOS.Utilities;
@@ -10,12 +7,3 @@ using OpenTK.Input;
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
 using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using System.Timers;
 using System.Windows.Forms;
@@ -40,8 +28,2 @@ namespace KAOS
         protected AnimationTimer m_Timer;
-
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private Scene m_model;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
         
@@ -85,32 +67,2 @@ namespace KAOS
 
-        //private void CreateShaders()
-        //{
-        //    shaderManager = new ShaderManager("opentk-vs", "opentk-fs");
-
-        //    GL.UseProgram(shaderManager.ProgramHandle);
-        //    QueryMatrixLocations();
-
-        //    float aspect = ScreenWidth / (float)(ScreenHeight);
-        //    SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
-        //    SetModelviewMatrix(Matrix4.CreateRotationX(0.5f) * Matrix4.CreateTranslation(0, 0, -4));
-        //}
-
-        //protected void QueryMatrixLocations()
-        //{
-        //    projectionMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "projection_matrix");
-        //    modelviewMatrixLocation = GL.GetUniformLocation(shaderManager.ProgramHandle, "modelview_matrix");
-        //}
-
-        //protected void SetModelviewMatrix(Matrix4 matrix)
-        //{
-        //    modelviewMatrix = matrix;
-        //    GL.UniformMatrix4(modelviewMatrixLocation, false, ref modelviewMatrix);
-        //}
-
-        //protected void SetProjectionMatrix(Matrix4 matrix)
-        //{
-        //    projectionMatrix = matrix;
-        //    GL.UniformMatrix4(projectionMatrixLocation, false, ref projectionMatrix);
-        //}
-
         #endregion
@@ -130,3 +82,2 @@ namespace KAOS
 
-            //setmodelviewmatrix(matrix4.createrotationy((float)e.time) * modelviewmatrix);
             #endregion
@@ -150,42 +101,3 @@ namespace KAOS
 
-            //GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-
-            //SetModelviewMatrix(camera.GetViewMatrix());
-
-            // Single call to StateRenderer to take place here.
-
-            #region Assimp Example Code
-            //GL.Enable(EnableCap.Texture2D);
-            //GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            //GL.Enable(EnableCap.Lighting);
-            //GL.Enable(EnableCap.Light0);
-            //GL.Enable(EnableCap.DepthTest);
-            //GL.Enable(EnableCap.Normalize);
-            //GL.FrontFace(FrontFaceDirection.Ccw);
-
-            //GL.MatrixMode(MatrixMode.Modelview);
-            //Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            //GL.LoadMatrix(ref lookat);
-
-            //GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            //float tmp = m_sceneMax.X - m_sceneMin.X;
-            //tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            //tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            //tmp = 1.0f / tmp;
-            //GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            //GL.Translate(-m_sceneCenter);
-
-            //if (m_displayList == 0)
-            //{
-            //    m_displayList = GL.GenLists(1);
-            //    GL.NewList(m_displayList, ListMode.Compile);
-            //    RecursiveRender(m_model, m_model.RootNode);
-            //    GL.EndList();
-            //}
-
-            //GL.CallList(m_displayList); 
-            #endregion
+            
 
@@ -204,3 +116,2 @@ namespace KAOS
             float aspect = ScreenWidth / (float)ScreenHeight;
-            //SetProjectionMatrix(Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 100));
 
@@ -215,9 +126,2 @@ namespace KAOS
 
-        #region GameWindow.Dispose
-        public override void Dispose()
-        {
-            
-        } 
-        #endregion
-
         #region Input Control
@@ -259,255 +163,2 @@ namespace KAOS
 
-        #region Assimp example code
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-
-        #endregion
-
         protected override void OnUnload(EventArgs e)
@@ -515,3 +166,3 @@ namespace KAOS
             base.OnUnload(e);
-            GL.DeleteTexture(m_texId);
+            GL.DeleteTexture(Renderer.m_texId);
         }
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 310a609..fa734d6 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -1,2 +1,3 @@
-﻿using KAOS.Managers;
+﻿using Assimp;
+using KAOS.Managers;
 using OpenTK;
@@ -5,2 +6,6 @@ using OpenTK.Graphics.OpenGL;
 using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Reflection;
 
@@ -11,4 +16,9 @@ namespace KAOS.Utilities
         internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition;
-        internal static int handle_projectionMatrix, handle_modelViewProjectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix;
+        internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
+        internal static int
+            handle_projectionMatrix,
+            handle_modelViewProjectionMatrix,
+            handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, m_displayList, m_texId;
+        internal static Scene m_model;
+        internal static float m_angle;
 
@@ -24,3 +34,3 @@ namespace KAOS.Utilities
             GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(PrimitiveType.Triangles);
+            GL.Begin(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles);
             for (int i = 0; i < Sprite.VertexAmount; i++)
@@ -56,3 +66,3 @@ namespace KAOS.Utilities
         {
-            
+
         }
@@ -64,2 +74,37 @@ namespace KAOS.Utilities
 
+        public static void DrawModel()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
+        }
+
         internal static void ToggleWireframeOn()
@@ -73,3 +118,252 @@ namespace KAOS.Utilities
         }
+
+        private static void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private static void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        private static void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private static void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private static void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private static Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private static Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private static Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
     }
-}
+}
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/eeaaeb9e1f786f42bdbdd1364bc4b40807d96995">credited neokabuto for the Camera of his i am using.</a>  -  eeaaeb9</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index 59ace7e..998414d 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -10,3 +10,3 @@ namespace KAOS.Utilities
     /// <summary>
-    /// Camera
+    /// Camera: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html (slightly modified)
     /// </summary>
@@ -14,4 +14,4 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, 0f);
-        public static Vector3 Orientation = new Vector3(0f, 0f, 0f);
+        public static Vector3 Position = new Vector3(0f, 0f, -4f);
+        public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
         public static float MoveSpeed = 0.2f;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e9eb9be2e2030f24b34a564ef8730a58c53fc8cf">Inverted camera view matrix, think it has helped.</a>  -  e9eb9be</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index f59dbb5..3bf13db 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -93,4 +93,4 @@ namespace KAOS.States
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-            
-            Renderer.viewMatrix = Camera.GetViewMatrix();
+
+            Renderer.viewMatrix = Matrix4.Invert(Camera.GetViewMatrix());
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0d020599038f599f302abe078654c8794f7edfe6">~</a>  -  0d02059</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index 998414d..c60cfeb 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, -4f);
+        public static Vector3 Position = new Vector3(0f, 0f, -2f);
         public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/bb9086974f6d6322a2f1fcdded5819e83cc7929a">Mandelbrot shader.</a>  -  bb90869</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 4 files changed, 68 insertions(+), 6 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index b9c351c..96379f0 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -2,2 +2,7 @@
 
+uniform sampler1D tex;
+uniform vec2 center;
+uniform float scale;
+uniform int iter;
+
 uniform samplerCube tex_cubemap;
@@ -6,3 +11,3 @@ const vec3 ambient = vec3(0.1, 0.1, 0.1);
 const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
+const vec3 lightColor = vec3(0.8, 0.2, 0.8);
 
@@ -20,10 +25,29 @@ void main(void)
     // at the fragment
-    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+    //vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
 
     // Sample from scaled using reflection vector
-     color = texture(tex_cubemap, r);
+    // color = texture(tex_cubemap, r);
+
+	//float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+
+	//color = color * vec4(ambient + diffuse * lightColor, 1.0);
+
+
+	vec2 z, c;
+
+    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
+    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
+
+    int i;
+    z = c;
+    for(i=0; i<iter; i++) {
+        float x = (z.x * z.x - z.y * z.y) + c.x;
+        float y = (z.y * z.x + z.x * z.y) + c.y;
 
-	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+        if((x * x + y * y) > 4.0) break;
+        z.x = x;
+        z.y = y;
+    }
 
-	color = color * vec4(ambient + diffuse * lightColor, 1.0);
-}
+    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
+}
\ No newline at end of file
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 0970750..7839198 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -44,2 +44,25 @@ namespace KAOS.Managers
 
+        public void LoadTexture1D(string textureId, string path)
+        {
+            if (string.IsNullOrEmpty(path))
+                throw new ArgumentException(path);
+
+            GL.GenTextures(1, out textureGpuHandle);
+            GL.BindTexture(TextureTarget.Texture1D, textureGpuHandle);
+
+            OpenImageFile(path);
+
+            GL.TexImage1D(TextureTarget.Texture1D,
+                0, PixelInternalFormat.Rgba, bitmapData.Width, 0,
+                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, bitmapData.Scan0);
+
+            CloseImageFile();
+
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture1D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.Repeat);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+        }
+
         public void LoadSkyTexture(string textureId, string[] path)
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 3bf13db..e148df0 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -46,2 +46,4 @@ namespace KAOS.States
 
+            m_textureManager.LoadTexture1D("1d", "pal.bmp");
+
             LoadCubeMap();
@@ -62,2 +64,6 @@ namespace KAOS.States
             Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
+
+            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
+            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
+            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
         }
@@ -111,2 +117,8 @@ namespace KAOS.States
             GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.Uniform1(Renderer.handle_iter, 70);
+            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
+            GL.Uniform1(Renderer.handle_scale, 2.2);
+
+
+            GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
 
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index fa734d6..63cb8b8 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -23,2 +23,5 @@ namespace KAOS.Utilities
         internal static float m_angle;
+        public static int handle_centre;
+        public static int handle_scale;
+        public static int handle_iter;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f880fee4a5a2cf3eab9bbbfdf494d4f0775559f4">credited mandelbrot shader code + screenshots</a>  -  f880fee</p><p>authored by Anthony Woodward, 7 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 96379f0..5e99dcd 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -34,2 +34,3 @@ void main(void)
 
+	// see: http://nuclear.mutantstargoat.com/articles/sdr_fract/
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a2963b715d1768efa5223e13d4031d6886a31209">Integrating VertexStructs with object Manager.</a>  -  a2963b7</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 12 files changed, 276 insertions(+), 193 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
new file mode 100644
index 0000000..5eee4a3
--- /dev/null
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -0,0 +1,16 @@
+﻿using KAOS.Shapes;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface IDrawableShape
+    {
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
+        void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
+    }
+}
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 5ad5904..afca0fd 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -1,2 +1,4 @@
-﻿using KAOS.Utilities;
+﻿using KAOS.Interfaces;
+using KAOS.Shapes;
+using KAOS.Utilities;
 using OpenTK;
@@ -12,4 +14,25 @@ namespace KAOS.Managers
 
-        public void AddBufferObject(string name, BufferObject bufferObject, int program)
+        public void AddBufferObject(string name, IDrawableShape shape, int program)
         {
+            BufferObject bufferObject = new BufferObject();
+            //bufferObject.PositionData = new Vector3d[1];
+            //bufferObject.NormalsData = new Vector3d[1];
+            VertexT2dN3dV3d[] vertexData;
+            uint[] indices;
+            BeginMode type;
+
+            shape.GetArraysforVBO(out type, out vertexData, out indices);
+            for (int i = 0; i < vertexData.Length; i++)
+            {
+                if (i == 0)
+                {
+                    bufferObject.PositionData = new Vector3d[]{ vertexData[i].Position};
+                    bufferObject.NormalsData = new Vector3d[]{ vertexData[i].Normal};
+                }
+                bufferObject.PositionData = bufferObject.PositionData.Concat(new Vector3d[]{ vertexData[i].Position});
+                bufferObject.NormalsData = bufferObject.NormalsData.Concat(new Vector3d[]{ vertexData[i].Normal});
+            }
+
+            bufferObject.IndicesData = indices;
+
             int bufferHandle;
@@ -17,4 +40,4 @@ namespace KAOS.Managers
             #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
+            int sizeOfPositionData = Vector3d.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3d.SizeInBytes * bufferObject.NormalsData.Length;
             //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
@@ -36,6 +59,6 @@ namespace KAOS.Managers
             // Send Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer, noOffset,
+            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer, noOffset,
                 new IntPtr(sizeOfPositionData), bufferObject.PositionData);
             // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3>(BufferTarget.ArrayBuffer,
+            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer,
                 new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
@@ -68,3 +91,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, 0);
             GL.BindAttribLocation(program, bufferHandle, "in_position");
@@ -74,3 +97,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, sizeOfPositionData);
             GL.BindAttribLocation(program, bufferHandle, "in_normal");
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index 0f9cd8a..44029e0 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -21,3 +21,3 @@ namespace KAOS.Shapes
 
-    public abstract class DrawableShape: IDisposable
+    public abstract class DrawableShape: IDisposable, KAOS.Interfaces.IDrawableShape
     {
diff --git a/KAOS/Shapes/Base/VertexStructs.cs b/KAOS/Shapes/Base/VertexStructs.cs
index 0f64155..e98d9d7 100644
--- a/KAOS/Shapes/Base/VertexStructs.cs
+++ b/KAOS/Shapes/Base/VertexStructs.cs
@@ -11,3 +11,3 @@ namespace KAOS.Shapes
 
-        public VertexT2dN3dV3d( Vector2d texcoord, Vector3d normal, Vector3d position )
+        public VertexT2dN3dV3d(Vector2d texcoord, Vector3d normal, Vector3d position)
         {
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
index 99c2d1b..7782558 100644
--- a/KAOS/Shapes/Old/Cube.cs
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -28,3 +28,3 @@ namespace KAOS.Shapes
 
-            Indices = new int[]
+            Indices = new uint[]
             {
diff --git a/KAOS/Shapes/Old/IsoSphere.cs b/KAOS/Shapes/Old/IsoSphere.cs
index 4b2ae9f..f3fe113 100644
--- a/KAOS/Shapes/Old/IsoSphere.cs
+++ b/KAOS/Shapes/Old/IsoSphere.cs
@@ -22,3 +22,3 @@ namespace KAOS.Shapes
             Texcoords = new Vector2[count];
-            Indices = new int[6 * count / 4];
+            Indices = new uint[6 * count / 4];
 
@@ -41,8 +41,8 @@ namespace KAOS.Shapes
             {
-                Indices[i] = i;
-                Indices[i + 1] = i + 1;
-                Indices[i + 2] = i + 2 * s_steps + 1;
-                Indices[i + 3] = i + 2 * s_steps;
-                Indices[i + 4] = i;
-                Indices[i + 5] = i + 2 * s_steps + 1;
+                Indices[i] = (uint)i;
+                Indices[i + 1] = (uint)i + 1;
+                Indices[i + 2] = (uint)(i + 2 * s_steps + 1);
+                Indices[i + 3] = (uint)(i + 2 * s_steps);
+                Indices[i + 4] = (uint)i;
+                Indices[i + 5] = (uint)(i + 2 * s_steps + 1);
             }
diff --git a/KAOS/Shapes/Old/Plane.cs b/KAOS/Shapes/Old/Plane.cs
index df9a78e..e8199db 100644
--- a/KAOS/Shapes/Old/Plane.cs
+++ b/KAOS/Shapes/Old/Plane.cs
@@ -20,3 +20,3 @@ namespace KAOS.Shapes
             Normals = new Vector3[x_res * y_res];
-            Indices = new int[6 * x_res * y_res];
+            Indices = new uint[6 * x_res * y_res];
             Texcoords = new Vector2[x_res * y_res];
@@ -42,9 +42,9 @@ namespace KAOS.Shapes
                 {
-                    Indices[i++] = (y + 0) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 0) * x_res + x + 1;
+                    Indices[i++] = (uint)((y + 0) * x_res + x);
+                    Indices[i++] = (uint)((y + 1) * x_res + x);
+                    Indices[i++] = (uint)((y + 0) * x_res + x + 1);
 
-                    Indices[i++] = (y + 0) * x_res + x + 1;
-                    Indices[i++] = (y + 1) * x_res + x;
-                    Indices[i++] = (y + 1) * x_res + x + 1;
+                    Indices[i++] = (uint)((y + 0) * x_res + x + 1);
+                    Indices[i++] = (uint)((y + 1) * x_res + x);
+                    Indices[i++] = (uint)((y + 1) * x_res + x + 1);
                 }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index c5315af..7a29b06 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -9,2 +9,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 
@@ -12,3 +13,3 @@ namespace KAOS.Shapes
 {
-    public abstract class Shape
+    public abstract class Shape : KAOS.Interfaces.IDrawableShape
     {
@@ -16,3 +17,3 @@ namespace KAOS.Shapes
         private Vector2[] texcoords;
-        private int[] indices;
+        private uint[] indices;
         private int[] colors;
@@ -46,3 +47,3 @@ namespace KAOS.Shapes
 
-        public int[] Indices
+        public uint[] Indices
         {
@@ -63,2 +64,47 @@ namespace KAOS.Shapes
         }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2dN3dV3d[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length ; i++)
+            {
+                //vertices[i].TexCoord = (Vector2d)Texcoords[i];
+                vertices[i].Normal = (Vector3d)Normals[i] ;
+                vertices[i].Position = (Vector3d)Vertices[i];
+            }
+
+            indices = Indices;
+        }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2fN3fV3f[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length; i++)
+            {
+                vertices[i].TexCoord = Texcoords[i];
+                vertices[i].Normal = Normals[i];
+                vertices[i].Position = Vertices[i];
+            }
+
+            indices = Indices;
+        }
+
+        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        {
+            primitives = BeginMode.TriangleStrip;
+
+            vertices = new VertexT2hN3hV3h[Vertices.Length];
+            for (uint i = 0; i < Vertices.Length; i++)
+            {
+                vertices[i].TexCoord = (Vector2h)Texcoords[i];
+                vertices[i].Normal = (Vector3h)Normals[i];
+                vertices[i].Position = (Vector3h) Vertices[i];
+            }
+
+            indices = Indices;
+        }
     }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index e148df0..d663b10 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,10 +84,8 @@ namespace KAOS.States
             cube = new Cube(0, 0, 0);
-            cubeObject = new BufferObject();
-            cubeObject.PositionData = cube.Vertices;
-            cubeObject.NormalsData = cube.Normals;
-            cubeObject.IndicesData = cube.Indices;
-            cubeObject.PrimitiveType = PrimitiveType.TriangleStrip;
-
-            m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
+            //m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Torus", new TorusKnot( 256, 32, 0.1, 3, 4, 1, true ), ShaderManager.Render.ID);
+
+            //m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
+            //m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
         }
@@ -111,3 +109,3 @@ namespace KAOS.States
             
-            cubeObject = m_bufferManager.GetBuffer("Cube");
+            cubeObject = m_bufferManager.GetBuffer("Torus");
             GL.BindVertexArray(cubeObject.VaoID);
@@ -122,5 +120,5 @@ namespace KAOS.States
 
-            GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
+            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
 
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            //GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
index d65f97f..7faddb3 100644
--- a/KAOS/States/VboState.cs
+++ b/KAOS/States/VboState.cs
@@ -1,51 +1,51 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VboState : IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-        Cube cube = new Cube(0, 0, 0);
-
-        public VboState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            CreateVBOs();
-        }
-
-        private void CreateVBOs()
-        {
-            BufferObject tempVBO = new BufferObject();
-            tempVBO.PositionData = cube.Vertices;
-            tempVBO.NormalsData = cube.Normals;
-            tempVBO.IndicesData = cube.Indices;
-            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-
-        public void Render()
-        {
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType,
-                            m_bufferObject.IndicesData.Length,
-                            DrawElementsType.UnsignedInt,
-                            IntPtr.Zero);
-        }
-    }
-}
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Shapes;
+//using KAOS.Utilities;
+//using OpenTK.Graphics.OpenGL;
+//using System;
+
+//namespace KAOS.States
+//{
+//    public class VboState : IGameObject
+//    {
+//        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
+
+//        BufferObject m_bufferObject;
+//        StateManager m_stateManager;
+//        Cube cube = new Cube(0, 0, 0);
+
+//        public VboState(StateManager stateManager)
+//        {
+//            m_stateManager = stateManager;
+
+//            CreateVBOs();
+//        }
+
+//        private void CreateVBOs()
+//        {
+//            BufferObject tempVBO = new BufferObject();
+//            tempVBO.PositionData = cube.Vertices;
+//            tempVBO.NormalsData = cube.Normals;
+//            tempVBO.IndicesData = cube.Indices;
+//            tempVBO.PrimitiveType = PrimitiveType.Triangles;
+
+//            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
+//            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
+//        }
+
+//        public void Update(float elapsedTime)
+//        {
+
+//        }
+
+//        public void Render()
+//        {
+//            GL.BindVertexArray(m_bufferObject.VaoID);
+//            GL.DrawElements(m_bufferObject.PrimitiveType,
+//                            m_bufferObject.IndicesData.Length,
+//                            DrawElementsType.UnsignedInt,
+//                            IntPtr.Zero);
+//        }
+//    }
+//}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
index e8b82e2..e6f0ee8 100644
--- a/KAOS/States/VoxelState.cs
+++ b/KAOS/States/VoxelState.cs
@@ -1,100 +1,100 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace KAOS.States
-{
-    public class VoxelState : IGameObject
-    {
-        double currentRotation = 0;
-        public float length = 1f, height = 1f, width = 1f;
-
-        StateManager m_stateManager = new StateManager();
-
-        BufferObjectManager m_bufferObjectManager;
-        BufferObject m_bufferObject;
-
-        TextureManager m_textureManager = new TextureManager();
-
-        Cube[][][] m_blocks;
-
-        public VoxelState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-
-            m_bufferObjectManager = new BufferObjectManager();
-
-            //LoadSkyBox();
-
-            GenerateChunk();
-        }
-
-        private void LoadSkyBox()
-        {
-            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-            m_textureManager.LoadSkyTexture("skybox", 
-                new string[] 
-                {
-                    skyboxTexturePath + "jajlands1_ft.jpg",
-                    skyboxTexturePath + "jajlands1_bk.jpg",
-                    skyboxTexturePath + "jajlands1_lf.jpg",
-                    skyboxTexturePath + "jajlands1_rt.jpg",
-                    skyboxTexturePath + "jajlands1_up.jpg",
-                    skyboxTexturePath + "jajlands1_dn.jpg"
-                }
-            );
-
-        }
-
-        private void GenerateChunk()
-        {
-            BufferObject tmpVBO = new BufferObject();
-            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Shapes;
+//using KAOS.Utilities;
+//using OpenTK.Graphics.OpenGL;
+//using System;
+
+//namespace KAOS.States
+//{
+//    public class VoxelState : IGameObject
+//    {
+//        double currentRotation = 0;
+//        public float length = 1f, height = 1f, width = 1f;
+
+//        StateManager m_stateManager = new StateManager();
+
+//        BufferObjectManager m_bufferObjectManager;
+//        BufferObject m_bufferObject;
+
+//        TextureManager m_textureManager = new TextureManager();
+
+//        Cube[][][] m_blocks;
+
+//        public VoxelState(StateManager stateManager)
+//        {
+//            m_stateManager = stateManager;
+
+//            m_bufferObjectManager = new BufferObjectManager();
+
+//            //LoadSkyBox();
+
+//            GenerateChunk();
+//        }
+
+//        private void LoadSkyBox()
+//        {
+//            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
+//            m_textureManager.LoadSkyTexture("skybox", 
+//                new string[] 
+//                {
+//                    skyboxTexturePath + "jajlands1_ft.jpg",
+//                    skyboxTexturePath + "jajlands1_bk.jpg",
+//                    skyboxTexturePath + "jajlands1_lf.jpg",
+//                    skyboxTexturePath + "jajlands1_rt.jpg",
+//                    skyboxTexturePath + "jajlands1_up.jpg",
+//                    skyboxTexturePath + "jajlands1_dn.jpg"
+//                }
+//            );
+
+//        }
+
+//        private void GenerateChunk()
+//        {
+//            BufferObject tmpVBO = new BufferObject();
+//            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
+//            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
             
-            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-            {
-                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-                {
-                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-                    {
-                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-                        if (x == 0 && y == 0 && z == 0) 
-                        { 
-                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-                        }
-                        else
-                        { 
-                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-                        }
-                    }
-                }
-            }
-
-            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 100 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-            GL.BindVertexArray(m_bufferObject.VaoID);
-            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-        }
-    }
-}
+//            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
+//            {
+//                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
+//                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
+//                {
+//                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
+//                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
+//                    {
+//                        m_blocks[x][y][z] = new Cube(x, y, z);
+
+//                        if (x == 0 && y == 0 && z == 0) 
+//                        { 
+//                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
+//                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
+//                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
+//                        }
+//                        else
+//                        { 
+//                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
+//                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
+//                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
+//                        }
+//                    }
+//                }
+//            }
+
+//            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
+//            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
+//        }
+
+//        public void Update(float elapsedTime)
+//        {
+//            currentRotation = 100 * elapsedTime;
+//        }
+
+//        public void Render()
+//        {
+//            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+//            GL.BindVertexArray(m_bufferObject.VaoID);
+//            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
+//        }
+//    }
+//}
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
index 18a1ea1..9e616c4 100644
--- a/KAOS/Utilities/BufferObject.cs
+++ b/KAOS/Utilities/BufferObject.cs
@@ -20,5 +20,5 @@ namespace KAOS.Utilities
 
-        public Vector3[] PositionData { get; set; }
+        public Vector3d[] PositionData { get; set; }
 
-        public Vector3[] NormalsData { get; set; }
+        public Vector3d[] NormalsData { get; set; }
 
@@ -26,6 +26,6 @@ namespace KAOS.Utilities
 
-        public int[] IndicesData { get; set; }
+        public uint[] IndicesData { get; set; }
 
         public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, int[] indicesData) :this()
+            Vector3d[] vPositionData, Vector3d[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/21bbf396f0d2f6a32716ff639e8cdc0b2fc94854">Removed unused methods.</a>  -  21bbf39</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 63cb8b8..d447a0a 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -62,3 +62,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(cubeObject.PrimitiveType, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -67,12 +67,2 @@ namespace KAOS.Utilities
 
-        public static void DrawWireframeVoxel(float length, float height, float width)
-        {
-
-        }
-
-        public static void DrawChunk(Chunk chunk)
-        {
-
-        }
-
         public static void DrawModel()

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/330e81cce73464af94dc1207102b3709ad596bb2">removing fractal</a>  -  330e81c</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 5e99dcd..028e794 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -25,10 +25,10 @@ void main(void)
     // at the fragment
-    //vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
+    vec3 r = reflect(fs_in.view, normalize(fs_in.normal));
 
     // Sample from scaled using reflection vector
-    // color = texture(tex_cubemap, r);
+     color = texture(tex_cubemap, r);
 
-	//float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
+	float diffuse = clamp(dot(lightVecNormalized, normalize(fs_in.normal)), 0.0, 1.0);
 
-	//color = color * vec4(ambient + diffuse * lightColor, 1.0);
+	color = color * vec4(ambient + diffuse * lightColor, 1.0);
 
@@ -52,3 +52,3 @@ void main(void)
 
-    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
+    //gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);
 }
\ No newline at end of file
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d663b10..8b45f92 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -122,3 +122,3 @@ namespace KAOS.States
 
-            //GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1532475fa877dd12e93a9a639fc981eadd7b97f0">Narrowed down the issue to being caused by torus buffer conflicting with the cube buffer.</a>  -  1532475</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 7 files changed, 125 insertions(+), 100 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
index 5eee4a3..12f5eeb 100644
--- a/KAOS/Interfaces/IDrawableShape.cs
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -1,2 +1,3 @@
 ﻿using KAOS.Shapes;
+using OpenTK;
 using OpenTK.Graphics.OpenGL;
@@ -11,2 +12,7 @@ namespace KAOS.Interfaces
     {
+        Vector3[] Vertices { get; }
+        Vector3[] Normals { get; }
+        Vector2[] Texcoords { get; }
+        uint[] Indices { get; }
+
         void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index afca0fd..b045393 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -19,19 +19,11 @@ namespace KAOS.Managers
             //bufferObject.NormalsData = new Vector3d[1];
-            VertexT2dN3dV3d[] vertexData;
-            uint[] indices;
-            BeginMode type;
-
-            shape.GetArraysforVBO(out type, out vertexData, out indices);
-            for (int i = 0; i < vertexData.Length; i++)
-            {
-                if (i == 0)
-                {
-                    bufferObject.PositionData = new Vector3d[]{ vertexData[i].Position};
-                    bufferObject.NormalsData = new Vector3d[]{ vertexData[i].Normal};
-                }
-                bufferObject.PositionData = bufferObject.PositionData.Concat(new Vector3d[]{ vertexData[i].Position});
-                bufferObject.NormalsData = bufferObject.NormalsData.Concat(new Vector3d[]{ vertexData[i].Normal});
-            }
-
-            bufferObject.IndicesData = indices;
+            //VertexT2fN3fV3f[] vertexData;
+            //uint[] indices;
+            //BeginMode type;
+
+            //shape.GetArraysforVBO(out type, out vertexData, out indices);
+
+            bufferObject.PositionData = shape.Vertices;
+            bufferObject.NormalsData = shape.Normals;
+            bufferObject.IndicesData = shape.Indices;
 
@@ -40,4 +32,4 @@ namespace KAOS.Managers
             #region Get sizes of buffer stores
-            int sizeOfPositionData = Vector3d.SizeInBytes * bufferObject.PositionData.Length;
-            int sizeOfNormalsData = Vector3d.SizeInBytes * bufferObject.NormalsData.Length;
+            int sizeOfPositionData = Vector3.SizeInBytes * bufferObject.PositionData.Length;
+            int sizeOfNormalsData = Vector3.SizeInBytes * bufferObject.NormalsData.Length;
             //int sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
@@ -59,7 +51,7 @@ namespace KAOS.Managers
             // Send Position data.
-            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer, noOffset,
-                new IntPtr(sizeOfPositionData), bufferObject.PositionData);
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, noOffset, new IntPtr(sizeOfPositionData), bufferObject.PositionData);
             // Send Normals data, offset by size of Position data.
-            GL.BufferSubData<Vector3d>(BufferTarget.ArrayBuffer,
-                new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), bufferObject.NormalsData);
             
@@ -67,5 +59,4 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ElementArrayBuffer, bufferHandle);
-            GL.BufferData(BufferTarget.ElementArrayBuffer, 
-                new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), 
-                bufferObject.IndicesData, BufferUsageHint.StaticDraw);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, new IntPtr(sizeof(uint) * bufferObject.IndicesData.Length), bufferObject.IndicesData, BufferUsageHint.StaticDraw);
 
@@ -91,3 +82,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, 0);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
             GL.BindAttribLocation(program, bufferHandle, "in_position");
@@ -97,3 +88,3 @@ namespace KAOS.Managers
             GL.BindBuffer(BufferTarget.ArrayBuffer, bufferObject.VboID);
-            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3d.SizeInBytes, sizeOfPositionData);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
             GL.BindAttribLocation(program, bufferHandle, "in_normal");
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index 44029e0..a35c1cd 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -179,2 +179,49 @@ namespace KAOS.Shapes
         #endregion
+
+        public Vector3[] Normals
+        {
+            get
+            {
+                Vector3[] normals = new Vector3[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    normals[i] = (Vector3)VertexArray[i].Normal;
+                }
+                return normals;
+            }
+        }
+
+        public Vector2[] Texcoords
+        {
+            get
+            {
+                Vector2[] vertices = new Vector2[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    vertices[i] = (Vector2)VertexArray[i].TexCoord;
+                }
+                return vertices;
+            }
+        }
+
+        public uint[] Indices
+        {
+            get
+            {
+                return IndexArray;
+            }
+        }
+
+        public Vector3[] Vertices
+        {
+            get
+            {
+                Vector3[] postion = new Vector3[VertexArray.Length];
+                for (uint i = 0; i < VertexArray.Length; i++)
+                {
+                    postion[i] = (Vector3)VertexArray[i].Position;
+                }
+                return postion;
+            }
+        }
     }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 7a29b06..620b11f 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -23,6 +23,3 @@ namespace KAOS.Shapes
             get { return vertices; }
-            protected set
-            {
-                vertices = value;
-            }
+            set { vertices = value; }
         }
@@ -32,6 +29,3 @@ namespace KAOS.Shapes
             get { return normals; }
-            protected set
-            {
-                normals = value;
-            }
+            set { normals = value; }
         }
@@ -41,6 +35,3 @@ namespace KAOS.Shapes
             get { return texcoords; }
-            protected set
-            {
-                texcoords = value;
-            }
+            set { texcoords = value; }
         }
@@ -50,6 +41,3 @@ namespace KAOS.Shapes
             get { return indices; }
-            protected set
-            {
-                indices = value;
-            }
+            set { indices = value; }
         }
@@ -87,3 +75,3 @@ namespace KAOS.Shapes
             {
-                vertices[i].TexCoord = Texcoords[i];
+                //vertices[i].TexCoord = Texcoords[i];
                 vertices[i].Normal = Normals[i];
@@ -102,3 +90,3 @@ namespace KAOS.Shapes
             {
-                vertices[i].TexCoord = (Vector2h)Texcoords[i];
+                //vertices[i].TexCoord = (Vector2h)Texcoords[i];
                 vertices[i].Normal = (Vector3h)Normals[i];
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 8b45f92..79bb852 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -18,3 +18,2 @@ namespace KAOS.States
         Cube cube;
-        BufferObject cubeObject;
 
@@ -31,7 +30,3 @@ namespace KAOS.States
 
-        Matrix3 modelMatrix3, normalMatrix;
-        Vector3 eyeObjectSpace;
-        Vector3 trans;
-        
-        int eye_handle, skybox_vao;
+        int skybox_vao;
 
@@ -52,3 +47,2 @@ namespace KAOS.States
             _rotation = MathHelper.DegreesToRadians(90);
-            trans = new Vector3(0f, 0f, -10f);
 
@@ -85,7 +79,4 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
-            //m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
-            m_bufferManager.AddBufferObject("Torus", new TorusKnot( 256, 32, 0.1, 3, 4, 1, true ), ShaderManager.Render.ID);
-
-            //m_bufferManager.AddBufferObject("SkyCube", cubeObject, ShaderManager.Skybox.ID);
-            //m_bufferManager.AddBufferObject("Cube", cubeObject, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Torus", new TorusKnot(256, 32, 0.1, 3, 4, 1, false), ShaderManager.Render.ID); 
+            m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
         }
@@ -106,19 +97,4 @@ namespace KAOS.States
         {
-            cubeObject = m_bufferManager.GetBuffer("SkyCube");
-            Renderer.DrawSkyBox(m_textureManager, cubeObject);
-            
-            cubeObject = m_bufferManager.GetBuffer("Torus");
-            GL.BindVertexArray(cubeObject.VaoID);
-            GL.UseProgram(ShaderManager.Render.ID);
-
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
-            GL.Uniform1(Renderer.handle_iter, 70);
-            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
-            GL.Uniform1(Renderer.handle_scale, 2.2);
-
-
-            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
-
-            GL.DrawElements(PrimitiveType.Triangles, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Cube"));
         }
diff --git a/KAOS/Utilities/BufferObject.cs b/KAOS/Utilities/BufferObject.cs
index 9e616c4..0c591c0 100644
--- a/KAOS/Utilities/BufferObject.cs
+++ b/KAOS/Utilities/BufferObject.cs
@@ -20,5 +20,5 @@ namespace KAOS.Utilities
 
-        public Vector3d[] PositionData { get; set; }
+        public Vector3[] PositionData { get; set; }
 
-        public Vector3d[] NormalsData { get; set; }
+        public Vector3[] NormalsData { get; set; }
 
@@ -29,3 +29,3 @@ namespace KAOS.Utilities
         public BufferObject(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
-            Vector3d[] vPositionData, Vector3d[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
         {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index d447a0a..bf15170 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -15,13 +15,12 @@ namespace KAOS.Utilities
     {
-        internal static Matrix4 projectionMatrix, modelViewProjectionMatrix, modelViewMatrix, viewMatrix;
+        #region Members
+        internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
         internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
-        internal static int
-            handle_projectionMatrix,
-            handle_modelViewProjectionMatrix,
-            handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, m_displayList, m_texId;
+        internal static int handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
+            m_displayList, m_texId, 
+            handle_centre, handle_scale, handle_iter;
+
         internal static Scene m_model;
         internal static float m_angle;
-        public static int handle_centre;
-        public static int handle_scale;
-        public static int handle_iter;
+        #endregion
 
@@ -48,3 +47,3 @@ namespace KAOS.Utilities
 
-        public static void DrawSkyBox(TextureManager m_textureManager, BufferObject cubeObject)
+        public static void DrawSkyBox(TextureManager textureManager, BufferObject Object)
         {
@@ -55,5 +54,5 @@ namespace KAOS.Utilities
             GL.ActiveTexture(TextureUnit.Texture0);
-            GL.BindTexture(TextureTarget.TextureCubeMap, m_textureManager.Get("skybox1").ID);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureManager.Get("skybox1").ID);
 
-            GL.BindVertexArray(cubeObject.VaoID);
+            GL.BindVertexArray(Object.VaoID);
             GL.Disable(EnableCap.DepthTest);
@@ -62,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, cubeObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, Object.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -67,2 +66,29 @@ namespace KAOS.Utilities
 
+        public static void DrawObject(TextureManager textureManager, BufferObject bufferObject)
+        {
+
+            GL.BindVertexArray(bufferObject.VaoID);
+            GL.UseProgram(ShaderManager.Render.ID);
+
+            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
+            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.Uniform1(Renderer.handle_iter, 70);
+            GL.Uniform2(Renderer.handle_centre, 0f, 0f);
+            GL.Uniform1(Renderer.handle_scale, 2.2);
+
+            //GL.BindTexture(TextureTarget.Texture1D, m_textureManager.Get("1d").ID);
+
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+        }
+        internal static void ToggleWireframeOn()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+        }
+
+        internal static void ToggleWireframeOff()
+        {
+            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+        }
+
+        #region Assimp Example
         public static void DrawModel()
@@ -102,12 +128,2 @@ namespace KAOS.Utilities
 
-        internal static void ToggleWireframeOn()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-        }
-
-        internal static void ToggleWireframeOff()
-        {
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-        }
-
         private static void ComputeBoundingBox()
@@ -360,2 +376,3 @@ namespace KAOS.Utilities
         }
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/262f8a35b7afc9e87eeaac3d0dfc713936edab6b">This fixes an issue I have been experiencing caused by not unbinding vao's upon completing setting it up.</a>  -  262f8a3</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index b045393..7a36acd 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -93,3 +93,4 @@ namespace KAOS.Managers
 
-            GL.BindVertexArray(bufferObject.VaoID);
+            // IMPORTANT: vertex array needs unbinding here to avoid rendering incorrectly
+            GL.BindVertexArray(0);
 
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 79bb852..1b9492f 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -41,3 +41,3 @@ namespace KAOS.States
 
-            m_textureManager.LoadTexture1D("1d", "pal.bmp");
+            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
 
@@ -79,4 +79,3 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("Torus", new TorusKnot(256, 32, 0.1, 3, 4, 1, false), ShaderManager.Render.ID); 
-            m_bufferManager.AddBufferObject("Cube", cube, ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
         }
@@ -98,3 +97,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Cube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
         }
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index bf15170..cbb0d0b 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -47,3 +47,3 @@ namespace KAOS.Utilities
 
-        public static void DrawSkyBox(TextureManager textureManager, BufferObject Object)
+        public static void DrawSkyBox(TextureManager textureManager, BufferObject bufferObject)
         {
@@ -56,3 +56,3 @@ namespace KAOS.Utilities
 
-            GL.BindVertexArray(Object.VaoID);
+            GL.BindVertexArray(bufferObject.VaoID);
             GL.Disable(EnableCap.DepthTest);
@@ -61,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, Object.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -68,8 +68,7 @@ namespace KAOS.Utilities
         {
-
-            GL.BindVertexArray(bufferObject.VaoID);
             GL.UseProgram(ShaderManager.Render.ID);
+            GL.BindVertexArray(bufferObject.VaoID);
 
-            GL.UniformMatrix4(Renderer.handle_modelViewMatrix, false, ref Renderer.modelViewMatrix);
-            GL.UniformMatrix4(Renderer.handle_projectionMatrix, false, ref Renderer.projectionMatrix);
+            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+            GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);
             GL.Uniform1(Renderer.handle_iter, 70);
@@ -80,3 +79,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/84c7766bd6c13e08423994d9146c318d6f716262">Refactoring.</a>  -  84c7766</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index a35c1cd..ea2284f 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -197,8 +197,8 @@ namespace KAOS.Shapes
             {
-                Vector2[] vertices = new Vector2[VertexArray.Length];
+                Vector2[] texCoords = new Vector2[VertexArray.Length];
                 for (uint i = 0; i < VertexArray.Length; i++)
                 {
-                    vertices[i] = (Vector2)VertexArray[i].TexCoord;
+                    texCoords[i] = (Vector2)VertexArray[i].TexCoord;
                 }
-                return vertices;
+                return texCoords;
             }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 620b11f..8660961 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -23,3 +23,3 @@ namespace KAOS.Shapes
             get { return vertices; }
-            set { vertices = value; }
+            protected set { vertices = value; }
         }
@@ -29,3 +29,3 @@ namespace KAOS.Shapes
             get { return normals; }
-            set { normals = value; }
+            protected set { normals = value; }
         }
@@ -35,3 +35,3 @@ namespace KAOS.Shapes
             get { return texcoords; }
-            set { texcoords = value; }
+            protected set { texcoords = value; }
         }
@@ -41,3 +41,3 @@ namespace KAOS.Shapes
             get { return indices; }
-            set { indices = value; }
+            protected set { indices = value; }
         }
@@ -55,3 +55,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 
@@ -70,3 +70,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 
@@ -85,3 +85,3 @@ namespace KAOS.Shapes
         {
-            primitives = BeginMode.TriangleStrip;
+            primitives = BeginMode.Triangles;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fecf380b631287a5be804fd25701042b3cacf640">Updated mouse input.</a>  -  fecf380</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 428ad86..5fa9815 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -69,2 +69,4 @@ namespace KAOS
 
+        MouseState current, previous;
+
         #region Game Loop
@@ -72,12 +74,18 @@ namespace KAOS
         {
-            #region input
-            if (Focused)
+            #region Mouse Input
+            current = OpenTK.Input.Mouse.GetState();
+            if (current[MouseButton.Left])
             {
-                Point center = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-                Point delta = new Point(center.X - Cursor.Position.X, center.Y - Cursor.Position.Y);
-
-                Utilities.Camera.AddRotation(delta.X, delta.Y);
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
                 ResetCursor();
             }
-
+            
             #endregion

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9b757d8df9393f57bf15d6cf60fc277df6f1a2d8">Updated Example.Shapes.* to use PrimitiveType.</a>  -  9b757d8</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 12 files changed, 38 insertions(+), 27 deletions(-)

diff --git a/KAOS/Interfaces/IDrawableShape.cs b/KAOS/Interfaces/IDrawableShape.cs
index 12f5eeb..99e36eb 100644
--- a/KAOS/Interfaces/IDrawableShape.cs
+++ b/KAOS/Interfaces/IDrawableShape.cs
@@ -17,5 +17,5 @@ namespace KAOS.Interfaces
 
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
-        void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices);
+        void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices);
     }
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index ea2284f..c9489e3 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -23,3 +23,3 @@ namespace KAOS.Shapes
     {
-        protected BeginMode PrimitiveMode;
+        protected PrimitiveType PrimitiveMode;
         protected VertexT2dN3dV3d[] VertexArray;
@@ -32,4 +32,4 @@ namespace KAOS.Shapes
                 switch ( PrimitiveMode )
-                { 
-                case BeginMode.Triangles:
+                {
+                    case PrimitiveType.Triangles:
                     if ( IndexArray != null )
@@ -57,3 +57,3 @@ namespace KAOS.Shapes
             UseDisplayList = useDisplayList;
-            PrimitiveMode = BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             VertexArray = null;
@@ -64,3 +64,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
         {
@@ -79,3 +79,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
         {
@@ -94,3 +94,3 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
         {
diff --git a/KAOS/Shapes/Capsule.cs b/KAOS/Shapes/Capsule.cs
index cd6f7e6..56d270a 100644
--- a/KAOS/Shapes/Capsule.cs
+++ b/KAOS/Shapes/Capsule.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -46,5 +47,5 @@ namespace KAOS.Shapes
             }
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            PrimitiveType TemporaryMode;
             VertexT2dN3dV3d[] TemporaryVBO;
diff --git a/KAOS/Shapes/ChamferCube.cs b/KAOS/Shapes/ChamferCube.cs
index 1c340a1..6fa540b 100644
--- a/KAOS/Shapes/ChamferCube.cs
+++ b/KAOS/Shapes/ChamferCube.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -50,3 +51,3 @@ namespace KAOS.Shapes
             List<Chunk> AllChunks = new List<Chunk>();
-            OpenTK.Graphics.OpenGL.BeginMode TemporaryMode;
+            PrimitiveType TemporaryMode;
             VertexT2dN3dV3d[] TemporaryVBO;
@@ -271,3 +272,3 @@ namespace KAOS.Shapes
             #region Final Assembly of Chunks
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             Chunk.GetArray( ref AllChunks, out VertexArray, out IndexArray );
diff --git a/KAOS/Shapes/Helpers/VboShape.cs b/KAOS/Shapes/Helpers/VboShape.cs
index 62d5462..64ffdd2 100644
--- a/KAOS/Shapes/Helpers/VboShape.cs
+++ b/KAOS/Shapes/Helpers/VboShape.cs
@@ -1 +1,2 @@
+using OpenTK.Graphics.OpenGL;
 namespace KAOS.Shapes
@@ -4,3 +5,3 @@ namespace KAOS.Shapes
     {
-        public VboShape( ref OpenTK.Graphics.OpenGL.BeginMode primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
+        public VboShape( ref PrimitiveType primitives, ref VertexT2dN3dV3d[] vertices, ref uint[] indices, bool useDL )
             : base( useDL )
diff --git a/KAOS/Shapes/KochTetrahedron.cs b/KAOS/Shapes/KochTetrahedron.cs
index a662cfe..07b63d9 100644
--- a/KAOS/Shapes/KochTetrahedron.cs
+++ b/KAOS/Shapes/KochTetrahedron.cs
@@ -1 +1,2 @@
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -51,3 +52,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
diff --git a/KAOS/Shapes/MengerSponge.cs b/KAOS/Shapes/MengerSponge.cs
index c1d54c6..88c7826 100644
--- a/KAOS/Shapes/MengerSponge.cs
+++ b/KAOS/Shapes/MengerSponge.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -40,3 +41,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index 8660961..aeac9a0 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -15,2 +15,4 @@ namespace KAOS.Shapes
     {
+        protected PrimitiveType PrimitiveMode;
+        
         private Vector3[] vertices, normals;
@@ -53,5 +55,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2dN3dV3d[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
@@ -68,5 +70,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2fN3fV3f[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
@@ -83,5 +85,5 @@ namespace KAOS.Shapes
 
-        public void GetArraysforVBO(out OpenTK.Graphics.OpenGL.BeginMode primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
+        public void GetArraysforVBO(out PrimitiveType primitives, out VertexT2hN3hV3h[] vertices, out uint[] indices)
         {
-            primitives = BeginMode.Triangles;
+            primitives = PrimitiveMode;
 
diff --git a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
index fcb493d..1293391 100644
--- a/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
+++ b/KAOS/Shapes/Old/SierpinskiTetrahedron.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System;
@@ -66,3 +67,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
             SierpinskiTetrahedron.GetVertexArray( ref Triangles, out VertexArray );
diff --git a/KAOS/Shapes/SlicedHose.cs b/KAOS/Shapes/SlicedHose.cs
index 8a744ca..50bcc8c 100644
--- a/KAOS/Shapes/SlicedHose.cs
+++ b/KAOS/Shapes/SlicedHose.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 
@@ -32,3 +33,3 @@ namespace KAOS.Shapes
         {
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/SlicedSphere.cs b/KAOS/Shapes/SlicedSphere.cs
index 7c5ee4f..e63acfb 100644
--- a/KAOS/Shapes/SlicedSphere.cs
+++ b/KAOS/Shapes/SlicedSphere.cs
@@ -1,2 +1,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Collections.Generic;
@@ -39,3 +40,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.Triangles;
+            PrimitiveMode = PrimitiveType.Triangles;
 
diff --git a/KAOS/Shapes/TorusKnot.cs b/KAOS/Shapes/TorusKnot.cs
index 898c314..c79b77e 100644
--- a/KAOS/Shapes/TorusKnot.cs
+++ b/KAOS/Shapes/TorusKnot.cs
@@ -1,2 +1,3 @@
 ﻿using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Diagnostics;
@@ -21,3 +22,3 @@ namespace KAOS.Shapes
 
-            PrimitiveMode = OpenTK.Graphics.OpenGL.BeginMode.TriangleStrip;
+            PrimitiveMode = PrimitiveType.TriangleStrip;
 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/dbc18e0d5c031e5a9808c9d272c5f32064d6fecc">Removed hardcoded PrimitiveMode values.</a>  -  dbc18e0</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 5 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 7a36acd..97c264f 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -19,7 +19,7 @@ namespace KAOS.Managers
             //bufferObject.NormalsData = new Vector3d[1];
-            //VertexT2fN3fV3f[] vertexData;
-            //uint[] indices;
-            //BeginMode type;
+            VertexT2fN3fV3f[] vertexData;
+            uint[] indices;
+            PrimitiveType type;
 
-            //shape.GetArraysforVBO(out type, out vertexData, out indices);
+            shape.GetArraysforVBO(out type, out vertexData, out indices);
 
@@ -28,2 +28,3 @@ namespace KAOS.Managers
             bufferObject.IndicesData = shape.Indices;
+            bufferObject.PrimitiveType = type;
 
diff --git a/KAOS/Shapes/Base/DrawableShape.cs b/KAOS/Shapes/Base/DrawableShape.cs
index c9489e3..dd04c57 100644
--- a/KAOS/Shapes/Base/DrawableShape.cs
+++ b/KAOS/Shapes/Base/DrawableShape.cs
@@ -6,2 +6,3 @@
 
+using KAOS.Interfaces;
 using OpenTK;
@@ -21,3 +22,3 @@ namespace KAOS.Shapes
 
-    public abstract class DrawableShape: IDisposable, KAOS.Interfaces.IDrawableShape
+    public abstract class DrawableShape: IDisposable, IDrawableShape
     {
diff --git a/KAOS/Shapes/Old/Cube.cs b/KAOS/Shapes/Old/Cube.cs
index 7782558..ae559fd 100644
--- a/KAOS/Shapes/Old/Cube.cs
+++ b/KAOS/Shapes/Old/Cube.cs
@@ -7,2 +7,3 @@
 using OpenTK;
+using OpenTK.Graphics.OpenGL;
 using System.Drawing;
@@ -67,2 +68,4 @@ namespace KAOS.Shapes
             };
+
+            PrimitiveMode = PrimitiveType.Triangles;
         }
diff --git a/KAOS/Shapes/Old/Shape.cs b/KAOS/Shapes/Old/Shape.cs
index aeac9a0..40faf97 100644
--- a/KAOS/Shapes/Old/Shape.cs
+++ b/KAOS/Shapes/Old/Shape.cs
@@ -8,2 +8,3 @@
 
+using KAOS.Interfaces;
 using OpenTK;
@@ -13,3 +14,3 @@ namespace KAOS.Shapes
 {
-    public abstract class Shape : KAOS.Interfaces.IDrawableShape
+    public abstract class Shape : IDrawableShape
     {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index cbb0d0b..e1eb71c 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -61,3 +61,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(bufferObject.PrimitiveType, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
 
@@ -79,3 +79,3 @@ namespace KAOS.Utilities
 
-            GL.DrawElements(OpenTK.Graphics.OpenGL.PrimitiveType.TriangleStrip, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
+            GL.DrawElements(bufferObject.PrimitiveType, bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fdabdd1156f919672c04051531ad2105f2b2127a">Implemented suggestion from Code Analysis.</a>  -  fdabdd1</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 7839198..1656fb4 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -105,12 +105,4 @@ namespace KAOS.Managers
             bitmap.UnlockBits(bitmapData);
-
-            CleanUp();
-        }
-
-        private void CleanUp()
-        {
-            bitmap.Dispose();
         }
 
-
         public void Dispose()
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 1b9492f..e96452b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -11,3 +11,3 @@ namespace KAOS.States
 {
-    public class Skyboxstate : IGameObject
+    public class Skyboxstate : IDisposable, IGameObject
     {
@@ -148,2 +148,7 @@ namespace KAOS.States
         }
+
+        public void Dispose()
+        {
+            m_textureManager.Dispose();
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/5fe170c7d3e9eb3830e1d6fc2af7269ae57f1030">Removed a whole load of old unused code to remove all build warnings.</a>  -  5fe170c</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 18 files changed, 213 insertions(+), 942 deletions(-)

diff --git a/KAOS/Interfaces/IGroupNode.cs b/KAOS/Interfaces/IGroupNode.cs
new file mode 100644
index 0000000..802144d
--- /dev/null
+++ b/KAOS/Interfaces/IGroupNode.cs
@@ -0,0 +1,14 @@
+﻿using KAOS.Interfaces;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface IGroupNode : IEnumerable<ISceneNode>
+    {
+        void AddChild(ISceneNode child);
+        void RemoveChild(ISceneNode child);
+    }
+}
\ No newline at end of file
diff --git a/KAOS/Interfaces/ISceneNode.cs b/KAOS/Interfaces/ISceneNode.cs
new file mode 100644
index 0000000..a07ccb6
--- /dev/null
+++ b/KAOS/Interfaces/ISceneNode.cs
@@ -0,0 +1,13 @@
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Interfaces
+{
+    public interface ISceneNode 
+    {
+        void Render();
+    }
+}
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
index 5fa9815..e755aac 100644
--- a/KAOS/KAOSWindow.cs
+++ b/KAOS/KAOSWindow.cs
@@ -23,4 +23,2 @@ namespace KAOS
         public int ScreenHeight { get { return this.ClientSize.Height; } }
-        
-        int modelviewMatrixLocation, projectionMatrixLocation;
 
@@ -174,3 +172,2 @@ namespace KAOS
             base.OnUnload(e);
-            GL.DeleteTexture(Renderer.m_texId);
         }
diff --git a/KAOS/Nodes/AWCube.cs b/KAOS/Nodes/AWCube.cs
deleted file mode 100644
index 58875a5..0000000
--- a/KAOS/Nodes/AWCube.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿using KAOS.Shapes;
-using KAOS.Tutorial;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    /// <summary>
-    /// Cube Node
-    /// </summary>
-    public class AWCube : AWNode, ISceneNode
-    {
-        #region Private Members
-        
-        private static Vector3[] CubeVertices = new Vector3[]{
-            new Vector3(-1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f, -1.0f,  1.0f),
-            new Vector3( 1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f,  1.0f,  1.0f),
-            new Vector3(-1.0f, -1.0f, -1.0f),
-            new Vector3( 1.0f, -1.0f, -1.0f), 
-            new Vector3( 1.0f,  1.0f, -1.0f),
-            new Vector3(-1.0f,  1.0f, -1.0f) 
-        };
-
-        private static int[] CubeElements = new int[]{
-                // front face
-                0, 1, 2, 2, 3, 0,
-                // top face
-                3, 2, 6, 6, 7, 3,
-                // back face
-                7, 6, 5, 5, 4, 7,
-                // left face
-                4, 0, 3, 3, 7, 4,
-                // bottom face
-                0, 1, 5, 5, 4, 0,
-                // right face
-                1, 5, 6, 6, 2, 1, 
-        };
-
-        #endregion
-
-        public Vector3[] Vertices
-        {
-            get { return CubeVertices; }
-        }
-
-        public int[] Indices
-        {
-            get { return CubeElements; }
-        }
-
-        public AWCube()
-        {
-        }
-
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/AWGraphLines.cs b/KAOS/Nodes/AWGraphLines.cs
deleted file mode 100644
index 1e65c18..0000000
--- a/KAOS/Nodes/AWGraphLines.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWGraphLines : AWNode, ISceneNode
-    {
-        private int m_gridSize = 20;
-
-        public Vector3[] Vertices
-        {
-            get { return m_vertices; }
-        }
-
-        private static Vector3[] m_vertices;
-
-        public AWGraphLines(int gridSize)
-        {
-            m_gridSize = gridSize;
-            m_vertices = new Vector3[m_gridSize * 2];
-            BuildVertices();
-        }
-
-        private void BuildVertices()
-        {
-            for (int i = 0; i < m_gridSize *2; i += 4)
-            {
-                m_vertices[i] = new Vector3((float)i, .0f, -(float)m_gridSize);
-                m_vertices[i + 1] = new Vector3((float)i, .0f, (float)m_gridSize);
-                m_vertices[i + 2] = new Vector3(-(float)m_gridSize, .0f, (float)i);
-                m_vertices[i + 3] = new Vector3((float)m_gridSize, .0f, (float)i);
-            }
-        }
-
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Lines);
-            for (int i = -m_gridSize; i <= m_gridSize; i++)
-            {
-                if (i == 0) { GL.Color3(.6f, .3f, .3f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3((float)i, .0f, -(float)m_gridSize);
-                GL.Vertex3((float)i, .0f, (float)m_gridSize);
-                if (i == 0) { GL.Color3(.3f, .3f, .6f); } else { GL.Color3(Color.LightGray); }
-                GL.Vertex3(-(float)m_gridSize, .0f, (float)i);
-                GL.Vertex3((float)m_gridSize, .0f, (float)i);
-            }
-            GL.End();
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/AWGroupNode.cs b/KAOS/Nodes/AWGroupNode.cs
index 0fb12d0..f40140e 100644
--- a/KAOS/Nodes/AWGroupNode.cs
+++ b/KAOS/Nodes/AWGroupNode.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Graphics.OpenGL;
+﻿using KAOS.Interfaces;
+using OpenTK.Graphics.OpenGL;
 using System;
diff --git a/KAOS/Nodes/AWMesh.cs b/KAOS/Nodes/AWMesh.cs
deleted file mode 100644
index d5f77a0..0000000
--- a/KAOS/Nodes/AWMesh.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWMesh : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-}
diff --git a/KAOS/Nodes/AWParticles.cs b/KAOS/Nodes/AWParticles.cs
deleted file mode 100644
index 44911f9..0000000
--- a/KAOS/Nodes/AWParticles.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    class AWParticles : AWNode
-    {
-        public override void Render()
-        {
-            throw new NotImplementedException();
-        }
-    }
-
-}
-/*
-        #region Private Members
-        protected static int m_MaxParticleCount = 2000;
-        public int m_VisibleParticleCount;
-        private VertexC4ubV3f[] m_VBO = new VertexC4ubV3f[m_MaxParticleCount];
-        private ParticleAttribut[] m_ParticleAttributes = new ParticleAttribut[m_MaxParticleCount];
-
-        private uint VBOHandle;
-
-        private float xPos = 0.1f;
-        private float yPos = 0.1f;
-        #endregion Private Members
-
-        public AWParticles()
-        {
-            // Setup parameters for Points
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.PointSmooth);
-            GL.Hint(HintTarget.PointSmoothHint, HintMode.Nicest);
-
-            // set up vbo state - depreceted as of 3.0>> (?)
-            GL.EnableClientState(ArrayCap.ColorArray);
-            GL.EnableClientState(ArrayCap.VertexArray);
-
-            // Generate the buffers
-            GL.GenBuffers(1, out VBOHandle);
-
-            // Set it up
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOHandle);
-            GL.ColorPointer(4, ColorPointerType.UnsignedByte, VertexC4ubV3f.SizeInBytes, (IntPtr)0);
-            GL.VertexPointer(3, VertexPointerType.Float, VertexC4ubV3f.SizeInBytes, (IntPtr)(4 * sizeof(byte)));
-
-            Random rndNum = new Random();
-            Vector3 tmp = Vector3.Zero;
-
-            // generate some random stuff for the particle system
-            for (uint i = 0; i < m_MaxParticleCount; i++)
-            {
-                m_VBO[i].R = (byte)rndNum.Next(0, 256);
-                m_VBO[i].G = (byte)rndNum.Next(0, 256);
-                m_VBO[i].B = (byte)rndNum.Next(0, 256);
-                m_VBO[i].A = (byte)rndNum.Next(0, 256); // isn't actually used
-                m_VBO[i].Position = Vector3.Zero; // all particles are born at the origin
-
-                // generate direction vector in the range [-0.25f...+0.25f] 
-                // that's slow enough so you can see particles 'disappear' when they are respawned
-                tmp.X = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Y = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                tmp.Z = (float)((rndNum.NextDouble() - 0.5) * 0.5f);
-                m_ParticleAttributes[i].Direction = tmp; // copy 
-                m_ParticleAttributes[i].Age = 0;
-            }
-
-            m_VisibleParticleCount = 0;
-        }
-
-        public void Update()
-        {
-            // will update particles here. When using a Physics SDK, it's update rate is much higher than
-            // the framerate and it would be a waste of cycles copying to the VBO more often than drawing it.
-            if (m_VisibleParticleCount < m_MaxParticleCount)
-            {
-                m_VisibleParticleCount++;
-            }
-
-            Vector3 temp;
-
-            Random rand = new Random();
-
-            for (int i = m_MaxParticleCount - m_VisibleParticleCount; i < m_MaxParticleCount; i++)
-            {
-                if (m_ParticleAttributes[i].Age >= m_MaxParticleCount)
-                {
-                    // reset particle
-                    m_ParticleAttributes[i].Age = 0;
-                    m_VBO[i].Position = Vector3.Zero;
-                }
-                else
-                {
-                    m_ParticleAttributes[i].Age += (uint)Math.Max(m_ParticleAttributes[i].Direction.LengthFast * 10, 1);
-                    Vector3.Multiply(ref m_ParticleAttributes[i].Direction, (float)rand.NextDouble(), out temp);
-                    Vector3.Add(ref m_VBO[i].Position, ref temp, out m_VBO[i].Position);
-                }
-            }
-        }
-
-        public override void Render()
-        {
-            Update();
-
-            // Tell OpenGL to discard old VBO when done drawing it and reserve memory _now_ for a new buffer.
-            // without this, GL would wait until draw operations on old VBO are complete before writing to it
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), IntPtr.Zero, BufferUsageHint.StreamDraw);
-            // Fill newly allocated buffer
-            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexC4ubV3f.SizeInBytes * m_MaxParticleCount), m_VBO, BufferUsageHint.StreamDraw);
-            // Only draw particles that are alive
-            GL.DrawArrays(PrimitiveType.Points, m_MaxParticleCount - m_VisibleParticleCount, m_VisibleParticleCount);
-
-        }
-    }
-}
-        */
\ No newline at end of file
diff --git a/KAOS/Nodes/AWPolygon.cs b/KAOS/Nodes/AWPolygon.cs
deleted file mode 100644
index 85afb1d..0000000
--- a/KAOS/Nodes/AWPolygon.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Nodes
-{
-    public class AWPolygon : AWNode
-    {
-        Vector3[] m_Verticies;
-        Vector3 m_Normals, m_TexCoords;
-
-        public AWPolygon()
-        {
-            m_Verticies = new Vector3[3];
-            m_Normals = new Vector3();
-        }
-        public override void Render()
-        {
-            GL.Begin(PrimitiveType.Polygon);
-            GL.Color3(Color.NavajoWhite);
-            for (int i = 0; i < m_Verticies.Length; i++)
-            {
-                if (i < 1)
-                {
-                    GL.Normal3(m_Normals);
-                }
-
-                GL.Vertex3(m_Verticies[i]);
-            }
-            GL.End();
-        }
-
-        public void AddVertex(int index, Vector3 v) 
-        {
-            m_Verticies[index] = v;
-        }
-
-        public void AddNormal(Vector3 n)
-        {
-            m_Normals = n;
-        }
-
-        public void AddTexCoord(Vector3 t)
-        {
-
-        }
-
-    }
-}
diff --git a/KAOS/Nodes/IGroupNode.cs b/KAOS/Nodes/IGroupNode.cs
deleted file mode 100644
index 888793f..0000000
--- a/KAOS/Nodes/IGroupNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface IGroupNode : IEnumerable<ISceneNode>
-    {
-        void AddChild(ISceneNode child);
-        void RemoveChild(ISceneNode child);
-    }
-}
\ No newline at end of file
diff --git a/KAOS/Nodes/ISceneNode.cs b/KAOS/Nodes/ISceneNode.cs
deleted file mode 100644
index 0924346..0000000
--- a/KAOS/Nodes/ISceneNode.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Nodes
-{
-    public interface ISceneNode 
-    {
-        void Render();
-    }
-}
diff --git a/KAOS/States/AssimpImportedState.cs b/KAOS/States/AssimpImportedState.cs
deleted file mode 100644
index 40dbc84..0000000
--- a/KAOS/States/AssimpImportedState.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-
-namespace KAOS.States
-{
-    public class AssimpImportedState :IGameObject
-    {
-        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-        BufferObject m_bufferObject;
-        StateManager m_stateManager;
-
-        public AssimpImportedState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Render()
-        {
-
-        }
-
-        public void Update(float elapsedTime)
-        {
-
-        }
-    }
-}
diff --git a/KAOS/States/DefaultState.cs b/KAOS/States/DefaultState.cs
deleted file mode 100644
index e26345e..0000000
--- a/KAOS/States/DefaultState.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DefaultState : IGameObject
-    {
-        double currentRotation = 0;
-
-        StateManager m_stateManager;
-        public DefaultState(StateManager stateManager)
-        {
-            m_stateManager = stateManager;
-        }
-
-        public void Update(float elapsedTime)
-        {
-            currentRotation = 10 * elapsedTime;
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(Color.Black);
-            GL.PointSize(5f);
-
-            GL.Rotate(currentRotation, 0, 1, 0);
-            GL.Begin(PrimitiveType.TriangleStrip);
-
-            GL.Color4(new Color4(1f, 0f, 0f, .5f));
-            GL.Vertex3(new Vector3(-50f, 0f, 0f));
-            GL.Color3(new Vector3(0f, 1f, 0f));
-            GL.Vertex3(new Vector3(50f, 0, 0));
-            GL.Color3(new Vector3(0f, 0f, 1f));
-            GL.Vertex3(new Vector3(0f, 50f, 0));
-
-            GL.End();
-            GL.Finish();
-        }
-    }
-}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
index f83dcda..c41a56d 100644
--- a/KAOS/States/DrawSpriteState.cs
+++ b/KAOS/States/DrawSpriteState.cs
@@ -1,79 +1,79 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System.Drawing;
-
-namespace KAOS.States
-{
-    public class DrawSpriteState : IGameObject
-    {
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        double height, width, halfHeight, halfWidth, x, y, z;
-        float topUV, bottomUV, leftUV, rightUV;
-
-        #region IGameObject States
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            Texture texture = m_textureManager.Get("sprite1");
-            GL.Enable(EnableCap.Texture2D);
-            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-            GL.ClearColor(Color.Black);
-            GL.Begin(PrimitiveType.Triangles);
-
-            GL.TexCoord2(new Vector2d(leftUV, topUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.TexCoord2(new Vector2d(rightUV, topUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-            GL.End();
-
-        } 
-        #endregion
-
-        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-        {
-            m_stateManager = stateManager;
-            m_textureManager = texturManager;
-            Initialise();
-        }
-
-        private void Initialise()
-        {
-            this.height = 200;
-            this.width = 200;
-
-            this.halfHeight = this.height / 2;
-            this.halfWidth = this.width / 2;
-
-            this.x = 0;
-            this.y = 0;
-            this.z = 2;
-
-            this.topUV = 0;
-            this.bottomUV = 1;
-            this.leftUV = 0;
-            this.rightUV = 1;
-        }
-    }
-}
+﻿//using KAOS.Interfaces;
+//using KAOS.Managers;
+//using KAOS.Utilities;
+//using OpenTK;
+//using OpenTK.Graphics.OpenGL;
+//using System.Drawing;
+
+//namespace KAOS.States
+//{
+//    public class DrawSpriteState : IGameObject
+//    {
+//        private StateManager m_stateManager;
+//        private TextureManager m_textureManager;
+
+//        double height, width, halfHeight, halfWidth, x, y, z;
+//        float topUV, bottomUV, leftUV, rightUV;
+
+//        #region IGameObject States
+
+//        public void Update(float elapsedTime)
+//        {
+//            //throw new NotImplementedException();
+//        }
+
+//        public void Render()
+//        {
+//            Texture texture = m_textureManager.Get("sprite1");
+//            GL.Enable(EnableCap.Texture2D);
+//            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
+
+
+//            GL.ClearColor(Color.Black);
+//            GL.Begin(PrimitiveType.Triangles);
+
+//            GL.TexCoord2(new Vector2d(leftUV, topUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
+//            GL.TexCoord2(new Vector2d(rightUV, topUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+//            GL.TexCoord2(new Vector2d(rightUV, topUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
+//            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
+//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
+//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
+
+//            GL.End();
+
+//        } 
+//        #endregion
+
+//        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
+//        {
+//            m_stateManager = stateManager;
+//            m_textureManager = texturManager;
+//            Initialise();
+//        }
+
+//        private void Initialise()
+//        {
+//            this.height = 200;
+//            this.width = 200;
+
+//            this.halfHeight = this.height / 2;
+//            this.halfWidth = this.width / 2;
+
+//            this.x = 0;
+//            this.y = 0;
+//            this.z = 2;
+
+//            this.topUV = 0;
+//            this.bottomUV = 1;
+//            this.leftUV = 0;
+//            this.rightUV = 1;
+//        }
+//    }
+//}
diff --git a/KAOS/States/VboState.cs b/KAOS/States/VboState.cs
deleted file mode 100644
index 7faddb3..0000000
--- a/KAOS/States/VboState.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Shapes;
-//using KAOS.Utilities;
-//using OpenTK.Graphics.OpenGL;
-//using System;
-
-//namespace KAOS.States
-//{
-//    public class VboState : IGameObject
-//    {
-//        BufferObjectManager m_bufferObjectManager = new BufferObjectManager();
-
-//        BufferObject m_bufferObject;
-//        StateManager m_stateManager;
-//        Cube cube = new Cube(0, 0, 0);
-
-//        public VboState(StateManager stateManager)
-//        {
-//            m_stateManager = stateManager;
-
-//            CreateVBOs();
-//        }
-
-//        private void CreateVBOs()
-//        {
-//            BufferObject tempVBO = new BufferObject();
-//            tempVBO.PositionData = cube.Vertices;
-//            tempVBO.NormalsData = cube.Normals;
-//            tempVBO.IndicesData = cube.Indices;
-//            tempVBO.PrimitiveType = PrimitiveType.Triangles;
-
-//            m_bufferObjectManager.AddBufferObject("test-cube", tempVBO, ShaderManager.Skybox.ID);
-//            m_bufferObject = m_bufferObjectManager.GetBuffer("test-cube");
-//        }
-
-//        public void Update(float elapsedTime)
-//        {
-
-//        }
-
-//        public void Render()
-//        {
-//            GL.BindVertexArray(m_bufferObject.VaoID);
-//            GL.DrawElements(m_bufferObject.PrimitiveType,
-//                            m_bufferObject.IndicesData.Length,
-//                            DrawElementsType.UnsignedInt,
-//                            IntPtr.Zero);
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
index 4d80ab9..3cee9cd 100644
--- a/KAOS/Utilities/Block.cs
+++ b/KAOS/Utilities/Block.cs
@@ -1,29 +1,29 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿//using System;
+//using System.Collections.Generic;
+//using System.Linq;
+//using System.Text;
+//using System.Threading.Tasks;
 
-namespace KAOS.Utilities
-{
-    public class Block
-    {
-        enum BlockType
-        {
-            BlockType_Default = 0,
+//namespace KAOS.Utilities
+//{
+//    public class Block
+//    {
+//        enum BlockType
+//        {
+//            BlockType_Default = 0,
 
-            BlockType_Grass,
-            BlockType_Dirt,
-            BlockType_Water,
-            BlockType_Stone,
-            BlockType_Wood,
-            BlockType_Sand,
+//            BlockType_Grass,
+//            BlockType_Dirt,
+//            BlockType_Water,
+//            BlockType_Stone,
+//            BlockType_Wood,
+//            BlockType_Sand,
 
-            BlockType_NumTypes,
-        };
+//            BlockType_NumTypes,
+//        };
 
-        public bool IsActive { get; set; }
-        private bool m_active;
-        private BlockType type;
-    }
-}
+//        public bool IsActive { get; set; }
+//        private bool m_active;
+//        private BlockType type;
+//    }
+//}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
index 26681e0..0282844 100644
--- a/KAOS/Utilities/Chunk.cs
+++ b/KAOS/Utilities/Chunk.cs
@@ -1,91 +1,91 @@
-﻿using KAOS.Shapes;
-using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-namespace KAOS.Utilities
-{
-    public class Chunk : IDisposable
-    {
-        public const int CHUNK_SIZE = 16;
-        private Block[][][] m_blocks;
-        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
+﻿//using KAOS.Shapes;
+//using OpenTK;
+//using System;
+//using System.Collections.Generic;
+//using System.Linq;
+//using System.Text;
+//using System.Threading.Tasks;
+//namespace KAOS.Utilities
+//{
+//    public class Chunk : IDisposable
+//    {
+//        public const int CHUNK_SIZE = 16;
+//        private Block[][][] m_blocks;
+//        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
 
-        public Chunk()
-        {
-            //Create Blocks
-            m_blocks = new Block[CHUNK_SIZE][][];
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
-                m_blocks[i] = new Block[CHUNK_SIZE][];
+//        public Chunk()
+//        {
+//            //Create Blocks
+//            m_blocks = new Block[CHUNK_SIZE][][];
+//            for (int i = 0; i < CHUNK_SIZE; i++)
+//            {
+//                m_blocks[i] = new Block[CHUNK_SIZE][];
 
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-                }
-            }
-        }
+//                for (int j = 0; j < CHUNK_SIZE; j++)
+//                {
+//                    m_blocks[i][j] = new Block[CHUNK_SIZE];
+//                }
+//            }
+//        }
 
-        public void Update(float dt) { }
+//        public void Update(float dt) { }
 
-        public void Render() { }
+//        public void Render() { }
 
-        public void Dispose()
-        {
-            // Delete blocks
-            for (int i = 0; i < CHUNK_SIZE; i++)
-            {
+//        public void Dispose()
+//        {
+//            // Delete blocks
+//            for (int i = 0; i < CHUNK_SIZE; i++)
+//            {
                 
 
-                for (int j = 0; j < CHUNK_SIZE; j++)
-                {
-                    m_blocks[i][j] = null;
-                }
-                m_blocks[i] = null;
-            }
-            m_blocks = null;
-        }
+//                for (int j = 0; j < CHUNK_SIZE; j++)
+//                {
+//                    m_blocks[i][j] = null;
+//                }
+//                m_blocks[i] = null;
+//            }
+//            m_blocks = null;
+//        }
 
-        public void CreateMesh()
-        {
-            for (int x = 0; x < CHUNK_SIZE; x++)
-            {
-                for (int y = 0; y < CHUNK_SIZE; y++)
-                {
-                    for (int z = 0; z < CHUNK_SIZE; z++)
-                    {
-                        if (m_blocks[x][y][z].IsActive == false)
-                        {
-                            // Don't create triangle data for inactive blocks
-                            continue;
-                        }
+//        public void CreateMesh()
+//        {
+//            for (int x = 0; x < CHUNK_SIZE; x++)
+//            {
+//                for (int y = 0; y < CHUNK_SIZE; y++)
+//                {
+//                    for (int z = 0; z < CHUNK_SIZE; z++)
+//                    {
+//                        if (m_blocks[x][y][z].IsActive == false)
+//                        {
+//                            // Don't create triangle data for inactive blocks
+//                            continue;
+//                        }
 
-                        CreateCube(x, y, z);
-                    }
-                }
-            }
-        }
+//                        CreateCube(x, y, z);
+//                    }
+//                }
+//            }
+//        }
 
-        private void CreateCube(int x, int y, int z)
-        {
-            float blockSize = 1f;
+//        private void CreateCube(int x, int y, int z)
+//        {
+//            float blockSize = 1f;
 
             
-            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
+//            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
+//            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+//            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+//            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
+//            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
+//            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+//            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
+//            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
 
-            Vector3 n1;
+//            Vector3 n1;
 
 
-            throw new NotImplementedException();
-        }
-    }
-}
+//            throw new NotImplementedException();
+//        }
+//    }
+//}
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index e1eb71c..a0a9e8e 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -17,9 +17,6 @@ namespace KAOS.Utilities
         internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
-        internal static Vector3 eyePosition, m_sceneCenter, m_sceneMin, m_sceneMax;
-        internal static int handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
-            m_displayList, m_texId, 
+        internal static Vector3 eyePosition;
+        internal static int 
+            handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
             handle_centre, handle_scale, handle_iter;
-
-        internal static Scene m_model;
-        internal static float m_angle;
         #endregion
@@ -81,2 +78,3 @@ namespace KAOS.Utilities
         }
+        
         internal static void ToggleWireframeOn()
@@ -91,287 +89,2 @@ namespace KAOS.Utilities
 
-        #region Assimp Example
-        public static void DrawModel()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.Normalize);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.LoadMatrix(ref lookat);
-
-            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            float tmp = m_sceneMax.X - m_sceneMin.X;
-            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            tmp = 1.0f / tmp;
-            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            GL.Translate(-m_sceneCenter);
-
-            if (m_displayList == 0)
-            {
-                m_displayList = GL.GenLists(1);
-                GL.NewList(m_displayList, ListMode.Compile);
-                RecursiveRender(m_model, m_model.RootNode);
-                GL.EndList();
-            }
-
-            GL.CallList(m_displayList);
-        }
-
-        private static void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private static void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        private static void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private static void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private static void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private static Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private static Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private static Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/72361501abd6439a5fe4193882c403e3e9da03c3">Documentation updates.</a>  -  7236150</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 9 files changed, 27 insertions(+), 22 deletions(-)

diff --git a/KAOS/Managers/BufferObjectManager.cs b/KAOS/Managers/BufferObjectManager.cs
index 97c264f..e30466e 100644
--- a/KAOS/Managers/BufferObjectManager.cs
+++ b/KAOS/Managers/BufferObjectManager.cs
@@ -10,2 +10,5 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for uploading vertex data to the gpu and setting up vertex arrays.
+    /// </summary>
     public class BufferObjectManager
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index 83ddedd..c6e84e7 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -5,2 +5,5 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for polling user input, updating parameters as and when a change is detected.
+    /// </summary>
     public static class InputManager
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
index 92525db..4c8182d 100644
--- a/KAOS/Managers/ShaderManager.cs
+++ b/KAOS/Managers/ShaderManager.cs
@@ -12,3 +12,4 @@ namespace KAOS.Managers
     {
-        static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
+        #region Private Members
+        private static Dictionary<string, Shader> m_shaderStorage;// = new Dictionary<string, Shader>();
 
@@ -20,2 +21,3 @@ namespace KAOS.Managers
         private static string m_fragmentShaderFile = "skybox-fs";
+        #endregion
 
@@ -137,20 +139,2 @@ namespace KAOS.Managers
 
-        #region Public Methods
-
-        //public void SetUniforms(
-        //    out int projMatrixHandle, out int mvMatrixHandle,
-        //    out Matrix4 projMatrix, Matrix4 mvMatrix,
-        //    Size dimensions, ref Camera camera)
-        //{
-        //    projMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "projection_matrix");
-        //    mvMatrixHandle = GL.GetUniformLocation(this.ProgramHandle, "modelview_matrix");
-
-        //    float aspectRatio = dimensions.Width / (float)(dimensions.Height);
-        //    Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, aspectRatio, 1, 100, out projMatrix);
-
-        //    GL.UniformMatrix4(projMatrixHandle, false, ref projMatrix);
-        //    GL.UniformMatrix4(mvMatrixHandle, false, ref mvMatrix);
-        //} 
-        #endregion
-
     }
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
index 8a00128..f39e5e1 100644
--- a/KAOS/Managers/StateManager.cs
+++ b/KAOS/Managers/StateManager.cs
@@ -6,5 +6,8 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for managing different game states such as splash screen, menus, etc...
+    /// </summary>
     public class StateManager
     {
-        Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
+        private Dictionary<string, IGameObject> stateStore = new Dictionary<string, IGameObject>();
         IGameObject currentState = null;
diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index 1656fb4..f81dc83 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -9,5 +9,8 @@ namespace KAOS.Managers
 {
+    /// <summary>
+    /// Responsible for uploading textures to the GPU.
+    /// </summary>
     public class TextureManager : IDisposable
     {
-        Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
+        private Dictionary<string, Texture> m_textureDatabase = new Dictionary<string, Texture>();
 
diff --git a/KAOS/Utilities/AnimationTimer.cs b/KAOS/Utilities/AnimationTimer.cs
index 8de3bf5..7595374 100644
--- a/KAOS/Utilities/AnimationTimer.cs
+++ b/KAOS/Utilities/AnimationTimer.cs
@@ -8,2 +8,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Provides accurate timing information which may later be used for any animation.
+    /// </summary>
     public class AnimationTimer
diff --git a/KAOS/Utilities/Extensions.cs b/KAOS/Utilities/Extensions.cs
index 759ed2a..f7f6d4f 100644
--- a/KAOS/Utilities/Extensions.cs
+++ b/KAOS/Utilities/Extensions.cs
@@ -8,2 +8,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Extension methods belong here.
+    /// </summary>
     public static class Extensions
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
index 6e15e05..6ba58c9 100644
--- a/KAOS/Utilities/Logger.cs
+++ b/KAOS/Utilities/Logger.cs
@@ -7,3 +7,3 @@ namespace KAOS.Utilities
     /// <summary>
-    /// AWLogger
+    /// Responsible for displaying runtime information.
     /// </summary>
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index a0a9e8e..bd94465 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -13,2 +13,5 @@ namespace KAOS.Utilities
 {
+    /// <summary>
+    /// Responsible for all rendering.
+    /// </summary>
     public static class Renderer

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/6561af24985842cd648d925af0b33da0afe9429a">Slight refactoring.</a>  -  6561af2</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 4 files changed, 175 insertions(+), 177 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index e284cc0..6115a7c 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -11,3 +11,3 @@ namespace Game
 {
-    class Game : KAOSWindow
+    class Game : KAOSEngine
     {
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
new file mode 100644
index 0000000..f4cdc0e
--- /dev/null
+++ b/KAOS/KAOSEngine.cs
@@ -0,0 +1,173 @@
+﻿using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// This is the main interface to the system. Inherit from here to get started.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS-Engine"; } }
+
+        public int ScreenWidth { get { return this.ClientSize.Width; } }
+        public int ScreenHeight { get { return this.ClientSize.Height; } }
+
+        protected AnimationTimer m_Timer;
+
+        MouseState current, previous;
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        #region Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new AnimationTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
+        }
+
+        public abstract void Initialise();
+
+        #endregion
+
+        #region Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            #region Mouse Input
+            current = OpenTK.Input.Mouse.GetState();
+            if (current[MouseButton.Left])
+            {
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
+                ResetCursor();
+            }
+            
+            #endregion
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+
+            #region Assimp Example Code
+            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
+            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perspective); 
+            #endregion
+        }
+        #endregion
+
+        #region Input Control
+        
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        #endregion
+
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/KAOS/KAOSWindow.cs b/KAOS/KAOSWindow.cs
deleted file mode 100644
index e755aac..0000000
--- a/KAOS/KAOSWindow.cs
+++ /dev/null
@@ -1,175 +0,0 @@
-﻿using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// Inherit from here to get started.
-    /// This is the main interface to the system.
-    /// </summary>
-    public abstract class KAOSWindow : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "AWEngine"; } }
-
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
-
-        protected Matrix4 projectionMatrix, modelviewMatrix;
-        protected AnimationTimer m_Timer;
-        
-        public KAOSWindow(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSWindow.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        #region Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new AnimationTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultSkyboxShader();
-            ShaderManager.LoadDefaultRenderShader();
-        }
-
-        public abstract void Initialise();
-
-        #endregion
-
-        MouseState current, previous;
-
-        #region Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Mouse Input
-            current = OpenTK.Input.Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-                ResetCursor();
-            }
-            
-            #endregion
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            Title = KAOSWindow.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
-        }
-        #endregion
-
-        #region Input Control
-        
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-    }
-}
\ No newline at end of file
diff --git a/KAOS/Utilities/Logger.cs b/KAOS/Utilities/Logger.cs
index 6ba58c9..ef36cef 100644
--- a/KAOS/Utilities/Logger.cs
+++ b/KAOS/Utilities/Logger.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
         {
-            Console.WriteLine(KAOSWindow.AppName + " Logger: " + output.Trim());
+            Console.WriteLine(KAOSEngine.AppName + " Logger: " + output.Trim());
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/c9fd162018be4ceb0ce8bb4b51e97d700052274f">Removing redundant code.</a>  -  c9fd162</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 12 files changed, 1464 deletions(-)

diff --git a/KAOS/Managers/ModelManager.cs b/KAOS/Managers/ModelManager.cs
deleted file mode 100644
index c118589..0000000
--- a/KAOS/Managers/ModelManager.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿
-namespace KAOS.Managers
-{
-    class ModelManager
-    {
-    }
-}
diff --git a/KAOS/Scene/FBOScene.cs b/KAOS/Scene/FBOScene.cs
deleted file mode 100644
index ee33056..0000000
--- a/KAOS/Scene/FBOScene.cs
+++ /dev/null
@@ -1,246 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    public class FBOScene : DefaultScene
-    {
-        #region Private Member Variables
-        private Font sans = new Font(System.Drawing.FontFamily.GenericSansSerif, 16.0f);
-
-        private uint ColorTexture;
-        private uint DepthTexture;
-        private uint FBOHandle;
-
-        private const int TextureSize = 512;
-
-        private DrawableShape Object;
-        #endregion
-
-        protected override void OnUnload(EventArgs e)
-        {
-            Object.Dispose();
-
-            // Clean up what we allocated before exiting
-            if (ColorTexture != 0)
-                GL.DeleteTextures(1, ref ColorTexture);
-
-            if (DepthTexture != 0)
-                GL.DeleteTextures(1, ref DepthTexture);
-
-            if (FBOHandle != 0)
-                GL.Ext.DeleteFramebuffers(1, ref FBOHandle);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.PushMatrix();
-            {
-                // Draw the Color Texture
-                GL.Translate(-1.1f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-
-                // Draw the Depth Texture
-                GL.Translate(+2.2f, 0f, 0f);
-                GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-                GL.Begin(BeginMode.Quads);
-                {
-                    GL.TexCoord2(0f, 1f);
-                    GL.Vertex2(-1.0f, 1.0f);
-                    GL.TexCoord2(0.0f, 0.0f);
-                    GL.Vertex2(-1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 0.0f);
-                    GL.Vertex2(1.0f, -1.0f);
-                    GL.TexCoord2(1.0f, 1.0f);
-                    GL.Vertex2(1.0f, 1.0f);
-                }
-                GL.End();
-            }
-            GL.PopMatrix();
-
-            SwapBuffers();
-        }
-
-        public override void Setup(EventArgs e)
-        {
-            if (!GL.GetString(StringName.Extensions).Contains("GL_EXT_framebuffer_object"))
-            {
-                throw new NotSupportedException(
-                     "GL_EXT_framebuffer_object extension is required. Please update your drivers.");
-                Exit();
-            }
-
-            Object = new Shapes.TorusKnot(256, 16, 0.2, 7, 8, 1, true);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.ClearDepth(1.0);
-            GL.DepthFunc(DepthFunction.Lequal);
-
-            GL.Enable(EnableCap.CullFace);
-
-            // Create Color Tex
-            GL.GenTextures(1, out ColorTexture);
-            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, TextureSize, TextureSize, 0, PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create Depth Tex
-            GL.GenTextures(1, out DepthTexture);
-            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)All.DepthComponent32, TextureSize, TextureSize, 0, PixelFormat.DepthComponent, PixelType.UnsignedInt, IntPtr.Zero);
-            // things go horribly wrong if DepthComponent's Bitcount does not match the main Framebuffer's Depth
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToBorder);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToBorder);
-            // GL.Ext.GenerateMipmap( GenerateMipmapTarget.Texture2D );
-
-            // Create a FBO and attach the textures
-            GL.Ext.GenFramebuffers(1, out FBOHandle);
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, FBOHandle);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.ColorAttachment0Ext, TextureTarget.Texture2D, ColorTexture, 0);
-            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt, FramebufferAttachment.DepthAttachmentExt, TextureTarget.Texture2D, DepthTexture, 0);
-
-            #region Test for Error
-
-            switch (GL.Ext.CheckFramebufferStatus(FramebufferTarget.FramebufferExt))
-            {
-                case FramebufferErrorCode.FramebufferCompleteExt:
-                    {
-                        Console.WriteLine("FBO: The framebuffer is complete and valid for rendering.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteMissingAttachmentExt:
-                    {
-                        Console.WriteLine("FBO: There are no attachments.");
-                        break;
-                    }
-                /* case  FramebufferErrorCode.GL_FRAMEBUFFER_INCOMPLETE_DUPLICATE_ATTACHMENT_EXT: 
-                     {
-                         Console.WriteLine("FBO: An object has been attached to more than one attachment point.");
-                         break;
-                     }*/
-                case FramebufferErrorCode.FramebufferIncompleteDimensionsExt:
-                    {
-                        Console.WriteLine("FBO: Attachments are of different size. All attachments must have the same width and height.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteFormatsExt:
-                    {
-                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteDrawBufferExt:
-                    {
-                        Console.WriteLine("FBO: An attachment point referenced by GL.DrawBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferIncompleteReadBufferExt:
-                    {
-                        Console.WriteLine("FBO: The attachment point referenced by GL.ReadBuffers() doesn’t have an attachment.");
-                        break;
-                    }
-                case FramebufferErrorCode.FramebufferUnsupportedExt:
-                    {
-                        Console.WriteLine("FBO: This particular FBO configuration is not supported by the implementation.");
-                        break;
-                    }
-                default:
-                    {
-                        Console.WriteLine("FBO: Status unknown. (yes, this is really bad.)");
-                        break;
-                    }
-            }
-
-            // using FBO might have changed states, e.g. the FBO might not support stereoscopic views or double buffering
-            int[] queryinfo = new int[6];
-            GL.GetInteger(GetPName.MaxColorAttachmentsExt, out queryinfo[0]);
-            GL.GetInteger(GetPName.AuxBuffers, out queryinfo[1]);
-            GL.GetInteger(GetPName.MaxDrawBuffers, out queryinfo[2]);
-            GL.GetInteger(GetPName.Stereo, out queryinfo[3]);
-            GL.GetInteger(GetPName.Samples, out queryinfo[4]);
-            GL.GetInteger(GetPName.Doublebuffer, out queryinfo[5]);
-            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +
-                               "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
-
-            Console.WriteLine("Last GL Error: " + GL.GetError());
-
-            #endregion Test for Error
-
-            GL.PushAttrib(AttribMask.ViewportBit);
-            {
-                GL.Viewport(0, 0, TextureSize, TextureSize);
-
-                // clear the screen in red, to make it very obvious what the clear affected. only the FBO, not the real framebuffer
-                GL.ClearColor(1f, 0f, 0f, 0f);
-                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, TextureSize / (float)TextureSize, 2.5f, 6f);
-                GL.MatrixMode(MatrixMode.Projection);
-                GL.LoadMatrix(ref perspective);
-
-                Matrix4 lookat = Matrix4.LookAt(0f, 0f, 4.5f, 0f, 0f, 0f, 0f, 1f, 0f);
-                GL.MatrixMode(MatrixMode.Modelview);
-                GL.LoadMatrix(ref lookat);
-
-                // draw some complex object into the FBO's textures
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.Light0);
-                GL.Enable(EnableCap.ColorMaterial);
-                GL.Color3(0f, 1f, 0f);
-                Object.Draw();
-                GL.Disable(EnableCap.ColorMaterial);
-                GL.Disable(EnableCap.Light0);
-                GL.Disable(EnableCap.Lighting);
-
-            }
-            GL.PopAttrib();
-            GL.Ext.BindFramebuffer(FramebufferTarget.FramebufferExt, 0); // disable rendering into the FBO
-
-            GL.ClearColor(.1f, .2f, .3f, 0f);
-            GL.Color3(1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Texture2D); // enable Texture Mapping
-            GL.BindTexture(TextureTarget.Texture2D, 0); // bind default texture
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            double aspect_ratio = Width / (double)Height;
-
-            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, (float)aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perspective);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-        }
-    }
-}
diff --git a/KAOS/Scene/PickerScene.cs b/KAOS/Scene/PickerScene.cs
deleted file mode 100644
index 3aca921..0000000
--- a/KAOS/Scene/PickerScene.cs
+++ /dev/null
@@ -1,204 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Diagnostics;
-using System.Drawing;
-
-namespace AWGL.Scene
-{
-    /// <summary>
-    /// This demo shows over which triangle the cursor is, it does so by assigning all 3 vertices of a triangle the same Ids.
-    /// Each Id is a uint, split into 4 bytes and used as triangle color. In an extra pass, the screen is cleared to uint.MaxValue,
-    /// and then the mesh is drawn using color. Using GL.ReadPixels() the value under the mouse cursor is read and can be converted.
-    /// </summary>
-    public class PickerScene : DefaultScene
-    {
-        public PickerScene()
-        {
-            this.VSync = VSyncMode.Off;
-        }
-
-        #region Private Member variable
-        private const TextureTarget Target = TextureTarget.TextureRectangleArb;
-        private float angle;
-        private BeginMode VBO_PrimMode;
-        private Vertex[] VBO_Array;
-        uint VBO_Handle;
-
-        private uint SelectedTriangle;
-
-        private int VertexShaderObject, FragmentShaderObject, ProgramObject;
-        #endregion
-
-        #region OnLoad
-        /// <summary>Load resources here.</summary>
-        /// <param name="e">Not used.</param>
-        protected override void OnLoad(EventArgs e)
-        {
-            base.OnLoad(e);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.CullFace);
-
-            #region prepare data for VBO from procedural object
-            DrawableShape temp_obj = new SierpinskiTetrahedron(3f, SierpinskiTetrahedron.eSubdivisions.Five, false);
-            VertexT2fN3fV3f[] temp_VBO;
-            uint[] temp_IBO;
-            temp_obj.GetArraysforVBO(out VBO_PrimMode, out temp_VBO, out temp_IBO);
-            temp_obj.Dispose();
-            if (temp_IBO != null)
-                throw new Exception("Expected data for GL.DrawArrays, but Element Array is not null.");
-
-            // Convert from temp mesh to final object, copy position and add triangle Ids for the color attribute.
-            VBO_Array = new Vertex[temp_VBO.Length];
-            int TriangleCounter = -1;
-            for (int i = 0; i < temp_VBO.Length; i++)
-            {
-                // Position
-                VBO_Array[i].Position = temp_VBO[i].Position;
-
-                // Index
-                if (i % 3 == 0)
-                    TriangleCounter++;
-                VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));
-            }
-            #endregion prepare data for VBO from procedural object
-
-            #region Setup VBO for drawing
-            GL.GenBuffers(1, out VBO_Handle);
-            GL.BindBuffer(BufferTarget.ArrayBuffer, VBO_Handle);
-            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer, (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes), VBO_Array, BufferUsageHint.StaticDraw);
-            GL.InterleavedArrays(InterleavedArrayFormat.C4ubV3f, 0, IntPtr.Zero);
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("VBO Setup failed (Error: " + err + "). Attempting to continue.");
-            #endregion Setup VBO for drawing
-
-            #region Shader
-
-            //create and compile shaders
-            VertexShaderObject = AWUtils.BuildShader("Picking_VS.glsl", ShaderType.VertexShader);
-            FragmentShaderObject = AWUtils.BuildShader("Picking_FS.glsl", ShaderType.FragmentShader);
-
-            //create program object, attach shaders and link
-            ProgramObject = AWUtils.BuildProgram(VertexShaderObject, FragmentShaderObject);
-
-            // flag ShaderObjects for delete when not used anymore
-            GL.DeleteShader(VertexShaderObject);
-            GL.DeleteShader(FragmentShaderObject);
-
-            GL.UseProgram(0);
-
-            #endregion Shader
-
-        }
-        #endregion
-
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
-            GL.DeleteBuffers(1, ref VBO_Handle);
-
-            base.OnUnload(e);
-        }
-        #endregion
-
-        #region OnResize
-        /// <summary>
-        /// Called when your window is resized. Set your viewport here. It is also
-        /// a good place to set up your projection matrix (which probably changes
-        /// along when the aspect ratio of your window).
-        /// </summary>
-        /// <param name="e">Contains information on the new Width and Size of the GameWindow.</param>
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-
-            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, this.Width / (float)this.Height, 0.1f, 10.0f);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref projection);
-        }
-        #endregion
-
-        #region OnRenderFrame
-        /// <summary>
-        /// Called when it is time to render the next frame. Add your rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            GL.Color3(Color.White);
-            GL.EnableClientState(EnableCap.ColorArray);
-
-            #region Pass 1: Draw Object and pick Triangle
-            GL.ClearColor(1f, 1f, 1f, 1f); // clears to uint.MaxValue
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            Matrix4 modelview = Matrix4.LookAt(Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref modelview);
-            GL.Translate(0f, 0f, -3f);
-            GL.Rotate(angle, Vector3.UnitX);
-            GL.Rotate(angle, Vector3.UnitY);
-            angle += (float)e.Time * 3.0f;
-
-            // You may re-enable the shader, but it works perfectly without and will run on intel HW too
-             GL.UseProgram(ProgramObject);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            // GL.UseProgram(0);
-
-            // Read Pixel under mouse cursor
-            Byte4 Pixel = new Byte4();
-            GL.ReadPixels(Mouse.X, this.Height - Mouse.Y, 1, 1, PixelFormat.Rgba, PixelType.UnsignedByte, ref Pixel);
-            SelectedTriangle = Pixel.ToUInt32();
-            #endregion Pass 1: Draw Object and pick Triangle
-
-            GL.Color3(Color.White);
-            GL.DisableClientState(EnableCap.ColorArray);
-
-            #region Pass 2: Draw Shape
-            if (SelectedTriangle == uint.MaxValue)
-                GL.ClearColor(.2f, .1f, .3f, 1f); // purple
-            else
-                GL.ClearColor(0f, .2f, .3f, 1f); // cyan
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            GL.Color3(1f, 1f, 1f);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-            GL.Color3(Color.Red);
-            GL.DrawArrays(VBO_PrimMode, 0, VBO_Array.Length);
-            GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-
-            if (SelectedTriangle != uint.MaxValue)
-            {
-                GL.Disable(EnableCap.DepthTest);
-                GL.Color3(Color.Green);
-                GL.DrawArrays(VBO_PrimMode, (int)SelectedTriangle * 3, 3);
-                GL.Enable(EnableCap.DepthTest);
-            }
-            #endregion Pass 2: Draw Shape
-
-            this.SwapBuffers();
-
-            ErrorCode err = GL.GetError();
-            if (err != ErrorCode.NoError)
-                Trace.WriteLine("Error at Swapbuffers: " + err);
-        }
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-    }
-}
diff --git a/KAOS/Scene/StencilCSGScene.cs b/KAOS/Scene/StencilCSGScene.cs
deleted file mode 100644
index 8acb843..0000000
--- a/KAOS/Scene/StencilCSGScene.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class StencilCSGScene : DefaultScene
-    {
-        #region Model Related
-        private DrawableShape OperandB;
-        private DrawableShape OperandA;
-        private float MySphereZOffset = 0f;
-        private float MySphereXOffset = 0f;
-
-        private int Texture;
-        #endregion Model Related
-
-        private bool ShowDebugWireFrame = true;
-
-        private float CameraZoom;
-        private float CameraRotX;
-        private float CameraRotY;
-        private Vector3 EyePosition = new Vector3(0f, 0f, 15f);
-
-        #region Window
-        public StencilCSGScene()
-        {
-            base.VSync = VSyncMode.Off;
-            Keyboard.KeyDown += delegate(object sender, KeyboardKeyEventArgs e)
-            {
-                switch (e.Key)
-                {
-                    case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;
-                }
-            };
-        }
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.MatrixMode(MatrixMode.Projection);
-            Matrix4 p = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, Width / (float)Height, 0.1f, 64.0f);
-            GL.LoadMatrix(ref p);
-        }
-        #endregion Window
-
-        public override void Setup(EventArgs e)
-        {
-            #region Abort on platforms which will not be able to execute the ops properly
-            /*
-            if (!GL.SupportsExtension("VERSION_1_2"))
-            {
-                Trace.WriteLine("Aborting. OpenGL 1.2 or later required.");
-                this.Exit();
-            }
-
-            int[] t = new int[2];
-            GL.GetInteger(GetPName.MajorVersion, out t[0]);
-            GL.GetInteger(GetPName.MinorVersion, out t[1]);
-            Trace.WriteLine("OpenGL Context Version: " + t[0] + "." + t[1]);
-
-            GL.GetInteger(GetPName.DepthBits, out t[0]);
-            Trace.WriteLine("Depth Bits: " + t[0]);
-            GL.GetInteger(GetPName.StencilBits, out t[1]);
-            Trace.WriteLine("Stencil Bits: " + t[1]);
-
-            if (t[0] < 16)
-            {
-                Trace.WriteLine("Aborting. Need at least 16 depth bits, only " + t[0] + " available.");
-                this.Exit();
-            }
-
-            if (t[1] < 1)
-            {
-                Trace.WriteLine("Aborting. Need at least 1 stencil bit, only " + t[1] + " available.");
-                this.Exit();
-            }
-            */
-            #endregion Abort on platforms which will not be able to execute the ops properly
-
-            #region GL States
-            GL.ClearColor(.08f, .12f, .16f, 1f);
-
-            GL.Enable(EnableCap.DepthTest);
-            GL.DepthFunc(DepthFunction.Less);
-            GL.ClearDepth(1.0);
-
-            GL.Enable(EnableCap.StencilTest);
-            GL.ClearStencil(0);
-            GL.StencilMask(0xFFFFFFFF); // read&write
-
-            GL.Enable(EnableCap.CullFace);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-            GL.CullFace(CullFaceMode.Back);
-
-            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
-
-            GL.Color4(1f, 1f, 1f, 1f);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.ShadeModel(ShadingModel.Smooth);
-
-            #endregion GL States
-
-            #region Load Texture
-            Bitmap bitmap = new Bitmap("Data/Textures/logo-dark.jpg");
-            bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
-
-            GL.GenTextures(1, out Texture);
-            GL.BindTexture(TextureTarget.Texture2D, Texture);
-
-            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-            GL.Finish();
-            bitmap.UnlockBits(data);
-            #endregion Load Texture
-
-            OperandA = new ChamferCube(1.5, 2.0, 2.5, ChamferCube.SubDivs.Four, 0.42, true);
-            OperandB = new SlicedSphere(2.0f, Vector3d.Zero,
-                                           SlicedSphere.eSubdivisions.Three,
-                                           new SlicedSphere.eDir[] { SlicedSphere.eDir.All },
-                                           true);
-
-            #region Invert Operand B's Normals
-            // only the inside of the operand is ever drawn to color buffers and lighting requires this.
-            BeginMode tempPrimMode;
-            VertexT2dN3dV3d[] tempVertices;
-            uint[] tempIndices;
-
-            OperandB.GetArraysforVBO(out tempPrimMode, out tempVertices, out tempIndices);
-            OperandB.Dispose();
-
-            for (int i = 0; i < tempVertices.Length; i++)
-            {
-                tempVertices[i].Normal *= -1.0;
-                tempVertices[i].Normal.Normalize();
-            }
-
-            OperandB = new VboShape(ref tempPrimMode, ref tempVertices, ref tempIndices, true);
-            #endregion Invert Operand B's Normals
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref Texture);
-
-            OperandA.Dispose();
-            OperandB.Dispose();
-
-            base.OnUnload(e);
-        }
-
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            #region Magic numbers for camera
-            CameraRotX = -Mouse.X * .5f;
-            CameraRotY = Mouse.Y * .5f;
-            CameraZoom = Mouse.Wheel * .2f;
-            #endregion Magic numbers for camera
-        }
-
-        public void DrawOperandB()
-        {
-            GL.PushMatrix();
-            GL.Translate(Math.Cos(MySphereXOffset), -1f, Math.Cos(MySphereZOffset));
-            OperandB.Draw();
-            GL.PopMatrix();
-        }
-
-        public void DrawOperandA()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            OperandA.Draw();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        public void RenderCsg()
-        {
-            // first pass
-            GL.Disable(EnableCap.StencilTest);
-
-            GL.ColorMask(false, false, false, false);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB();// draw front-faces into depth buffer
-
-            // use stencil plane to find parts of b in a 
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // increment the stencil where the front face of a is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandA(); // decrement the stencil buffer where the back face of a is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Notequal, 0, 1);
-            DrawOperandB(); // draw the part of b that's in a
-
-            // fix depth
-            GL.ColorMask(false, false, false, false);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Disable(EnableCap.StencilTest);
-            GL.DepthFunc(DepthFunction.Always);
-            DrawOperandA();
-            GL.DepthFunc(DepthFunction.Less);
-
-            // second pass
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA();
-
-            GL.DepthMask(false);
-            GL.Enable(EnableCap.StencilTest);
-
-            GL.StencilFunc(StencilFunction.Always, 0, 0);
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Incr);
-            DrawOperandB(); // increment the stencil where the front face of b is drawn
-
-            GL.StencilOp(StencilOp.Keep, StencilOp.Keep, StencilOp.Decr);
-            GL.CullFace(CullFaceMode.Front);
-            DrawOperandB(); // decrement the stencil buffer where the back face of b is drawn
-
-            GL.DepthMask(true);
-            GL.Disable(EnableCap.DepthTest);
-
-            GL.ColorMask(true, true, true, true);
-            GL.StencilFunc(StencilFunction.Equal, 0, 1);
-            GL.CullFace(CullFaceMode.Back);
-            DrawOperandA(); // draw the part of a that's in b
-
-            GL.Enable(EnableCap.DepthTest);
-        }
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            this.Title = Title + "  FPS: " + (1f / e.Time).ToString("0.");
-
-            MySphereZOffset += (float)(e.Time * 3.1);
-            MySphereXOffset += (float)(e.Time * 4.2);
-
-            #region Transform setup
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit | ClearBufferMask.StencilBufferBit);
-
-            // Camera
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 mv = Matrix4.LookAt(EyePosition, Vector3.Zero, Vector3.UnitY);
-            GL.LoadMatrix(ref mv);
-
-            GL.Translate(0f, 0f, CameraZoom);
-            GL.Rotate(CameraRotX, Vector3.UnitY);
-            GL.Rotate(CameraRotY, Vector3.UnitX);
-            #endregion Transform setup
-
-            RenderCsg();
-
-            // ---------------------------------
-
-            if (ShowDebugWireFrame)
-            {
-                GL.Color3(System.Drawing.Color.LightGray);
-                GL.Disable(EnableCap.StencilTest);
-                GL.Disable(EnableCap.Lighting);
-                //GL.Disable( EnableCap.DepthTest );
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Line);
-                DrawOperandB();
-                GL.PolygonMode(MaterialFace.Front, PolygonMode.Fill);
-                GL.Enable(EnableCap.DepthTest);
-                GL.Enable(EnableCap.Lighting);
-                GL.Enable(EnableCap.StencilTest);
-            }
-            SwapBuffers();
-        }
-
-    }
-}
diff --git a/KAOS/Scene/StereoVisionScene.cs b/KAOS/Scene/StereoVisionScene.cs
deleted file mode 100644
index 2b84210..0000000
--- a/KAOS/Scene/StereoVisionScene.cs
+++ /dev/null
@@ -1,164 +0,0 @@
-﻿using AWGL.Shapes;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-
-namespace AWGL.Scene
-{
-    public class StereoVisionScene : DefaultScene
-    {
-        public StereoVisionScene()
-        {
-            this.VSync = VSyncMode.On;
-        }
-
-        #region Private Fields
-        private TorusKnot obj;
-        private float Angle;
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-
-            obj = new TorusKnot(256, 32, 0.1, 3, 4, 1, true);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            //throw new NotImplementedException();
-        }
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            Angle += (float)(e.Time * 20.0);
-
-            GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
-
-            SetupCamera(Eye.right);
-            GL.ColorMask(true, false, false, true);
-            Draw();
-
-            GL.Clear(ClearBufferMask.DepthBufferBit); // 
-            SetupCamera(Eye.left);
-            GL.ColorMask(false, true, true, true);
-            Draw();
-
-            GL.ColorMask(true, true, true, true);
-
-            SwapBuffers();
-        }
-        #endregion
-    
-        #region OnUnload
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-            obj.Dispose();
-        }
-        #endregion
-
-        #region Setup Camera(Eye eye)
-        private void SetupCamera(Eye eye)
-        {
-            Camera camera;
-
-            camera.Position = Vector3.UnitZ;
-            camera.Up = Vector3.UnitY;
-            camera.Direction = -Vector3.UnitZ;
-            camera.NearPlane = 1.0;
-            camera.FarPlane = 5.0;
-            camera.FocalLength = 2.0;
-            camera.EyeSeparation = camera.FocalLength / 30.0;
-            camera.Aperture = 75.0;
-
-            double left, right,
-                   bottom, top;
-
-            double widthdiv2 = camera.NearPlane * Math.Tan(MathHelper.DegreesToRadians((float)(camera.Aperture / 2.0))); // aperture in radians
-            double precalc1 = ClientRectangle.Width / (double)ClientRectangle.Height * widthdiv2;
-            double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
-
-            Vector3 Right = Vector3.Cross(camera.Direction, camera.Up); // Each unit vectors
-            Right.Normalize();
-
-            Right.X *= (float)(camera.EyeSeparation / 2.0);
-            Right.Y *= (float)(camera.EyeSeparation / 2.0);
-            Right.Z *= (float)(camera.EyeSeparation / 2.0);
-
-            // Projection Matrix
-            top = widthdiv2;
-            bottom = -widthdiv2;
-            if (eye == Eye.right)
-            {
-                left = -precalc1 - precalc2;
-                right = precalc1 - precalc2;
-            }
-            else
-            {
-                left = -precalc1 + precalc2;
-                right = precalc1 + precalc2;
-            }
-
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Frustum(left, right, bottom, top, camera.NearPlane, camera.FarPlane);
-
-            // Modelview Matrix
-            Matrix4 modelview;
-            if (eye == Eye.right)
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X + Right.X, camera.Position.Y + Right.Y, camera.Position.Z + Right.Z),
-                    new Vector3(camera.Position.X + Right.X + camera.Direction.X, camera.Position.Y + Right.Y + camera.Direction.Y, camera.Position.Z + Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            else
-            {
-                modelview = Matrix4.LookAt(
-                    new Vector3(camera.Position.X - Right.X, camera.Position.Y - Right.Y, camera.Position.Z - Right.Z),
-                    new Vector3(camera.Position.X - Right.X + camera.Direction.X, camera.Position.Y - Right.Y + camera.Direction.Y, camera.Position.Z - Right.Z + camera.Direction.Z),
-                    camera.Up);
-            }
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.MultMatrix(ref modelview);
-        }
-        #endregion
-
-        #region Draw
-        private void Draw()
-        {
-            GL.Translate(0f, 0f, -2f);
-            GL.Rotate(Angle, Vector3.UnitY);
-            obj.Draw();
-        }
-        #endregion
-    
-    }
-    #region StereoVison Structs
-    public struct Camera
-    {
-        public Vector3 Position, Direction, Up;
-        public double NearPlane, FarPlane;
-        public double EyeSeparation;
-        public double Aperture; // FOV in degrees
-        public double FocalLength;
-    }
-
-    public enum Eye
-    {
-        left,
-        right,
-    }
-    #endregion
-}
diff --git a/KAOS/Scene/Texture2DScene.cs b/KAOS/Scene/Texture2DScene.cs
deleted file mode 100644
index ec53ee7..0000000
--- a/KAOS/Scene/Texture2DScene.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Drawing;
-using System.Drawing.Imaging;
-
-namespace AWGL.Scene
-{
-    public class Texture2DScene : DefaultScene
-    {
-        #region Private Members
-
-        private Bitmap bitmap = new Bitmap("Data/Textures/logo.jpg");
-        private int texture;
-
-        #endregion
-
-        public override void Setup(EventArgs e)
-        {
-            GL.PointSize(5f);
-            GL.Enable(EnableCap.Texture2D);
-
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-
-            GL.GenTextures(1, out texture);
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);
-
-            BitmapData data = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
-                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0,
-                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
-
-            bitmap.UnlockBits(data);
-        }
-
-        public override void Resize(EventArgs e)
-        {
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);
-        }
-
-        #region OnUnload
-
-        protected override void OnUnload(EventArgs e)
-        {
-            GL.DeleteTextures(1, ref texture);
-        }
-
-        #endregion
-
-        #region OnRenderFrame
-
-        /// <summary>
-        /// Add your game rendering code here.
-        /// </summary>
-        /// <param name="e">Contains timing information.</param>
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-
-            GL.Clear(ClearBufferMask.ColorBufferBit);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-
-            GL.Begin(BeginMode.Quads);
-
-            GL.TexCoord2(0.0f, 1.0f); GL.Vertex2(-0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 1.0f); GL.Vertex2(0.6f, -0.4f);
-            GL.TexCoord2(1.0f, 0.0f); GL.Vertex2(0.6f, 0.4f);
-            GL.TexCoord2(0.0f, 0.0f); GL.Vertex2(-0.6f, 0.4f);
-
-            GL.End();
-
-            SwapBuffers();
-        }
-        #endregion
-
-    }
-}
diff --git a/KAOS/States/DrawSpriteState.cs b/KAOS/States/DrawSpriteState.cs
deleted file mode 100644
index c41a56d..0000000
--- a/KAOS/States/DrawSpriteState.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Utilities;
-//using OpenTK;
-//using OpenTK.Graphics.OpenGL;
-//using System.Drawing;
-
-//namespace KAOS.States
-//{
-//    public class DrawSpriteState : IGameObject
-//    {
-//        private StateManager m_stateManager;
-//        private TextureManager m_textureManager;
-
-//        double height, width, halfHeight, halfWidth, x, y, z;
-//        float topUV, bottomUV, leftUV, rightUV;
-
-//        #region IGameObject States
-
-//        public void Update(float elapsedTime)
-//        {
-//            //throw new NotImplementedException();
-//        }
-
-//        public void Render()
-//        {
-//            Texture texture = m_textureManager.Get("sprite1");
-//            GL.Enable(EnableCap.Texture2D);
-//            GL.BindTexture(TextureTarget.Texture2D, texture.ID);
-
-
-//            GL.ClearColor(Color.Black);
-//            GL.Begin(PrimitiveType.Triangles);
-
-//            GL.TexCoord2(new Vector2d(leftUV, topUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y + halfHeight, 0)); //top left
-//            GL.TexCoord2(new Vector2d(rightUV, topUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-//            GL.TexCoord2(new Vector2d(rightUV, topUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + halfHeight, 0)); //top right
-//            GL.TexCoord2(new Vector2d(rightUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x + halfWidth, y + -halfHeight, 0)); //bottom right
-//            GL.TexCoord2(new Vector2d(leftUV, bottomUV));
-//            GL.Vertex3(new Vector3d(x - halfWidth, y - halfHeight, 0)); //bottom left
-
-//            GL.End();
-
-//        } 
-//        #endregion
-
-//        public DrawSpriteState(StateManager stateManager, TextureManager texturManager)
-//        {
-//            m_stateManager = stateManager;
-//            m_textureManager = texturManager;
-//            Initialise();
-//        }
-
-//        private void Initialise()
-//        {
-//            this.height = 200;
-//            this.width = 200;
-
-//            this.halfHeight = this.height / 2;
-//            this.halfWidth = this.width / 2;
-
-//            this.x = 0;
-//            this.y = 0;
-//            this.z = 2;
-
-//            this.topUV = 0;
-//            this.bottomUV = 1;
-//            this.leftUV = 0;
-//            this.rightUV = 1;
-//        }
-//    }
-//}
diff --git a/KAOS/States/TestSpriteClassState.cs b/KAOS/States/TestSpriteClassState.cs
deleted file mode 100644
index 814b797..0000000
--- a/KAOS/States/TestSpriteClassState.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-﻿using AWGL.Interfaces;
-using AWGL.Managers;
-using AWGL.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace AWGL.States
-{
-    public class TestSpriteClassState : IGameObject
-    {
-        Renderer m_renderer = new Renderer();
-        TextureManager m_textureManager = new TextureManager();
-        Sprite sprite1 = new Sprite();
-        Sprite sprite2 = new Sprite();
-
-        public TestSpriteClassState(TextureManager textureManager)
-        {
-            m_textureManager = textureManager;
-            sprite1.Texture = m_textureManager.Get("sprite1");
-            sprite1.SetHeight(256 * 0.5f);
-            sprite1.SetPosition(new Vector3d(100, 100, 0));
-            sprite1.SetColour(new Color4(256, 256, 256, 1));
-
-            sprite2.Texture = m_textureManager.Get("sprite2");
-            sprite2.SetHeight(256 * .5f);
-            sprite2.SetPosition(new Vector3d(-100, -100, 0));
-            sprite2.SetColour(new Color4(256, 256, 256, 1));
-        }
-
-        public void Update(float elapsedTime)
-        {
-            //throw new NotImplementedException();
-        }
-
-        public void Render()
-        {
-            GL.ClearColor(1f, 1f, 1f, 1f);
-            m_renderer.DrawSprite(sprite1);
-            m_renderer.DrawSprite(sprite2);
-            GL.Finish();
-        }
-    }
-}
diff --git a/KAOS/States/VoxelState.cs b/KAOS/States/VoxelState.cs
deleted file mode 100644
index e6f0ee8..0000000
--- a/KAOS/States/VoxelState.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿//using KAOS.Interfaces;
-//using KAOS.Managers;
-//using KAOS.Shapes;
-//using KAOS.Utilities;
-//using OpenTK.Graphics.OpenGL;
-//using System;
-
-//namespace KAOS.States
-//{
-//    public class VoxelState : IGameObject
-//    {
-//        double currentRotation = 0;
-//        public float length = 1f, height = 1f, width = 1f;
-
-//        StateManager m_stateManager = new StateManager();
-
-//        BufferObjectManager m_bufferObjectManager;
-//        BufferObject m_bufferObject;
-
-//        TextureManager m_textureManager = new TextureManager();
-
-//        Cube[][][] m_blocks;
-
-//        public VoxelState(StateManager stateManager)
-//        {
-//            m_stateManager = stateManager;
-
-//            m_bufferObjectManager = new BufferObjectManager();
-
-//            //LoadSkyBox();
-
-//            GenerateChunk();
-//        }
-
-//        private void LoadSkyBox()
-//        {
-//            string skyboxTexturePath = "Data/Skyboxes/jajlands1/";
-//            m_textureManager.LoadSkyTexture("skybox", 
-//                new string[] 
-//                {
-//                    skyboxTexturePath + "jajlands1_ft.jpg",
-//                    skyboxTexturePath + "jajlands1_bk.jpg",
-//                    skyboxTexturePath + "jajlands1_lf.jpg",
-//                    skyboxTexturePath + "jajlands1_rt.jpg",
-//                    skyboxTexturePath + "jajlands1_up.jpg",
-//                    skyboxTexturePath + "jajlands1_dn.jpg"
-//                }
-//            );
-
-//        }
-
-//        private void GenerateChunk()
-//        {
-//            BufferObject tmpVBO = new BufferObject();
-//            tmpVBO.PrimitiveType = PrimitiveType.Triangles;
-//            m_blocks = new Cube[Utilities.Chunk.CHUNK_SIZE][][];
-            
-//            for (int x = 0; x < Utilities.Chunk.CHUNK_SIZE; x++)
-//            {
-//                m_blocks[x] = new Cube[Utilities.Chunk.CHUNK_SIZE][];
-//                for (int y = 0; y < Utilities.Chunk.CHUNK_SIZE; y++)
-//                {
-//                    m_blocks[x][y] = new Cube[Utilities.Chunk.CHUNK_SIZE];
-//                    for (int z = 0; z < Utilities.Chunk.CHUNK_SIZE; z++)
-//                    {
-//                        m_blocks[x][y][z] = new Cube(x, y, z);
-
-//                        if (x == 0 && y == 0 && z == 0) 
-//                        { 
-//                            tmpVBO.PositionData = m_blocks[x][y][z].Vertices;
-//                            tmpVBO.NormalsData = m_blocks[x][y][z].Normals;
-//                            tmpVBO.IndicesData = m_blocks[x][y][z].Indices;
-//                        }
-//                        else
-//                        { 
-//                            tmpVBO.PositionData = tmpVBO.PositionData.Concat(m_blocks[x][y][z].Vertices);
-//                            tmpVBO.NormalsData = tmpVBO.NormalsData.Concat(m_blocks[x][y][z].Normals);
-//                            tmpVBO.IndicesData = tmpVBO.IndicesData.Concat(m_blocks[x][y][z].Indices);
-//                        }
-//                    }
-//                }
-//            }
-
-//            m_bufferObjectManager.AddBufferObject("chunk-test", tmpVBO, ShaderManager.Get("Voxel").ID);
-//            m_bufferObject = m_bufferObjectManager.GetBuffer("chunk-test");
-//        }
-
-//        public void Update(float elapsedTime)
-//        {
-//            currentRotation = 100 * elapsedTime;
-//        }
-
-//        public void Render()
-//        {
-//            GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
-//            GL.BindVertexArray(m_bufferObject.VaoID);
-//            GL.DrawElements(m_bufferObject.PrimitiveType, m_bufferObject.IndicesData.Length, DrawElementsType.UnsignedInt, IntPtr.Zero);                    
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Block.cs b/KAOS/Utilities/Block.cs
deleted file mode 100644
index 3cee9cd..0000000
--- a/KAOS/Utilities/Block.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-﻿//using System;
-//using System.Collections.Generic;
-//using System.Linq;
-//using System.Text;
-//using System.Threading.Tasks;
-
-//namespace KAOS.Utilities
-//{
-//    public class Block
-//    {
-//        enum BlockType
-//        {
-//            BlockType_Default = 0,
-
-//            BlockType_Grass,
-//            BlockType_Dirt,
-//            BlockType_Water,
-//            BlockType_Stone,
-//            BlockType_Wood,
-//            BlockType_Sand,
-
-//            BlockType_NumTypes,
-//        };
-
-//        public bool IsActive { get; set; }
-//        private bool m_active;
-//        private BlockType type;
-//    }
-//}
diff --git a/KAOS/Utilities/Chunk.cs b/KAOS/Utilities/Chunk.cs
deleted file mode 100644
index 0282844..0000000
--- a/KAOS/Utilities/Chunk.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿//using KAOS.Shapes;
-//using OpenTK;
-//using System;
-//using System.Collections.Generic;
-//using System.Linq;
-//using System.Text;
-//using System.Threading.Tasks;
-//namespace KAOS.Utilities
-//{
-//    public class Chunk : IDisposable
-//    {
-//        public const int CHUNK_SIZE = 16;
-//        private Block[][][] m_blocks;
-//        private List<Block> m_blockStore = new List<Block>(CHUNK_SIZE * 3);
-
-//        public Chunk()
-//        {
-//            //Create Blocks
-//            m_blocks = new Block[CHUNK_SIZE][][];
-//            for (int i = 0; i < CHUNK_SIZE; i++)
-//            {
-//                m_blocks[i] = new Block[CHUNK_SIZE][];
-
-//                for (int j = 0; j < CHUNK_SIZE; j++)
-//                {
-//                    m_blocks[i][j] = new Block[CHUNK_SIZE];
-//                }
-//            }
-//        }
-
-//        public void Update(float dt) { }
-
-//        public void Render() { }
-
-//        public void Dispose()
-//        {
-//            // Delete blocks
-//            for (int i = 0; i < CHUNK_SIZE; i++)
-//            {
-                
-
-//                for (int j = 0; j < CHUNK_SIZE; j++)
-//                {
-//                    m_blocks[i][j] = null;
-//                }
-//                m_blocks[i] = null;
-//            }
-//            m_blocks = null;
-//        }
-
-//        public void CreateMesh()
-//        {
-//            for (int x = 0; x < CHUNK_SIZE; x++)
-//            {
-//                for (int y = 0; y < CHUNK_SIZE; y++)
-//                {
-//                    for (int z = 0; z < CHUNK_SIZE; z++)
-//                    {
-//                        if (m_blocks[x][y][z].IsActive == false)
-//                        {
-//                            // Don't create triangle data for inactive blocks
-//                            continue;
-//                        }
-
-//                        CreateCube(x, y, z);
-//                    }
-//                }
-//            }
-//        }
-
-//        private void CreateCube(int x, int y, int z)
-//        {
-//            float blockSize = 1f;
-
-            
-//            Vector3 p1 = new Vector3(x - blockSize, y - blockSize, z + blockSize);
-//            Vector3 p2 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-//            Vector3 p3 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-//            Vector3 p4 = new Vector3(x + blockSize, y + blockSize, z + blockSize);
-//            Vector3 p5 = new Vector3(x + blockSize, y - blockSize, z + blockSize);
-//            Vector3 p6 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-//            Vector3 p7 = new Vector3(x - blockSize, y + blockSize, z - blockSize);
-//            Vector3 p8 = new Vector3(x + blockSize, y + blockSize, z - blockSize);
-
-//            Vector3 n1;
-
-
-//            throw new NotImplementedException();
-//        }
-//    }
-//}
diff --git a/KAOS/Utilities/Sprite.cs b/KAOS/Utilities/Sprite.cs
deleted file mode 100644
index 8ce0c32..0000000
--- a/KAOS/Utilities/Sprite.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿using OpenTK;
-using OpenTK.Graphics;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace KAOS.Utilities
-{
-    public class Sprite
-    {
-        internal const int VertexAmount = 6;
-        Vector3d[] vertexPositions = new Vector3d[VertexAmount];
-        Color4[] vertexColours = new Color4[VertexAmount];
-        Vector2[] vertexUVs = new Vector2[VertexAmount];
-        Texture texture = new Texture();
-
-        public Texture Texture
-        {
-            get { return texture; }
-            set
-            {
-                texture = value;
-
-                InitVertexPositions(GetCentre(), texture.Width, texture.Height);
-            }
-        }
-        public Vector3d[] VertexPositions { get { return vertexPositions; } }
-
-        public Color4[] VertexColours { get { return vertexColours; } }
-
-        public Vector2[] VertexUVs { get { return vertexUVs; } }
-
-        public Sprite()
-        {
-            InitVertexPositions(new Vector3d(0, 0, 0 ), 1, 1);
-            //SetColour(new Color4(1, 1, 1, 1));
-            SetUVs(new Vector2(0, 0), new Vector2(1, 1));
-        }
-
-        private Vector3d GetCentre()
-        {
-            double halfWidth = GetWidth() / 2;
-            double halfHeight = GetHeight() / 2;
-
-            return new Vector3d(
-                vertexPositions[0].X + halfWidth,
-                vertexPositions[0].Y - halfHeight,
-                vertexPositions[0].Z);
-        }
-
-        private void InitVertexPositions(Vector3d position, double width, double height)
-        {
-            double halfWidth = width / 2;
-            double halfHeight = height / 2;
-
-            vertexPositions[0] = new Vector3d(position.X - halfWidth, position.Y + halfHeight, position.Z); //top left
-            vertexPositions[1] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[2] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-
-            vertexPositions[3] = new Vector3d(position.X + halfWidth, position.Y + halfHeight, position.Z); //top right
-            vertexPositions[4] = new Vector3d(position.X + halfWidth, position.Y + -halfHeight, position.Z); //bottom right
-            vertexPositions[5] = new Vector3d(position.X - halfWidth, position.Y - halfHeight, position.Z); //bottom left
-        }
-
-        public double GetWidth()
-        {
-            //top right -> top left
-            return vertexPositions[1].X - vertexPositions[0].X;
-        }
-
-        public double GetHeight()
-        {
-            //top left -> bottom left
-            return vertexPositions[0].Y - vertexPositions[2].Y;
-        }
-
-        public void SetWidth(double width)
-        {
-            InitVertexPositions(GetCentre(), width, GetHeight());
-        }
-
-        public void SetHeight(double height)
-        {
-            InitVertexPositions(GetCentre(), GetWidth(), height);
-        }
-
-        public void SetPosition(double x, double y)
-        {
-            SetPosition(new Vector3d(x, y, 0));
-        }
-
-        public void SetPosition(Vector3d position)
-        {
-            InitVertexPositions(position, GetWidth(), GetHeight());
-        }
-
-        public void SetColour(Color4 color4)
-        {
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                vertexColours[i] = color4;
-            }
-        }
-
-        private void SetUVs(Vector2 topLeft, Vector2 bottomRight)
-        {
-            vertexUVs[0] = topLeft;
-            vertexUVs[1] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[2] = new Vector2(topLeft.X, bottomRight.Y);
-
-            vertexUVs[3] = new Vector2(bottomRight.X, topLeft.Y);
-            vertexUVs[4] = bottomRight;
-            vertexUVs[5] = new Vector2(topLeft.X, bottomRight.Y);
-        }
-    }
-}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/00a816df5fc5d185bf8fe187db800d274e737861">Moving input handling to a separate class.</a>  -  00a816d</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 32 insertions(+), 29 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index f4cdc0e..eb862c7 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -24,4 +24,2 @@ namespace KAOS
         protected AnimationTimer m_Timer;
-
-        MouseState current, previous;
         
@@ -42,3 +40,2 @@ namespace KAOS
             InitialiseTimer();
-            InitialiseInput();
             InitialiseStockShaders();
@@ -46,8 +43,2 @@ namespace KAOS
 
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
         private void InitialiseTimer()
@@ -70,19 +61,4 @@ namespace KAOS
         {
-            #region Mouse Input
-            current = OpenTK.Input.Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-                ResetCursor();
-            }
-            
-            #endregion
+            InputManager.PollInput();
+            ResetCursor();
 
@@ -131,3 +107,3 @@ namespace KAOS
         #region Input Control
-        
+
         private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index c6e84e7..be3edc1 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -1,2 +1,3 @@
-﻿using OpenTK.Input;
+﻿using OpenTK;
+using OpenTK.Input;
 using System.Collections.Generic;
@@ -10,5 +11,31 @@ namespace KAOS.Managers
     {
-        public static List<Key> keyList = new List<Key>();
+        internal static List<Key> keyList = new List<Key>();
 
+        internal static MouseState current, previous;
+        internal static KeyboardState keyState;
 
+        internal static void PollInput()
+        {
+            #region Keyboard
+            keyState = Keyboard.GetState();
+
+            #endregion
+
+            #region Mouse
+            current = Mouse.GetState();
+            if (current[MouseButton.Left])
+            {
+                if (current != previous)
+                {
+                    // Mouse state has changed
+                    int xdelta = current.X - previous.X;
+                    int ydelta = current.Y - previous.Y;
+                    int zdelta = current.Wheel - previous.Wheel;
+                    Utilities.Camera.AddRotation(xdelta, ydelta);
+                }
+                previous = current;
+            }
+
+            #endregion
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8f9c7a8a3697332dbf2d8aec53739d0ad1819f58">Moved more input implementation into it's own class.</a>  -  8f9c7a8</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 4 files changed, 58 insertions(+), 78 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index eb862c7..e416431 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -40,2 +40,3 @@ namespace KAOS
             InitialiseTimer();
+            InitialiseInput();
             InitialiseStockShaders();
@@ -43,2 +44,8 @@ namespace KAOS
 
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
         private void InitialiseTimer()
@@ -96,9 +103,2 @@ namespace KAOS
             float aspect = ScreenWidth / (float)ScreenHeight;
-
-            #region Assimp Example Code
-            //float widthToHeight = ScreenWidth / (float)ScreenHeight;
-            //Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4, widthToHeight, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perspective); 
-            #endregion
         }
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index be3edc1..21e6993 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -18,8 +18,8 @@ namespace KAOS.Managers
         {
-            #region Keyboard
-            keyState = Keyboard.GetState();
-
-            #endregion
+            KeyboardUpdate();
+            MouseUpdate();
+        }
 
-            #region Mouse
+        private static void MouseUpdate()
+        {
             current = Mouse.GetState();
@@ -37,5 +37,50 @@ namespace KAOS.Managers
             }
+        }
+
+        private static void KeyboardUpdate()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Utilities.Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Utilities.Camera.Move(-0.1f, 0f, 0f);
+                        break;
 
-            #endregion
+                    case Key.S:
+                        Utilities.Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Utilities.Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Utilities.Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Utilities.Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Utilities.Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Utilities.Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+
+            }
         }
+
     }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index e96452b..9cfca73 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,4 +84,2 @@ namespace KAOS.States
         {
-            MoveCamera();
-
             Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
@@ -100,51 +98,2 @@ namespace KAOS.States
 
-        #region Input Control
-        private void MoveCamera()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-
-            }
-        #endregion
-        }
-
         public void Dispose()
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index bd94465..abc0782 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -33,16 +33,2 @@ namespace KAOS.Utilities
 
-        public static void DrawSprite(Sprite sprite)
-        {
-            GL.BindTexture(TextureTarget.Texture2D, sprite.Texture.ID);
-            GL.Begin(OpenTK.Graphics.OpenGL.PrimitiveType.Triangles);
-            for (int i = 0; i < Sprite.VertexAmount; i++)
-            {
-                DrawImmediateModeVertex(
-                    sprite.VertexPositions[i],
-                    sprite.VertexColours[i],
-                    sprite.VertexUVs[i]);
-            }
-            GL.End();
-        }
-
         public static void DrawSkyBox(TextureManager textureManager, BufferObject bufferObject)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2287b63bc37ba5a750637cc84efdb99125731e6b">Removing more redundant code.</a>  -  2287b63</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 19 files changed, 367 deletions(-)

diff --git a/KAOS/Data/Shaders/CH02_FS.glsl b/KAOS/Data/Shaders/CH02_FS.glsl
deleted file mode 100644
index dff573e..0000000
--- a/KAOS/Data/Shaders/CH02_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-#version 140 core
-
-out vec4 color;
-
-void main(void)
-{
-	color = vec4(0.0, 0.8, 0.0, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CH02_VS.glsl b/KAOS/Data/Shaders/CH02_VS.glsl
deleted file mode 100644
index 6a17ae4..0000000
--- a/KAOS/Data/Shaders/CH02_VS.glsl
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿#version 140 core
-
-void main(void)
-{
-	const vec4 vertices[3] = vec4[3](
-		vec4(0.25, -0.25, 0.5, 1.0),
-		vec4(-0.25, 0.25, 0.5, 1.0),
-		vec4(0.25, 0.25, 0.5, 1.0)
-		);
-	// Index into our array using gl_VertexID
-	gl_Position = vertices[gl_VertexID];
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_FS.glsl b/KAOS/Data/Shaders/CubeMap_FS.glsl
deleted file mode 100644
index 2376923..0000000
--- a/KAOS/Data/Shaders/CubeMap_FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-uniform samplerCube Earth;
-varying vec3 Normal;
-
-void main()
-{ 
-  gl_FragColor = textureCube( Earth, Normal.xyz ); 
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/CubeMap_VS.glsl b/KAOS/Data/Shaders/CubeMap_VS.glsl
deleted file mode 100644
index 21b3c99..0000000
--- a/KAOS/Data/Shaders/CubeMap_VS.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// MUST be written to for FS
-varying vec3 Normal;
-
-void main()
-{
-  gl_Position = ftransform();
-  Normal = /*gl_NormalMatrix * */ gl_Normal ;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/FS.glsl b/KAOS/Data/Shaders/FS.glsl
deleted file mode 100644
index 5525234..0000000
--- a/KAOS/Data/Shaders/FS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 330
- 
-in vec4 color;
-out vec4 outputColor;
- 
-void main()
-{
-    outputColor = color;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
deleted file mode 100644
index 10fe5cd..0000000
--- a/KAOS/Data/Shaders/JuliaSet_SM2_FS.glsl
+++ /dev/null
@@ -1,66 +0,0 @@
-#version 110
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-// uniforms from OpenGL
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-// GLSL internal variables. 
-const int MAXIterations = 16; // must be greater than zero, 16 is a good blend between detail and speed
-float XPos;
-float YPos;
-float XQuad;
-float YQuad; // half precision floating point could be used on those 4 floats for speed, but will throw a warning.
-int TableIndex;
-int LoopCount;
-
-// this function reduces duplicate code
-void Iterate(void)
-{
-  YPos = 2.0 * XPos * YPos + CETY;
-  XPos = XQuad - YQuad + CETX;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex++;
-  if ( (XQuad + YQuad) > 4.0 ) LoopCount = MAXIterations; // skip further iterations for this Pixel
-  LoopCount++;
-}
-
-// Shader entry point, this is executed per Pixel
-void main(void)
-{
-  XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  XQuad = pow(XPos, 2.0);
-  YQuad = pow(YPos, 2.0);
-  TableIndex = -1;
-  LoopCount = 0;
-  // the loop is unrolled for SM 2.0 compatibility
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==0
-  if ( LoopCount > 1 ) discard; // attempt to early-out, will affect ~1/3 of all Pixels
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); 
-  if ( LoopCount <= MAXIterations ) Iterate(); // TableIndex==16
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
- 
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-// gl_FragColor.rgb = vec3(FinalTableIndex); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl b/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
deleted file mode 100644
index 003068b..0000000
--- a/KAOS/Data/Shaders/JuliaSet_SM3_FS.glsl
+++ /dev/null
@@ -1,41 +0,0 @@
-#version 120
-// www.OpenTK.net GLSL Julia Set (c) 2008 Christoph Brandtner
-
-uniform sampler1D COLORTABLE;
-uniform float CETX;
-uniform float CETY;
-uniform float SCALINGX;
-uniform float SCALINGY;
-uniform float OFFSETX;
-uniform float OFFSETY;
-
-const int MAXIterations = 32; // *must* be > 0
-
-void main(void)
-{
-  float XPos = gl_FragCoord.x / SCALINGX - OFFSETX;
-  float YPos = gl_FragCoord.y / SCALINGY - OFFSETY;
-  float XQuad = pow( XPos, 2.0 );
-  float YQuad = pow( YPos, 2.0 );
-  int TableIndex = -1;
-  int LoopCount = 0;
-  while ( LoopCount <= MAXIterations )
-    {
-      YPos = 2.0 * XPos * YPos + CETY;
-      XPos = XQuad - YQuad + CETX;
-      XQuad = pow( XPos, 2.0 );
-      YQuad = pow( YPos, 2.0 );
-      TableIndex++;
-      if ( (XQuad + YQuad) > 4.0 )
-      { 
-         if (TableIndex == 0)
-           discard;
-         LoopCount = MAXIterations;
-      }
-      LoopCount++;
-    }
-  float FinalTableIndex = float( TableIndex ) / float( MAXIterations );
-
-  gl_FragColor = texture1D( COLORTABLE, FinalTableIndex ); // lookup texture for output
-  // gl_FragColor.rgb = vec3( FinalTableIndex ); // Debug: output greyscale
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/JuliaSet_VS.glsl b/KAOS/Data/Shaders/JuliaSet_VS.glsl
deleted file mode 100644
index cbee942..0000000
--- a/KAOS/Data/Shaders/JuliaSet_VS.glsl
+++ /dev/null
@@ -1,4 +0,0 @@
-void main(void)
-{
-  gl_Position = ftransform(); // gl_ModelViewProjectionMatrix * gl_Vertex;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_FS.glsl b/KAOS/Data/Shaders/Parallax_FS.glsl
deleted file mode 100644
index ea259a4..0000000
--- a/KAOS/Data/Shaders/Parallax_FS.glsl
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// Material uniforms
-uniform sampler2D Material_DiffuseAndHeight;
-uniform sampler2D Material_NormalAndGloss;
-uniform vec3 Material_ScaleBiasShininess; // x=Scale, y=Bias, z=Shininess
-
-// Light uniforms
-uniform vec3 Light_DiffuseColor;
-uniform vec3 Light_SpecularColor;
-
-// from VS
-varying vec3 VaryingLightVector;
-varying vec3 VaryingEyeVector;
-
-vec3 normal;
-
-void main()
-{ 
-  vec3 lightVector = normalize( VaryingLightVector );
-  vec3 eyeVector = normalize( VaryingEyeVector );
-
-  // first, find the parallax displacement by reading only the height map
-  float parallaxOffset = texture2D( Material_DiffuseAndHeight, gl_TexCoord[0].st ).a *
-                         Material_ScaleBiasShininess.x - Material_ScaleBiasShininess.y;
-  vec2 newTexCoords = gl_TexCoord[0].st + ( parallaxOffset * eyeVector.xy ); // displace texcoords according to viewer
-
-  // knowing the displacement, read RGB, Normal and Gloss
-  vec3 diffuseColor = texture2D( Material_DiffuseAndHeight, newTexCoords.st ).rgb;
-  vec4 temp = texture2D( Material_NormalAndGloss, newTexCoords.st );
-  
-  // build a usable normal vector
-  normal.xy = temp.ag * 2.0 - 1.0; // swizzle alpha and green to x/y and scale to [-1..+1]
-  normal.z = sqrt( 1.0 - normal.x*normal.x - normal.y*normal.y ); // z = sqrt(1-x^2-y^2)
-  
-  // move other properties to be better readable
-  float gloss = temp.r;
-  
-//  float alpha = temp.b;
-//  if ( alpha < 0.2 ) // optimization: should move this test before reading RGB texture
-//    discard;
-  
-  // tweaked phong lighting
-  float lambert = max( dot( lightVector, normal ), 0.0 );
-
-  gl_FragColor = vec4( Light_DiffuseColor * diffuseColor, 1.0 ) * 
-                 lambert;
-
-  if ( lambert > 0.0 )
-  {
-    float specular = pow(
-                         clamp( dot( reflect( -lightVector, normal ), eyeVector ), 0.0, 1.0 ), 
-                         Material_ScaleBiasShininess.z );
-
-    gl_FragColor += vec4( Light_SpecularColor * diffuseColor, 1.0 ) * ( specular * gloss );
-  }
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Parallax_VS.glsl b/KAOS/Data/Shaders/Parallax_VS.glsl
deleted file mode 100644
index 49268be..0000000
--- a/KAOS/Data/Shaders/Parallax_VS.glsl
+++ /dev/null
@@ -1,35 +0,0 @@
-// Copyright (c) 2008 the OpenTK Team. See license.txt for legal bla
-
-// custom vertex attribute
-attribute vec3 AttributeTangent; 
-
-// world uniforms
-uniform vec3 Light_Position;
-uniform vec3 Camera_Position;
-
-// MUST be written to for FS
-varying vec3 VaryingLightVector; 
-varying vec3 VaryingEyeVector;
-
-void main()
-{
-  gl_Position = ftransform();
-  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
-
-  vec3 nor = normalize( gl_NormalMatrix * gl_Normal );
-  vec3 tan = normalize( gl_NormalMatrix * AttributeTangent );
-  vec3 bi = cross(nor, tan);
-  
-  // need positions in tangent space
-  vec3 vertex = vec3( gl_ModelViewMatrix * gl_Vertex );
-
-  vec3 temp = Light_Position - vertex;
-  VaryingLightVector.x = dot(temp, tan); // optimization, calculate dot products rather than building TBN matrix
-  VaryingLightVector.y = dot(temp, bi);
-  VaryingLightVector.z = dot(temp, nor);
-
-  temp = Camera_Position - vertex;
-  VaryingEyeVector.x = dot(temp, tan);
-  VaryingEyeVector.y = dot(temp, bi);
-  VaryingEyeVector.z = dot(temp, nor);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_FS.glsl b/KAOS/Data/Shaders/Picking_FS.glsl
deleted file mode 100644
index f4e2af6..0000000
--- a/KAOS/Data/Shaders/Picking_FS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor;
-
-void main(void)
-{
-  gl_FragColor = vColor;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Picking_VS.glsl b/KAOS/Data/Shaders/Picking_VS.glsl
deleted file mode 100644
index 0deb532..0000000
--- a/KAOS/Data/Shaders/Picking_VS.glsl
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿#version 120
-
-flat varying vec4 vColor; // must be flat, cannot have this interpolated in any way
-
-void main(void)
-{
-  vColor = gl_Color;
-  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // ftransform();
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_FS.glsl b/KAOS/Data/Shaders/Simple_FS.glsl
deleted file mode 100644
index 85e2a85..0000000
--- a/KAOS/Data/Shaders/Simple_FS.glsl
+++ /dev/null
@@ -1,5 +0,0 @@
-/* Copies incoming fragment color without change. */
-void main()
-{
-    gl_FragColor = gl_Color;
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/Simple_VS.glsl b/KAOS/Data/Shaders/Simple_VS.glsl
deleted file mode 100644
index b0fc2a6..0000000
--- a/KAOS/Data/Shaders/Simple_VS.glsl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Copies incoming vertex color without change.
- * Applies the transformation matrix to vertex position.
- */
-void main()
-{
-    gl_FrontColor = gl_Color;
-    gl_Position = ftransform();
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/VS.glsl b/KAOS/Data/Shaders/VS.glsl
deleted file mode 100644
index 687408f..0000000
--- a/KAOS/Data/Shaders/VS.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-﻿#version 330
- 
-in vec3 vPosition;
-in  vec3 vColor;
-out vec4 color;
-uniform mat4 modelview;
- 
-void main()
-{
-    gl_Position = modelview * vec4(vPosition, 1.0);
- 
-    color = vec4( vColor, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-fs.glsl b/KAOS/Data/Shaders/opentk-fs.glsl
deleted file mode 100644
index f890462..0000000
--- a/KAOS/Data/Shaders/opentk-fs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-const vec3 ambient = vec3(0.1, 0.1, 0.1);
-const vec3 lightVecNormalized = normalize(vec3(0.5, 0.5, 2.0));
-const vec3 lightColor = vec3(1.0, 0.2, 0.2);
-
-in vec3 normal;
-
-out vec4 out_frag_color;
-
-void main(void)
-{
-  float diffuse = clamp(dot(lightVecNormalized, normalize(normal)), 0.0, 1.0);
-  out_frag_color = vec4(ambient + diffuse * lightColor, 1.0);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/opentk-vs.glsl b/KAOS/Data/Shaders/opentk-vs.glsl
deleted file mode 100644
index 1cd8777..0000000
--- a/KAOS/Data/Shaders/opentk-vs.glsl
+++ /dev/null
@@ -1,26 +0,0 @@
-#version 410 core
-
-precision highp float;
-
-// object space to camera space transformation
-uniform mat4 modelview_matrix;
- 
-// camera space to clip coordinates
-uniform mat4 projection_matrix;
- 
-// incoming vertex position
-in vec3 in_position;
- 
-// incoming vertex normal
-in vec3 in_normal;
- 
-// transformed vertex normal
-out vec3 normal;
-
-void main(void)
-{
-  //works only for orthogonal modelview
-  //normal = (modelview_matrix * vec4(in_normal, 0)).xyz;
-  
-  gl_Position = projection_matrix * modelview_matrix * vec4(in_position, 1);
-}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-fs.glsl b/KAOS/Data/Shaders/spincube-fs.glsl
deleted file mode 100644
index a8d60b9..0000000
--- a/KAOS/Data/Shaders/spincube-fs.glsl
+++ /dev/null
@@ -1,13 +0,0 @@
-#version 330 core                                                  
-                                                                               
-out vec4 color;                                                    
-                                                                               
-in VS_OUT                                                          
-{                                                                  
-    vec4 color;                                                    
-} fs_in;                                                           
-                                                                               
-void main(void)                                                    
-{                                                                  
-    color = fs_in.color;                                           
-}    
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/spincube-vs.glsl b/KAOS/Data/Shaders/spincube-vs.glsl
deleted file mode 100644
index 9de1ae1..0000000
--- a/KAOS/Data/Shaders/spincube-vs.glsl
+++ /dev/null
@@ -1,17 +0,0 @@
-#version 330 core                                                   
-                                                                                
-in vec4 position;                                                   
-                                                                                
-out VS_OUT                                                          
-{                                                                   
-    vec4 color;                                                     
-} vs_out;                                                           
-                                                                                
-uniform mat4 mv_matrix;                                             
-uniform mat4 proj_matrix;                                           
-                                                                                
-void main(void)                                                     
-{                                                                   
-    gl_Position = proj_matrix * mv_matrix * position;               
-    vs_out.color = position * 2.0 + vec4(0.5, 0.5, 0.5, 0.0);       
-}   
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9519e4015c6e0dd051d0678799bdb587807aeec6">and more organising.</a>  -  9519e40</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 9cfca73..d52abeb 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -19,3 +19,3 @@ namespace KAOS.States
 
-        static string defaultSkyboxPath = "Data/Skyboxes/set 16/";
+        static string defaultSkyboxPath = "Data/Textures/skybox/";
         string[] skyboxFaces = new String[]

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0eb21b64fad28b9ce647c7d1416796e3cfa40121">More tidying.</a>  -  0eb21b6</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/KAOS/Managers/TextureManager.cs b/KAOS/Managers/TextureManager.cs
index f81dc83..359485a 100644
--- a/KAOS/Managers/TextureManager.cs
+++ b/KAOS/Managers/TextureManager.cs
@@ -21,3 +21,3 @@ namespace KAOS.Managers
 
-        private int textureGpuHandle;
+        private int textureGpuHandle, textureVao;
         private Bitmap bitmap;
@@ -44,3 +44,3 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
@@ -67,3 +67,3 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
@@ -94,3 +94,10 @@ namespace KAOS.Managers
 
-            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, bitmapData.Width, bitmapData.Height));
+            //GL.Enable(EnableCap.TextureCubeMapSeamless);
+
+            //GL.GenVertexArrays(1, out textureVao);
+            //GL.BindVertexArray(textureVao);
+
+            //GL.DepthFunc(DepthFunction.Lequal);
+
+            m_textureDatabase.Add(textureId, new Texture(textureGpuHandle, textureVao, bitmapData.Width, bitmapData.Height));
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d52abeb..4b3ac6b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -17,4 +17,2 @@ namespace KAOS.States
 
-        Cube cube;
-
         static string defaultSkyboxPath = "Data/Textures/skybox/";
@@ -30,4 +28,2 @@ namespace KAOS.States
 
-        int skybox_vao;
-
         float aspect = 1024 / (float)600;
@@ -67,8 +63,2 @@ namespace KAOS.States
             m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-            GL.Enable(EnableCap.TextureCubeMapSeamless);
-
-            GL.GenVertexArrays(1, out skybox_vao);
-            GL.BindVertexArray(skybox_vao);
-
-            GL.DepthFunc(DepthFunction.Lequal);
         }
@@ -77,4 +67,3 @@ namespace KAOS.States
         {
-            cube = new Cube(0, 0, 0);
-            m_bufferManager.AddBufferObject("SkyCube", cube, ShaderManager.Skybox.ID);
+            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
             m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
diff --git a/KAOS/Utilities/Texture.cs b/KAOS/Utilities/Texture.cs
index fffdeb7..77562b6 100644
--- a/KAOS/Utilities/Texture.cs
+++ b/KAOS/Utilities/Texture.cs
@@ -10,2 +10,3 @@ namespace KAOS.Utilities
         public int ID { get; set; }
+        public int VAO { get; set; }
         public int Width { get; set; }
@@ -13,5 +14,6 @@ namespace KAOS.Utilities
 
-        public Texture(int id, int width, int height) :this()
+        public Texture(int id, int vao, int width, int height) :this()
         {
             ID = id;
+            VAO = vao;
             Width = width;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9b30638cf4ebe986cf5d77b29a6629bbffe3ceaf">Separated modelViewMatrix.</a>  -  9b30638</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
index 4f89dba..c2bfc32 100644
--- a/KAOS/Data/Shaders/render-vs.glsl
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -2,5 +2,7 @@
 
-uniform mat4 mv_matrix;
+uniform mat4 model_matrix;
+uniform mat4 view_matrix;
 uniform mat4 proj_matrix;
 
+
 layout (location = 0) in vec4 in_position;
@@ -16,2 +18,3 @@ void main(void)
 {
+	mat4  mv_matrix = view_matrix * model_matrix;
     vec4 pos_vs = mv_matrix * in_position;
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 4b3ac6b..70d910d 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -53,3 +53,4 @@ namespace KAOS.States
             Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
-            Renderer.handle_modelViewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "mv_matrix");
+            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
 
@@ -75,5 +76,6 @@ namespace KAOS.States
 
-            Renderer.viewMatrix = Matrix4.Invert(Camera.GetViewMatrix());
+            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            Renderer.modelMatrix = Matrix4.CreateScale(2f);
 
-            Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
+            //Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index abc0782..3e3848a 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -19,7 +19,7 @@ namespace KAOS.Utilities
         #region Members
-        internal static Matrix4 projectionMatrix, modelViewMatrix, viewMatrix;
+        internal static Matrix4 projectionMatrix, modelMatrix, viewMatrix;
         internal static Vector3 eyePosition;
         internal static int 
-            handle_projectionMatrix, handle_modelViewMatrix, handle_eyePosition, handle_viewMatrix, 
-            handle_centre, handle_scale, handle_iter;
+            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix, 
+            handle_centre, handle_scale, handle_iter, handle_modelMatrix;
         #endregion
@@ -57,3 +57,5 @@ namespace KAOS.Utilities
 
-            GL.UniformMatrix4(handle_modelViewMatrix, false, ref modelViewMatrix);
+
+            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+            GL.UniformMatrix4(handle_modelMatrix, false, ref modelMatrix);
             GL.UniformMatrix4(handle_projectionMatrix, false, ref projectionMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e0bf1ea76e5668a0e49558075d34b8d12c95ec60">Fixed camera at last.</a>  -  e0bf1ea</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 70d910d..d33ea8e 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -54,3 +54,3 @@ namespace KAOS.States
             Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
+            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
 
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 3e3848a..dbab8b2 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -21,5 +21,5 @@ namespace KAOS.Utilities
         internal static Vector3 eyePosition;
-        internal static int 
-            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix, 
-            handle_centre, handle_scale, handle_iter, handle_modelMatrix;
+        internal static int
+            handle_projectionMatrix, handle_eyePosition, handle_viewMatrix,
+            handle_centre, handle_scale, handle_iter, handle_modelMatrix, handle_viewMatrix2;
         #endregion
@@ -58,3 +58,3 @@ namespace KAOS.Utilities
 
-            GL.UniformMatrix4(handle_viewMatrix, false, ref viewMatrix);
+            GL.UniformMatrix4(handle_viewMatrix2, false, ref viewMatrix);
             GL.UniformMatrix4(handle_modelMatrix, false, ref modelMatrix);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/535c9e93b12e0507b0f91461abe6c98001e9c1f4">removing regions</a>  -  535c9e9</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 4 insertions(+), 9 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index e416431..41fc861 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -30,3 +30,3 @@ namespace KAOS
 
-        #region Load everything here
+        // Load everything here
         protected override void OnLoad(System.EventArgs e)
@@ -63,5 +63,3 @@ namespace KAOS
 
-        #endregion
-
-        #region Game Loop
+        // Game Loop
         protected override void OnUpdateFrame(FrameEventArgs e)
@@ -104,5 +102,4 @@ namespace KAOS
         }
-        #endregion
-
-        #region Input Control
+        
+        // Input Control
 
@@ -141,4 +138,2 @@ namespace KAOS
         
-        #endregion
-
         protected override void OnUnload(EventArgs e)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/db46e2187120c5e303af1431400bd233b7555be7">Some fixes in order for it work on lab computers.</a>  -  db46e21</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 8 files changed, 14 insertions(+), 15 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 6115a7c..9e46ee4 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -35,3 +35,3 @@ namespace Game
         {
-            stateManager.Update(elapsedTime);
+            stateManager.Update(elapsedTime, (float)ScreenWidth / ScreenHeight);
         }
diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 028e794..076dc19 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -38,4 +38,4 @@ void main(void)
 
-    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
-    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
+    //c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;
+    //c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;
 
diff --git a/KAOS/Interfaces/IGameObject.cs b/KAOS/Interfaces/IGameObject.cs
index b2da157..b6249e5 100644
--- a/KAOS/Interfaces/IGameObject.cs
+++ b/KAOS/Interfaces/IGameObject.cs
@@ -5,3 +5,3 @@ namespace KAOS.Interfaces
     {
-        void Update(float elapsedTime);
+        void Update(float elapsedTime, float aspect);
         void Render();
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index 41fc861..1284dae 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -20,4 +20,4 @@ namespace KAOS
 
-        public int ScreenWidth { get { return this.ClientSize.Width; } }
-        public int ScreenHeight { get { return this.ClientSize.Height; } }
+        protected int ScreenWidth { get { return this.ClientSize.Width; } }
+        protected int ScreenHeight { get { return this.ClientSize.Height; } }
 
@@ -78,3 +78,6 @@ namespace KAOS
             
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
 
diff --git a/KAOS/Managers/StateManager.cs b/KAOS/Managers/StateManager.cs
index f39e5e1..b4fcefe 100644
--- a/KAOS/Managers/StateManager.cs
+++ b/KAOS/Managers/StateManager.cs
@@ -14,3 +14,3 @@ namespace KAOS.Managers
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
@@ -18,3 +18,3 @@ namespace KAOS.Managers
                 return;
-            currentState.Update(elapsedTime);
+            currentState.Update(elapsedTime, aspect);
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index d33ea8e..c005773 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -28,3 +28,2 @@ namespace KAOS.States
 
-        float aspect = 1024 / (float)600;
         float _rotation;
@@ -72,3 +71,3 @@ namespace KAOS.States
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
diff --git a/KAOS/States/SplashScreenState.cs b/KAOS/States/SplashScreenState.cs
index c18d9ec..497ace2 100644
--- a/KAOS/States/SplashScreenState.cs
+++ b/KAOS/States/SplashScreenState.cs
@@ -25,3 +25,3 @@ namespace KAOS.States
 
-        public void Update(float elapsedTime)
+        public void Update(float elapsedTime, float aspect)
         {
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index dbab8b2..1e6c0eb 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -35,5 +35,2 @@ namespace KAOS.Utilities
         {
-            GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
             GL.UseProgram(ShaderManager.Skybox.ID);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0f4548031978c9189eed0206b269cf0e213fdcf8">Updated camera, thank you NeoKabuto: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html</a>  -  0f45480</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 3 files changed, 226 insertions(+), 231 deletions(-)

diff --git a/Game/Program.cs b/Game/Program.cs
index c1a111c..e245025 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1024, 600, 3, 3)) { game.Run(60, 0); }
+            using (Game game = new Game(1280, 720, 3, 3)) { game.Run(60, 0); }
         }
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index 1284dae..ecdade2 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -1,79 +1,86 @@
-﻿using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Drawing;
-using System.Windows.Forms;
-
-namespace KAOS
-{
-    /// <summary>
-    /// This is the main interface to the system. Inherit from here to get started.
-    /// </summary>
-    public abstract class KAOSEngine : GameWindow, IDisposable
-    {
-
-        public static string AppName { get { return "KAOS-Engine"; } }
-
-        protected int ScreenWidth { get { return this.ClientSize.Width; } }
-        protected int ScreenHeight { get { return this.ClientSize.Height; } }
-
-        protected AnimationTimer m_Timer;
-        
-        public KAOSEngine(int height, int width, int major, int minor)
-            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
-        { }
-
-        // Load everything here
-        protected override void OnLoad(System.EventArgs e)
-        {
-            BaseInitialisation();
-            Initialise();
-        }
-
-        private void BaseInitialisation()
-        {
-            InitialiseTimer();
-            InitialiseInput();
-            InitialiseStockShaders();
-        }
-
-        private void InitialiseInput()
-        {
-            Keyboard.KeyDown += HandleKeyDown;
-            Keyboard.KeyUp += HandleKeyUp;
-        }
-
-        private void InitialiseTimer()
-        {
-            m_Timer = new AnimationTimer();
-        }
-
-        private void InitialiseStockShaders()
-        {
-            ShaderManager.LoadDefaultSkyboxShader();
-            ShaderManager.LoadDefaultRenderShader();
-        }
-
-        public abstract void Initialise();
-
-        // Game Loop
-        protected override void OnUpdateFrame(FrameEventArgs e)
-        {
-            InputManager.PollInput();
-            ResetCursor();
-
-            UpdateFrame(m_Timer.GetElapsedTime());
-        }
-
-        new public abstract void UpdateFrame(float elapsedTime);
-
-        protected override void OnRenderFrame(FrameEventArgs e)
-        {
-            base.OnRenderFrame(e);
-            
+﻿using KAOS.Managers;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Drawing;
+using System.Windows.Forms;
+
+namespace KAOS
+{
+    /// <summary>
+    /// This is the main interface to the system. Inherit from here to get started.
+    /// </summary>
+    public abstract class KAOSEngine : GameWindow, IDisposable
+    {
+
+        public static string AppName { get { return "KAOS-Engine"; } }
+
+        protected int ScreenWidth { get { return this.ClientSize.Width; } }
+        protected int ScreenHeight { get { return this.ClientSize.Height; } }
+
+        protected AnimationTimer m_Timer;
+        protected Vector2 lastMousePos = new Vector2();
+        
+        public KAOSEngine(int height, int width, int major, int minor)
+            : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+        { }
+
+        // Load everything here
+        protected override void OnLoad(System.EventArgs e)
+        {
+            BaseInitialisation();
+            Initialise();
+        }
+
+        private void BaseInitialisation()
+        {
+            InitialiseTimer();
+            InitialiseInput();
+            InitialiseStockShaders();
+        }
+
+        private void InitialiseInput()
+        {
+            Keyboard.KeyDown += HandleKeyDown;
+            Keyboard.KeyUp += HandleKeyUp;
+        }
+
+        private void InitialiseTimer()
+        {
+            m_Timer = new AnimationTimer();
+        }
+
+        private void InitialiseStockShaders()
+        {
+            ShaderManager.LoadDefaultSkyboxShader();
+            ShaderManager.LoadDefaultRenderShader();
+        }
+
+        public abstract void Initialise();
+
+        // Game Loop
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+            InputManager.PollKeyboard();
+            if (Focused)
+            {
+                Vector2 delta = lastMousePos - new Vector2(OpenTK.Input.Mouse.GetState().X, OpenTK.Input.Mouse.GetState().Y);
+
+                Camera.AddRotation(delta.X, delta.Y);
+                ResetCursor();
+            }
+
+            UpdateFrame(m_Timer.GetElapsedTime());
+        }
+
+        new public abstract void UpdateFrame(float elapsedTime);
+
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            base.OnRenderFrame(e);
+            
             GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
@@ -81,67 +88,66 @@ namespace KAOS
             GL.ClearBuffer(ClearBuffer.Color, 0, new float[] { 0.2f, 0.2f, 0.2f, 1.0f });
-            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
-
-            Title = KAOSEngine.AppName +
-
-                " OpenGL: " + GL.GetString(StringName.Version) +
-                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
-                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
-
-            
-
-            RenderFrame(m_Timer.GetElapsedTime());
-
-            SwapBuffers();
-        }
-
-        new public abstract void RenderFrame(float elapsedTime);
-
-        protected override void OnResize(EventArgs e)
-        {
-            base.OnResize(e);
-            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
-
-            float aspect = ScreenWidth / (float)ScreenHeight;
-        }
-        
-        // Input Control
-
-        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
-        {
-            if (e.Key == Key.Escape)
-                Exit();
-            InputManager.keyList.Add(e.Key);
-        }
-
-        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
-        {
-            for (int count = 0; count < InputManager.keyList.Count; count++)
-            {
-                if (InputManager.keyList[count] == e.Key)
-                {
-                    InputManager.keyList.Remove(InputManager.keyList[count]);
-                }
-            }
-        }
-
-        public void ResetCursor()
-        {
-            System.Windows.Forms.Cursor.Position = new Point(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
-        }
-
-        protected override void OnFocusedChanged(EventArgs e)
-        {
-            base.OnFocusedChanged(e);
-
-            if (Focused)
-            {
-                ResetCursor();
-            }
-        } 
-        
-        protected override void OnUnload(EventArgs e)
-        {
-            base.OnUnload(e);
-        }
-    }
+            GL.ClearBuffer(ClearBuffer.Depth, 0, new float[] { 1.0f });
+
+            Title = KAOSEngine.AppName +
+
+                " OpenGL: " + GL.GetString(StringName.Version) +
+                " GLSL: " + GL.GetString(StringName.ShadingLanguageVersion) +
+                " FPS: " + string.Format("{0:F}", 1.0 / e.Time);
+
+            RenderFrame(m_Timer.GetElapsedTime());
+
+            SwapBuffers();
+        }
+
+        new public abstract void RenderFrame(float elapsedTime);
+
+        protected override void OnResize(EventArgs e)
+        {
+            base.OnResize(e);
+            GL.Viewport(0, 0, ScreenWidth, ScreenHeight);
+
+            float aspect = ScreenWidth / (float)ScreenHeight;
+        }
+        
+        // Input Control
+
+        private void HandleKeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            if (e.Key == Key.Escape)
+                Exit();
+            InputManager.keyList.Add(e.Key);
+        }
+
+        private void HandleKeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            for (int count = 0; count < InputManager.keyList.Count; count++)
+            {
+                if (InputManager.keyList[count] == e.Key)
+                {
+                    InputManager.keyList.Remove(InputManager.keyList[count]);
+                }
+            }
+        }
+
+        public void ResetCursor()
+        {
+            OpenTK.Input.Mouse.SetPosition(Bounds.Left + Bounds.Width / 2, Bounds.Top + Bounds.Height / 2);
+            lastMousePos = new Vector2(OpenTK.Input.Mouse.GetState().X, OpenTK.Input.Mouse.GetState().Y);
+        }
+
+        protected override void OnFocusedChanged(EventArgs e)
+        {
+            base.OnFocusedChanged(e);
+
+            if (Focused)
+            {
+                ResetCursor();
+            }
+        } 
+        
+        protected override void OnUnload(EventArgs e)
+        {
+            base.OnUnload(e);
+        }
+    }
 }
\ No newline at end of file
diff --git a/KAOS/Managers/InputManager.cs b/KAOS/Managers/InputManager.cs
index 21e6993..1a530f0 100644
--- a/KAOS/Managers/InputManager.cs
+++ b/KAOS/Managers/InputManager.cs
@@ -1,87 +1,76 @@
-﻿using OpenTK;
-using OpenTK.Input;
-using System.Collections.Generic;
-
-namespace KAOS.Managers
-{
-    /// <summary>
-    /// Responsible for polling user input, updating parameters as and when a change is detected.
-    /// </summary>
-    public static class InputManager
-    {
-        internal static List<Key> keyList = new List<Key>();
-
-        internal static MouseState current, previous;
-        internal static KeyboardState keyState;
-
-        internal static void PollInput()
-        {
-            KeyboardUpdate();
-            MouseUpdate();
-        }
-
-        private static void MouseUpdate()
-        {
-            current = Mouse.GetState();
-            if (current[MouseButton.Left])
-            {
-                if (current != previous)
-                {
-                    // Mouse state has changed
-                    int xdelta = current.X - previous.X;
-                    int ydelta = current.Y - previous.Y;
-                    int zdelta = current.Wheel - previous.Wheel;
-                    Utilities.Camera.AddRotation(xdelta, ydelta);
-                }
-                previous = current;
-            }
-        }
-
-        private static void KeyboardUpdate()
-        {
-            foreach (Key key in InputManager.keyList)
-            {
-
-                switch (key)
-                {
-                    case Key.W:
-                        Utilities.Camera.Move(0f, 0.1f, 0f);
-                        break;
-
-                    case Key.A:
-                        Utilities.Camera.Move(-0.1f, 0f, 0f);
-                        break;
-
-                    case Key.S:
-                        Utilities.Camera.Move(0f, -0.1f, 0f);
-                        break;
-
-                    case Key.D:
-                        Utilities.Camera.Move(0.1f, 0f, 0f);
-                        break;
-
-                    case Key.Q:
-                        Utilities.Camera.Move(0f, 0f, 0.1f);
-                        break;
-
-                    case Key.E:
-                        Utilities.Camera.Move(0f, 0f, -0.1f);
-                        break;
-
-                    case Key.F1:
-                        Utilities.Renderer.ToggleWireframeOn();
-                        break;
-
-                    case Key.F2:
-                        Utilities.Renderer.ToggleWireframeOff();
-                        break;
-
-                    default:
-                        break;
-                }
-
-            }
-        }
-
-    }
-}
+﻿using OpenTK;
+using OpenTK.Input;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    /// <summary>
+    /// Responsible for polling user input, updating parameters as and when a change is detected.
+    /// </summary>
+    public static class InputManager
+    {
+        internal static List<Key> keyList = new List<Key>();
+
+        internal static MouseState current, previous;
+        internal static KeyboardState keyState;
+
+        internal static void PollKeyboard()
+        {
+            foreach (Key key in InputManager.keyList)
+            {
+
+                switch (key)
+                {
+                    case Key.W:
+                        Utilities.Camera.Move(0f, 0.1f, 0f);
+                        break;
+
+                    case Key.A:
+                        Utilities.Camera.Move(-0.1f, 0f, 0f);
+                        break;
+
+                    case Key.S:
+                        Utilities.Camera.Move(0f, -0.1f, 0f);
+                        break;
+
+                    case Key.D:
+                        Utilities.Camera.Move(0.1f, 0f, 0f);
+                        break;
+
+                    case Key.Q:
+                        Utilities.Camera.Move(0f, 0f, 0.1f);
+                        break;
+
+                    case Key.E:
+                        Utilities.Camera.Move(0f, 0f, -0.1f);
+                        break;
+
+                    case Key.F1:
+                        Utilities.Renderer.ToggleWireframeOn();
+                        break;
+
+                    case Key.F2:
+                        Utilities.Renderer.ToggleWireframeOff();
+                        break;
+
+                    default:
+                        break;
+                }
+            }
+        }
+
+        internal static void PollMouse()
+        {
+            current = Mouse.GetState();
+            if (current != previous)
+            {
+                // Mouse state has changed
+                int xdelta = current.X - previous.X;
+                int ydelta = current.Y - previous.Y;
+                int zdelta = current.Wheel - previous.Wheel;
+                Utilities.Camera.AddRotation(xdelta, ydelta);
+            }
+            previous = current;
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/1e98c9ee2108a164598c047564b3327a0ce2317e">fixed camera issue</a>  -  1e98c9e</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 2 files changed, 25 insertions(+), 26 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index c005773..2d7b954 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -48,3 +48,2 @@ namespace KAOS.States
         {
-            Renderer.handle_eyePosition = GL.GetUniformLocation(ShaderManager.Skybox.ID, "eye_position");
             Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
@@ -68,3 +67,4 @@ namespace KAOS.States
             m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID); 
+            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
+            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
         }
@@ -75,6 +75,5 @@ namespace KAOS.States
 
-            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
+            Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
             Renderer.modelMatrix = Matrix4.CreateScale(2f);
 
-            //Renderer.modelViewMatrix = Matrix4.Mult(Renderer.viewMatrix, Matrix4.CreateTranslation(Camera.Position));
             Renderer.eyePosition = Camera.Position;
@@ -85,3 +84,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
         }
diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index c60cfeb..cb7f942 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -14,3 +14,3 @@ namespace KAOS.Utilities
     {
-        public static Vector3 Position = new Vector3(0f, 0f, -2f);
+        public static Vector3 Position = Vector3.Zero;
         public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
@@ -20,9 +20,9 @@ namespace KAOS.Utilities
         public static Matrix4 GetViewMatrix()
-        {
-            Vector3 lookat = new Vector3();
-
-            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-            lookat.Y = (float)Math.Sin((float)Orientation.Y);
-            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
-
+        {
+            Vector3 lookat = new Vector3();
+
+            lookat.X = (float)(Math.Sin((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+            lookat.Y = (float)Math.Sin((float)Orientation.Y);
+            lookat.Z = (float)(Math.Cos((float)Orientation.X) * Math.Cos((float)Orientation.Y));
+
             return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
@@ -31,15 +31,15 @@ namespace KAOS.Utilities
         public static void Move(float x, float y, float z)
-        {
-            Vector3 offset = new Vector3();
-
-            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
-            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
-
-            offset += x * right;
-            offset += y * forward;
-            offset.Y += z;
-
-            offset.NormalizeFast();
-            offset = Vector3.Multiply(offset, MoveSpeed);
-
+        {
+            Vector3 offset = new Vector3();
+
+            Vector3 forward = new Vector3((float)Math.Sin((float)Orientation.X), 0, (float)Math.Cos((float)Orientation.X));
+            Vector3 right = new Vector3(-forward.Z, 0, forward.X);
+
+            offset += x * right;
+            offset += y * forward;
+            offset.Y += z;
+
+            offset.NormalizeFast();
+            offset = Vector3.Multiply(offset, MoveSpeed);
+
             Position += offset;

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f1101eb63cfc99ad8dba2e2fcec7f88ff4b58893">using normalize(in_position.xyz) in the vertex shader. previously it was not being normalised and so the skybox rotated in the wrong direction. @see http://stackoverflow.com/a/10828100</a>  -  f1101eb</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
index c433716..0301135 100644
--- a/KAOS/Data/Shaders/skybox-vs.glsl
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -13,3 +13,3 @@ in lowp vec3 in_position;
  {
-	vs_out.tc = mat3(view_matrix) * in_position.xyz;
+	vs_out.tc = mat3(view_matrix) * normalize(in_position.xyz);
 	gl_Position = vec4(in_position.xyz, 1.0);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8c85052854359475c048ef374d67abd4f49a243f">TextRenderer class taken from the OpenTK Examples.</a>  -  8c85052</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 158 insertions(+)

diff --git a/KAOS/Utilities/TextRenderer.cs b/KAOS/Utilities/TextRenderer.cs
new file mode 100644
index 0000000..f536e71
--- /dev/null
+++ b/KAOS/Utilities/TextRenderer.cs
@@ -0,0 +1,158 @@
+﻿// This code was written for the OpenTK library and has been released
+// to the Public Domain.
+// It is provided "as is" without express or implied warranty of any kind.
+
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// Uses System.Drawing for 2d text rendering.
+    /// </summary>
+    public class TextRenderer : IDisposable
+    {
+        Bitmap bmp;
+        Graphics gfx;
+        int texture;
+        Rectangle dirty_region;
+        bool disposed;
+
+        #region Constructors
+
+        /// <summary>
+        /// Constructs a new instance.
+        /// </summary>
+        /// <param name="width">The width of the backing store in pixels.</param>
+        /// <param name="height">The height of the backing store in pixels.</param>
+        public TextRenderer(int width, int height)
+        {
+            if (width <= 0)
+                throw new ArgumentOutOfRangeException("width");
+            if (height <= 0)
+                throw new ArgumentOutOfRangeException("height ");
+            if (GraphicsContext.CurrentContext == null)
+                throw new InvalidOperationException("No GraphicsContext is current on the calling thread.");
+
+            bmp = new Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            gfx = Graphics.FromImage(bmp);
+            gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
+
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, width, height, 0,
+                PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+        }
+
+        #endregion
+
+        #region Public Members
+
+        /// <summary>
+        /// Clears the backing store to the specified color.
+        /// </summary>
+        /// <param name="color">A <see cref="System.Drawing.Color"/>.</param>
+        public void Clear(Color color)
+        {
+            gfx.Clear(color);
+            dirty_region = new Rectangle(0, 0, bmp.Width, bmp.Height);
+        }
+
+        /// <summary>
+        /// Draws the specified string to the backing store.
+        /// </summary>
+        /// <param name="text">The <see cref="System.String"/> to draw.</param>
+        /// <param name="font">The <see cref="System.Drawing.Font"/> that will be used.</param>
+        /// <param name="brush">The <see cref="System.Drawing.Brush"/> that will be used.</param>
+        /// <param name="point">The location of the text on the backing store, in 2d pixel coordinates.
+        /// The origin (0, 0) lies at the top-left corner of the backing store.</param>
+        public void DrawString(string text, Font font, Brush brush, PointF point)
+        {
+            gfx.DrawString(text, font, brush, point);
+
+            SizeF size = gfx.MeasureString(text, font);
+            dirty_region = Rectangle.Round(RectangleF.Union(dirty_region, new RectangleF(point, size)));
+            dirty_region = Rectangle.Intersect(dirty_region, new Rectangle(0, 0, bmp.Width, bmp.Height));
+        }
+
+        /// <summary>
+        /// Gets a <see cref="System.Int32"/> that represents an OpenGL 2d texture handle.
+        /// The texture contains a copy of the backing store. Bind this texture to TextureTarget.Texture2d
+        /// in order to render the drawn text on screen.
+        /// </summary>
+        public int Texture
+        {
+            get
+            {
+                UploadBitmap();
+                return texture;
+            }
+        }
+
+        #endregion
+
+        #region Private Members
+
+        // Uploads the dirty regions of the backing store to the OpenGL texture.
+        void UploadBitmap()
+        {
+            if (dirty_region != RectangleF.Empty)
+            {
+                System.Drawing.Imaging.BitmapData data = bmp.LockBits(dirty_region,
+                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+
+                GL.BindTexture(TextureTarget.Texture2D, texture);
+                GL.TexSubImage2D(TextureTarget.Texture2D, 0,
+                    dirty_region.X, dirty_region.Y, dirty_region.Width, dirty_region.Height,
+                    PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);
+
+                bmp.UnlockBits(data);
+
+                dirty_region = Rectangle.Empty;
+            }
+        }
+
+        #endregion
+
+        #region IDisposable Members
+
+        void Dispose(bool manual)
+        {
+            if (!disposed)
+            {
+                if (manual)
+                {
+                    bmp.Dispose();
+                    gfx.Dispose();
+                    if (GraphicsContext.CurrentContext != null)
+                        GL.DeleteTexture(texture);
+                }
+
+                disposed = true;
+            }
+        }
+
+        public void Dispose()
+        {
+            Dispose(true);
+            GC.SuppressFinalize(this);
+        }
+
+        ~TextRenderer()
+        {
+            Console.WriteLine("[Warning] Resource leaked: {0}.", typeof(TextRenderer));
+        }
+
+        #endregion
+    }
+
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3954a2623616fe2bb9f134f9903d24d0369e46bb">Normalised line endings.</a>  -  3954a26</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 91 insertions(+), 91 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 2d7b954..f18eb3b 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -1,93 +1,93 @@
-﻿using KAOS.Interfaces;
-using KAOS.Managers;
-using KAOS.Shapes;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-
-namespace KAOS.States
-{
-    public class Skyboxstate : IDisposable, IGameObject
-    {
-        private BufferObjectManager m_bufferManager;
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
-        static string defaultSkyboxPath = "Data/Textures/skybox/";
-        string[] skyboxFaces = new String[]
-        {
-            defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
-            defaultSkyboxPath + "pos_y.bmp",
-            defaultSkyboxPath + "neg_y.bmp",
-            defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
-        };
-
-        float _rotation;
-
-        public Skyboxstate(StateManager stateManager)
-        {
-            m_bufferManager = new BufferObjectManager();
-            m_stateManager = stateManager;
-            m_textureManager = new TextureManager();
-
-            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
-
-            LoadCubeMap();
-            QueryShaders();
-
-            _rotation = MathHelper.DegreesToRadians(90);
-
-            LoadTestObject();
-        }
-
-        private void QueryShaders()
-        {
-            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
-
-            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
-            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
-            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
-
-            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
-            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
-            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
-        }
-
-        private void LoadCubeMap()
-        {
-            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
-        }
-
-        private void LoadTestObject()
-        {
-            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+
+namespace KAOS.States
+{
+    public class Skyboxstate : IDisposable, IGameObject
+    {
+        private BufferObjectManager m_bufferManager;
+        private StateManager m_stateManager;
+        private TextureManager m_textureManager;
+
+        static string defaultSkyboxPath = "Data/Textures/skybox/";
+        string[] skyboxFaces = new String[]
+        {
+            defaultSkyboxPath + "pos_x.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "pos_y.bmp",
+            defaultSkyboxPath + "neg_y.bmp",
+            defaultSkyboxPath + "pos_z.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
+        };
+
+        float _rotation;
+
+        public Skyboxstate(StateManager stateManager)
+        {
+            m_bufferManager = new BufferObjectManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+
+            //m_textureManager.LoadTexture1D("1d", "pal.bmp");
+
+            LoadCubeMap();
+            QueryShaders();
+
+            _rotation = MathHelper.DegreesToRadians(90);
+
+            LoadTestObject();
+        }
+
+        private void QueryShaders()
+        {
+            Renderer.handle_viewMatrix = GL.GetUniformLocation(ShaderManager.Skybox.ID, "view_matrix");
+
+            Renderer.handle_projectionMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "proj_matrix");
+            Renderer.handle_modelMatrix = GL.GetUniformLocation(ShaderManager.Render.ID, "model_matrix");
+            Renderer.handle_viewMatrix2 = GL.GetUniformLocation(ShaderManager.Render.ID, "view_matrix");
+
+            Renderer.handle_centre = GL.GetUniformLocation(ShaderManager.Render.ID, "center");
+            Renderer.handle_scale = GL.GetUniformLocation(ShaderManager.Render.ID, "scale");
+            Renderer.handle_iter = GL.GetUniformLocation(ShaderManager.Render.ID, "iter");
+        }
+
+        private void LoadCubeMap()
+        {
+            m_textureManager.LoadSkyTexture("skybox1", skyboxFaces);
+        }
+
+        private void LoadTestObject()
+        {
+            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
             m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
-            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
-        }
-
-        public void Update(float elapsedTime, float aspect)
-        {
-            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
-
+            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            Renderer.projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(90.0f), aspect, 0.1f, 100.0f);
+
             Renderer.viewMatrix = Matrix4.Mult(Matrix4.Identity, Camera.GetViewMatrix());
-            Renderer.modelMatrix = Matrix4.CreateScale(2f);
-
-            Renderer.eyePosition = Camera.Position;
-        }
-
-        public void Render()
-        {
-            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
-        }
-
-        public void Dispose()
-        {
-            m_textureManager.Dispose();
-        }
-    }
-}
+            Renderer.modelMatrix = Matrix4.CreateScale(2f);
+
+            Renderer.eyePosition = Camera.Position;
+        }
+
+        public void Render()
+        {
+            Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
+        }
+
+        public void Dispose()
+        {
+            m_textureManager.Dispose();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/fac2f7211a6a486af3d72ad358a5577e3cb32666">Load MengerSponge</a>  -  fac2f72</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index f18eb3b..ade7e96 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,3 +84,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/de57ec946fef38559993c17550b101e47ba535b3">Normalise line endings  once again.</a>  -  de57ec9</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 1 file changed, 39 insertions(+), 39 deletions(-)

diff --git a/KAOS/Utilities/Camera.cs b/KAOS/Utilities/Camera.cs
index cb7f942..d09e223 100644
--- a/KAOS/Utilities/Camera.cs
+++ b/KAOS/Utilities/Camera.cs
@@ -1,21 +1,21 @@
-﻿using OpenTK;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.Utilities
-{
-    /// <summary>
-    /// Camera: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html (slightly modified)
-    /// </summary>
-    public static class Camera
-    {
-        public static Vector3 Position = Vector3.Zero;
-        public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
-        public static float MoveSpeed = 0.2f;
-        public static float MouseSensitivity = 0.01f;
-
-        public static Matrix4 GetViewMatrix()
+﻿using OpenTK;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.Utilities
+{
+    /// <summary>
+    /// Camera: http://neokabuto.blogspot.co.uk/2014/01/opentk-tutorial-5-basic-camera.html (slightly modified)
+    /// </summary>
+    public static class Camera
+    {
+        public static Vector3 Position = Vector3.Zero;
+        public static Vector3 Orientation = new Vector3((float)Math.PI, 0f, 0f);
+        public static float MoveSpeed = 0.2f;
+        public static float MouseSensitivity = 0.01f;
+
+        public static Matrix4 GetViewMatrix()
         {
@@ -27,6 +27,6 @@ namespace KAOS.Utilities
 
-            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
-        }
-
-        public static void Move(float x, float y, float z)
+            return Matrix4.LookAt(Position, Position + lookat, Vector3.UnitY);
+        }
+
+        public static void Move(float x, float y, float z)
         {
@@ -44,16 +44,16 @@ namespace KAOS.Utilities
 
-            Position += offset;
-
-            Logger.WriteLine("Camera Position = " + Position);
-        }
-
-        public static void AddRotation(float x, float y)
-        {
-            x = x * MouseSensitivity;
-            y = y * MouseSensitivity;
-
-            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
-            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
-        }
-    }
-}
+            Position += offset;
+
+            Logger.WriteLine("Camera Position = " + Position);
+        }
+
+        public static void AddRotation(float x, float y)
+        {
+            x = x * MouseSensitivity;
+            y = y * MouseSensitivity;
+
+            Orientation.X = (Orientation.X + x) % ((float)Math.PI * 2.0f);
+            Orientation.Y = Math.Max(Math.Min(Orientation.Y + y, (float)Math.PI / 2.0f - 0.1f), (float)-Math.PI / 2.0f + 0.1f);
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/81a07baba3d1d5b7e4ce0d42eb3f5f9651a3b544">Committing latest version of Matali Physics.</a>  -  81a07ba</p><p>authored by Anthony Woodward, 6 weeks ago</p></div><pre>
 107 files changed, 31631 insertions(+)

diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Amphibian1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Amphibian1Animation1.cs
new file mode 100644
index 0000000..398c385
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Amphibian1Animation1.cs
@@ -0,0 +1,309 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Amphibian1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string shot1Name;
+        string shot1BaseName;
+        string shot1LightName;
+        string shot2Name;
+        string shot2BaseName;
+        string shot2LightName;
+        string yellowName;
+
+        PhysicsObject shot;
+        PhysicsObject shotBase;
+        PhysicsObject shotLight;
+
+        Shape sphere;
+        PhysicsObject turretGun;
+        Constraint turretConstraint;
+        Constraint turretGunConstraint;
+        PhysicsObject turretGun1;
+        PhysicsObject turretGun2;
+        PhysicsObject turretBodyDown;
+
+        int shotCount;
+        int maxShotCount;
+
+        DemoKeyboardState oldKeyboardState;
+
+        Vector3 vectorZero;
+        Vector3 unitY;
+        Matrix4 matrixIdentity;
+
+        public Amphibian1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            shot1Name = "Amphibian 1 Gun 1 Shot" + instanceIndexName + " ";
+            shot1BaseName = "Amphibian 1 Gun 1 Shot Base" + instanceIndexName + " ";
+            shot1LightName = "Amphibian 1 Gun 1 Shot Light" + instanceIndexName + " ";
+            shot2Name = "Amphibian 1 Gun 2 Shot" + instanceIndexName + " ";
+            shot2BaseName = "Amphibian 1 Gun 2 Shot Base" + instanceIndexName + " ";
+            shot2LightName = "Amphibian 1 Gun 2 Shot Light" + instanceIndexName + " ";
+            yellowName = "Yellow";
+
+            maxShotCount = 10;
+
+            vectorZero = Vector3.Zero;
+            unitY = Vector3.UnitY;
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+            turretGun = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun" + instanceIndexName);
+            turretConstraint = scene.Factory.ConstraintManager.Find("Amphibian 1 Turret Constraint" + instanceIndexName);
+            turretGunConstraint = scene.Factory.ConstraintManager.Find("Amphibian 1 Turret Gun Constraint" + instanceIndexName);
+
+            turretGun1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun 1" + instanceIndexName);
+            turretGun2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun 2" + instanceIndexName);
+            turretBodyDown = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Body Down" + instanceIndexName);
+
+            shotCount = -1;
+
+            oldKeyboardState = demo.GetKeyboardState();
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if ((turretGun == null) || (turretConstraint == null) || (turretGunConstraint == null))
+                return;
+
+            Vector3 deltaTranslation = vectorZero;
+
+            bool turretWorking = true;
+            if (objectBase.IsBrokenRigidGroup || turretConstraint.IsBroken)
+                turretWorking = false;
+
+            bool turretGunWorking = true;
+            if (!turretWorking || turretGun.IsBrokenRigidGroup || turretGunConstraint.IsBroken)
+                turretGunWorking = false;
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (keyboardState[Key.Up])
+                deltaTranslation.Z += 10000.0f;
+
+            if (keyboardState[Key.Down])
+                deltaTranslation.Z -= 10000.0f;
+
+            if (deltaTranslation.LengthSquared != 0.0f)
+                objectBase.WorldAccumulator.AddLocalForce(ref deltaTranslation);
+
+            if (turretWorking)
+            {
+                if (keyboardState[Key.Right])
+                    turretConstraint.ControlDegAngleY -= 2.0f;
+
+                if (keyboardState[Key.Left])
+                    turretConstraint.ControlDegAngleY += 2.0f;
+            }
+
+            if (turretGunWorking)
+            {
+                if (keyboardState[Key.PageUp])
+                    turretGunConstraint.ControlDegAngleX += 1.0f;
+
+                if (keyboardState[Key.PageDown])
+                    turretGunConstraint.ControlDegAngleX -= 1.0f;
+
+                if (keyboardState[Key.F] && !oldKeyboardState[Key.F])
+                {
+                    shotCount = (shotCount + 1) % maxShotCount;
+                    string shotCountName = shotCount.ToString();
+
+                    if (turretGun1 != null)
+                    {
+                        shot = scene.Factory.PhysicsObjectManager.FindOrCreate(shot1Name + shotCountName);
+                        shotBase = scene.Factory.PhysicsObjectManager.FindOrCreate(shot1BaseName + shotCountName);
+                        shotLight = scene.Factory.PhysicsObjectManager.FindOrCreate(shot1LightName + shotCountName);
+
+                        shot.AddChildPhysicsObject(shotBase);
+                        shot.AddChildPhysicsObject(shotLight);
+
+                        Vector3 turretGunPosition = vectorZero;
+                        Matrix4 turretGunRotation = matrixIdentity;
+
+                        turretGun1.MainWorldTransform.GetPosition(ref turretGunPosition);
+                        turretGun1.MainWorldTransform.GetRotation(ref turretGunRotation);
+
+                        Vector3 shotPosition = vectorZero;
+                        Vector3 shotLocalPosition = vectorZero;
+
+                        shotLocalPosition.X = 0.0f;
+                        shotLocalPosition.Y = 2.0f;
+                        shotLocalPosition.Z = 0.0f;
+
+                        Vector3.TransformVector(ref shotLocalPosition, ref turretGunRotation, out shotPosition);
+                        Vector3.Add(ref shotPosition, ref turretGunPosition, out shotPosition);
+
+                        Vector3 shotDirection = vectorZero;
+                        Vector3 shotScale = vectorZero;
+
+                        shotDirection.X = turretGunRotation.Row1.X;
+                        shotDirection.Y = turretGunRotation.Row1.Y;
+                        shotDirection.Z = turretGunRotation.Row1.Z;
+
+                        shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+
+                        shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                        shot.InitLocalTransform.SetPosition(ref shotPosition);
+
+                        Vector3.Multiply(ref shotDirection, 200.0f, out shotDirection);
+
+                        shot.InitLocalTransform.SetLinearVelocity(ref shotDirection);
+                        shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                        shot.MaxSimulationFrameCount = 100;
+                        shot.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+
+                        shotBase.Shape = sphere;
+                        shotBase.UserDataStr = sphereName;
+                        shotBase.Material.RigidGroup = true;
+                        shotBase.InitLocalTransform.SetScale(ref shotScale);
+                        shotBase.Integral.SetDensity(1.0f);
+                        shotBase.EnableCollisions = true;
+                        shotBase.DisableCollision(turretGun1, true);
+                        shotBase.MaxDisableCollisionFrameCount = 10;
+                        shotBase.EnableBreakRigidGroup = false;
+                        shotBase.CreateSound(true);
+
+                        shotLight.Shape = sphere;
+                        shotLight.UserDataStr = sphereName;
+                        shotLight.CreateLight(true);
+                        shotLight.Light.Type = PhysicsLightType.Point;
+                        shotLight.Light.Range = 20.0f;
+                        shotLight.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                        shotLight.InitLocalTransform.SetScale(20.0f);
+                        shotLight.Material.RigidGroup = true;
+                        shotLight.Material.UserDataStr = yellowName;
+                        shotLight.EnableBreakRigidGroup = false;
+                        shotLight.EnableCollisions = false;
+                        shotLight.EnableCursorInteraction = false;
+                        shotLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                        scene.UpdateFromInitLocalTransform(shot);
+                    }
+
+                    if (turretGun2 != null)
+                    {
+                        shot = scene.Factory.PhysicsObjectManager.FindOrCreate(shot2Name + shotCountName);
+                        shotBase = scene.Factory.PhysicsObjectManager.FindOrCreate(shot2BaseName + shotCountName);
+                        shotLight = scene.Factory.PhysicsObjectManager.FindOrCreate(shot2LightName + shotCountName);
+
+                        shot.AddChildPhysicsObject(shotBase);
+                        shot.AddChildPhysicsObject(shotLight);
+
+                        Vector3 turretGunPosition = vectorZero;
+                        Matrix4 turretGunRotation = matrixIdentity;
+
+                        turretGun2.MainWorldTransform.GetPosition(ref turretGunPosition);
+                        turretGun2.MainWorldTransform.GetRotation(ref turretGunRotation);
+
+                        Vector3 shotPosition = vectorZero;
+                        Vector3 shotLocalPosition = vectorZero;
+
+                        shotLocalPosition.X = 0.0f;
+                        shotLocalPosition.Y = 2.0f;
+                        shotLocalPosition.Z = 0.0f;
+
+                        Vector3.TransformVector(ref shotLocalPosition, ref turretGunRotation, out shotPosition);
+                        Vector3.Add(ref shotPosition, ref turretGunPosition, out shotPosition);
+
+                        Vector3 shotDirection = vectorZero;
+                        Vector3 shotScale = vectorZero;
+
+                        shotDirection.X = turretGunRotation.Row1.X;
+                        shotDirection.Y = turretGunRotation.Row1.Y;
+                        shotDirection.Z = turretGunRotation.Row1.Z;
+
+                        shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+
+                        shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                        shot.InitLocalTransform.SetPosition(ref shotPosition);
+
+                        Vector3.Multiply(ref shotDirection, 200.0f, out shotDirection);
+
+                        shot.InitLocalTransform.SetLinearVelocity(ref shotDirection);
+                        shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                        shot.MaxSimulationFrameCount = 100;
+                        shot.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+
+                        shotBase.Shape = sphere;
+                        shotBase.UserDataStr = sphereName;
+                        shotBase.Material.RigidGroup = true;
+                        shotBase.InitLocalTransform.SetScale(ref shotScale);
+                        shotBase.Integral.SetDensity(1.0f);
+                        shotBase.EnableCollisions = true;
+                        shotBase.DisableCollision(turretGun1, true);
+                        shotBase.MaxDisableCollisionFrameCount = 10;
+                        shotBase.EnableBreakRigidGroup = false;
+                        shotBase.CreateSound(true);
+
+                        shotLight.Shape = sphere;
+                        shotLight.UserDataStr = sphereName;
+                        shotLight.CreateLight(true);
+                        shotLight.Light.Type = PhysicsLightType.Point;
+                        shotLight.Light.Range = 20.0f;
+                        shotLight.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                        shotLight.InitLocalTransform.SetScale(20.0f);
+                        shotLight.Material.RigidGroup = true;
+                        shotLight.Material.UserDataStr = yellowName;
+                        shotLight.EnableBreakRigidGroup = false;
+                        shotLight.EnableCollisions = false;
+                        shotLight.EnableCursorInteraction = false;
+                        shotLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                        scene.UpdateFromInitLocalTransform(shot);
+                    }
+                }
+            }
+            else
+            {
+                if (turretGunConstraint.IsBroken)
+                {
+                    turretBodyDown.DisableCollision(turretGun1, false);
+                    turretBodyDown.DisableCollision(turretGun2, false);
+                }
+            }
+
+            oldKeyboardState = keyboardState;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Boat1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Boat1Animation1.cs
new file mode 100644
index 0000000..c57bf06
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Boat1Animation1.cs
@@ -0,0 +1,411 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Boat1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string cameraBodyName;
+        string cameraDownName;
+        string cameraConstraintName;
+
+        PhysicsObject bodyBox0;
+        PhysicsObject engineSwitch;
+
+        Constraint constraint1;
+        Constraint constraint2;
+
+        PhysicsObject engine;
+        PhysicsObject engineRotor;
+
+        DemoKeyboardState oldKeyboardState;
+        bool enableExternalMoving;
+
+        Vector3 driverLocalPosition;
+
+        Vector3 position;
+        Matrix4 rotation;
+        Vector3 velocity;
+        Quaternion objectOrientation;
+        Matrix4 objectRotation;
+        Matrix4 objectInitRotation;
+
+        Vector3 position1;
+        Quaternion orientation1;
+        Quaternion orientation2;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+        Vector3 unitZ;
+
+        public Boat1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            cameraBodyName = "Camera 2 Body";
+            cameraDownName = "Camera 2 Down";
+            cameraConstraintName = "Boat 1 Camera Constraint" + instanceIndexName;
+
+            driverLocalPosition = new Vector3(0.0f, 4.3f, -11.0f);
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+            unitZ = Vector3.UnitZ;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers(bool enableExternalMoving)
+        {
+            bodyBox0 = scene.Factory.PhysicsObjectManager.Find("Boat 1 Body Box 0" + instanceIndexName);
+            engineSwitch = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine Switch" + instanceIndexName);
+
+            constraint1 = scene.Factory.ConstraintManager.Find("Boat 1 Constraint 1" + instanceIndexName);
+            constraint2 = scene.Factory.ConstraintManager.Find("Boat 1 Constraint 2" + instanceIndexName);
+
+            engine = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine" + instanceIndexName);
+            engineRotor = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine Rotor" + instanceIndexName);
+
+            oldKeyboardState = demo.GetKeyboardState();
+            this.enableExternalMoving = enableExternalMoving;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Boat 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+        }
+
+        void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsObject cameraBody = physicsObjectWithActiveCamera.RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+            PhysicsObject cameraDown = physicsObjectWithActiveCamera.RigidGroupOwner.FindChildPhysicsObject(cameraDownName, true, true);
+
+            if ((bodyBox0 == null) || (engineSwitch == null) || (cameraBody == null) || (cameraDown == null)) return;
+
+            Constraint CameraConstraint = objectBase.Scene.Factory.ConstraintManager.Find(cameraConstraintName);
+
+            bool rotorWorking = true;
+
+            if (constraint2 != null)
+            {
+                if (constraint2.PhysicsObject1 != null)
+                    if (constraint2.PhysicsObject1.IsBrokenRigidGroup || constraint2.IsBroken)
+                        rotorWorking = false;
+
+                if (constraint2.PhysicsObject2 != null)
+                    if (constraint2.PhysicsObject2.IsBrokenRigidGroup || constraint2.IsBroken)
+                        rotorWorking = false;
+            }
+            else
+            {
+                rotorWorking = false;
+            }
+
+            if (objectBase.IsBrokenRigidGroup || !rotorWorking)
+            {
+                if (constraint1 != null)
+                    constraint1.EnableControlAngleY = false;
+
+                if ((CameraConstraint != null) && (CameraConstraint.PhysicsObject1 == cameraDown))
+                {
+                    objectBase.Scene.Factory.ConstraintManager.Remove(CameraConstraint);
+                    physicsObjectWithActiveCamera.Camera.EnableControl = false;
+
+                    cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 0.0f;
+                    cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 0.0f;
+
+                    Vector3 euler = vectorZero;
+                    Vector3 cameraEuler = vectorZero;
+                    Vector3 objectEuler = vectorZero;
+
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref cameraEuler);
+                    physicsObjectWithActiveCamera.MainWorldTransform.GetTransposeRotation(ref objectRotation);
+                    physicsObjectWithActiveCamera.InitLocalTransform.GetRotation(ref objectInitRotation);
+                    Matrix4.Mult(ref objectRotation, ref objectInitRotation, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref objectEuler);
+                    Vector3.Add(ref objectEuler, ref cameraEuler, out euler);
+
+                    Matrix4 rotationX, rotationY;
+                    Matrix4.CreateRotationX(-euler.X, out rotationX);
+                    Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                    Matrix4.Mult(ref rotationY, ref rotationX, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref euler);
+                    physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+
+                    Matrix4.CreateRotationY(euler.Y, out rotation);
+
+                    physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                    physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+                }
+
+                return;
+            }
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (physicsObjectWithActiveCamera.Camera.EnableControl && (CameraConstraint != null) && (CameraConstraint.PhysicsObject1 == cameraDown))
+            {
+                if (keyboardState[Key.Space] && !oldKeyboardState[Key.Space])
+                {
+                    if (constraint1 != null)
+                        constraint1.EnableControlAngleY = false;
+
+                    objectBase.Scene.Factory.ConstraintManager.Remove(CameraConstraint);
+                    physicsObjectWithActiveCamera.Camera.EnableControl = false;
+
+                    cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 0.0f;
+                    cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 0.0f;
+
+                    Vector3 euler = vectorZero;
+                    Vector3 cameraEuler = vectorZero;
+                    Vector3 objectEuler = vectorZero;
+
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref cameraEuler);
+                    physicsObjectWithActiveCamera.MainWorldTransform.GetTransposeRotation(ref objectRotation);
+                    physicsObjectWithActiveCamera.InitLocalTransform.GetRotation(ref objectInitRotation);
+                    Matrix4.Mult(ref objectRotation, ref objectInitRotation, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref objectEuler);
+                    Vector3.Add(ref objectEuler, ref cameraEuler, out euler);
+                    euler.Z = 0.0f;
+
+                    Matrix4 rotationX, rotationY;
+                    Matrix4.CreateRotationX(-euler.X, out rotationX);
+                    Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                    Matrix4.Mult(ref rotationY, ref rotationX, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref euler);
+                    physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+
+                    Matrix4.CreateRotationY(euler.Y, out rotation);
+
+                    physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                    physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+
+                    oldKeyboardState = keyboardState;
+
+                    return;
+                }
+
+                if (keyboardState[Key.W])
+                {
+                    if ((engine != null) && (engineRotor != null))
+                    {
+                        Vector3.Multiply(ref unitZ, -10.0f, out velocity);
+
+                        engineRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+
+                        if (engineRotor.IsUnderFluidSurface)
+                        {
+                            Vector3.Multiply(ref unitZ, 5.0f, out velocity);
+
+                            engine.MainWorldTransform.AddLocalLinearVelocity(ref velocity);
+                        }
+                    }
+                }
+
+                if (keyboardState[Key.S])
+                {
+                    if ((engine != null) && (engineRotor != null))
+                    {
+                        Vector3.Multiply(ref unitZ, 10.0f, out velocity);
+
+                        engineRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+
+                        if (engineRotor.IsUnderFluidSurface)
+                        {
+                            Vector3.Multiply(ref unitZ, -5.0f, out velocity);
+
+                            engine.MainWorldTransform.AddLocalLinearVelocity(ref velocity);
+                        }
+                    }
+                }
+
+                if (keyboardState[Key.D])
+                {
+                    if (constraint1 != null)
+                        constraint1.ControlDegAngleY += 0.5f;
+                }
+
+                if (keyboardState[Key.A])
+                {
+                    if (constraint1 != null)
+                        constraint1.ControlDegAngleY -= 0.5f;
+                }
+            }
+            else
+            {
+                if (constraint1 != null)
+                    constraint1.EnableControlAngleY = false;
+
+                if (engineSwitch.IsColliding(cameraBody))
+                {
+                    if (keyboardState[Key.Space] && !oldKeyboardState[Key.Space])
+                    {
+                        physicsObjectWithActiveCamera.Camera.EnableControl = true;
+
+                        if (constraint1 != null)
+                            constraint1.EnableControlAngleY = true;
+
+                        constraint1.ControlDegAngleY = 0.0f;
+
+                        cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 1000.0f;
+                        cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 1000.0f;
+
+                        Quaternion cameraOrientationX = quaternionIdentity;
+                        Quaternion cameraOrientationY = quaternionIdentity;
+                        Quaternion cameraOrientationZ = quaternionIdentity;
+                        Quaternion cameraOrientationXY = quaternionIdentity;
+                        Quaternion cameraOrientation = quaternionIdentity;
+
+                        Quaternion.Multiply(ref cameraOrientationX, ref cameraOrientationY, out cameraOrientationXY);
+                        Quaternion.Multiply(ref cameraOrientationXY, ref cameraOrientationZ, out cameraOrientation);
+                        rotation = Matrix4.CreateFromQuaternion(cameraOrientation);
+
+                        physicsObjectWithActiveCamera.Camera.SetOrientation(ref cameraOrientation);
+                        physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+                        physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+
+                        objectOrientation = quaternionIdentity;
+                        objectRotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+                        Vector3 boatDeckPosition = vectorZero;
+                        Matrix4 boatDeckRotation = matrixIdentity;
+
+                        bodyBox0.MainWorldTransform.GetPosition(ref boatDeckPosition);
+                        bodyBox0.MainWorldTransform.GetRotation(ref boatDeckRotation);
+
+                        Matrix4.Mult(ref objectRotation, ref boatDeckRotation, out rotation);
+
+                        Vector3.TransformVector(ref driverLocalPosition, ref boatDeckRotation, out position);
+                        Vector3.Add(ref boatDeckPosition, ref position, out position);
+
+                        physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                        physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetPosition(ref position);
+                        physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+
+                        if (CameraConstraint == null)
+                        {
+                            CameraConstraint = scene.Factory.ConstraintManager.Create(cameraConstraintName);
+                            CameraConstraint.PhysicsObject1 = cameraDown;
+                            CameraConstraint.PhysicsObject2 = bodyBox0;
+                            CameraConstraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                            CameraConstraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                            CameraConstraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+
+                            boatDeckPosition.X = boatDeckPosition.Z = 0.0f;
+                            boatDeckPosition.Y = 2.0f;
+                            Vector3.Subtract(ref position1, ref boatDeckPosition, out position1);
+
+                            CameraConstraint.SetAnchor1(ref position1);
+                            CameraConstraint.SetAnchor2(ref position1);
+                            CameraConstraint.SetInitWorldOrientation1(ref orientation1);
+                            CameraConstraint.SetInitWorldOrientation2(ref orientation2);
+                            CameraConstraint.EnableLimitAngleX = true;
+                            CameraConstraint.EnableLimitAngleY = true;
+                            CameraConstraint.EnableLimitAngleZ = true;
+                            CameraConstraint.LimitAngleForce = 0.6f;
+                            CameraConstraint.Update();
+                        }
+                    }
+                }
+
+                if (enableExternalMoving)
+                {
+                    if (keyboardState[Key.Up])
+                    {
+                        if (constraint1 != null)
+                            constraint1.EnableControlAngleY = true;
+
+                        if ((engine != null) && (engineRotor != null))
+                        {
+                            Vector3.Multiply(ref unitZ, -10.0f, out velocity);
+
+                            engineRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+
+                            if (engineRotor.IsUnderFluidSurface)
+                            {
+                                Vector3.Multiply(ref unitZ, 5.0f, out velocity);
+
+                                engine.MainWorldTransform.AddLocalLinearVelocity(ref velocity);
+                            }
+                        }
+                    }
+
+                    if (keyboardState[Key.Down])
+                    {
+                        if (constraint1 != null)
+                            constraint1.EnableControlAngleY = true;
+
+                        if ((engine != null) && (engineRotor != null))
+                        {
+                            Vector3.Multiply(ref unitZ, 10.0f, out velocity);
+
+                            engineRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+
+                            if (engineRotor.IsUnderFluidSurface)
+                            {
+                                Vector3.Multiply(ref unitZ, -5.0f, out velocity);
+
+                                engine.MainWorldTransform.AddLocalLinearVelocity(ref velocity);
+                            }
+                        }
+                    }
+
+                    if (keyboardState[Key.Right])
+                    {
+                        if (constraint1 != null)
+                            constraint1.EnableControlAngleY = true;
+
+                        if (constraint1 != null)
+                            constraint1.ControlDegAngleY += 0.5f;
+                    }
+
+                    if (keyboardState[Key.Left])
+                    {
+                        if (constraint1 != null)
+                            constraint1.EnableControlAngleY = true;
+
+                        if (constraint1 != null)
+                            constraint1.ControlDegAngleY -= 0.5f;
+                    }
+                }
+            }
+
+            oldKeyboardState = keyboardState;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera1Animation1.cs
new file mode 100644
index 0000000..e3c0d92
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera1Animation1.cs
@@ -0,0 +1,568 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string cursorName;
+        string cursorAName;
+        string cursorBName;
+        string shotName;
+        string shotBaseName;
+        string shotLightName;
+        string yellowName;
+        string hitName;
+        string defaultName;
+
+        Shape sphere;
+
+        PhysicsObject[] shotTab;
+        bool enableShotTab;
+        int shotCount;
+
+        DemoMouseState oldMouseState;
+        DemoKeyboardState oldKeyboardState;
+
+        Vector3 position;
+        Vector3 direction;
+        Matrix4 rotation;
+        Matrix4 cameraRotation;
+        Matrix4 projection;
+        Matrix4 view;
+
+        Vector3 listenerPosition;
+        Vector3 listenerTopDirection;
+        Vector3 listenerFrontDirection;
+        Vector3 hitPosition;
+        Vector3 rollPosition;
+        Vector3 slidePosition;
+        Vector3 backgroundPosition;
+
+        float hitVolume;
+        float rollVolume;
+        float slideVolume;
+        float backgroundVolume;
+        float listenerRange;
+
+        Vector2 mousePosition;
+
+        Random random;
+
+        DemoListener listener;
+        DemoEmitter emitter;
+        DemoSoundGroup shotSoundGroup;
+        DemoSound shotSound;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+
+        public Camera1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            cursorName = "Cursor";
+            cursorAName = "Cursor A";
+            cursorBName = "Cursor B";
+            shotName = "Camera 1 Shot" + instanceIndexName + " ";
+            shotBaseName = "Camera 1 Shot Object" + instanceIndexName + " ";
+            shotLightName = "Camera 1 Shot Light" + instanceIndexName + " ";
+            yellowName = "Yellow";
+            hitName = "Hit";
+            defaultName = "Default";
+
+            shotTab = new PhysicsObject[10];
+
+            random = new Random();
+
+            listener = new DemoListener();
+            emitter = new DemoEmitter();
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+
+            shotCount = -1;
+            enableShotTab = false;
+            for (int i = 0; i < shotTab.Length; i++)
+                shotTab[i] = null;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 1" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.TransformMethods += new SimulateMethod(MoveCursor);
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void MoveCursor(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            bool mouseButton = false;
+            float mouseScrollWheel = 0.0f;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+            mouseScrollWheel = mouseState.Wheel;
+            mouseButton = mouseState[MouseButton.Left];
+
+            bool hitMenu = false;
+            if (demo.EnableMenu)
+                hitMenu = (demo.MenuScene.MenuAnimation1.CurrentSwitch != null);
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            CursorController cursorController = objectBase.InternalControllers.CursorController;
+            cursorController.SetViewport(0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f);
+            cursorController.SetViewMatrix(ref view);
+            cursorController.SetProjectionMatrix(ref projection);
+            cursorController.SetMousePosition(ref mousePosition);
+            cursorController.MouseButton = mouseButton && !hitMenu;
+            cursorController.MouseScrollWheel = mouseScrollWheel;
+            cursorController.DragWheelSpeed = 50.0f;
+            cursorController.WindowActive = true;
+            cursorController.Update();
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            Vector3 deltaRotation = vectorZero;
+            Vector3 deltaTranslation = vectorZero;
+            float rotationSpeed = 8.0f;
+            float translationSpeed = 8.0f;
+            float soundPositionFactor = 0.1f;
+            bool enableShot = false;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (mouseState[MouseButton.Right])
+            {
+                deltaRotation.Y += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.X - oldMouseState.X) * time);
+                deltaRotation.X += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.Y - oldMouseState.Y) * time);
+            }
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+
+            if (mouseState[MouseButton.Middle] && !oldMouseState[MouseButton.Middle])
+                enableShot = true;
+
+            if ((keyboardState[Key.ControlRight] && !oldKeyboardState[Key.ControlRight]) ||
+               (keyboardState[Key.ControlLeft] && !oldKeyboardState[Key.ControlLeft]))
+                enableShot = true;
+
+            PhysicsObject cursorA = scene.Factory.PhysicsObjectManager.Find(cursorAName);
+            PhysicsObject cursorB = scene.Factory.PhysicsObjectManager.Find(cursorBName);
+
+            if (!demo.EnableMenu)
+            {
+                if (cursorA != null)
+                    cursorA.EnableDrawing = true;
+
+                if (cursorB != null)
+                    cursorB.EnableDrawing = true;
+            }
+            else
+            {
+                if (cursorA != null)
+                    cursorA.EnableDrawing = false;
+
+                if (cursorB != null)
+                    cursorB.EnableDrawing = false;
+            }
+
+            if (keyboardState[Key.W])
+                deltaTranslation.Z += translationSpeed * time;
+
+            if (keyboardState[Key.S])
+                deltaTranslation.Z -= translationSpeed * time;
+
+            if (keyboardState[Key.D])
+                deltaTranslation.X += translationSpeed * time;
+
+            if (keyboardState[Key.A])
+                deltaTranslation.X -= translationSpeed * time;
+
+            oldMouseState = mouseState;
+            oldKeyboardState = keyboardState;
+
+            if (deltaRotation.LengthSquared != 0.0f)
+            {
+                Vector3 euler = vectorZero;
+                objectBase.Camera.GetEuler(ref euler);
+                Vector3.Add(ref euler, ref deltaRotation, out euler);
+                objectBase.Camera.SetEuler(ref euler);
+
+                Matrix4 rotationX, rotationY;
+                Matrix4.CreateRotationX(-euler.X, out rotationX);
+                Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                Matrix4.Mult(ref rotationY, ref rotationX, out cameraRotation);
+
+                objectBase.Camera.SetRotation(ref cameraRotation);
+
+                objectBase.MainWorldTransform.SetTransposeRotation(ref cameraRotation);
+                objectBase.RecalculateMainTransform();
+            }
+
+            if (deltaTranslation.LengthSquared != 0.0f)
+            {
+                objectBase.MainWorldTransform.GetRotation(ref rotation);
+                Vector3.TransformVector(ref deltaTranslation, ref rotation, out direction);
+
+                objectBase.MainWorldTransform.GetPosition(ref position);
+                Vector3.Add(ref position, ref direction, out position);
+                objectBase.MainWorldTransform.SetPosition(ref position);
+
+                objectBase.RecalculateMainTransform();
+            }
+
+            objectBase.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectBase.MainWorldTransform.GetPosition(ref position);
+            objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectBase.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectBase.Camera.UpdateFrustum();
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            Vector3 rayPosition, rayDirection;
+
+            rayPosition = rayDirection = vectorZero;
+
+            objectBase.UnProjectToRay(ref mousePosition, 0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f, ref view, ref matrixIdentity, ref projection, ref rayPosition, ref rayDirection);
+
+            PhysicsObject cursor = scene.Factory.PhysicsObjectManager.Find(cursorName);
+
+            if (cursor != null)
+            {
+                Vector3 cursorPosition = vectorZero;
+                Matrix4 cursorLocalRotation = matrixIdentity;
+                Matrix4 cursorWorldRotation = matrixIdentity;
+
+                cursor.InitLocalTransform.GetPosition(ref cursorPosition);
+                cursor.InitLocalTransform.GetRotation(ref cursorLocalRotation);
+                cursor.MainWorldTransform.GetRotation(ref cursorWorldRotation);
+
+                objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+                Matrix4.Mult(ref cursorLocalRotation, ref cameraRotation, out rotation);
+
+                Vector3.TransformVector(ref cursorPosition, ref cursorWorldRotation, out position);
+
+                cursor.MainWorldTransform.SetRotation(ref rotation);
+                Vector3.Add(ref position, ref rayPosition, out position);
+                Vector3.Add(ref position, ref rayDirection, out position);
+                cursor.MainWorldTransform.SetPosition(ref position);
+
+                cursor.RecalculateMainTransform();
+            }
+
+            CursorController cursorController = objectBase.InternalControllers.CursorController;
+
+            if (cursorController.IsDragging)
+            {
+                if (cursorController.HitPhysicsObject.Integral.IsStatic && (cursorController.HitPhysicsObject.Shape != null) && (cursorController.HitPhysicsObject.Shape.ShapePrimitive != null) && (cursorController.HitPhysicsObject.Shape.ShapePrimitive.ShapePrimitiveType == ShapePrimitiveType.TriangleMesh))
+                {
+                    Vector3 cursorStartPosition = vectorZero;
+                    Vector3 cursorEndPosition = vectorZero;
+
+                    cursorController.GetAnchor1(ref cursorStartPosition);
+                    cursorController.GetAnchor2(ref cursorEndPosition);
+
+                    Vector3.Subtract(ref cursorEndPosition, ref cursorStartPosition, out direction);
+
+                    if (direction.LengthSquared != 0.0f)
+                    {
+                        cursorController.HitPhysicsObject.MainWorldTransform.GetPosition(ref cursorStartPosition);
+
+                        Vector3.Add(ref cursorStartPosition, ref direction, out cursorStartPosition);
+
+                        cursorController.HitPhysicsObject.MainWorldTransform.SetPosition(ref cursorStartPosition);
+                        cursorController.HitPhysicsObject.RecalculateMainTransform();
+                    }
+                }
+            }
+
+            objectBase.MainWorldTransform.GetPosition(ref listenerPosition);
+            objectBase.Camera.GetTransposeRotation(ref rotation);
+
+            Vector3.Multiply(ref listenerPosition, soundPositionFactor, out position);
+            listenerTopDirection.X = rotation.Row1.X;
+            listenerTopDirection.Y = rotation.Row1.Y;
+            listenerTopDirection.Z = rotation.Row1.Z;
+            listenerFrontDirection.X = rotation.Row2.X;
+            listenerFrontDirection.Y = rotation.Row2.Y;
+            listenerFrontDirection.Z = rotation.Row2.Z;
+
+            listener.Position = position;
+            listener.TopDirection = listenerTopDirection;
+            listener.FrontDirection = listenerFrontDirection;
+            listenerRange = objectBase.Sound.Range;
+
+            if (enableShot)
+            {
+                Vector3 shotScale, shotColor;
+
+                shotCount = (shotCount + 1) % shotTab.Length;
+                string shotCountName = shotCount.ToString();
+
+                PhysicsObject shot = scene.Factory.PhysicsObjectManager.FindOrCreate(shotName + shotCountName);
+                PhysicsObject shotBase = scene.Factory.PhysicsObjectManager.FindOrCreate(shotBaseName + shotCountName);
+                PhysicsObject shotLight = scene.Factory.PhysicsObjectManager.FindOrCreate(shotLightName + shotCountName);
+
+                shot.AddChildPhysicsObject(shotBase);
+                shot.AddChildPhysicsObject(shotLight);
+
+                shotTab[shotCount] = shotBase;
+                enableShotTab = true;
+
+                shotScale = shotColor = vectorZero;
+
+                shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+                Vector3.Multiply(ref rayDirection, 300.0f, out rayDirection);
+
+                shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot.InitLocalTransform.SetPosition(ref rayPosition);
+                shot.InitLocalTransform.SetLinearVelocity(ref rayDirection);
+                shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot.MaxSimulationFrameCount = 200;
+                shot.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+                //shot.EnableLocalGravity = true;
+
+                shotBase.Shape = sphere;
+                shotBase.UserDataStr = sphereName;
+                shotBase.InitLocalTransform.SetScale(ref shotScale);
+                shotBase.Integral.SetDensity(10.0f);
+                shotBase.Material.RigidGroup = true;
+                shotBase.EnableBreakRigidGroup = false;
+                shotBase.EnableCollisions = true;
+                shotBase.DisableCollision(objectBase, true);
+                shotBase.MaxDisableCollisionFrameCount = 50;
+                shotBase.CreateSound(true);
+
+                shotLight.Shape = sphere;
+                shotLight.UserDataStr = sphereName;
+                shotLight.CreateLight(true);
+                shotLight.Light.Type = PhysicsLightType.Point;
+                shotLight.Light.Range = 20.0f;
+
+                shotColor.X = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Y = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Z = (float)Math.Max(random.NextDouble(), random.NextDouble());
+
+                shotLight.Light.SetDiffuse(ref shotColor);
+                shotLight.InitLocalTransform.SetScale(20.0f);
+                shotLight.Material.UserDataStr = yellowName;
+                shotLight.Material.RigidGroup = true;
+                shotLight.EnableBreakRigidGroup = false;
+                shotLight.EnableCollisions = false;
+                shotLight.EnableCursorInteraction = false;
+                shotLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                scene.UpdateFromInitLocalTransform(shot);
+
+                shotSoundGroup = demo.SoundGroups[hitName];
+                shotSoundGroup.MaxHitRepeatTime = 0.0f;
+
+                if (shotSound == null)
+                    shotSound = shotSoundGroup.GetSound(objectBase.Sound, listener, emitter);
+
+                shotSound.Update(time);
+
+                Vector3.Multiply(ref rayPosition, soundPositionFactor, out shotSound.HitPosition);
+                shotSound.HitVolume = 1.0f;
+
+                shotSound.FrontDirection.X = rotation.Row2.X;
+                shotSound.FrontDirection.Y = rotation.Row2.Y;
+                shotSound.FrontDirection.Z = rotation.Row2.Z;
+
+                demo.SoundQueue.EnqueueSound(shotSound);
+            }
+            else
+            {
+                PhysicsObject shotBase;
+                DemoSound shotBaseSound;
+
+                if (shotSound != null)
+                {
+                    shotSound.Update(time);
+
+                    if (shotSound.Stop())
+                    {
+                        shotSound.SoundGroup.SetSound(shotSound);
+                        shotSound = null;
+                    }
+                }
+
+                if (enableShotTab)
+                {
+                    enableShotTab = false;
+
+                    for (int i = 0; i < shotTab.Length; i++)
+                    {
+                        shotBase = shotTab[i];
+
+                        if (shotBase != null)
+                        {
+                            if (shotBase.Sound.UserDataObj != null)
+                            {
+                                enableShotTab = true;
+                                shotBaseSound = (DemoSound)shotBase.Sound.UserDataObj;
+                                shotBaseSound.Update(time);
+
+                                if (shotBaseSound.Stop())
+                                {
+                                    shotBaseSound.SoundGroup.SetSound(shotBaseSound);
+                                    shotBase.Sound.UserDataObj = null;
+                                    shotTab[i] = null;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            objectBase.Camera.UpdatePhysicsObjects(true, true, true);
+            objectBase.Camera.SortDrawPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortTransparentPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortLightPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+
+            PhysicsObject currentPhysicsObject;
+            PhysicsSound currentSound;
+            DemoSoundGroup soundGroup;
+            DemoSound sound;
+
+            if (demo.SoundQueue.SoundCount > 0)
+                return;
+
+            for (int i = 0; i < scene.TotalPhysicsObjectCount; i++)
+            {
+                if (demo.SoundQueue.SoundCount >= demo.SoundQueue.MaxSoundCount)
+                    break;
+
+                currentPhysicsObject = scene.GetPhysicsObject(i);
+
+                currentSound = !currentPhysicsObject.EnableSoundFromRigidGroupOwner ? currentPhysicsObject.Sound : currentPhysicsObject.RigidGroupOwner.Sound;
+
+                if (currentSound == null)
+                    continue;
+
+                if (!currentSound.Enabled)
+                    continue;
+
+                if (currentSound.UserDataStr == null)
+                    soundGroup = demo.SoundGroups[defaultName];
+                else
+                    soundGroup = demo.SoundGroups[currentSound.UserDataStr];
+
+                if (currentPhysicsObject.IsSleeping && (currentSound.UserDataObj == null) && !soundGroup.EnableBackground)
+                    continue;
+
+                if (currentPhysicsObject.GetSoundData(ref listenerPosition, listenerRange, soundGroup.EnableHit, soundGroup.EnableRoll, soundGroup.EnableSlide, soundGroup.EnableBackground, currentSound.BackgroundVolumeVelocityModulation, ref hitPosition, ref rollPosition, ref slidePosition, ref backgroundPosition, ref hitVolume, ref rollVolume, ref slideVolume, ref backgroundVolume))
+                {
+                    if (currentSound.UserDataObj == null)
+                    {
+                        sound = soundGroup.GetSound(currentSound, listener, emitter);
+                        currentSound.UserDataObj = sound;
+                    }
+                    else
+                    {
+                        sound = (DemoSound)currentSound.UserDataObj;
+                    }
+
+                    sound.Update(time);
+
+                    currentPhysicsObject.MainWorldTransform.GetTransposeRotation(ref rotation);
+
+                    Vector3.Multiply(ref hitPosition, soundPositionFactor, out sound.HitPosition);
+                    Vector3.Multiply(ref rollPosition, soundPositionFactor, out sound.RollPosition);
+                    Vector3.Multiply(ref slidePosition, soundPositionFactor, out sound.SlidePosition);
+                    Vector3.Multiply(ref backgroundPosition, soundPositionFactor, out sound.BackgroundPosition);
+
+                    sound.HitVolume = hitVolume;
+                    sound.RollVolume = rollVolume;
+                    sound.SlideVolume = slideVolume;
+                    sound.BackgroundVolume = backgroundVolume;
+
+                    sound.FrontDirection.X = rotation.Row2.X;
+                    sound.FrontDirection.Y = rotation.Row2.Y;
+                    sound.FrontDirection.Z = rotation.Row2.Z;
+
+                    demo.SoundQueue.EnqueueSound(sound);
+                }
+                else
+                {
+                    if (currentSound.UserDataObj != null)
+                    {
+                        sound = (DemoSound)currentSound.UserDataObj;
+                        sound.Update(time);
+
+                        if (sound.Stop())
+                        {
+                            soundGroup.SetSound(sound);
+                            currentSound.UserDataObj = null;
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera2Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera2Animation1.cs
new file mode 100644
index 0000000..c28dbe0
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera2Animation1.cs
@@ -0,0 +1,917 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera2Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string cursorName;
+        string cursorAName;
+        string cursorBName;
+        string shotName;
+        string shotBaseName;
+        string shotLightName;
+        string yellowName;
+        string hitName;
+        string defaultName;
+
+        Shape sphere;
+        PhysicsObject cameraUp;
+        PhysicsObject cameraBody;
+        PhysicsObject cameraDown;
+
+        PhysicsObject[] shotTab;
+        bool enableShotTab;
+        int shotCount;
+
+        DemoMouseState oldMouseState;
+        DemoKeyboardState oldKeyboardState;
+
+        bool enableDistanceCollision;
+
+        bool enableDistance;
+        bool enableControl;
+        float distance;
+
+        float maxTangentLength;
+        float maxDistance;
+
+        Vector3 position;
+        Vector3 direction;
+        Matrix4 rotation;
+        Matrix4 cameraRotation;
+        Matrix4 projection;
+        Matrix4 view;
+
+        Vector3 startPoint;
+        Vector3 endPoint;
+        Vector3 hitPoint;
+        Vector3 hitDistance;
+
+        Vector3 listenerPosition;
+        Vector3 listenerTopDirection;
+        Vector3 listenerFrontDirection;
+        Vector3 hitPosition;
+        Vector3 rollPosition;
+        Vector3 slidePosition;
+        Vector3 backgroundPosition;
+
+        float hitVolume;
+        float rollVolume;
+        float slideVolume;
+        float backgroundVolume;
+        float listenerRange;
+
+        Vector3 fluidNormal;
+        Vector3 moveForce;
+        Vector2 mousePosition;
+
+        Random random;
+
+        DemoListener listener;
+        DemoEmitter emitter;
+        DemoSoundGroup shotSoundGroup;
+        DemoSound shotSound;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+
+        public Camera2Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            cursorName = "Cursor";
+            cursorAName = "Cursor A";
+            cursorBName = "Cursor B";
+            shotName = "Camera 2 Shot" + instanceIndexName + " ";
+            shotBaseName = "Camera 2 Shot Object" + instanceIndexName + " ";
+            shotLightName = "Camera 2 Shot Light" + instanceIndexName + " ";
+            yellowName = "Yellow";
+            hitName = "Hit";
+            defaultName = "Default";
+
+            maxTangentLength = 10.0f;
+            maxDistance = -10.0f;
+
+            shotTab = new PhysicsObject[10];
+
+            random = new Random();
+
+            listener = new DemoListener();
+            emitter = new DemoEmitter();
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers(bool enableDistanceCollision)
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+            cameraUp = scene.Factory.PhysicsObjectManager.Find("Camera 2 Up" + instanceIndexName);
+            cameraBody = scene.Factory.PhysicsObjectManager.Find("Camera 2 Body" + instanceIndexName);
+            cameraDown = scene.Factory.PhysicsObjectManager.Find("Camera 2 Down" + instanceIndexName);
+
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+
+            this.enableDistanceCollision = enableDistanceCollision;
+
+            enableDistance = false;
+            enableControl = false;
+            distance = 0;
+
+            shotCount = -1;
+            enableShotTab = false;
+            for (int i = 0; i < shotTab.Length; i++)
+                shotTab[i] = null;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 2 Up" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.TransformMethods += new SimulateMethod(MoveCursor);
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void MoveCursor(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            bool mouseButton = false;
+            float mouseScrollWheel = 0.0f;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+            mouseScrollWheel = mouseState.Wheel;
+            mouseButton = mouseState[MouseButton.Left];
+
+            bool hitMenu = false;
+            if (demo.EnableMenu)
+                hitMenu = (demo.MenuScene.MenuAnimation1.CurrentSwitch != null);
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            CursorController cursorController = objectBase.InternalControllers.CursorController;
+            cursorController.SetViewport(0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f);
+            cursorController.SetViewMatrix(ref view);
+            cursorController.SetProjectionMatrix(ref projection);
+            cursorController.SetMousePosition(ref mousePosition);
+            cursorController.MouseButton = mouseButton && !hitMenu;
+            cursorController.MouseScrollWheel = mouseScrollWheel;
+            cursorController.DragWheelSpeed = 50.0f;
+            cursorController.WindowActive = true;
+            cursorController.Update();
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            Vector3 deltaRotation = vectorZero;
+            Vector3 deltaTranslation = vectorZero;
+            float rotationSpeed = 8.0f;
+            float translationSpeed = 8.0f;
+            float jumpSpeed = 8.0f;
+            float swimUpSpeed = 0.2f;
+            float swimUpOnSurfaceSpeed = 0.06f;
+            float translationInFluidFactor = 0.15f;
+            float soundPositionFactor = 0.1f;
+            bool enableJump = false;
+            bool enableSwimUp = false;
+            bool enableShot = false;
+
+            bool cameraBodyCollision = cameraBody.IsColliding();
+            bool cameraDownCollision = cameraDown.IsColliding();
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (mouseState[MouseButton.Right])
+            {
+                deltaRotation.Y += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.X - oldMouseState.X) * time);
+                deltaRotation.X += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.Y - oldMouseState.Y) * time);
+            }
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+
+            if (!objectBase.Camera.EnableControl)
+            {
+                if (mouseState[MouseButton.Middle] && !oldMouseState[MouseButton.Middle])
+                    enableShot = true;
+
+                if ((keyboardState[Key.ControlRight] && !oldKeyboardState[Key.ControlRight]) ||
+                   (keyboardState[Key.ControlLeft] && !oldKeyboardState[Key.ControlLeft]))
+                    enableShot = true;
+            }
+
+            PhysicsObject cursorA = scene.Factory.PhysicsObjectManager.Find(cursorAName);
+            PhysicsObject cursorB = scene.Factory.PhysicsObjectManager.Find(cursorBName);
+
+            if (!demo.EnableMenu)
+            {
+                if (cursorA != null)
+                    cursorA.EnableDrawing = true;
+
+                if (cursorB != null)
+                    cursorB.EnableDrawing = true;
+            }
+            else
+            {
+                if (cursorA != null)
+                    cursorA.EnableDrawing = false;
+
+                if (cursorB != null)
+                    cursorB.EnableDrawing = false;
+            }
+
+            if (!objectBase.Camera.EnableControl)
+            {
+                if (keyboardState[Key.W])
+                    deltaTranslation.Z += translationSpeed * time;
+
+                if (keyboardState[Key.S])
+                    deltaTranslation.Z -= translationSpeed * time;
+
+                if (keyboardState[Key.D])
+                    deltaTranslation.X += translationSpeed * time;
+
+                if (keyboardState[Key.A])
+                    deltaTranslation.X -= translationSpeed * time;
+
+                if (keyboardState[Key.Space] && !oldKeyboardState[Key.Space])
+                    enableJump = true;
+
+                if (keyboardState[Key.Space])
+                    enableSwimUp = true;
+            }
+
+            if (keyboardState[Key.Tab] && !oldKeyboardState[Key.Tab])
+                enableDistance = !enableDistance;
+
+            oldMouseState = mouseState;
+            oldKeyboardState = keyboardState;
+
+            Vector3 gravityDirection = vectorZero;
+            scene.GetGravityDirection(ref gravityDirection);
+
+            if (!objectBase.Camera.EnableControl)
+            {
+                if (deltaRotation.LengthSquared != 0.0f)
+                {
+                    Vector3 euler = vectorZero;
+                    objectBase.Camera.GetEuler(ref euler);
+                    Vector3.Add(ref euler, ref deltaRotation, out euler);
+                    objectBase.Camera.SetEuler(ref euler);
+
+                    Matrix4 rotationX, rotationY;
+                    Matrix4.CreateRotationX(-euler.X, out rotationX);
+                    Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                    Matrix4.Mult(ref rotationY, ref rotationX, out cameraRotation);
+
+                    objectBase.Camera.SetRotation(ref cameraRotation);
+
+                    Matrix4.CreateRotationY(euler.Y, out rotation);
+
+                    objectBase.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                    objectBase.RigidGroupOwner.RecalculateMainTransform();
+                }
+            }
+            else
+            {
+                Vector3 euler = vectorZero;
+                Matrix4 objectRotation = matrixIdentity;
+                objectBase.Camera.GetEuler(ref euler);
+                Vector3.Add(ref euler, ref deltaRotation, out euler);
+                objectBase.RigidGroupOwner.MainWorldTransform.GetRotation(ref objectRotation);
+
+                Matrix4 rotationX, rotationY;
+                Matrix4.CreateRotationX(euler.X, out rotationX);
+                Matrix4.CreateRotationY(euler.Y, out rotationY);
+
+                Matrix4.Mult(ref rotationX, ref rotationY, out cameraRotation);
+                Matrix4.Mult(ref cameraRotation, ref objectRotation, out rotation);
+
+                objectBase.Camera.SetEuler(ref euler);
+                objectBase.Camera.SetTransposeRotation(ref rotation);
+            }
+
+            if (deltaTranslation.LengthSquared != 0.0f)
+            {
+                if (objectBase.RigidGroupOwner.IsUnderFluidSurface)
+                {
+                    objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 10.0f;
+                    objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 10.0f;
+
+                    if (enableSwimUp)
+                    {
+                        objectBase.InitLocalTransform.GetTransposeRotation(ref rotation);
+                        Vector3.TransformVector(ref deltaTranslation, ref rotation, out direction);
+
+                        objectBase.MainWorldTransform.GetRotation(ref rotation);
+                        Vector3.TransformVector(ref direction, ref rotation, out moveForce);
+                        Vector3.Multiply(ref moveForce, translationInFluidFactor * objectBase.RigidGroupOwner.Integral.Mass / (time * time), out moveForce);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                    }
+                    else
+                    {
+                        objectBase.Camera.GetTransposeRotation(ref rotation);
+                        Vector3.TransformVector(ref deltaTranslation, ref rotation, out moveForce);
+                        Vector3.Multiply(ref moveForce, translationInFluidFactor * objectBase.RigidGroupOwner.Integral.Mass / (time * time), out moveForce);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                    }
+                }
+                else
+                {
+                    if (cameraDownCollision)
+                    {
+                        objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 100000.0f;
+                        objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 100000.0f;
+
+                        objectBase.InitLocalTransform.GetTransposeRotation(ref rotation);
+                        Vector3.TransformVector(ref deltaTranslation, ref rotation, out direction);
+
+                        objectBase.MainWorldTransform.GetRotation(ref rotation);
+                        Vector3.TransformVector(ref direction, ref rotation, out moveForce);
+                        Vector3.Multiply(ref moveForce, objectBase.RigidGroupOwner.Integral.Mass / (time * time), out moveForce);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                        cameraDown.UpdateFeedbackForce(ref moveForce);
+                    }
+                    else
+                    {
+                        if (objectBase.RigidGroupOwner.IsInFluid)
+                        {
+                            objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 10.0f;
+                            objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 10.0f;
+
+                            objectBase.InitLocalTransform.GetTransposeRotation(ref rotation);
+                            Vector3.TransformVector(ref deltaTranslation, ref rotation, out direction);
+
+                            objectBase.MainWorldTransform.GetRotation(ref rotation);
+                            Vector3.TransformVector(ref direction, ref rotation, out moveForce);
+                            Vector3.Multiply(ref moveForce, translationInFluidFactor * objectBase.RigidGroupOwner.Integral.Mass / (time * time), out moveForce);
+
+                            objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                        }
+                    }
+                }
+            }
+
+            if (enableSwimUp)
+            {
+                if (cameraDown.IsUnderFluidSurface && cameraBody.IsUnderFluidSurface)
+                {
+                    objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 10.0f;
+                    objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 10.0f;
+
+                    PhysicsObject fluidPhysicsObject = objectBase.RigidGroupOwner.FluidPhysicsObject;
+                    fluidPhysicsObject.InternalControllers.FluidController.GetNormal(ref fluidNormal);
+
+                    Vector3.Multiply(ref fluidNormal, swimUpSpeed * objectBase.RigidGroupOwner.Integral.Mass / time, out moveForce);
+
+                    objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                }
+                else
+                    if (!cameraDownCollision && cameraBody.IsInFluid && (deltaTranslation.LengthSquared == 0.0f))
+                    {
+                        objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 10.0f;
+                        objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 10.0f;
+
+                        PhysicsObject fluidPhysicsObject = objectBase.RigidGroupOwner.FluidPhysicsObject;
+                        fluidPhysicsObject.InternalControllers.FluidController.GetNormal(ref fluidNormal);
+
+                        Vector3.Multiply(ref fluidNormal, swimUpOnSurfaceSpeed * objectBase.RigidGroupOwner.Integral.Mass / time, out moveForce);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                    }
+            }
+
+            if (enableJump)
+            {
+                if (!enableControl && !objectBase.Camera.EnableControl && cameraDownCollision && !cameraDown.IsUnderFluidSurface && !cameraBody.IsUnderFluidSurface)
+                {
+                    objectBase.RigidGroupOwner.MaxPreUpdateLinearVelocity = 100000.0f;
+                    objectBase.RigidGroupOwner.MaxPostUpdateLinearVelocity = 100000.0f;
+
+                    Vector3.Multiply(ref gravityDirection, -jumpSpeed * objectBase.RigidGroupOwner.Integral.Mass / time, out moveForce);
+
+                    objectBase.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref moveForce);
+                    cameraDown.UpdateFeedbackForce(ref moveForce);
+                }
+            }
+
+            if (enableDistance)
+            {
+                if (distance > maxDistance)
+                    distance -= 2.0f;
+
+                if (enableDistanceCollision)
+                {
+                    float margin = 1.0f;
+
+                    objectBase.MainWorldTransform.GetPosition(ref startPoint);
+
+                    objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+                    direction.X = cameraRotation.Row2.X;
+                    direction.Y = cameraRotation.Row2.Y;
+                    direction.Z = cameraRotation.Row2.Z;
+
+                    Vector3.Multiply(ref direction, distance, out direction);
+                    Vector3.Add(ref startPoint, ref direction, out endPoint);
+
+                    scene.UpdatePhysicsObjectsIntersectedBySegment(ref startPoint, ref endPoint, margin, true);
+
+                    float minDistance = float.MaxValue;
+                    float curDistance = 0.0f;
+
+                    for (int i = 0; i < scene.IntersectedPhysicsObjectsCount; i++)
+                    {
+                        PhysicsObject hitObject = scene.GetIntersectedPhysicsObject(i, ref hitPoint);
+
+                        if (hitObject.RigidGroupOwner == objectBase.RigidGroupOwner)
+                            continue;
+
+                        //if ((hitObject.InternalControllers.FluidController != null) && hitObject.InternalControllers.FluidController.Enabled)
+                        //    continue;
+
+                        if (!hitObject.EnableCollisions)
+                            continue;
+
+                        Vector3.Subtract(ref startPoint, ref hitPoint, out hitDistance);
+                        curDistance = hitDistance.Length;
+
+                        if (curDistance < minDistance)
+                            minDistance = curDistance;
+                    }
+
+                    if (minDistance < Math.Abs(distance))
+                        distance = -minDistance;
+                }
+            }
+            else
+            {
+                if (distance < 0.0f)
+                    distance += 2.0f;
+
+                if (distance > 0.0f)
+                    distance = 0.0f;
+            }
+
+            if (enableDistance)
+            {
+                if (distance > maxDistance)
+                {
+                    if ((cameraUp != null) && (cameraBody != null) && (cameraDown != null))
+                    {
+                        objectBase.RigidGroupOwner.EnableDrawing = true;
+                        cameraUp.EnableDrawing = true;
+                        cameraBody.EnableDrawing = true;
+                        cameraDown.EnableDrawing = true;
+                    }
+                }
+            }
+            else
+            {
+                if (distance >= 0.0f)
+                {
+                    if ((cameraUp != null) && (cameraBody != null) && (cameraDown != null))
+                    {
+                        objectBase.RigidGroupOwner.EnableDrawing = false;
+                        cameraUp.EnableDrawing = false;
+                        cameraBody.EnableDrawing = false;
+                        cameraDown.EnableDrawing = false;
+                    }
+                }
+            }
+
+            enableControl = objectBase.Camera.EnableControl;
+
+            float gravityDistance = 0.0f;
+            Vector3 gravityLinearVelocity = vectorZero;
+            Vector3 tangentLinearVelocity = vectorZero;
+            Vector3 velocity = vectorZero;
+
+            objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+            Vector3.Dot(ref gravityDirection, ref velocity, out gravityDistance);
+            Vector3.Multiply(ref gravityDirection, gravityDistance, out gravityLinearVelocity);
+            Vector3.Subtract(ref velocity, ref gravityLinearVelocity, out tangentLinearVelocity);
+
+            float tangentLength = tangentLinearVelocity.Length;
+
+            if (tangentLength > maxTangentLength)
+                tangentLinearVelocity *= maxTangentLength / tangentLength;
+
+            Vector3.Add(ref gravityLinearVelocity, ref tangentLinearVelocity, out velocity);
+
+            objectBase.RigidGroupOwner.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+            objectBase.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectBase.MainWorldTransform.GetPosition(ref position);
+            objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectBase.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, distance);
+            objectBase.Camera.UpdateFrustum();
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            Vector3 rayPosition, rayDirection;
+
+            rayPosition = rayDirection = vectorZero;
+
+            objectBase.UnProjectToRay(ref mousePosition, 0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f, ref view, ref matrixIdentity, ref projection, ref rayPosition, ref rayDirection);
+
+            PhysicsObject cursor = scene.Factory.PhysicsObjectManager.Find(cursorName);
+
+            if (cursor != null)
+            {
+                Vector3 cursorPosition = vectorZero;
+                Matrix4 cursorLocalRotation = matrixIdentity;
+                Matrix4 cursorWorldRotation = matrixIdentity;
+
+                cursor.InitLocalTransform.GetPosition(ref cursorPosition);
+                cursor.InitLocalTransform.GetRotation(ref cursorLocalRotation);
+                cursor.MainWorldTransform.GetRotation(ref cursorWorldRotation);
+
+                objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+                Matrix4.Mult(ref cursorLocalRotation, ref cameraRotation, out rotation);
+
+                Vector3.TransformVector(ref cursorPosition, ref cursorWorldRotation, out position);
+
+                cursor.MainWorldTransform.SetRotation(ref rotation);
+                Vector3.Add(ref position, ref rayPosition, out position);
+                Vector3.Add(ref position, ref rayDirection, out position);
+                cursor.MainWorldTransform.SetPosition(ref position);
+
+                cursor.RecalculateMainTransform();
+            }
+
+            CursorController cursorController = objectBase.InternalControllers.CursorController;
+
+            if (cursorController.IsDragging)
+            {
+                if (cursorController.HitPhysicsObject.Integral.IsStatic && (cursorController.HitPhysicsObject.InternalControllers.HeightmapController != null) && cursorController.HitPhysicsObject.InternalControllers.HeightmapController.Enabled)
+                {
+                    Vector3 cursorStartPosition = vectorZero;
+                    Vector3 cursorEndPosition = vectorZero;
+
+                    cursorController.GetAnchor1(ref cursorStartPosition);
+                    cursorController.GetAnchor2(ref cursorEndPosition);
+
+                    Vector3.Subtract(ref cursorEndPosition, ref cursorStartPosition, out direction);
+
+                    float dir = direction.Y;
+
+                    if (dir != 0.0f)
+                    {
+                        Vector3 scale = vectorZero;
+
+                        cursorController.HitPhysicsObject.MainWorldTransform.GetScale(ref scale);
+
+                        float positionX = cursorStartPosition.X + 0.5f * scale.X;
+                        float positionY = cursorStartPosition.Y + 0.5f * scale.Y;
+                        float positionZ = cursorStartPosition.Z + 0.5f * scale.Z;
+
+                        cursorController.HitPhysicsObject.InternalControllers.HeightmapController.AddHeight(positionX, positionY, positionZ, dir / scale.Y);
+                        cursorController.HitPhysicsObject.InternalControllers.HeightmapController.UpdateBounding();
+
+                        // To change the friction and restitution of the heightmap surface by the cursor, add the following lines of code
+
+                        //cursorController.HitPhysicsObject.InternalControllers.HeightmapController.SetFriction(positionX, positionY, positionZ, 0.0f);
+                        //cursorController.HitPhysicsObject.InternalControllers.HeightmapController.SetRestitution(positionX, positionY, positionZ, 2.0f);
+
+                        cursorStartPosition.Y += dir;
+                        cursorController.SetAnchor1(ref cursorStartPosition);
+                    }
+                }
+
+                if (cursorController.HitPhysicsObject.Integral.IsStatic && (cursorController.HitPhysicsObject.InternalControllers.HeightmapController != null) && cursorController.HitPhysicsObject.InternalControllers.HeightmapController.Enabled)
+                {
+                    Vector3 cursorStartPosition = vectorZero;
+                    Vector3 cursorEndPosition = vectorZero;
+
+                    cursorController.GetAnchor1(ref cursorStartPosition);
+                    cursorController.GetAnchor2(ref cursorEndPosition);
+
+                    Vector3.Subtract(ref cursorEndPosition, ref cursorStartPosition, out direction);
+
+                    if (direction.LengthSquared != 0.0f)
+                    {
+                        // To move the heightmap surface by the cursor, add the following lines of code
+
+                        //cursorController.HitPhysicsObject.MainWorldTransform.GetPosition(ref cursorStartPosition);
+
+                        //Vector3.Add(ref cursorStartPosition, ref direction, out cursorStartPosition);
+
+                        //cursorController.HitPhysicsObject.MainWorldTransform.SetPosition(ref cursorStartPosition);
+                        //cursorController.HitPhysicsObject.RecalculateMainTransform();
+                    }
+                }
+
+                if (cursorController.HitPhysicsObject.Integral.IsStatic && (cursorController.HitPhysicsObject.InternalControllers.FluidController != null) && cursorController.HitPhysicsObject.InternalControllers.FluidController.Enabled)
+                {
+                    Vector3 cursorStartPosition = vectorZero;
+                    Vector3 cursorEndPosition = vectorZero;
+
+                    cursorController.GetAnchor1(ref cursorStartPosition);
+                    cursorController.GetAnchor2(ref cursorEndPosition);
+
+                    Vector3.Subtract(ref cursorEndPosition, ref cursorStartPosition, out direction);
+
+                    if (direction.LengthSquared != 0.0f)
+                    {
+                        // To move the fluid surface by the cursor, add the following lines of code
+                        // and set EnableCursorInteraction flag to true in the Lake class
+
+                        //cursorController.HitPhysicsObject.MainWorldTransform.GetPosition(ref cursorStartPosition);
+
+                        //Vector3.Add(ref cursorStartPosition, ref direction, out cursorStartPosition);
+
+                        //cursorController.HitPhysicsObject.MainWorldTransform.SetPosition(ref cursorStartPosition);
+                        //cursorController.HitPhysicsObject.RecalculateMainTransform();
+                    }
+                }
+            }
+
+            objectBase.MainWorldTransform.GetPosition(ref listenerPosition);
+            objectBase.Camera.GetTransposeRotation(ref rotation);
+
+            Vector3.Multiply(ref listenerPosition, soundPositionFactor, out position);
+            listenerTopDirection.X = rotation.Row1.X;
+            listenerTopDirection.Y = rotation.Row1.Y;
+            listenerTopDirection.Z = rotation.Row1.Z;
+            listenerFrontDirection.X = rotation.Row2.X;
+            listenerFrontDirection.Y = rotation.Row2.Y;
+            listenerFrontDirection.Z = rotation.Row2.Z;
+
+            listener.Position = position;
+            listener.TopDirection = listenerTopDirection;
+            listener.FrontDirection = listenerFrontDirection;
+            listenerRange = objectBase.Sound.Range;
+
+            if (enableShot)
+            {
+                Vector3 shotScale, shotColor;
+
+                shotCount = (shotCount + 1) % shotTab.Length;
+                string shotCountName = shotCount.ToString();
+
+                PhysicsObject shot = scene.Factory.PhysicsObjectManager.FindOrCreate(shotName + shotCountName);
+                PhysicsObject shotBase = scene.Factory.PhysicsObjectManager.FindOrCreate(shotBaseName + shotCountName);
+                PhysicsObject shotLight = scene.Factory.PhysicsObjectManager.FindOrCreate(shotLightName + shotCountName);
+
+                shot.AddChildPhysicsObject(shotBase);
+                shot.AddChildPhysicsObject(shotLight);
+
+                shotTab[shotCount] = shotBase;
+                enableShotTab = true;
+
+                shotScale = shotColor = vectorZero;
+
+                shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+                Vector3.Multiply(ref rayDirection, 300.0f, out rayDirection);
+
+                shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot.InitLocalTransform.SetPosition(ref rayPosition);
+                shot.InitLocalTransform.SetLinearVelocity(ref rayDirection);
+                shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot.MaxSimulationFrameCount = 200;
+                shot.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+                //shot.EnableLocalGravity = true;
+
+                shotBase.Shape = sphere;
+                shotBase.UserDataStr = sphereName;
+                shotBase.InitLocalTransform.SetScale(ref shotScale);
+                shotBase.Integral.SetDensity(10.0f);
+                shotBase.Material.RigidGroup = true;
+                shotBase.EnableBreakRigidGroup = false;
+                shotBase.EnableCollisions = true;
+                shotBase.CreateSound(true);
+
+                if ((cameraUp != null) && (cameraBody != null) && (cameraDown != null))
+                {
+                    shotBase.DisableCollision(cameraUp, true);
+                    shotBase.DisableCollision(cameraBody, true);
+                    shotBase.DisableCollision(cameraDown, true);
+                    shotBase.MaxDisableCollisionFrameCount = 50;
+                }
+
+                shotLight.Shape = sphere;
+                shotLight.UserDataStr = sphereName;
+                shotLight.CreateLight(true);
+                shotLight.Light.Type = PhysicsLightType.Point;
+                shotLight.Light.Range = 20.0f;
+
+                shotColor.X = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Y = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Z = (float)Math.Max(random.NextDouble(), random.NextDouble());
+
+                shotLight.Light.SetDiffuse(ref shotColor);
+                shotLight.InitLocalTransform.SetScale(20.0f);
+                shotLight.Material.RigidGroup = true;
+                shotLight.Material.UserDataStr = yellowName;
+                shotLight.EnableBreakRigidGroup = false;
+                shotLight.EnableCollisions = false;
+                shotLight.EnableCursorInteraction = false;
+                shotLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                scene.UpdateFromInitLocalTransform(shot);
+
+                shotSoundGroup = demo.SoundGroups[hitName];
+                shotSoundGroup.MaxHitRepeatTime = 0.0f;
+
+                if (shotSound == null)
+                    shotSound = shotSoundGroup.GetSound(objectBase.Sound, listener, emitter);
+
+                shotSound.Update(time);
+
+                Vector3.Multiply(ref rayPosition, soundPositionFactor, out shotSound.HitPosition);
+                shotSound.HitVolume = 1.0f;
+
+                shotSound.FrontDirection.X = rotation.Row2.X;
+                shotSound.FrontDirection.Y = rotation.Row2.Y;
+                shotSound.FrontDirection.Z = rotation.Row2.Z;
+
+                demo.SoundQueue.EnqueueSound(shotSound);
+            }
+            else
+            {
+                PhysicsObject shotBase;
+                DemoSound shotBaseSound;
+
+                if (shotSound != null)
+                {
+                    shotSound.Update(time);
+
+                    if (shotSound.Stop())
+                    {
+                        shotSound.SoundGroup.SetSound(shotSound);
+                        shotSound = null;
+                    }
+                }
+
+                if (enableShotTab)
+                {
+                    enableShotTab = false;
+
+                    for (int i = 0; i < shotTab.Length; i++)
+                    {
+                        shotBase = shotTab[i];
+
+                        if (shotBase != null)
+                        {
+                            if (shotBase.Sound.UserDataObj != null)
+                            {
+                                enableShotTab = true;
+                                shotBaseSound = (DemoSound)shotBase.Sound.UserDataObj;
+                                shotBaseSound.Update(time);
+
+                                if (shotBaseSound.Stop())
+                                {
+                                    shotBaseSound.SoundGroup.SetSound(shotBaseSound);
+                                    shotBase.Sound.UserDataObj = null;
+                                    shotTab[i] = null;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            objectBase.Camera.UpdatePhysicsObjects(true, true, true);
+            objectBase.Camera.SortDrawPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortTransparentPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortLightPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+
+            PhysicsObject currentPhysicsObject;
+            PhysicsSound currentSound;
+            DemoSoundGroup soundGroup;
+            DemoSound sound;
+
+            if (demo.SoundQueue.SoundCount > 0)
+                return;
+
+            for (int i = 0; i < scene.TotalPhysicsObjectCount; i++)
+            {
+                if (demo.SoundQueue.SoundCount >= demo.SoundQueue.MaxSoundCount)
+                    break;
+
+                currentPhysicsObject = scene.GetPhysicsObject(i);
+
+                currentSound = !currentPhysicsObject.EnableSoundFromRigidGroupOwner ? currentPhysicsObject.Sound : currentPhysicsObject.RigidGroupOwner.Sound;
+
+                if (currentSound == null)
+                    continue;
+
+                if (!currentSound.Enabled)
+                    continue;
+
+                if (currentSound.UserDataStr == null)
+                    soundGroup = demo.SoundGroups[defaultName];
+                else
+                    soundGroup = demo.SoundGroups[currentSound.UserDataStr];
+
+                if (currentPhysicsObject.IsSleeping && (currentSound.UserDataObj == null) && !soundGroup.EnableBackground)
+                    continue;
+
+                if (currentPhysicsObject.GetSoundData(ref listenerPosition, listenerRange, soundGroup.EnableHit, soundGroup.EnableRoll, soundGroup.EnableSlide, soundGroup.EnableBackground, currentSound.BackgroundVolumeVelocityModulation, ref hitPosition, ref rollPosition, ref slidePosition, ref backgroundPosition, ref hitVolume, ref rollVolume, ref slideVolume, ref backgroundVolume))
+                {
+                    if (currentSound.UserDataObj == null)
+                    {
+                        sound = soundGroup.GetSound(currentSound, listener, emitter);
+                        currentSound.UserDataObj = sound;
+                    }
+                    else
+                    {
+                        sound = (DemoSound)currentSound.UserDataObj;
+                    }
+
+                    sound.Update(time);
+
+                    currentPhysicsObject.MainWorldTransform.GetTransposeRotation(ref rotation);
+
+                    Vector3.Multiply(ref hitPosition, soundPositionFactor, out sound.HitPosition);
+                    Vector3.Multiply(ref rollPosition, soundPositionFactor, out sound.RollPosition);
+                    Vector3.Multiply(ref slidePosition, soundPositionFactor, out sound.SlidePosition);
+                    Vector3.Multiply(ref backgroundPosition, soundPositionFactor, out sound.BackgroundPosition);
+
+                    sound.HitVolume = hitVolume;
+                    sound.RollVolume = rollVolume;
+                    sound.SlideVolume = slideVolume;
+                    sound.BackgroundVolume = backgroundVolume;
+
+                    sound.FrontDirection.X = rotation.Row2.X;
+                    sound.FrontDirection.Y = rotation.Row2.Y;
+                    sound.FrontDirection.Z = rotation.Row2.Z;
+
+                    demo.SoundQueue.EnqueueSound(sound);
+                }
+                else
+                {
+                    if (currentSound.UserDataObj != null)
+                    {
+                        sound = (DemoSound)currentSound.UserDataObj;
+                        sound.Update(time);
+
+                        if (sound.Stop())
+                        {
+                            soundGroup.SetSound(sound);
+                            currentSound.UserDataObj = null;
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera3Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera3Animation1.cs
new file mode 100644
index 0000000..eaab2ba
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Camera3Animation1.cs
@@ -0,0 +1,246 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera3Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string cursorName;
+        string shotName;
+
+        Shape sphere;
+
+        DemoMouseState oldMouseState;
+
+        Vector3 startPosition;
+        Vector3 step;
+        int stepCount;
+        int maxStepCount;
+
+        Vector3 position;
+        Matrix4 rotation;
+        Matrix4 cameraRotation;
+        Matrix4 projection;
+        Matrix4 view;
+
+        Vector2 mousePosition;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+
+        public Camera3Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            cursorName = "Cursor";
+            shotName = "Camera 3 Shot" + instanceIndexName + " ";
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            startPosition = Vector3.Zero;
+            step = Vector3.Zero;
+            stepCount = 0;
+            maxStepCount = 0;
+        }
+
+        public void SetControllers(Vector3 objectStep, int objectMaxStepCount)
+        {
+            step = objectStep;
+            maxStepCount = objectMaxStepCount;
+
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            stepCount = 0;
+
+            oldMouseState = demo.GetMouseState();
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 3" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                objectBase.Camera.Active = false;
+
+                objectBase.UserControllers.TransformMethods += new SimulateMethod(MoveCursor);
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            stepCount = 0;
+
+            oldMouseState = demo.GetMouseState();
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 3" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.Camera.Active = false;
+        }
+
+        public void MoveCursor(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            ScreenToRayController screenToRayController = objectBase.InternalControllers.ScreenToRayController;
+            screenToRayController.SetViewport(0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f);
+            screenToRayController.SetViewMatrix(ref view);
+            screenToRayController.SetProjectionMatrix(ref projection);
+            screenToRayController.SetScreenPosition(ref mousePosition);
+            screenToRayController.MouseButton = true;
+            screenToRayController.Update();
+        }
+
+        void Move(SimulateMethodArgs args)
+        {
+            Vector3 cameraPosition;
+
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+
+            if (!objectBase.Camera.Active)
+            {
+                objectBase.InitLocalTransform.GetPosition(ref startPosition);
+                Vector3.Multiply(ref step, stepCount, out cameraPosition);
+                Vector3.Add(ref cameraPosition, ref startPosition, out cameraPosition);
+
+                if (stepCount <= maxStepCount)
+                {
+                    objectBase.MainWorldTransform.SetPosition(ref cameraPosition);
+                    objectBase.RecalculateMainTransform();
+                    stepCount++;
+                }
+                else
+                    objectBase.Camera.Active = true;
+            }
+
+            float time = (float)args.Time;
+
+            bool enableShot = false;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+
+            if (mouseState[MouseButton.Left] && !oldMouseState[MouseButton.Left])
+                enableShot = true;
+
+            mousePosition.X = mouseState.X;
+            mousePosition.Y = mouseState.Y;
+
+            oldMouseState = mouseState;
+
+            objectBase.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectBase.MainWorldTransform.GetPosition(ref position);
+            objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectBase.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectBase.Camera.UpdateFrustum();
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            Vector3 rayPosition, rayDirection;
+
+            rayPosition = rayDirection = vectorZero;
+
+            objectBase.UnProjectToRay(ref mousePosition, 0, 0, demo.WindowWidth, demo.WindowHeight, 0.0f, 1.0f, ref view, ref matrixIdentity, ref projection, ref rayPosition, ref rayDirection);
+
+            PhysicsObject cursor = scene.Factory.PhysicsObjectManager.Find(cursorName);
+
+            if (cursor != null)
+            {
+                Vector3 cursorPosition = vectorZero;
+                Matrix4 cursorLocalRotation = matrixIdentity;
+                Matrix4 cursorWorldRotation = matrixIdentity;
+
+                cursor.InitLocalTransform.GetPosition(ref cursorPosition);
+                cursor.InitLocalTransform.GetRotation(ref cursorLocalRotation);
+                cursor.MainWorldTransform.GetRotation(ref cursorWorldRotation);
+
+                objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+                Matrix4.Mult(ref cursorLocalRotation, ref cameraRotation, out rotation);
+
+                Vector3.TransformVector(ref cursorPosition, ref cursorWorldRotation, out position);
+
+                cursor.MainWorldTransform.SetRotation(ref rotation);
+                Vector3.Add(ref position, ref rayPosition, out position);
+                Vector3.Add(ref position, ref rayDirection, out position);
+                cursor.MainWorldTransform.SetPosition(ref position);
+            }
+
+            if (enableShot)
+            {
+                PhysicsObject shot = scene.Factory.PhysicsObjectManager.Create(shotName + scene.SimulationFrameCount.ToString());
+
+                shot.Shape = sphere;
+                shot.UserDataStr = sphereName;
+
+                Vector3 shotScale = vectorZero;
+                shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+
+                Vector3.Multiply(ref rayDirection, 1000.0f, out rayDirection);
+
+                shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot.InitLocalTransform.SetPosition(ref rayPosition);
+                shot.InitLocalTransform.SetScale(ref shotScale);
+
+                shot.InitLocalTransform.SetLinearVelocity(ref rayDirection);
+                shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot.Integral.SetDensity(10.0f);
+                shot.MaxSimulationFrameCount = 10;
+                shot.EnableCursorInteraction = false;
+                shot.EnableCollisionResponse = false;
+                shot.EnableDrawing = false;
+                shot.EnableCollisions = true;
+                shot.DisableCollision(objectBase, true);
+                shot.MaxDisableCollisionFrameCount = 10;
+
+                scene.UpdateFromInitLocalTransform(shot);
+            }
+
+            objectBase.Camera.UpdatePhysicsObjects(true, true, true);
+            objectBase.Camera.SortDrawPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortTransparentPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Car1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Car1Animation1.cs
new file mode 100644
index 0000000..b461526
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Car1Animation1.cs
@@ -0,0 +1,661 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Car1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string cameraBodyName;
+        string cameraDownName;
+        string cameraConstraintName;
+
+        PhysicsObject steeringGearSwitch;
+        PhysicsObject steeringGearDown;
+        PhysicsObject chassisUpPanel;
+        PhysicsObject chassisDownPanel;
+
+        PhysicsObject steeringWheel;
+        PhysicsObject chassisBack;
+
+        PhysicsObject wheel1;
+        PhysicsObject wheel2;
+
+        Constraint steeringGearConstraint;
+        Constraint constraint1;
+        Constraint constraint4;
+
+        Constraint rightDoorConstraint;
+        PhysicsObject rightDoorBody;
+
+        Constraint leftDoorConstraint;
+        PhysicsObject leftDoorBody;
+
+        PhysicsObject chassisMiddleDown;
+        PhysicsObject chassisMiddleFront;
+        PhysicsObject chassisMiddleBack;
+        PhysicsObject upBodyFront;
+        PhysicsObject upBodyDownBack;
+
+        DemoKeyboardState oldKeyboardState;
+
+        double totalSwitchRightTime;
+        double totalSwitchLeftTime;
+        bool enableExternalMoving;
+
+        float maxSwitchRightTime;
+        float maxSwitchLeftTime;
+        Vector3 driverLocalPosition;
+
+        Vector3 position;
+        Matrix4 rotation;
+        Vector3 torque;
+        Vector3 velocity;
+        Quaternion objectOrientation;
+        Matrix4 objectRotation;
+        Matrix4 objectInitRotation;
+
+        Vector3 position1;
+        Quaternion orientation1;
+        Quaternion orientation2;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+        Vector3 unitY;
+
+        public Car1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            cameraBodyName = "Camera 2 Body";
+            cameraDownName = "Camera 2 Down";
+            cameraConstraintName = "Car 1 Camera Constraint" + instanceIndexName;
+
+            maxSwitchRightTime = 10.0f;
+            maxSwitchLeftTime = 10.0f;
+            driverLocalPosition = new Vector3(2.0f, 4.3f, 0.7f);
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+            unitY = Vector3.UnitY;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers(bool enableExternalMoving)
+        {
+            steeringGearSwitch = scene.Factory.PhysicsObjectManager.Find("Car 1 Steering Gear Switch" + instanceIndexName);
+            steeringGearDown = scene.Factory.PhysicsObjectManager.Find("Car 1 Steering Gear Down" + instanceIndexName);
+            chassisUpPanel = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Up Panel" + instanceIndexName);
+            chassisDownPanel = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Down Panel" + instanceIndexName);
+
+            steeringWheel = scene.Factory.PhysicsObjectManager.Find("Car 1 Steering Wheel" + instanceIndexName);
+            chassisBack = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Back" + instanceIndexName);
+
+            wheel1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 1" + instanceIndexName);
+            wheel2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 2" + instanceIndexName);
+
+            steeringGearConstraint = scene.Factory.ConstraintManager.Find("Car 1 Steering Gear Constraint" + instanceIndexName);
+            constraint1 = scene.Factory.ConstraintManager.Find("Car 1 Constraint 1" + instanceIndexName);
+            constraint4 = scene.Factory.ConstraintManager.Find("Car 1 Constraint 4" + instanceIndexName);
+
+            rightDoorConstraint = scene.Factory.ConstraintManager.Find("Car 1 Right Door Constraint" + instanceIndexName);
+            rightDoorBody = scene.Factory.PhysicsObjectManager.Find("Car 1 Right Door Body" + instanceIndexName);
+
+            leftDoorConstraint = scene.Factory.ConstraintManager.Find("Car 1 Left Door Constraint" + instanceIndexName);
+            leftDoorBody = scene.Factory.PhysicsObjectManager.Find("Car 1 Left Door Body" + instanceIndexName);
+
+            chassisMiddleDown = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Down" + instanceIndexName);
+            chassisMiddleFront = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Front" + instanceIndexName);
+            chassisMiddleBack = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Back" + instanceIndexName);
+            upBodyFront = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Front" + instanceIndexName);
+            upBodyDownBack = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Back" + instanceIndexName);
+
+            oldKeyboardState = demo.GetKeyboardState();
+            this.enableExternalMoving = enableExternalMoving;
+
+            totalSwitchLeftTime = 2.0f * maxSwitchLeftTime;
+            totalSwitchRightTime = 2.0f * maxSwitchRightTime;
+
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Left Door Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchLeft);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Right Door Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchRight);
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsObject cameraBody = physicsObjectWithActiveCamera.RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+            PhysicsObject cameraDown = physicsObjectWithActiveCamera.RigidGroupOwner.FindChildPhysicsObject(cameraDownName, true, true);
+
+            if ((chassisMiddleDown == null) || (steeringGearSwitch == null)) return;
+
+            Constraint CameraConstraint = objectBase.Scene.Factory.ConstraintManager.Find(cameraConstraintName);
+
+            bool steeringGearWorking = true;
+
+            if (steeringGearConstraint != null)
+            {
+                if (steeringGearConstraint.PhysicsObject1 != null)
+                    if (steeringGearConstraint.PhysicsObject1.IsBrokenRigidGroup || steeringGearConstraint.IsBroken)
+                        steeringGearWorking = false;
+
+                if (steeringGearConstraint.PhysicsObject2 != null)
+                    if (steeringGearConstraint.PhysicsObject2.IsBrokenRigidGroup || steeringGearConstraint.IsBroken)
+                        steeringGearWorking = false;
+            }
+            else
+            {
+                steeringGearWorking = false;
+            }
+
+            if (!steeringGearWorking)
+            {
+                steeringGearDown.DisableCollision(chassisUpPanel, false);
+                steeringGearDown.DisableCollision(chassisDownPanel, false);
+                steeringGearDown.DisableCollision(upBodyFront, false);
+                steeringGearDown.DisableCollision(upBodyDownBack, false);
+            }
+
+            if (objectBase.IsBrokenRigidGroup || !steeringGearWorking)
+            {
+                if ((CameraConstraint != null) && (CameraConstraint.PhysicsObject1 == cameraDown))
+                {
+                    objectBase.Scene.Factory.ConstraintManager.Remove(CameraConstraint);
+                    physicsObjectWithActiveCamera.Camera.EnableControl = false;
+
+                    cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 0.0f;
+                    cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 0.0f;
+
+                    cameraDown.DisableCollision(steeringWheel, false);
+                    cameraDown.DisableCollision(chassisBack, false);
+                    cameraDown.DisableCollision(chassisMiddleBack, false);
+                    cameraDown.DisableCollision(upBodyFront, false);
+                    cameraDown.DisableCollision(upBodyDownBack, false);
+
+                    cameraBody.DisableCollision(steeringGearDown, false);
+                    cameraBody.DisableCollision(steeringWheel, false);
+                    cameraBody.DisableCollision(chassisBack, false);
+                    cameraBody.DisableCollision(chassisMiddleBack, false);
+                    cameraBody.DisableCollision(upBodyFront, false);
+                    cameraBody.DisableCollision(upBodyDownBack, false);
+
+                    Vector3 euler = vectorZero;
+                    Vector3 cameraEuler = vectorZero;
+                    Vector3 objectEuler = vectorZero;
+
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref cameraEuler);
+                    physicsObjectWithActiveCamera.MainWorldTransform.GetTransposeRotation(ref objectRotation);
+                    physicsObjectWithActiveCamera.InitLocalTransform.GetRotation(ref objectInitRotation);
+                    Matrix4.Mult(ref objectRotation, ref objectInitRotation, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref objectEuler);
+                    Vector3.Add(ref objectEuler, ref cameraEuler, out euler);
+
+                    Matrix4 rotationX, rotationY;
+                    Matrix4.CreateRotationX(-euler.X, out rotationX);
+                    Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                    Matrix4.Mult(ref rotationY, ref rotationX, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref euler);
+                    physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+
+                    Matrix4.CreateRotationY(euler.Y, out rotation);
+
+                    physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                    physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+                }
+
+                return;
+            }
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (physicsObjectWithActiveCamera.Camera.EnableControl && (CameraConstraint != null) && (CameraConstraint.PhysicsObject1 == cameraDown))
+            {
+                if (keyboardState[Key.Space] && !oldKeyboardState[Key.Space])
+                {
+                    objectBase.Scene.Factory.ConstraintManager.Remove(CameraConstraint);
+                    physicsObjectWithActiveCamera.Camera.EnableControl = false;
+
+                    cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 0.0f;
+                    cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 0.0f;
+
+                    cameraDown.DisableCollision(steeringWheel, false);
+                    cameraDown.DisableCollision(chassisBack, false);
+                    cameraDown.DisableCollision(chassisMiddleBack, false);
+                    cameraDown.DisableCollision(upBodyFront, false);
+                    cameraDown.DisableCollision(upBodyDownBack, false);
+
+                    cameraBody.DisableCollision(steeringGearDown, false);
+                    cameraBody.DisableCollision(steeringWheel, false);
+                    cameraBody.DisableCollision(chassisBack, false);
+                    cameraBody.DisableCollision(chassisMiddleBack, false);
+                    cameraBody.DisableCollision(upBodyFront, false);
+                    cameraBody.DisableCollision(upBodyDownBack, false);
+
+                    Vector3 euler = vectorZero;
+                    Vector3 cameraEuler = vectorZero;
+                    Vector3 objectEuler = vectorZero;
+
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref cameraEuler);
+                    physicsObjectWithActiveCamera.MainWorldTransform.GetTransposeRotation(ref objectRotation);
+                    physicsObjectWithActiveCamera.InitLocalTransform.GetRotation(ref objectInitRotation);
+                    Matrix4.Mult(ref objectRotation, ref objectInitRotation, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+                    physicsObjectWithActiveCamera.Camera.GetEuler(ref objectEuler);
+                    Vector3.Add(ref objectEuler, ref cameraEuler, out euler);
+                    euler.Z = 0.0f;
+
+                    Matrix4 rotationX, rotationY;
+                    Matrix4.CreateRotationX(-euler.X, out rotationX);
+                    Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                    Matrix4.Mult(ref rotationY, ref rotationX, out rotation);
+
+                    physicsObjectWithActiveCamera.Camera.SetEuler(ref euler);
+                    physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+
+                    Matrix4.CreateRotationY(euler.Y, out rotation);
+
+                    physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                    physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+
+                    oldKeyboardState = keyboardState;
+
+                    return;
+                }
+
+                if (keyboardState[Key.W])
+                {
+                    if (wheel1 != null)
+                    {
+                        Vector3.Multiply(ref unitY, 5.0f, out velocity);
+
+                        wheel1.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                    }
+
+                    if (wheel2 != null)
+                    {
+                        Vector3.Multiply(ref unitY, 5.0f, out velocity);
+
+                        wheel2.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                    }
+                }
+
+                if (keyboardState[Key.S])
+                {
+                    if (wheel1 != null)
+                    {
+                        Vector3.Multiply(ref unitY, -5.0f, out velocity);
+
+                        wheel1.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                    }
+
+                    if (wheel2 != null)
+                    {
+                        Vector3.Multiply(ref unitY, -5.0f, out velocity);
+
+                        wheel2.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                    }
+                }
+
+                if (keyboardState[Key.D])
+                {
+                    if (steeringGearConstraint != null)
+                        steeringGearConstraint.ControlDegAngleY -= 2.0f;
+
+                    if (constraint1 != null)
+                        constraint1.ControlDegAngleY += 1.0f;
+
+                    if (constraint4 != null)
+                        constraint4.ControlDegAngleY += 1.0f;
+                }
+
+                if (keyboardState[Key.A])
+                {
+                    if (steeringGearConstraint != null)
+                        steeringGearConstraint.ControlDegAngleY += 2.0f;
+
+                    if (constraint1 != null)
+                        constraint1.ControlDegAngleY -= 1.0f;
+
+                    if (constraint4 != null)
+                        constraint4.ControlDegAngleY -= 1.0f;
+                }
+            }
+            else
+            {
+                if ((cameraBody != null) && steeringGearSwitch.IsColliding(cameraBody))
+                {
+                    if (keyboardState[Key.Space] && !oldKeyboardState[Key.Space])
+                    {
+                        physicsObjectWithActiveCamera.Camera.EnableControl = true;
+
+                        cameraDown.RigidGroupOwner.MaxPreUpdateAngularVelocity = 1000.0f;
+                        cameraDown.RigidGroupOwner.MaxPostUpdateAngularVelocity = 1000.0f;
+
+                        cameraDown.DisableCollision(steeringWheel, true);
+                        cameraDown.DisableCollision(chassisBack, true);
+                        cameraDown.DisableCollision(chassisMiddleBack, true);
+                        cameraDown.DisableCollision(upBodyFront, true);
+                        cameraDown.DisableCollision(upBodyDownBack, true);
+
+                        cameraBody.DisableCollision(steeringGearDown, true);
+                        cameraBody.DisableCollision(steeringWheel, true);
+                        cameraBody.DisableCollision(chassisBack, true);
+                        cameraBody.DisableCollision(chassisMiddleBack, true);
+                        cameraBody.DisableCollision(upBodyFront, true);
+                        cameraBody.DisableCollision(upBodyDownBack, true);
+
+                        Quaternion cameraOrientationX = quaternionIdentity;
+                        Quaternion cameraOrientationY = quaternionIdentity;
+                        Quaternion cameraOrientationZ = quaternionIdentity;
+                        Quaternion cameraOrientationXY = quaternionIdentity;
+                        Quaternion cameraOrientation = quaternionIdentity;
+
+                        Quaternion.Multiply(ref cameraOrientationX, ref cameraOrientationY, out cameraOrientationXY);
+                        Quaternion.Multiply(ref cameraOrientationXY, ref cameraOrientationZ, out cameraOrientation);
+                        rotation = Matrix4.CreateFromQuaternion(cameraOrientation);
+
+                        physicsObjectWithActiveCamera.Camera.SetOrientation(ref cameraOrientation);
+                        physicsObjectWithActiveCamera.Camera.SetRotation(ref rotation);
+                        physicsObjectWithActiveCamera.Camera.SetEuler(ref rotation);
+
+                        objectOrientation = Quaternion.FromAxisAngle(unitY, MathHelper.DegreesToRadians(180.0f));
+                        objectRotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+                        Vector3 carChassisPosition = vectorZero;
+                        Matrix4 carChassisRotation = matrixIdentity;
+
+                        chassisMiddleDown.MainWorldTransform.GetPosition(ref carChassisPosition);
+                        chassisMiddleDown.MainWorldTransform.GetRotation(ref carChassisRotation);
+
+                        Matrix4.Mult(ref objectRotation, ref carChassisRotation, out rotation);
+
+                        Vector3.TransformVector(ref driverLocalPosition, ref carChassisRotation, out position);
+                        Vector3.Add(ref carChassisPosition, ref position, out position);
+
+                        physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetRotation(ref rotation);
+                        physicsObjectWithActiveCamera.RigidGroupOwner.MainWorldTransform.SetPosition(ref position);
+                        physicsObjectWithActiveCamera.RigidGroupOwner.RecalculateMainTransform();
+
+                        if (CameraConstraint == null)
+                        {
+                            CameraConstraint = scene.Factory.ConstraintManager.Create(cameraConstraintName);
+                            CameraConstraint.PhysicsObject1 = cameraDown;
+                            CameraConstraint.PhysicsObject2 = chassisMiddleDown;
+                            CameraConstraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                            CameraConstraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                            CameraConstraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+
+                            carChassisPosition.X = carChassisPosition.Z = 0.0f;
+                            carChassisPosition.Y = 2.0f;
+                            Vector3.Subtract(ref position1, ref carChassisPosition, out position1);
+
+                            CameraConstraint.SetAnchor1(ref position1);
+                            CameraConstraint.SetAnchor2(ref position1);
+                            CameraConstraint.SetInitWorldOrientation1(ref orientation1);
+                            CameraConstraint.SetInitWorldOrientation2(ref orientation2);
+                            CameraConstraint.EnableLimitAngleX = true;
+                            CameraConstraint.EnableLimitAngleY = true;
+                            CameraConstraint.EnableLimitAngleZ = true;
+                            CameraConstraint.LimitAngleForce = 0.4f;
+                            CameraConstraint.MinResponseLinearVelocity = 0.005f;
+                            CameraConstraint.MinResponseAngularVelocity = 0.005f;
+                            CameraConstraint.Update();
+                        }
+                    }
+                }
+
+                if (enableExternalMoving)
+                {
+                    if (keyboardState[Key.Up])
+                    {
+                        if (wheel1 != null)
+                        {
+                            Vector3.Multiply(ref unitY, 5.0f, out velocity);
+
+                            wheel1.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                        }
+
+                        if (wheel2 != null)
+                        {
+                            Vector3.Multiply(ref unitY, 5.0f, out velocity);
+
+                            wheel2.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                        }
+                    }
+
+                    if (keyboardState[Key.Down])
+                    {
+                        if (wheel1 != null)
+                        {
+                            Vector3.Multiply(ref unitY, -5.0f, out velocity);
+
+                            wheel1.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                        }
+
+                        if (wheel2 != null)
+                        {
+                            Vector3.Multiply(ref unitY, -5.0f, out velocity);
+
+                            wheel2.MainWorldTransform.AddLocalAngularVelocity(ref velocity);
+                        }
+                    }
+
+                    if (keyboardState[Key.Right])
+                    {
+                        if (steeringGearConstraint != null)
+                            steeringGearConstraint.ControlDegAngleY -= 2.0f;
+
+                        if (constraint1 != null)
+                            constraint1.ControlDegAngleY += 1.0f;
+
+                        if (constraint4 != null)
+                            constraint4.ControlDegAngleY += 1.0f;
+                    }
+
+                    if (keyboardState[Key.Left])
+                    {
+                        if (steeringGearConstraint != null)
+                            steeringGearConstraint.ControlDegAngleY += 2.0f;
+
+                        if (constraint1 != null)
+                            constraint1.ControlDegAngleY -= 1.0f;
+
+                        if (constraint4 != null)
+                            constraint4.ControlDegAngleY -= 1.0f;
+                    }
+                }
+            }
+
+            oldKeyboardState = keyboardState;
+        }
+
+        public void SwitchRight(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (rightDoorConstraint.IsBroken || rightDoorConstraint.PhysicsObject1.IsBrokenRigidGroup || rightDoorConstraint.PhysicsObject2.IsBrokenRigidGroup)
+            {
+                rightDoorConstraint.EnableControlAngleY = false;
+
+                rightDoorBody.DisableCollision(chassisMiddleDown, false);
+                rightDoorBody.DisableCollision(chassisMiddleFront, false);
+                rightDoorBody.DisableCollision(chassisMiddleBack, false);
+                rightDoorBody.DisableCollision(upBodyFront, false);
+                rightDoorBody.DisableCollision(upBodyDownBack, false);
+
+                return;
+            }
+
+            PhysicsObject cameraBody = scene.GetPhysicsObjectWithActiveCamera(0).RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+
+            if (cameraBody == null)
+            {
+                rightDoorConstraint.EnableControlAngleY = true;
+                return;
+            }
+
+            bool switchColliding = objectBase.IsColliding(cameraBody);
+            bool doorColliding = objectBase.RigidGroupOwner.IsColliding(cameraBody);
+
+            if (switchColliding)
+            {
+                totalSwitchRightTime = 0.0;
+                rightDoorConstraint.EnableControlAngleY = false;
+            }
+
+            if (totalSwitchRightTime < maxSwitchRightTime)
+            {
+                Vector3.Multiply(ref unitY, 2000.0f, out torque);
+
+                objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+            }
+            else
+                if (totalSwitchRightTime < 2.0f * maxSwitchRightTime)
+                {
+                    if (!doorColliding)
+                    {
+                        Vector3.Multiply(ref unitY, -2000.0f, out torque);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+                    }
+                    else
+                    {
+                        totalSwitchRightTime = 0.0;
+                    }
+                }
+                else
+                    if (!doorColliding)
+                    {
+                        rightDoorConstraint.EnableControlAngleY = true;
+                    }
+                    else
+                    {
+                        totalSwitchRightTime = 0.0;
+                    }
+
+            totalSwitchRightTime += time;
+
+            if (totalSwitchRightTime > 2.0f * maxSwitchRightTime)
+                totalSwitchRightTime = 2.0f * maxSwitchRightTime;
+        }
+
+        public void SwitchLeft(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (leftDoorConstraint.IsBroken || leftDoorConstraint.PhysicsObject1.IsBrokenRigidGroup || leftDoorConstraint.PhysicsObject2.IsBrokenRigidGroup)
+            {
+                leftDoorConstraint.EnableControlAngleY = false;
+
+                leftDoorBody.DisableCollision(chassisMiddleDown, false);
+                leftDoorBody.DisableCollision(chassisMiddleFront, false);
+                leftDoorBody.DisableCollision(chassisMiddleBack, false);
+                leftDoorBody.DisableCollision(upBodyFront, false);
+                leftDoorBody.DisableCollision(upBodyDownBack, false);
+
+                return;
+            }
+
+            PhysicsObject cameraBody = scene.GetPhysicsObjectWithActiveCamera(0).RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+
+            if (cameraBody == null)
+            {
+                leftDoorConstraint.EnableControlAngleY = true;
+                return;
+            }
+
+            bool switchColliding = objectBase.IsColliding(cameraBody);
+            bool doorColliding = objectBase.RigidGroupOwner.IsColliding(cameraBody);
+
+            if (switchColliding)
+            {
+                totalSwitchLeftTime = 0.0;
+                leftDoorConstraint.EnableControlAngleY = false;
+            }
+
+            if (totalSwitchLeftTime < maxSwitchLeftTime)
+            {
+                Vector3.Multiply(ref unitY, -2000.0f, out torque);
+
+                objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+            }
+            else
+                if (totalSwitchLeftTime < 2.0f * maxSwitchLeftTime)
+                {
+                    if (!doorColliding)
+                    {
+                        Vector3.Multiply(ref unitY, 2000.0f, out torque);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+                    }
+                    else
+                    {
+                        totalSwitchLeftTime = 0.0;
+                    }
+                }
+                else
+                    if (!doorColliding)
+                    {
+                        leftDoorConstraint.EnableControlAngleY = true;
+                    }
+                    else
+                    {
+                        totalSwitchLeftTime = 0.0;
+                    }
+
+            totalSwitchLeftTime += time;
+
+            if (totalSwitchLeftTime > 2.0f * maxSwitchLeftTime)
+                totalSwitchLeftTime = 2.0f * maxSwitchLeftTime;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/CargoJackAnimation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/CargoJackAnimation1.cs
new file mode 100644
index 0000000..bf85117
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/CargoJackAnimation1.cs
@@ -0,0 +1,199 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class CargoJackAnimation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        Constraint constraint1;
+        Constraint constraint2;
+        Constraint constraint3;
+
+        PhysicsObject body;
+        PhysicsObject panel;
+        PhysicsObject panelButton;
+        PhysicsObject panelLight;
+
+        bool enableRun;
+        bool flipRotation;
+
+        float distanceSpeed;
+        float rotationSpeed;
+
+        float maxDistance;
+        float maxAngle;
+
+        int frameCount;
+        int maxFrameCount;
+        bool flipLight;
+
+        public CargoJackAnimation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            distanceSpeed = 0.02f;
+            rotationSpeed = 0.2f;
+
+            maxDistance = 9.0f;
+            maxAngle = 180.0f;
+
+            maxFrameCount = 25;
+            flipLight = true;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            constraint1 = scene.Factory.ConstraintManager.Find("Cargo Jack Constraint 1" + instanceIndexName);
+            constraint2 = scene.Factory.ConstraintManager.Find("Cargo Jack Constraint 2" + instanceIndexName);
+            constraint3 = scene.Factory.ConstraintManager.Find("Cargo Jack Constraint 3" + instanceIndexName);
+            body = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Body" + instanceIndexName);
+            panel = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Panel" + instanceIndexName);
+            panelButton = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Panel Button" + instanceIndexName);
+            panelLight = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Panel Button Light" + instanceIndexName);
+
+            if (constraint3 != null)
+                constraint3.MaxLimitDistanceY = maxDistance;
+
+            enableRun = false;
+            flipRotation = false;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Panel Button Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.CollisionMethods += new CollisionMethod(Run);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Body Motor" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Transport);
+        }
+
+        void Run(CollisionMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if ((constraint1 == null) || (panel == null) || constraint1.IsBroken || panel.IsBrokenRigidGroup) return;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if ((physicsObjectWithActiveCamera == null) || !physicsObjectWithActiveCamera.RigidGroupOwner.IsColliding(objectBase)) return;
+
+            if (!enableRun)
+            {
+                enableRun = true;
+
+                if ((constraint2 != null) && (constraint2.ControlDegAngleY >= 180.0f))
+                    flipRotation = true;
+                else
+                    flipRotation = false;
+            }
+        }
+
+        void Transport(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (panelButton != null)
+            {
+                if ((constraint1 != null) && (constraint2 != null) && (constraint3 != null) && (body != null) && (panel != null) && !constraint1.IsBroken && !constraint2.IsBroken && !constraint3.IsBroken && !body.IsBrokenRigidGroup && !panel.IsBrokenRigidGroup)
+                {
+                    if (enableRun)
+                    {
+                        panelButton.Material.SetAmbient(0.7f, 0.4f, 0.4f);
+                        panelButton.Material.SetDiffuse(1.0f, 0.4f, 0.4f);
+                        if ((panelLight != null) && (panelLight.Light != null))
+                        {
+                            panelLight.Light.SetDiffuse(1.0f, 0.2f, 0.2f);
+
+                            frameCount = (frameCount + 1) % maxFrameCount;
+
+                            if (frameCount == 0)
+                                flipLight = !flipLight;
+
+                            if (flipLight)
+                                panelLight.Light.Intensity = 1.0f;
+                            else
+                                panelLight.Light.Intensity = 0.2f;
+                        }
+                    }
+                    else
+                    {
+                        panelButton.Material.SetAmbient(0.4f, 0.7f, 0.4f);
+                        panelButton.Material.SetDiffuse(0.4f, 1.0f, 0.4f);
+                        if ((panelLight != null) && (panelLight.Light != null))
+                        {
+                            panelLight.Light.SetDiffuse(0.2f, 1.0f, 0.2f);
+                            panelLight.Light.Intensity = 1.0f;
+                        }
+                    }
+                }
+                else
+                {
+                    panelButton.Material.SetAmbient(0.4f, 0.7f, 0.4f);
+                    panelButton.Material.SetDiffuse(0.4f, 1.0f, 0.4f);
+                    if ((panelLight != null) && (panelLight.Light != null))
+                        panelLight.Light.Enabled = false;
+                }
+            }
+
+            if (!enableRun) return;
+
+            if ((constraint2 == null) || (constraint3 == null) || (body == null) || constraint2.IsBroken || constraint3.IsBroken || body.IsBrokenRigidGroup) return;
+
+            if (!flipRotation)
+            {
+                if ((constraint3.ControlDistanceY < constraint3.MaxLimitDistanceY) && (constraint2.ControlDegAngleY <= 0.0))
+                    constraint3.ControlDistanceY += distanceSpeed;
+
+                if ((constraint3.ControlDistanceY > constraint3.MinLimitDistanceY) && (constraint2.ControlDegAngleY >= maxAngle))
+                    constraint3.ControlDistanceY -= distanceSpeed;
+
+                if ((constraint2.ControlDegAngleY < maxAngle) && (constraint3.ControlDistanceY >= constraint3.MaxLimitDistanceY))
+                    constraint2.ControlDegAngleY += rotationSpeed;
+
+                if (constraint3.ControlDistanceY <= constraint3.MinLimitDistanceY)
+                    enableRun = false;
+            }
+            else
+            {
+                if ((constraint3.ControlDistanceY < constraint3.MaxLimitDistanceY) && (constraint2.ControlDegAngleY >= maxAngle))
+                    constraint3.ControlDistanceY += distanceSpeed;
+
+                if ((constraint3.ControlDistanceY > constraint3.MinLimitDistanceY) && (constraint2.ControlDegAngleY <= 0.0f))
+                    constraint3.ControlDistanceY -= distanceSpeed;
+
+                if ((constraint2.ControlDegAngleY > 0.0f) && (constraint3.ControlDistanceY >= constraint3.MaxLimitDistanceY))
+                    constraint2.ControlDegAngleY -= rotationSpeed;
+
+                if (constraint3.ControlDistanceY <= constraint3.MinLimitDistanceY)
+                    enableRun = false;
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Crab1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Crab1Animation1.cs
new file mode 100644
index 0000000..21b0bee
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Crab1Animation1.cs
@@ -0,0 +1,852 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Crab1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        Constraint rightLimbFront1Constraint;
+        Constraint rightLimbFront2Constraint;
+        Constraint rightLimbFront3Constraint;
+        Constraint rightLimbMiddleFront1Constraint;
+        Constraint rightLimbMiddleFront2Constraint;
+        Constraint rightLimbMiddleFront3Constraint;
+        Constraint rightLimbMiddleBack1Constraint;
+        Constraint rightLimbMiddleBack2Constraint;
+        Constraint rightLimbMiddleBack3Constraint;
+        Constraint rightLimbBack1Constraint;
+        Constraint rightLimbBack2Constraint;
+        Constraint rightLimbBack3Constraint;
+        Constraint leftLimbFront1Constraint;
+        Constraint leftLimbFront2Constraint;
+        Constraint leftLimbFront3Constraint;
+        Constraint leftLimbMiddleFront1Constraint;
+        Constraint leftLimbMiddleFront2Constraint;
+        Constraint leftLimbMiddleFront3Constraint;
+        Constraint leftLimbMiddleBack1Constraint;
+        Constraint leftLimbMiddleBack2Constraint;
+        Constraint leftLimbMiddleBack3Constraint;
+        Constraint leftLimbBack1Constraint;
+        Constraint leftLimbBack2Constraint;
+        Constraint leftLimbBack3Constraint;
+
+        Vector3 scale;
+
+        bool moveUp;
+
+        float maxUp1AngleX;
+        float maxUp2AngleX;
+        float maxUp3AngleX;
+
+        float maxUpFrontAngleY;
+        float maxUpMiddleFrontAngleY;
+        float maxUpMiddleBackAngleY;
+        float maxUpBackAngleY;
+
+        float maxAhead1AngleY;
+        float maxAhead2AngleY;
+        float maxAhead3AngleY;
+        float maxAhead4AngleY;
+        float maxAhead5AngleY;
+
+        float rightFront1AngleYStep;
+        float rightFront1AngleXStep;
+        float rightFront2AngleXStep;
+        float rightFront3AngleXStep;
+
+        float rightMiddleFront1AngleYStep;
+        float rightMiddleFront1AngleXStep;
+        float rightMiddleFront2AngleXStep;
+        float rightMiddleFront3AngleXStep;
+
+        float rightMiddleBack1AngleYStep;
+        float rightMiddleBack1AngleXStep;
+        float rightMiddleBack2AngleXStep;
+        float rightMiddleBack3AngleXStep;
+
+        float rightBack1AngleYStep;
+        float rightBack1AngleXStep;
+        float rightBack2AngleXStep;
+        float rightBack3AngleXStep;
+
+        float leftFront1AngleYStep;
+        float leftFront1AngleXStep;
+        float leftFront2AngleXStep;
+        float leftFront3AngleXStep;
+
+        float leftMiddleFront1AngleYStep;
+        float leftMiddleFront1AngleXStep;
+        float leftMiddleFront2AngleXStep;
+        float leftMiddleFront3AngleXStep;
+
+        float leftMiddleBack1AngleYStep;
+        float leftMiddleBack1AngleXStep;
+        float leftMiddleBack2AngleXStep;
+        float leftMiddleBack3AngleXStep;
+
+        float leftBack1AngleYStep;
+        float leftBack1AngleXStep;
+        float leftBack2AngleXStep;
+        float leftBack3AngleXStep;
+
+        public Crab1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            moveUp = true;
+
+            maxUp1AngleX = 10.0f;
+            maxUp2AngleX = 30.0f;
+            maxUp3AngleX = 30.0f;
+
+            maxUpFrontAngleY = 60.0f;
+            maxUpMiddleFrontAngleY = 20.0f;
+            maxUpMiddleBackAngleY = -20.0f;
+            maxUpBackAngleY = -40.0f;
+
+            maxAhead1AngleY = 60.0f;
+            maxAhead2AngleY = 20.0f;
+            maxAhead3AngleY = 0.0f;
+            maxAhead4AngleY = -20.0f;
+            maxAhead5AngleY = -40.0f;
+
+            rightFront1AngleYStep = 1.0f;
+            rightFront1AngleXStep = 1.0f;
+            rightFront2AngleXStep = 1.0f;
+            rightFront3AngleXStep = 1.0f;
+
+            rightMiddleFront1AngleYStep = 1.0f;
+            rightMiddleFront1AngleXStep = 1.0f;
+            rightMiddleFront2AngleXStep = 1.0f;
+            rightMiddleFront3AngleXStep = 1.0f;
+
+            rightMiddleBack1AngleYStep = 1.0f;
+            rightMiddleBack1AngleXStep = 1.0f;
+            rightMiddleBack2AngleXStep = 1.0f;
+            rightMiddleBack3AngleXStep = 1.0f;
+
+            rightBack1AngleYStep = 1.0f;
+            rightBack1AngleXStep = 1.0f;
+            rightBack2AngleXStep = 1.0f;
+            rightBack3AngleXStep = 1.0f;
+
+            leftFront1AngleYStep = -1.0f;
+            leftFront1AngleXStep = -1.0f;
+            leftFront2AngleXStep = -1.0f;
+            leftFront3AngleXStep = -1.0f;
+
+            leftMiddleFront1AngleYStep = -1.0f;
+            leftMiddleFront1AngleXStep = -1.0f;
+            leftMiddleFront2AngleXStep = -1.0f;
+            leftMiddleFront3AngleXStep = -1.0f;
+
+            leftMiddleBack1AngleYStep = -1.0f;
+            leftMiddleBack1AngleXStep = -1.0f;
+            leftMiddleBack2AngleXStep = -1.0f;
+            leftMiddleBack3AngleXStep = -1.0f;
+
+            leftBack1AngleYStep = -1.0f;
+            leftBack1AngleXStep = -1.0f;
+            leftBack2AngleXStep = -1.0f;
+            leftBack3AngleXStep = -1.0f;
+
+            rightLimbFront1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Front 1 Constraint" + instanceIndexName);
+            rightLimbFront2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Front 2 Constraint" + instanceIndexName);
+            rightLimbFront3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Front 3 Constraint" + instanceIndexName);
+            rightLimbMiddleFront1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Front 1 Constraint" + instanceIndexName);
+            rightLimbMiddleFront2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Front 2 Constraint" + instanceIndexName);
+            rightLimbMiddleFront3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Front 3 Constraint" + instanceIndexName);
+            rightLimbMiddleBack1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Back 1 Constraint" + instanceIndexName);
+            rightLimbMiddleBack2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Back 2 Constraint" + instanceIndexName);
+            rightLimbMiddleBack3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Middle Back 3 Constraint" + instanceIndexName);
+            rightLimbBack1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Back 1 Constraint" + instanceIndexName);
+            rightLimbBack2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Back 2 Constraint" + instanceIndexName);
+            rightLimbBack3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Right Limb Back 3 Constraint" + instanceIndexName);
+            leftLimbFront1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Front 1 Constraint" + instanceIndexName);
+            leftLimbFront2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Front 2 Constraint" + instanceIndexName);
+            leftLimbFront3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Front 3 Constraint" + instanceIndexName);
+            leftLimbMiddleFront1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Front 1 Constraint" + instanceIndexName);
+            leftLimbMiddleFront2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Front 2 Constraint" + instanceIndexName);
+            leftLimbMiddleFront3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Front 3 Constraint" + instanceIndexName);
+            leftLimbMiddleBack1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Back 1 Constraint" + instanceIndexName);
+            leftLimbMiddleBack2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Back 2 Constraint" + instanceIndexName);
+            leftLimbMiddleBack3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Middle Back 3 Constraint" + instanceIndexName);
+            leftLimbBack1Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Back 1 Constraint" + instanceIndexName);
+            leftLimbBack2Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Back 2 Constraint" + instanceIndexName);
+            leftLimbBack3Constraint = scene.Factory.ConstraintManager.Find("Crab 1 Left Limb Back 3 Constraint" + instanceIndexName);
+
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Crab 1" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Go);
+        }
+
+        void Go(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+            
+            objectBase.MainLocalTransform.GetScale(ref scale);
+
+            if (((scene.SimulationFrameCount % 200) == 0) && (scale.Y < 4.0f))
+            {
+                Vector3.Multiply(ref scale, 1.1f, out scale);
+
+                objectBase.MainLocalTransform.SetScale(ref scale);
+
+                objectBase.UpdateFromMainLocalTransform();
+            }
+
+            if (moveUp)
+            {
+                GoUp(args);
+            }
+            else
+                GoAhead(args);
+        }
+
+        void GoUp(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+            bool move = false;
+
+            if (Math.Abs(rightLimbFront1Constraint.ControlDegAngleY - maxUpFrontAngleY) > Math.Abs(rightFront1AngleYStep))
+            {
+                move = true;
+                if (rightLimbFront1Constraint.ControlDegAngleY < maxUpFrontAngleY)
+                    rightLimbFront1Constraint.ControlDegAngleY += rightFront1AngleYStep;
+                else
+                    if (rightLimbFront1Constraint.ControlDegAngleY > maxUpFrontAngleY)
+                        rightLimbFront1Constraint.ControlDegAngleY -= rightFront1AngleYStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleFront1Constraint.ControlDegAngleY - maxUpMiddleFrontAngleY) > Math.Abs(rightMiddleFront1AngleYStep))
+            {
+                move = true;
+                if (rightLimbMiddleFront1Constraint.ControlDegAngleY < maxUpMiddleFrontAngleY)
+                    rightLimbMiddleFront1Constraint.ControlDegAngleY += rightMiddleFront1AngleYStep;
+                else
+                    if (rightLimbMiddleFront1Constraint.ControlDegAngleY > maxUpMiddleFrontAngleY)
+                        rightLimbMiddleFront1Constraint.ControlDegAngleY -= rightMiddleFront1AngleYStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleBack1Constraint.ControlDegAngleY - maxUpMiddleBackAngleY) > Math.Abs(rightMiddleBack1AngleYStep))
+            {
+                move = true;
+                if (rightLimbMiddleBack1Constraint.ControlDegAngleY < maxUpMiddleBackAngleY)
+                    rightLimbMiddleBack1Constraint.ControlDegAngleY += rightMiddleBack1AngleYStep;
+                else
+                    if (rightLimbMiddleBack1Constraint.ControlDegAngleY > maxUpMiddleBackAngleY)
+                        rightLimbMiddleBack1Constraint.ControlDegAngleY -= rightMiddleBack1AngleYStep;
+            }
+
+            if (Math.Abs(rightLimbBack1Constraint.ControlDegAngleY - maxUpBackAngleY) > Math.Abs(rightMiddleBack1AngleYStep))
+            {
+                move = true;
+                if (rightLimbBack1Constraint.ControlDegAngleY < maxUpBackAngleY)
+                    rightLimbBack1Constraint.ControlDegAngleY += rightBack1AngleYStep;
+                else
+                    if (rightLimbBack1Constraint.ControlDegAngleY > maxUpBackAngleY)
+                        rightLimbBack1Constraint.ControlDegAngleY -= rightBack1AngleYStep;
+            }
+
+
+
+            if (Math.Abs(leftLimbFront1Constraint.ControlDegAngleY + maxUpFrontAngleY) > Math.Abs(leftFront1AngleYStep))
+            {
+                move = true;
+                if (leftLimbFront1Constraint.ControlDegAngleY > -maxUpFrontAngleY)
+                    leftLimbFront1Constraint.ControlDegAngleY += leftFront1AngleYStep;
+                else
+                    if (leftLimbFront1Constraint.ControlDegAngleY < -maxUpFrontAngleY)
+                        leftLimbFront1Constraint.ControlDegAngleY -= leftFront1AngleYStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleFront1Constraint.ControlDegAngleY + maxUpMiddleFrontAngleY) > Math.Abs(leftMiddleFront1AngleYStep))
+            {
+                move = true;
+                if (leftLimbMiddleFront1Constraint.ControlDegAngleY > -maxUpMiddleFrontAngleY)
+                    leftLimbMiddleFront1Constraint.ControlDegAngleY += leftMiddleFront1AngleYStep;
+                else
+                    if (leftLimbMiddleFront1Constraint.ControlDegAngleY < -maxUpMiddleFrontAngleY)
+                        leftLimbMiddleFront1Constraint.ControlDegAngleY -= leftMiddleFront1AngleYStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleBack1Constraint.ControlDegAngleY + maxUpMiddleBackAngleY) > Math.Abs(leftMiddleBack1AngleYStep))
+            {
+                move = true;
+                if (leftLimbMiddleBack1Constraint.ControlDegAngleY > -maxUpMiddleBackAngleY)
+                    leftLimbMiddleBack1Constraint.ControlDegAngleY += leftMiddleBack1AngleYStep;
+                else
+                    if (leftLimbMiddleBack1Constraint.ControlDegAngleY < -maxUpMiddleBackAngleY)
+                        leftLimbMiddleBack1Constraint.ControlDegAngleY -= leftMiddleBack1AngleYStep;
+            }
+
+            if (Math.Abs(leftLimbBack1Constraint.ControlDegAngleY + maxUpBackAngleY) > Math.Abs(leftBack1AngleYStep))
+            {
+                move = true;
+                if (leftLimbBack1Constraint.ControlDegAngleY > -maxUpBackAngleY)
+                    leftLimbBack1Constraint.ControlDegAngleY += leftBack1AngleYStep;
+                else
+                    if (leftLimbBack1Constraint.ControlDegAngleY < -maxUpBackAngleY)
+                        leftLimbBack1Constraint.ControlDegAngleY -= leftBack1AngleYStep;
+            }
+
+
+
+            if (Math.Abs(rightLimbFront1Constraint.ControlDegAngleX - maxUp1AngleX) > Math.Abs(rightFront1AngleXStep))
+            {
+                move = true;
+                if (rightLimbFront1Constraint.ControlDegAngleX < maxUp1AngleX)
+                    rightLimbFront1Constraint.ControlDegAngleX += rightFront1AngleXStep;
+                else
+                    if (rightLimbFront1Constraint.ControlDegAngleX > maxUp1AngleX)
+                        rightLimbFront1Constraint.ControlDegAngleX -= rightFront1AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbFront2Constraint.ControlDegAngleX - maxUp2AngleX) > Math.Abs(rightFront2AngleXStep))
+            {
+                move = true;
+                if (rightLimbFront2Constraint.ControlDegAngleX < maxUp2AngleX)
+                    rightLimbFront2Constraint.ControlDegAngleX += rightFront2AngleXStep;
+                else
+                    if (rightLimbFront2Constraint.ControlDegAngleX > maxUp2AngleX)
+                        rightLimbFront2Constraint.ControlDegAngleX -= rightFront2AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbFront3Constraint.ControlDegAngleX - maxUp3AngleX) > Math.Abs(rightFront3AngleXStep))
+            {
+                move = true;
+                if (rightLimbFront3Constraint.ControlDegAngleX < maxUp3AngleX)
+                    rightLimbFront3Constraint.ControlDegAngleX += rightFront3AngleXStep;
+                else
+                    if (rightLimbFront3Constraint.ControlDegAngleX > maxUp3AngleX)
+                        rightLimbFront3Constraint.ControlDegAngleX -= rightFront3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(rightLimbMiddleFront1Constraint.ControlDegAngleX - maxUp1AngleX) > Math.Abs(rightMiddleFront1AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleFront1Constraint.ControlDegAngleX < maxUp1AngleX)
+                    rightLimbMiddleFront1Constraint.ControlDegAngleX += rightMiddleFront1AngleXStep;
+                else
+                    if (rightLimbMiddleFront1Constraint.ControlDegAngleX > maxUp1AngleX)
+                        rightLimbMiddleFront1Constraint.ControlDegAngleX -= rightMiddleFront1AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleFront2Constraint.ControlDegAngleX - maxUp2AngleX) > Math.Abs(rightMiddleFront2AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleFront2Constraint.ControlDegAngleX < maxUp2AngleX)
+                    rightLimbMiddleFront2Constraint.ControlDegAngleX += rightMiddleFront2AngleXStep;
+                else
+                    if (rightLimbMiddleFront2Constraint.ControlDegAngleX > maxUp2AngleX)
+                        rightLimbMiddleFront2Constraint.ControlDegAngleX -= rightMiddleFront2AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleFront3Constraint.ControlDegAngleX - maxUp3AngleX) > Math.Abs(rightMiddleFront3AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleFront3Constraint.ControlDegAngleX < maxUp3AngleX)
+                    rightLimbMiddleFront3Constraint.ControlDegAngleX += rightMiddleFront3AngleXStep;
+                else
+                    if (rightLimbMiddleFront3Constraint.ControlDegAngleX > maxUp3AngleX)
+                        rightLimbMiddleFront3Constraint.ControlDegAngleX -= rightMiddleFront3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(rightLimbMiddleBack1Constraint.ControlDegAngleX - maxUp1AngleX) > Math.Abs(rightMiddleBack1AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleBack1Constraint.ControlDegAngleX < maxUp1AngleX)
+                    rightLimbMiddleBack1Constraint.ControlDegAngleX += rightMiddleBack1AngleXStep;
+                else
+                    if (rightLimbMiddleBack1Constraint.ControlDegAngleX > maxUp1AngleX)
+                        rightLimbMiddleBack1Constraint.ControlDegAngleX -= rightMiddleBack1AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleBack2Constraint.ControlDegAngleX - maxUp2AngleX) > Math.Abs(rightMiddleBack2AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleBack2Constraint.ControlDegAngleX < maxUp2AngleX)
+                    rightLimbMiddleBack2Constraint.ControlDegAngleX += rightMiddleBack2AngleXStep;
+                else
+                    if (rightLimbMiddleBack2Constraint.ControlDegAngleX > maxUp2AngleX)
+                        rightLimbMiddleBack2Constraint.ControlDegAngleX -= rightMiddleBack2AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbMiddleBack3Constraint.ControlDegAngleX - maxUp3AngleX) > Math.Abs(rightMiddleBack3AngleXStep))
+            {
+                move = true;
+                if (rightLimbMiddleBack3Constraint.ControlDegAngleX < maxUp3AngleX)
+                    rightLimbMiddleBack3Constraint.ControlDegAngleX += rightMiddleBack3AngleXStep;
+                else
+                    if (rightLimbMiddleBack3Constraint.ControlDegAngleX > maxUp3AngleX)
+                        rightLimbMiddleBack3Constraint.ControlDegAngleX -= rightMiddleBack3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(rightLimbBack1Constraint.ControlDegAngleX - maxUp1AngleX) > Math.Abs(rightBack1AngleXStep))
+            {
+                move = true;
+                if (rightLimbBack1Constraint.ControlDegAngleX < maxUp1AngleX)
+                    rightLimbBack1Constraint.ControlDegAngleX += rightBack1AngleXStep;
+                else
+                    if (rightLimbBack1Constraint.ControlDegAngleX > maxUp1AngleX)
+                        rightLimbBack1Constraint.ControlDegAngleX -= rightBack1AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbBack2Constraint.ControlDegAngleX - maxUp2AngleX) > Math.Abs(rightBack2AngleXStep))
+            {
+                move = true;
+                if (rightLimbBack2Constraint.ControlDegAngleX < maxUp2AngleX)
+                    rightLimbBack2Constraint.ControlDegAngleX += rightBack2AngleXStep;
+                else
+                    if (rightLimbBack2Constraint.ControlDegAngleX > maxUp2AngleX)
+                        rightLimbBack2Constraint.ControlDegAngleX -= rightBack2AngleXStep;
+            }
+
+            if (Math.Abs(rightLimbBack3Constraint.ControlDegAngleX - maxUp3AngleX) > Math.Abs(rightBack3AngleXStep))
+            {
+                move = true;
+                if (rightLimbBack3Constraint.ControlDegAngleX < maxUp3AngleX)
+                    rightLimbBack3Constraint.ControlDegAngleX += rightBack3AngleXStep;
+                else
+                    if (rightLimbBack3Constraint.ControlDegAngleX > maxUp3AngleX)
+                        rightLimbBack3Constraint.ControlDegAngleX -= rightBack3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(leftLimbFront1Constraint.ControlDegAngleX + maxUp1AngleX) > Math.Abs(leftFront1AngleXStep))
+            {
+                move = true;
+                if (leftLimbFront1Constraint.ControlDegAngleX > -maxUp1AngleX)
+                    leftLimbFront1Constraint.ControlDegAngleX += leftFront1AngleXStep;
+                else
+                    if (leftLimbFront1Constraint.ControlDegAngleX < -maxUp1AngleX)
+                        leftLimbFront1Constraint.ControlDegAngleX -= leftFront1AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbFront2Constraint.ControlDegAngleX + maxUp2AngleX) > Math.Abs(leftFront2AngleXStep))
+            {
+                move = true;
+                if (leftLimbFront2Constraint.ControlDegAngleX > -maxUp2AngleX)
+                    leftLimbFront2Constraint.ControlDegAngleX += leftFront2AngleXStep;
+                else
+                    if (leftLimbFront2Constraint.ControlDegAngleX < -maxUp2AngleX)
+                        leftLimbFront2Constraint.ControlDegAngleX -= leftFront2AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbFront3Constraint.ControlDegAngleX + maxUp3AngleX) > Math.Abs(leftFront3AngleXStep))
+            {
+                move = true;
+                if (leftLimbFront3Constraint.ControlDegAngleX > -maxUp3AngleX)
+                    leftLimbFront3Constraint.ControlDegAngleX += leftFront3AngleXStep;
+                else
+                    if (leftLimbFront3Constraint.ControlDegAngleX < -maxUp3AngleX)
+                        leftLimbFront3Constraint.ControlDegAngleX -= leftFront3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(leftLimbMiddleFront1Constraint.ControlDegAngleX + maxUp1AngleX) > Math.Abs(leftMiddleFront1AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleFront1Constraint.ControlDegAngleX > -maxUp1AngleX)
+                    leftLimbMiddleFront1Constraint.ControlDegAngleX += leftMiddleFront1AngleXStep;
+                else
+                    if (leftLimbMiddleFront1Constraint.ControlDegAngleX < -maxUp1AngleX)
+                        leftLimbMiddleFront1Constraint.ControlDegAngleX -= leftMiddleFront1AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleFront2Constraint.ControlDegAngleX + maxUp2AngleX) > Math.Abs(leftMiddleFront2AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleFront2Constraint.ControlDegAngleX > -maxUp2AngleX)
+                    leftLimbMiddleFront2Constraint.ControlDegAngleX += leftMiddleFront2AngleXStep;
+                else
+                    if (leftLimbMiddleFront2Constraint.ControlDegAngleX < -maxUp2AngleX)
+                        leftLimbMiddleFront2Constraint.ControlDegAngleX -= leftMiddleFront2AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleFront3Constraint.ControlDegAngleX + maxUp3AngleX) > Math.Abs(leftMiddleFront3AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleFront3Constraint.ControlDegAngleX > -maxUp3AngleX)
+                    leftLimbMiddleFront3Constraint.ControlDegAngleX += leftMiddleFront3AngleXStep;
+                else
+                    if (leftLimbMiddleFront3Constraint.ControlDegAngleX < -maxUp3AngleX)
+                        leftLimbMiddleFront3Constraint.ControlDegAngleX -= leftMiddleFront3AngleXStep;
+            }
+
+
+
+            if (Math.Abs(leftLimbMiddleBack1Constraint.ControlDegAngleX + maxUp1AngleX) > Math.Abs(leftMiddleBack1AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleBack1Constraint.ControlDegAngleX > -maxUp1AngleX)
+                    leftLimbMiddleBack1Constraint.ControlDegAngleX += leftMiddleBack1AngleXStep;
+                else
+                    if (leftLimbMiddleBack1Constraint.ControlDegAngleX < -maxUp1AngleX)
+                        leftLimbMiddleBack1Constraint.ControlDegAngleX -= leftMiddleBack1AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleBack2Constraint.ControlDegAngleX + maxUp2AngleX) > Math.Abs(leftMiddleBack2AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleBack2Constraint.ControlDegAngleX > -maxUp2AngleX)
+                    leftLimbMiddleBack2Constraint.ControlDegAngleX += leftMiddleBack2AngleXStep;
+                else
+                    if (leftLimbMiddleBack2Constraint.ControlDegAngleX < -maxUp2AngleX)
+                        leftLimbMiddleBack2Constraint.ControlDegAngleX -= leftMiddleBack2AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbMiddleBack3Constraint.ControlDegAngleX + maxUp3AngleX) > Math.Abs(leftMiddleBack3AngleXStep))
+            {
+                move = true;
+                if (leftLimbMiddleBack3Constraint.ControlDegAngleX > -maxUp3AngleX)
+                    leftLimbMiddleBack3Constraint.ControlDegAngleX += leftMiddleBack3AngleXStep;
+                else
+                    if (leftLimbMiddleBack3Constraint.ControlDegAngleX < -maxUp3AngleX)
+                        leftLimbMiddleBack3Constraint.ControlDegAngleX -= leftMiddleBack3AngleXStep;
+            }
+
+
+            if (Math.Abs(leftLimbBack1Constraint.ControlDegAngleX + maxUp1AngleX) > Math.Abs(leftBack1AngleXStep))
+            {
+                move = true;
+                if (leftLimbBack1Constraint.ControlDegAngleX > -maxUp1AngleX)
+                    leftLimbBack1Constraint.ControlDegAngleX += leftBack1AngleXStep;
+                else
+                    if (leftLimbBack1Constraint.ControlDegAngleX < -maxUp1AngleX)
+                        leftLimbBack1Constraint.ControlDegAngleX -= leftBack1AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbBack2Constraint.ControlDegAngleX + maxUp2AngleX) > Math.Abs(leftBack2AngleXStep))
+            {
+                move = true;
+                if (leftLimbBack2Constraint.ControlDegAngleX > -maxUp2AngleX)
+                    leftLimbBack2Constraint.ControlDegAngleX += leftBack2AngleXStep;
+                else
+                    if (leftLimbBack2Constraint.ControlDegAngleX < -maxUp2AngleX)
+                        leftLimbBack2Constraint.ControlDegAngleX -= leftBack2AngleXStep;
+            }
+
+            if (Math.Abs(leftLimbBack3Constraint.ControlDegAngleX + maxUp3AngleX) > Math.Abs(leftBack3AngleXStep))
+            {
+                move = true;
+                if (leftLimbBack3Constraint.ControlDegAngleX > -maxUp3AngleX)
+                    leftLimbBack3Constraint.ControlDegAngleX += leftBack3AngleXStep;
+                else
+                    if (leftLimbBack3Constraint.ControlDegAngleX < -maxUp3AngleX)
+                        leftLimbBack3Constraint.ControlDegAngleX -= leftBack3AngleXStep;
+            }
+
+            moveUp = move;
+        }
+
+        void GoAhead(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (rightFront1AngleXStep > 0.0f)
+            {
+                if (rightLimbFront1Constraint.ControlDegAngleX <= rightLimbFront1Constraint.MinLimitDegAngleX)
+                {
+                    if (rightLimbFront1Constraint.ControlDegAngleY >= maxAhead1AngleY)
+                    {
+                        rightFront1AngleXStep = -rightFront1AngleXStep;
+                        rightFront1AngleYStep = -rightFront1AngleYStep;
+                    }
+                    else
+                        rightLimbFront1Constraint.ControlDegAngleY += rightFront1AngleYStep;
+                }
+                else
+                    rightLimbFront1Constraint.ControlDegAngleX -= rightFront1AngleXStep;
+            }
+            else
+                if (rightFront1AngleXStep < 0.0f)
+                {
+                    if (rightLimbFront1Constraint.ControlDegAngleX >= maxUp1AngleX)
+                    {
+                        if (rightLimbFront1Constraint.ControlDegAngleY <= maxAhead2AngleY)
+                        {
+                            rightFront1AngleXStep = -rightFront1AngleXStep;
+                            rightFront1AngleYStep = -rightFront1AngleYStep;
+                        }
+                        else
+                            rightLimbFront1Constraint.ControlDegAngleY += rightFront1AngleYStep;
+                    }
+                    else
+                        rightLimbFront1Constraint.ControlDegAngleX -= rightFront1AngleXStep;
+                }
+
+
+            if ((rightMiddleFront1AngleXStep > 0.0f) && (leftFront1AngleXStep < 0.0f))
+            {
+                if (rightLimbMiddleFront1Constraint.ControlDegAngleX <= rightLimbMiddleFront1Constraint.MinLimitDegAngleX)
+                {
+                    if (rightLimbMiddleFront1Constraint.ControlDegAngleY >= maxAhead2AngleY)
+                    {
+                        rightMiddleFront1AngleXStep = -rightMiddleFront1AngleXStep;
+                        rightMiddleFront1AngleYStep = -rightMiddleFront1AngleYStep;
+                    }
+                    else
+                        rightLimbMiddleFront1Constraint.ControlDegAngleY += rightMiddleFront1AngleYStep;
+                }
+                else
+                    rightLimbMiddleFront1Constraint.ControlDegAngleX -= rightMiddleFront1AngleXStep;
+            }
+            else
+                if ((rightMiddleFront1AngleXStep < 0.0f) && (leftFront1AngleXStep > 0.0f))
+                {
+                    if (rightLimbMiddleFront1Constraint.ControlDegAngleX >= maxUp1AngleX)
+                    {
+                        if (rightLimbMiddleFront1Constraint.ControlDegAngleY <= maxAhead3AngleY)
+                        {
+                            rightMiddleFront1AngleXStep = -rightMiddleFront1AngleXStep;
+                            rightMiddleFront1AngleYStep = -rightMiddleFront1AngleYStep;
+                        }
+                        else
+                            rightLimbMiddleFront1Constraint.ControlDegAngleY += rightMiddleFront1AngleYStep;
+                    }
+                    else
+                        rightLimbMiddleFront1Constraint.ControlDegAngleX -= rightMiddleFront1AngleXStep;
+                }
+
+
+            if ((rightMiddleBack1AngleXStep > 0.0f) && (leftMiddleFront1AngleXStep < 0.0f))
+            {
+                if (rightLimbMiddleBack1Constraint.ControlDegAngleX <= rightLimbMiddleBack1Constraint.MinLimitDegAngleX)
+                {
+                    if (rightLimbMiddleBack1Constraint.ControlDegAngleY >= maxAhead3AngleY)
+                    {
+                        rightMiddleBack1AngleXStep = -rightMiddleBack1AngleXStep;
+                        rightMiddleBack1AngleYStep = -rightMiddleBack1AngleYStep;
+                    }
+                    else
+                        rightLimbMiddleBack1Constraint.ControlDegAngleY += rightMiddleBack1AngleYStep;
+                }
+                else
+                    rightLimbMiddleBack1Constraint.ControlDegAngleX -= rightMiddleBack1AngleXStep;
+            }
+            else
+                if ((rightMiddleBack1AngleXStep < 0.0f) && (leftMiddleFront1AngleXStep > 0.0f))
+                {
+                    if (rightLimbMiddleBack1Constraint.ControlDegAngleX >= maxUp1AngleX)
+                    {
+                        if (rightLimbMiddleBack1Constraint.ControlDegAngleY <= maxAhead4AngleY)
+                        {
+                            rightMiddleBack1AngleXStep = -rightMiddleBack1AngleXStep;
+                            rightMiddleBack1AngleYStep = -rightMiddleBack1AngleYStep;
+                        }
+                        else
+                            rightLimbMiddleBack1Constraint.ControlDegAngleY += rightMiddleBack1AngleYStep;
+                    }
+                    else
+                        rightLimbMiddleBack1Constraint.ControlDegAngleX -= rightMiddleBack1AngleXStep;
+                }
+
+
+            if ((rightBack1AngleXStep > 0.0f) && (leftMiddleBack1AngleXStep < 0.0f))
+            {
+                if (rightLimbBack1Constraint.ControlDegAngleX <= rightLimbBack1Constraint.MinLimitDegAngleX)
+                {
+                    if (rightLimbBack1Constraint.ControlDegAngleY >= maxAhead4AngleY)
+                    {
+                        rightBack1AngleXStep = -rightBack1AngleXStep;
+                        rightBack1AngleYStep = -rightBack1AngleYStep;
+                    }
+                    else
+                        rightLimbBack1Constraint.ControlDegAngleY += rightBack1AngleYStep;
+                }
+                else
+                    rightLimbBack1Constraint.ControlDegAngleX -= rightBack1AngleXStep;
+            }
+            else
+                if ((rightBack1AngleXStep < 0.0f) && (leftMiddleBack1AngleXStep > 0.0f))
+                {
+                    if (rightLimbBack1Constraint.ControlDegAngleX >= maxUp1AngleX)
+                    {
+                        if (rightLimbBack1Constraint.ControlDegAngleY <= maxAhead5AngleY)
+                        {
+                            rightBack1AngleXStep = -rightBack1AngleXStep;
+                            rightBack1AngleYStep = -rightBack1AngleYStep;
+                        }
+                        else
+                            rightLimbBack1Constraint.ControlDegAngleY += rightBack1AngleYStep;
+                    }
+                    else
+                        rightLimbBack1Constraint.ControlDegAngleX -= rightBack1AngleXStep;
+                }
+
+
+
+            if ((leftFront1AngleXStep < 0.0f) && (rightFront1AngleXStep < 0.0f))
+            {
+                if (leftLimbFront1Constraint.ControlDegAngleX >= leftLimbFront1Constraint.MaxLimitDegAngleX)
+                {
+                    if (leftLimbFront1Constraint.ControlDegAngleY <= -maxAhead1AngleY)
+                    {
+                        leftFront1AngleXStep = -leftFront1AngleXStep;
+                        leftFront1AngleYStep = -leftFront1AngleYStep;
+                    }
+                    else
+                        leftLimbFront1Constraint.ControlDegAngleY += leftFront1AngleYStep;
+                }
+                else
+                    leftLimbFront1Constraint.ControlDegAngleX -= leftFront1AngleXStep;
+            }
+            else
+                if ((leftFront1AngleXStep > 0.0f) && (rightFront1AngleXStep > 0.0f))
+                {
+                    if (leftLimbFront1Constraint.ControlDegAngleX <= -maxUp1AngleX)
+                    {
+                        if (leftLimbFront1Constraint.ControlDegAngleY >= -maxAhead2AngleY)
+                        {
+                            leftFront1AngleXStep = -leftFront1AngleXStep;
+                            leftFront1AngleYStep = -leftFront1AngleYStep;
+                        }
+                        else
+                            leftLimbFront1Constraint.ControlDegAngleY += leftFront1AngleYStep;
+                    }
+                    else
+                        leftLimbFront1Constraint.ControlDegAngleX -= leftFront1AngleXStep;
+                }
+
+
+            if ((leftMiddleFront1AngleXStep < 0.0f) && (rightFront1AngleXStep > 0.0f))
+            {
+                if (leftLimbMiddleFront1Constraint.ControlDegAngleX >= leftLimbMiddleFront1Constraint.MaxLimitDegAngleX)
+                {
+                    if (leftLimbMiddleFront1Constraint.ControlDegAngleY <= -maxAhead2AngleY)
+                    {
+                        leftMiddleFront1AngleXStep = -leftMiddleFront1AngleXStep;
+                        leftMiddleFront1AngleYStep = -leftMiddleFront1AngleYStep;
+                    }
+                    else
+                        leftLimbMiddleFront1Constraint.ControlDegAngleY += leftMiddleFront1AngleYStep;
+                }
+                else
+                    leftLimbMiddleFront1Constraint.ControlDegAngleX -= leftMiddleFront1AngleXStep;
+            }
+            else
+                if ((leftMiddleFront1AngleXStep > 0.0f) && (rightFront1AngleXStep < 0.0f))
+                {
+                    if (leftLimbMiddleFront1Constraint.ControlDegAngleX <= -maxUp1AngleX)
+                    {
+                        if (leftLimbMiddleFront1Constraint.ControlDegAngleY >= maxAhead3AngleY)
+                        {
+                            leftMiddleFront1AngleXStep = -leftMiddleFront1AngleXStep;
+                            leftMiddleFront1AngleYStep = -leftMiddleFront1AngleYStep;
+                        }
+                        else
+                            leftLimbMiddleFront1Constraint.ControlDegAngleY += leftMiddleFront1AngleYStep;
+                    }
+                    else
+                        leftLimbMiddleFront1Constraint.ControlDegAngleX -= leftMiddleFront1AngleXStep;
+                }
+
+
+            if ((leftMiddleBack1AngleXStep < 0.0f) && (rightMiddleFront1AngleXStep > 0.0f))
+            {
+                if (leftLimbMiddleBack1Constraint.ControlDegAngleX >= leftLimbMiddleBack1Constraint.MaxLimitDegAngleX)
+                {
+                    if (leftLimbMiddleBack1Constraint.ControlDegAngleY <= maxAhead3AngleY)
+                    {
+                        leftMiddleBack1AngleXStep = -leftMiddleBack1AngleXStep;
+                        leftMiddleBack1AngleYStep = -leftMiddleBack1AngleYStep;
+                    }
+                    else
+                        leftLimbMiddleBack1Constraint.ControlDegAngleY += leftMiddleBack1AngleYStep;
+                }
+                else
+                    leftLimbMiddleBack1Constraint.ControlDegAngleX -= leftMiddleBack1AngleXStep;
+            }
+            else
+                if ((leftMiddleBack1AngleXStep > 0.0f) && (rightMiddleFront1AngleXStep < 0.0f))
+                {
+                    if (leftLimbMiddleBack1Constraint.ControlDegAngleX <= -maxUp1AngleX)
+                    {
+                        if (leftLimbMiddleBack1Constraint.ControlDegAngleY >= -maxAhead4AngleY)
+                        {
+                            leftMiddleBack1AngleXStep = -leftMiddleBack1AngleXStep;
+                            leftMiddleBack1AngleYStep = -leftMiddleBack1AngleYStep;
+                        }
+                        else
+                            leftLimbMiddleBack1Constraint.ControlDegAngleY += leftMiddleBack1AngleYStep;
+                    }
+                    else
+                        leftLimbMiddleBack1Constraint.ControlDegAngleX -= leftMiddleBack1AngleXStep;
+                }
+
+
+            if ((leftBack1AngleXStep < 0.0f) && (rightMiddleBack1AngleXStep > 0.0f))
+            {
+                if (leftLimbBack1Constraint.ControlDegAngleX >= leftLimbBack1Constraint.MaxLimitDegAngleX)
+                {
+                    if (leftLimbBack1Constraint.ControlDegAngleY <= -maxAhead4AngleY)
+                    {
+                        leftBack1AngleXStep = -leftBack1AngleXStep;
+                        leftBack1AngleYStep = -leftBack1AngleYStep;
+                    }
+                    else
+                        leftLimbBack1Constraint.ControlDegAngleY += leftBack1AngleYStep;
+                }
+                else
+                    leftLimbBack1Constraint.ControlDegAngleX -= leftBack1AngleXStep;
+            }
+            else
+                if ((leftBack1AngleXStep > 0.0f) && (rightMiddleBack1AngleXStep < 0.0f))
+                {
+                    if (leftLimbBack1Constraint.ControlDegAngleX <= -maxUp1AngleX)
+                    {
+                        if (leftLimbBack1Constraint.ControlDegAngleY >= -maxAhead5AngleY)
+                        {
+                            leftBack1AngleXStep = -leftBack1AngleXStep;
+                            leftBack1AngleYStep = -leftBack1AngleYStep;
+                        }
+                        else
+                            leftLimbBack1Constraint.ControlDegAngleY += leftBack1AngleYStep;
+                    }
+                    else
+                        leftLimbBack1Constraint.ControlDegAngleX -= leftBack1AngleXStep;
+                }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField1Animation1.cs
new file mode 100644
index 0000000..6a00fa7
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField1Animation1.cs
@@ -0,0 +1,77 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class ForceField1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        ForceField1 forceField;
+
+        Vector3 vectorZero;
+
+        public ForceField1Animation1(Demo demo, ForceField1 forceField)
+        {
+            this.demo = demo;
+            this.forceField = forceField;
+
+            vectorZero = Vector3.Zero;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("ForceField 1 Field");
+            if (objectBase != null)
+                objectBase.UserControllers.CollisionMethods += new CollisionMethod(ForceField);
+        }
+
+        void ForceField(CollisionMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            Vector3 axis = vectorZero;
+            Vector3 objectPosition = vectorZero;
+            Vector3 collisionObjectPosition = vectorZero;
+            PhysicsObject collisionPhysicsObject = null;
+
+            for (int i = 0; i < args.Collisions.Count; i++)
+            {
+                collisionPhysicsObject = scene.Factory.PhysicsObjectManager.Get(args.Collisions[i]);
+
+                if (!collisionPhysicsObject.IsStatic)
+                {
+                    objectBase.MainWorldTransform.GetPosition(ref objectPosition);
+                    collisionPhysicsObject.MainWorldTransform.GetPosition(ref collisionObjectPosition);
+
+                    Vector3.Subtract(ref collisionObjectPosition, ref objectPosition, out axis);
+                    axis.Normalize();
+
+                    Vector3.Multiply(ref axis, 40000.0f, out axis);
+
+                    collisionPhysicsObject.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref axis);
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField2Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField2Animation1.cs
new file mode 100644
index 0000000..3117836
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/ForceField2Animation1.cs
@@ -0,0 +1,78 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class ForceField2Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        ForceField2 forceField;
+
+        Vector3 vectorZero;
+
+        public ForceField2Animation1(Demo demo, ForceField2 forceField)
+        {
+            this.demo = demo;
+            this.forceField = forceField;
+
+            vectorZero = Vector3.Zero;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("ForceField 2 Field");
+            if (objectBase != null)
+                objectBase.UserControllers.CollisionMethods += new CollisionMethod(ForceField);
+        }
+
+        void ForceField(CollisionMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            Vector3 axis = vectorZero;
+            Vector3 objectPosition = vectorZero;
+            Vector3 collisionObjectPosition = vectorZero;
+
+            PhysicsObject collisionPhysicsObject = null;
+
+            for (int i = 0; i < args.Collisions.Count; i++)
+            {
+                collisionPhysicsObject = scene.Factory.PhysicsObjectManager.Get(args.Collisions[i]);
+
+                if (!collisionPhysicsObject.IsStatic)
+                {
+                    objectBase.MainWorldTransform.GetPosition(ref objectPosition);
+                    collisionPhysicsObject.MainWorldTransform.GetPosition(ref collisionObjectPosition);
+
+                    Vector3.Subtract(ref collisionObjectPosition, ref objectPosition, out axis);
+                    axis.Normalize();
+
+                    Vector3.Multiply(ref axis, -40000.0f, out axis);
+
+                    collisionPhysicsObject.RigidGroupOwner.WorldAccumulator.AddWorldForce(ref axis);
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Helicopter1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Helicopter1Animation1.cs
new file mode 100644
index 0000000..d21c0aa
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Helicopter1Animation1.cs
@@ -0,0 +1,666 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Helicopter1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        float maxRotorUpAngularVelocity;
+        float maxRotorUpFlyForce;
+
+        float maxRotorBackAngularVelocity;
+        float maxRotorBackFlyCompensationForce;
+        float maxRotorBackStartCompensationForce;
+
+        float maxFlyHeight;
+        float maxHeightDamping;
+        float maxMoveDirectionDamping;
+
+        float maxFlyTime;
+        float maxStartTime;
+        Vector3 flyPosition1;
+        Vector3 flyPosition2;
+        Vector3 flyPosition3;
+        Vector3 flyPosition4;
+
+        bool enableFly;
+        double totalStartTime;
+        double totalFlyTime;
+        double totalSwitchRightTime;
+        double totalSwitchLeftTime;
+        Vector3 endFlyPosition;
+        Vector3 landingPosition;
+
+        float maxSwitchRightTime;
+        float maxSwitchLeftTime;
+
+        Vector3 force;
+        Vector3 torque;
+
+        Vector3 vectorZero;
+        Vector3 unitY;
+        Vector3 unitZ;
+
+        string cameraBodyName;
+
+        Constraint cabinFrontButtonConstraint;
+        Constraint upRotorConstraint;
+        Constraint backRotorConstraint;
+
+        PhysicsObject body;
+        PhysicsObject upRotor;
+        PhysicsObject backRotor;
+        PhysicsObject upRotorBody;
+        PhysicsObject upBody2;
+        PhysicsObject tail4;
+        PhysicsObject tail3;
+
+        PhysicsObject cabinBodyUp1;
+        PhysicsObject cabinBodyUp2;
+        PhysicsObject cabinBodyDown1;
+        PhysicsObject cabinBodyDown2;
+
+        Constraint leftDoorConstraint;
+        PhysicsObject cabinBodyLeft1;
+        PhysicsObject cabinBodyLeft2;
+        PhysicsObject cabinBodyFrontLeft;
+        PhysicsObject leftDoorRight;
+        PhysicsObject leftDoorLeft;
+        PhysicsObject leftDoorUp;
+        PhysicsObject leftDoorDown;
+
+        Constraint rightDoorConstraint;
+        PhysicsObject cabinBodyRight1;
+        PhysicsObject cabinBodyRight2;
+        PhysicsObject cabinBodyFrontRight;
+        PhysicsObject rightDoorRight;
+        PhysicsObject rightDoorLeft;
+        PhysicsObject rightDoorUp;
+        PhysicsObject rightDoorDown;
+
+        public Helicopter1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            maxRotorUpAngularVelocity = 10.0f;
+            maxRotorUpFlyForce = 2500.0f;
+
+            maxRotorBackAngularVelocity = 10.0f;
+            maxRotorBackFlyCompensationForce = 10000.0f;
+            maxRotorBackStartCompensationForce = 1000.0f;
+
+            maxFlyHeight = 100.0f;
+
+            maxHeightDamping = 0.001f;
+            maxMoveDirectionDamping = 0.998f;
+
+            maxStartTime = 30.0f;
+            maxFlyTime = 500.0f;
+            flyPosition1 = new Vector3(500.0f, 100.0f, 500.0f);
+            flyPosition2 = new Vector3(500.0f, 100.0f, -500.0f);
+            flyPosition3 = new Vector3(-500.0f, 100.0f, -500.0f);
+            flyPosition4 = new Vector3(-500.0f, 100.0f, 500.0f);
+
+            maxSwitchRightTime = 10.0f;
+            maxSwitchLeftTime = 10.0f;
+
+            vectorZero = Vector3.Zero;
+            unitY = Vector3.UnitY;
+            unitZ = Vector3.UnitZ;
+
+            cameraBodyName = "Camera 2 Body";
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers(Vector3 endFlyPosition, Vector3 landingPosition)
+        {
+            cabinFrontButtonConstraint = scene.Factory.ConstraintManager.Find("Helicopter 1 Cabin Front Button Constraint" + instanceIndexName);
+            upRotorConstraint = scene.Factory.ConstraintManager.Find("Helicopter 1 Up Rotor Constraint" + instanceIndexName);
+            backRotorConstraint = scene.Factory.ConstraintManager.Find("Helicopter 1 Back Rotor Constraint" + instanceIndexName);
+
+            body = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Body" + instanceIndexName);
+            upRotor = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Rotor" + instanceIndexName);
+            backRotor = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Back Rotor" + instanceIndexName);
+            upRotorBody = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Rotor Body" + instanceIndexName);
+            upBody2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Body 2" + instanceIndexName);
+            tail4 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Tail 4" + instanceIndexName);
+            tail3 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Tail 3" + instanceIndexName);
+
+            cabinBodyUp1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Up 1" + instanceIndexName);
+            cabinBodyUp2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Up 2" + instanceIndexName);
+            cabinBodyDown1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Down 1" + instanceIndexName);
+            cabinBodyDown2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Down 2" + instanceIndexName);
+
+            leftDoorConstraint = scene.Factory.ConstraintManager.Find("Helicopter 1 Left Door Constraint" + instanceIndexName);
+            cabinBodyLeft1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 1" + instanceIndexName);
+            cabinBodyLeft2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 2" + instanceIndexName);
+            cabinBodyFrontLeft = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Front Left" + instanceIndexName);
+            leftDoorRight = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Right" + instanceIndexName);
+            leftDoorLeft = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Left" + instanceIndexName);
+            leftDoorUp = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Up" + instanceIndexName);
+            leftDoorDown = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName);
+
+            rightDoorConstraint = scene.Factory.ConstraintManager.Find("Helicopter 1 Right Door Constraint" + instanceIndexName);
+            cabinBodyRight1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 1" + instanceIndexName);
+            cabinBodyRight2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 2" + instanceIndexName);
+            cabinBodyFrontRight = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Front Right" + instanceIndexName);
+            rightDoorRight = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Right" + instanceIndexName);
+            rightDoorLeft = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Left" + instanceIndexName);
+            rightDoorUp = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Up" + instanceIndexName);
+            rightDoorDown = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName);
+
+            enableFly = false;
+            totalStartTime = 0.0;
+            totalFlyTime = 0.0;
+
+            this.endFlyPosition = endFlyPosition;
+            this.landingPosition = landingPosition;
+
+            totalSwitchLeftTime = 2.0f * maxSwitchLeftTime;
+            totalSwitchRightTime = 2.0f * maxSwitchRightTime;
+
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Front Button Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.CollisionMethods += new CollisionMethod(Run);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Fly);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchLeft);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Switch" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchRight);
+        }
+
+        void Run(CollisionMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if ((cabinFrontButtonConstraint == null) || (body == null) || cabinFrontButtonConstraint.IsBroken || body.IsBrokenRigidGroup) return;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if ((physicsObjectWithActiveCamera == null) || !physicsObjectWithActiveCamera.RigidGroupOwner.IsColliding(objectBase)) return;
+
+            if (!enableFly)
+            {
+                enableFly = true;
+                cabinFrontButtonConstraint.ControlDistanceX = 0.4f;
+            }
+        }
+
+        void Fly(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (!enableFly) return;
+
+            totalStartTime += time;
+
+            bool rotorUpWorking = true;
+            bool rotorBackWorking = true;
+            float rotorSpeedFactor = 0.0f;
+
+            if (totalStartTime > maxStartTime)
+            {
+                totalFlyTime += time;
+                rotorSpeedFactor = 1.2f;
+            }
+            else
+            {
+                totalFlyTime = 0.0f;
+                rotorSpeedFactor = 0.6f;
+            }
+
+            if (totalFlyTime >= maxFlyTime)
+            {
+                totalStartTime = 0.0f;
+                enableFly = false;
+
+                if (cabinFrontButtonConstraint != null)
+                    cabinFrontButtonConstraint.ControlDistanceX = 0.0f;
+            }
+
+            if (upRotorConstraint != null)
+            {
+                if (upRotorConstraint.PhysicsObject1 != null)
+                    if (upRotorConstraint.PhysicsObject1.IsBrokenRigidGroup || upRotorConstraint.IsBroken || (totalFlyTime >= maxFlyTime))
+                        rotorUpWorking = false;
+
+                if (upRotorConstraint.PhysicsObject2 != null)
+                    if (upRotorConstraint.PhysicsObject2.IsBrokenRigidGroup || upRotorConstraint.IsBroken || (totalFlyTime >= maxFlyTime))
+                        rotorUpWorking = false;
+            }
+            else
+            {
+                rotorUpWorking = false;
+            }
+
+            if (backRotorConstraint != null)
+            {
+                if (rotorUpWorking)
+                {
+                    if (backRotorConstraint.PhysicsObject1 != null)
+                        if (backRotorConstraint.PhysicsObject1.IsBrokenRigidGroup || backRotorConstraint.IsBroken)
+                            rotorBackWorking = false;
+
+                    if (backRotorConstraint.PhysicsObject2 != null)
+                        if (backRotorConstraint.PhysicsObject2.IsBrokenRigidGroup || backRotorConstraint.IsBroken)
+                            rotorBackWorking = false;
+                }
+                else
+                {
+                    rotorBackWorking = false;
+                }
+            }
+            else
+            {
+                rotorBackWorking = false;
+            }
+
+            float rotorUpAngularVelocity = 0.0f;
+            float rotorBackAngularVelocity = 0.0f;
+            Vector3 velocity = vectorZero;
+
+            if ((upRotor != null) && (totalFlyTime < maxFlyTime) && rotorUpWorking)
+            {
+                Vector3.Multiply(ref unitY, -rotorSpeedFactor * maxRotorUpAngularVelocity, out velocity);
+                upRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+                rotorUpAngularVelocity = velocity.Length;
+            }
+
+            if ((backRotor != null) && (totalFlyTime < maxFlyTime) && rotorBackWorking)
+            {
+                Vector3.Multiply(ref unitZ, rotorSpeedFactor * maxRotorBackAngularVelocity, out velocity);
+                backRotor.MainWorldTransform.SetLocalAngularVelocity(ref velocity);
+                rotorBackAngularVelocity = velocity.Length;
+            }
+
+            Vector3 gravityDirection = vectorZero;
+            scene.GetGravityDirection(ref gravityDirection);
+
+            if (rotorUpWorking)
+            {
+                if ((rotorUpAngularVelocity > maxRotorUpAngularVelocity))
+                {
+                    float upFactor = 1.0f;
+                    if (!rotorBackWorking)
+                        upFactor = 0.5f;
+
+                    Vector3.Multiply(ref gravityDirection, -maxRotorUpFlyForce * scene.GravityAcceleration * upFactor, out force);
+
+                    objectBase.WorldAccumulator.AddWorldForce(ref force);
+                }
+            }
+
+            if (rotorBackWorking && rotorUpWorking)
+            {
+                if (rotorUpAngularVelocity > maxRotorUpAngularVelocity)
+                {
+                    Vector3.Multiply(ref unitY, maxRotorBackFlyCompensationForce, out force);
+
+                    objectBase.WorldAccumulator.AddLocalTorque(ref force);
+                }
+                else
+                {
+                    Vector3.Multiply(ref unitY, maxRotorBackStartCompensationForce, out force);
+
+                    objectBase.WorldAccumulator.AddLocalTorque(ref force);
+                }
+            }
+
+            if ((rotorUpAngularVelocity > maxRotorUpAngularVelocity) && (rotorBackAngularVelocity > maxRotorBackAngularVelocity))
+            {
+                Vector3 deltaVelocity = vectorZero;
+                Vector3 moveDirection = vectorZero;
+                Vector3 position = vectorZero;
+
+                objectBase.MainWorldTransform.GetPosition(ref position);
+
+                if (totalFlyTime < maxFlyTime * 0.2f)
+                {
+                    objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                    Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                    objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                    Vector3.Subtract(ref flyPosition1, ref position, out moveDirection);
+                    moveDirection.Normalize();
+                    Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                    objectBase.WorldAccumulator.AddWorldForce(ref force);
+                }
+                else
+                    if (totalFlyTime < maxFlyTime * 0.4f)
+                    {
+                        objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                        Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                        objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                        Vector3.Subtract(ref flyPosition2, ref position, out moveDirection);
+                        moveDirection.Normalize();
+                        Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                        objectBase.WorldAccumulator.AddWorldForce(ref force);
+                    }
+                    else
+                        if (totalFlyTime < maxFlyTime * 0.6f)
+                        {
+                            objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                            Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                            objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                            Vector3.Subtract(ref flyPosition3, ref position, out moveDirection);
+                            moveDirection.Normalize();
+                            Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                            objectBase.WorldAccumulator.AddWorldForce(ref force);
+                        }
+                        else
+                            if (totalFlyTime < maxFlyTime * 0.8f)
+                            {
+                                objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                                Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                                objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                                Vector3.Subtract(ref flyPosition4, ref position, out moveDirection);
+                                moveDirection.Normalize();
+                                Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                                objectBase.WorldAccumulator.AddWorldForce(ref force);
+                            }
+                            else
+                                if (totalFlyTime < maxFlyTime * 0.95f)
+                                {
+                                    objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                                    Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                                    objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                                    Vector3.Subtract(ref endFlyPosition, ref position, out moveDirection);
+                                    moveDirection.Normalize();
+                                    Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                                    objectBase.WorldAccumulator.AddWorldForce(ref force);
+                                }
+                                else
+                                    if (totalFlyTime < maxFlyTime)
+                                    {
+                                        objectBase.WorldAccumulator.GetTotalWorldForce(ref force);
+                                        Vector3.Multiply(ref force, 0.9f, out force);
+                                        objectBase.WorldAccumulator.SetTotalWorldForce(ref force);
+
+                                        objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                                        Vector3.Multiply(ref velocity, maxMoveDirectionDamping, out velocity);
+                                        objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+
+                                        Vector3.Subtract(ref landingPosition, ref position, out moveDirection);
+                                        moveDirection.Normalize();
+                                        Vector3.Multiply(ref moveDirection, objectBase.Integral.Mass, out force);
+
+                                        objectBase.WorldAccumulator.AddWorldForce(ref force);
+                                    }
+
+                if ((upRotorBody != null) && (upBody2 != null) && (tail4 != null) && (tail3 != null) && (totalFlyTime < maxFlyTime))
+                {
+                    Vector3 axis = vectorZero;
+                    Vector3 forwardDirection = vectorZero;
+                    Vector3 tailStartPosition = vectorZero;
+                    Vector3 tailEndPosition = vectorZero;
+
+                    tail4.MainWorldTransform.GetPosition(ref tailStartPosition);
+                    tail3.MainWorldTransform.GetPosition(ref tailEndPosition);
+
+                    Vector3.Subtract(ref tailEndPosition, ref tailStartPosition, out forwardDirection);
+                    forwardDirection.Normalize();
+
+                    float bodyAngle = 0.0f;
+
+                    Vector3.Dot(ref forwardDirection, ref moveDirection, out bodyAngle);
+                    bodyAngle = (float)Math.Acos(bodyAngle);
+                    Vector3.Cross(ref moveDirection, ref forwardDirection, out axis);
+
+                    objectBase.MainWorldTransform.GetAngularVelocity(ref velocity);
+                    Vector3.Multiply(ref velocity, 0.5f, out velocity);
+                    Vector3.Multiply(ref axis, bodyAngle * (float)time, out axis);
+                    Vector3.Add(ref velocity, ref axis, out velocity);
+                    objectBase.MainWorldTransform.SetAngularVelocity(ref velocity);
+
+                    Vector3 upDirection = vectorZero;
+
+                    Vector3 upBodyStartPosition = vectorZero;
+                    Vector3 upBodyEndPosition = vectorZero;
+
+                    upRotorBody.MainWorldTransform.GetPosition(ref upBodyStartPosition);
+                    upBody2.MainWorldTransform.GetPosition(ref upBodyEndPosition);
+
+                    Vector3.Subtract(ref upBodyEndPosition, ref upBodyStartPosition, out upDirection);
+                    upDirection.Normalize();
+
+                    Vector3.Dot(ref upDirection, ref gravityDirection, out bodyAngle);
+                    bodyAngle = (float)Math.Acos(bodyAngle);
+                    Vector3.Cross(ref gravityDirection, ref upDirection, out axis);
+
+                    objectBase.MainWorldTransform.GetAngularVelocity(ref velocity);
+                    Vector3.Multiply(ref axis, bodyAngle * (float)time, out axis);
+                    Vector3.Add(ref velocity, ref axis, out velocity);
+                    objectBase.MainWorldTransform.SetAngularVelocity(ref velocity);
+                }
+
+                objectBase.MainWorldTransform.GetPosition(ref position);
+
+                if (position.Y > maxFlyHeight)
+                {
+                    float distance = position.Y - maxFlyHeight;
+
+                    Vector3.Multiply(ref gravityDirection, distance * maxHeightDamping, out deltaVelocity);
+
+                    objectBase.MainWorldTransform.GetLinearVelocity(ref velocity);
+                    Vector3.Add(ref velocity, ref deltaVelocity, out velocity);
+                    objectBase.MainWorldTransform.SetLinearVelocity(ref velocity);
+                }
+            }
+        }
+
+        void SwitchRight(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (rightDoorConstraint.IsBroken || rightDoorConstraint.PhysicsObject1.IsBrokenRigidGroup || rightDoorConstraint.PhysicsObject2.IsBrokenRigidGroup)
+            {
+                rightDoorConstraint.EnableControlAngleY = false;
+
+                cabinBodyRight1.DisableCollision(rightDoorRight, false);
+
+                cabinBodyRight2.DisableCollision(rightDoorUp, false);
+                cabinBodyRight2.DisableCollision(rightDoorDown, false);
+                cabinBodyRight2.DisableCollision(rightDoorLeft, false);
+
+                cabinBodyUp1.DisableCollision(rightDoorUp, false);
+
+                cabinBodyUp2.DisableCollision(rightDoorUp, false);
+                cabinBodyUp2.DisableCollision(rightDoorRight, false);
+
+                cabinBodyFrontRight.DisableCollision(rightDoorUp, false);
+                cabinBodyFrontRight.DisableCollision(rightDoorRight, false);
+                cabinBodyFrontRight.DisableCollision(rightDoorDown, false);
+
+                cabinBodyDown1.DisableCollision(rightDoorDown, false);
+
+                cabinBodyDown2.DisableCollision(rightDoorDown, false);
+
+                return;
+            }
+
+            PhysicsObject cameraBody = scene.GetPhysicsObjectWithActiveCamera(0).RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+
+            if (cameraBody == null)
+            {
+                rightDoorConstraint.EnableControlAngleY = true;
+                return;
+            }
+
+            bool switchColliding = objectBase.IsColliding(cameraBody);
+            bool doorColliding = objectBase.RigidGroupOwner.IsColliding(cameraBody);
+
+            if (switchColliding)
+            {
+                totalSwitchRightTime = 0.0;
+                rightDoorConstraint.EnableControlAngleY = false;
+            }
+
+            if (totalSwitchRightTime < maxSwitchRightTime)
+            {
+                Vector3.Multiply(ref unitY, 2000.0f, out torque);
+
+                objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+            }
+            else
+                if (totalSwitchRightTime < 2.0f * maxSwitchRightTime)
+                {
+                    if (!doorColliding)
+                    {
+                        Vector3.Multiply(ref unitY, -2000.0f, out torque);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+                    }
+                    else
+                    {
+                        totalSwitchRightTime = 0.0;
+                    }
+                }
+                else
+                    if (!doorColliding)
+                    {
+                        rightDoorConstraint.EnableControlAngleY = true;
+                    }
+                    else
+                    {
+                        totalSwitchRightTime = 0.0;
+                    }
+
+            totalSwitchRightTime += time;
+
+            if (totalSwitchRightTime > 2.0f * maxSwitchRightTime)
+                totalSwitchRightTime = 2.0f * maxSwitchRightTime;
+        }
+
+        void SwitchLeft(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (leftDoorConstraint.IsBroken || leftDoorConstraint.PhysicsObject1.IsBrokenRigidGroup || leftDoorConstraint.PhysicsObject2.IsBrokenRigidGroup)
+            {
+                leftDoorConstraint.EnableControlAngleY = false;
+
+                cabinBodyLeft1.DisableCollision(leftDoorRight, false);
+
+                cabinBodyLeft2.DisableCollision(leftDoorUp, false);
+                cabinBodyLeft2.DisableCollision(leftDoorDown, false);
+                cabinBodyLeft2.DisableCollision(leftDoorLeft, false);
+
+                cabinBodyUp1.DisableCollision(leftDoorUp, false);
+
+                cabinBodyUp2.DisableCollision(leftDoorUp, false);
+                cabinBodyUp2.DisableCollision(leftDoorRight, false);
+
+                cabinBodyFrontLeft.DisableCollision(leftDoorUp, false);
+                cabinBodyFrontLeft.DisableCollision(leftDoorRight, false);
+                cabinBodyFrontLeft.DisableCollision(leftDoorDown, false);
+
+                cabinBodyDown1.DisableCollision(leftDoorDown, false);
+
+                cabinBodyDown2.DisableCollision(leftDoorDown, false);
+
+                return;
+            }
+
+            PhysicsObject cameraBody = scene.GetPhysicsObjectWithActiveCamera(0).RigidGroupOwner.FindChildPhysicsObject(cameraBodyName, true, true);
+
+            if (cameraBody == null)
+            {
+                leftDoorConstraint.EnableControlAngleY = true;
+                return;
+            }
+
+            bool switchColliding = objectBase.IsColliding(cameraBody);
+            bool doorColliding = objectBase.RigidGroupOwner.IsColliding(cameraBody);
+
+            if (switchColliding)
+            {
+                totalSwitchLeftTime = 0.0;
+                leftDoorConstraint.EnableControlAngleY = false;
+            }
+
+            if (totalSwitchLeftTime < maxSwitchLeftTime)
+            {
+                Vector3.Multiply(ref unitY, -2000.0f, out torque);
+
+                objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+            }
+            else
+                if (totalSwitchLeftTime < 2.0f * maxSwitchLeftTime)
+                {
+                    if (!doorColliding)
+                    {
+                        Vector3.Multiply(ref unitY, 2000.0f, out torque);
+
+                        objectBase.RigidGroupOwner.WorldAccumulator.SetLocalTorque(ref torque);
+                    }
+                    else
+                    {
+                        totalSwitchLeftTime = 0.0;
+                    }
+                }
+                else
+                    if (!doorColliding)
+                    {
+                        leftDoorConstraint.EnableControlAngleY = true;
+                    }
+                    else
+                    {
+                        totalSwitchLeftTime = 0.0;
+                    }
+
+            totalSwitchLeftTime += time;
+
+            if (totalSwitchLeftTime > 2.0f * maxSwitchLeftTime)
+                totalSwitchLeftTime = 2.0f * maxSwitchLeftTime;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Lamp1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Lamp1Animation1.cs
new file mode 100644
index 0000000..35972b3
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Lamp1Animation1.cs
@@ -0,0 +1,162 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Lamp1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string yellowName;
+        string particleName;
+        string soundName;
+
+        Shape sphere;
+        PhysicsObject bodyMain;
+        PhysicsObject bodyEmitter;
+        PhysicsObject bodyLight;
+        Constraint constraint1;
+
+        int frameCount;
+
+        PhysicsObject particle;
+        StringBuilder particleNameBuilder;
+        string particleInstanceIndexName;
+        int particleNameLength;
+        int particleCount;
+        int maxParticleSimulationFrameCount;
+        int maxParticleFrameCount;
+        int maxParticleCount;
+
+        Random random;
+
+        Vector3 position;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+
+        public Lamp1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            yellowName = "Yellow";
+            particleName = "Lamp 1 Particle" + instanceIndexName + " ";
+            soundName = "Roll";
+
+            particleNameBuilder = new StringBuilder(particleName);
+            particleNameLength = particleNameBuilder.Length;
+            maxParticleSimulationFrameCount = 80;
+            maxParticleFrameCount = 4;
+            maxParticleCount = maxParticleSimulationFrameCount / maxParticleFrameCount;
+
+            random = new Random(instanceIndex);
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+            bodyMain = scene.Factory.PhysicsObjectManager.Find("Lamp 1 Body Main" + instanceIndexName);
+            bodyEmitter = scene.Factory.PhysicsObjectManager.Find("Lamp 1 Body Emitter" + instanceIndexName);
+            bodyLight = scene.Factory.PhysicsObjectManager.Find("Lamp 1 Body Light" + instanceIndexName);
+            constraint1 = scene.Factory.ConstraintManager.Find("Lamp 1 Constraint 1" + instanceIndexName);
+
+            frameCount = 0;
+            particleCount = -1;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Lamp 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Flame);
+        }
+
+        public void Flame(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if (objectBase.IsBrokenRigidGroup || (bodyEmitter == null) || (constraint1 == null) || constraint1.IsBroken)
+            {
+                if ((bodyLight != null) && (bodyLight.Light != null) && bodyLight.Light.Enabled)
+                    bodyLight.Light.Enabled = false;
+
+                return;
+            }
+
+            frameCount++;
+
+            if (frameCount > maxParticleFrameCount)
+            {
+                frameCount = 0;
+
+                bodyLight.Light.Intensity = (float)random.NextDouble() * 0.2f + 0.8f;
+                
+                particleCount = (particleCount + 1) % maxParticleCount;
+                particleNameBuilder.Remove(particleNameLength, particleNameBuilder.Length - particleNameLength);
+                particleNameBuilder.Append(particleCount);
+                particleInstanceIndexName = particleNameBuilder.ToString();
+
+                particle = scene.Factory.PhysicsObjectManager.FindOrCreate(particleInstanceIndexName);
+
+                particle.Shape = sphere;
+                particle.UserDataStr = sphereName;
+                particle.Material.UserDataStr = yellowName;
+                particle.Material.TransparencyFactor = 0.9f;
+                particle.Material.TransparencyStepFactor = -0.01f;
+                particle.CreateSound(true);
+                particle.Sound.Range = 50.0f;
+                particle.Sound.AmplitudeFactor = 1000.0f;
+                particle.Sound.MinAmplitudeFactor = 0.0f;
+                particle.Sound.UserDataStr = soundName;
+
+                bodyEmitter.MainWorldTransform.GetPosition(ref position);
+
+                particle.InitLocalTransform.SetRotation(ref matrixIdentity);
+                particle.InitLocalTransform.SetPosition(ref position);
+
+                Vector3 velocity = vectorZero;
+
+                scene.GetGravityDirection(ref velocity);
+
+                Vector3.Multiply(ref velocity, -10.0f, out velocity);
+
+                particle.InitLocalTransform.SetLinearVelocity(ref velocity);
+                particle.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                particle.Integral.SetDensity(0.002f);
+                particle.DisableCollision(bodyMain, true);
+                particle.MaxSimulationFrameCount = maxParticleSimulationFrameCount;
+                particle.MaxDisableCollisionFrameCount = 10;
+                particle.EnableCursorInteraction = false;
+                particle.EnableLocalGravity = true;
+                particle.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+                particle.Material.TransparencySecondPass = false;
+
+                scene.UpdateFromInitLocalTransform(particle);
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuAnimation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuAnimation1.cs
new file mode 100644
index 0000000..9bb5175
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuAnimation1.cs
@@ -0,0 +1,454 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class MenuAnimation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string defaultName;
+
+        PhysicsObject infoDescription;
+        PhysicsObject infoScreen;
+
+        MenuData userData;
+
+        bool enableStartInfo;
+        PhysicsObject switchPhysicsObject;
+        int baseSceneIndex;
+
+        public PhysicsObject CurrentSwitch { get { return switchPhysicsObject; } }
+
+        Vector3 vectorZero;
+        Vector3 unitZ;
+
+        public MenuAnimation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            defaultName = "Wood1";
+
+            vectorZero = Vector3.Zero;
+            unitZ = Vector3.UnitZ;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            enableStartInfo = true;
+            switchPhysicsObject = null;
+            baseSceneIndex = 0;
+        }
+
+        public void SetControllers()
+        {
+            infoDescription = scene.Factory.PhysicsObjectManager.Find("Info Description" + instanceIndexName);
+            infoScreen = scene.Factory.PhysicsObjectManager.Find("Info Screen" + instanceIndexName);
+
+            int sceneCount = 0;
+            PhysicsObject objectBase = null;
+            string switchInstanceName = null;
+            string switchSliderConstraintName = null;
+
+            enableStartInfo = true;
+            switchPhysicsObject = null;
+
+            userData.OldMouseState = demo.GetMouseState();
+            userData.OldSceneIndex = -1;
+            baseSceneIndex = 0;
+
+            for (int i = 0; i < 10; i++)
+            {
+                switchInstanceName = "Switch " + i.ToString();
+                switchSliderConstraintName = switchInstanceName + " Slider Constraint" + instanceIndexName;
+
+                objectBase = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+
+                if (objectBase != null)
+                {
+                    userData.SwitchSliderConstraintName = switchSliderConstraintName;
+                    userData.SceneIndex = sceneCount;
+                    userData.SwitchIndex = i;
+                    sceneCount++;
+
+                    objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+                    objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Switch);
+                }
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch Right" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                userData.SwitchSliderConstraintName = "Switch Right Slider Constraint" + instanceIndexName;
+                userData.SceneIndex = 0;
+                userData.SwitchIndex = 0;
+
+                objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchRight);
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch Left" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                userData.SwitchSliderConstraintName = "Switch Left Slider Constraint" + instanceIndexName;
+                userData.SceneIndex = 0;
+                userData.SwitchIndex = 0;
+
+                objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(SwitchLeft);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            PhysicsObject objectBase = null;
+            string switchInstanceName = null;
+
+            enableStartInfo = true;
+            switchPhysicsObject = null;
+
+            for (int i = 0; i < 10; i++)
+            {
+                switchInstanceName = "Switch " + i.ToString();
+
+                objectBase = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+
+                if (objectBase != null)
+                {
+                    userData = (MenuData)objectBase.UserControllers.PostTransformMethodArgs.UserDataObj;
+
+                    userData.OldMouseState = demo.GetMouseState();
+
+                    objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+                }
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch Right" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                userData = (MenuData)objectBase.UserControllers.PostTransformMethodArgs.UserDataObj;
+
+                userData.OldMouseState = demo.GetMouseState();
+
+                objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch Left" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                userData = (MenuData)objectBase.UserControllers.PostTransformMethodArgs.UserDataObj;
+
+                userData.OldMouseState = demo.GetMouseState();
+
+                objectBase.UserControllers.PostTransformMethodArgs.UserDataObj = userData;
+            }
+        }
+
+        void Switch(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            MenuData userData = (MenuData)args.UserDataObj;
+
+            string switchSliderConstraintName = userData.SwitchSliderConstraintName;
+            int sceneIndex = baseSceneIndex + userData.SceneIndex;
+            int oldSceneIndex = userData.OldSceneIndex;
+            int switchIndex = userData.SwitchIndex;
+
+            string sceneName = null;
+            string sceneScreenName = defaultName;
+
+            if ((sceneIndex >= 0) && (sceneIndex < demo.Scenes.Count))
+            {
+                sceneName = demo.Scenes[sceneIndex].SceneName;
+
+                if ((switchPhysicsObject != objectBase) || (sceneIndex != oldSceneIndex))
+                {
+                    if (demo.Textures.ContainsKey(sceneName))
+                        sceneScreenName = sceneName;
+
+                    objectBase.Material.UserDataStr = sceneScreenName;
+                }
+            }
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            Vector3 switchVelocity;
+
+            ScreenToRayController screenToRayController = physicsObjectWithActiveCamera.InternalControllers.ScreenToRayController;
+
+            Constraint switchSliderConstraint = scene.Factory.ConstraintManager.Find(switchSliderConstraintName);
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoMouseState oldMouseState = userData.OldMouseState;
+            int deltaX = mouseState.X - oldMouseState.X;
+            int deltaY = mouseState.Y - oldMouseState.Y;
+
+            if (switchSliderConstraint != null)
+            {
+                if (screenToRayController.IsHitPhysicsObject && (screenToRayController.HitPhysicsObject == objectBase))
+                {
+                    if (((switchPhysicsObject != objectBase) && !mouseState[MouseButton.Left] && !mouseState[MouseButton.Middle] && !mouseState[MouseButton.Right] && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)) || ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ < -4.95f)) || ((switchPhysicsObject == objectBase) && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)))
+                    {
+                        enableStartInfo = false;
+
+                        if (sceneName != null)
+                        {
+                            if (infoScreen != null)
+                            {
+                                if ((switchPhysicsObject != objectBase) || (sceneIndex != oldSceneIndex))
+                                    infoScreen.Material.UserDataStr = sceneScreenName;
+
+                                infoScreen.EnableDrawing = true;
+                            }
+
+                            if (infoDescription != null)
+                                infoDescription.EnableDrawing = true;
+                        }
+                        else
+                        {
+                            if (infoDescription != null)
+                                infoDescription.EnableDrawing = false;
+
+                            if (infoScreen != null)
+                                infoScreen.EnableDrawing = false;
+                        }
+
+                        switchPhysicsObject = objectBase;
+
+                        Vector3.Multiply(ref unitZ, -10.0f, out switchVelocity);
+                        objectBase.MainWorldTransform.SetLinearVelocity(ref switchVelocity);
+                        objectBase.MainWorldTransform.SetAngularVelocity(ref vectorZero);
+                    }
+
+                    if ((sceneName != null) && (switchPhysicsObject == objectBase) && mouseState[MouseButton.Left] && !oldMouseState[MouseButton.Left] && (switchSliderConstraint.ControlDistanceZ <= -0.5f))
+                        demo.SceneIndex = sceneIndex;
+                }
+                else
+                {
+                    if ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ >= -0.05))
+                    {
+                        if (infoScreen != null)
+                            infoScreen.EnableDrawing = false;
+
+                        if (infoDescription != null)
+                            infoDescription.EnableDrawing = false;
+
+                        switchPhysicsObject = null;
+                    }
+                }
+            }
+
+            if ((sceneName != null) && enableStartInfo && (demo.SceneIndex == sceneIndex))
+            {
+                if (infoScreen != null)
+                {
+                    if ((switchPhysicsObject != objectBase) || (sceneIndex != oldSceneIndex))
+                        infoScreen.Material.UserDataStr = sceneScreenName;
+
+                    infoScreen.EnableDrawing = true;
+                }
+
+                if (infoDescription != null)
+                    infoDescription.EnableDrawing = true;
+            }
+
+            userData.OldMouseState = mouseState;
+            userData.OldSceneIndex = sceneIndex;
+            args.UserDataObj = userData;
+        }
+
+        void SwitchRight(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            MenuData userData = (MenuData)args.UserDataObj;
+
+            string switchSliderConstraintName = userData.SwitchSliderConstraintName;
+            int sceneIndex = userData.SceneIndex;
+            int switchIndex = userData.SwitchIndex;
+
+            if ((baseSceneIndex + 10) < demo.Scenes.Count)
+                objectBase.Material.SetAmbient(0.4f, 0.4f, 0.25f);
+            else
+                objectBase.Material.SetAmbient(0.4f, 0.4f, 0.4f);
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            Vector3 switchVelocity;
+
+            ScreenToRayController screenToRayController = physicsObjectWithActiveCamera.InternalControllers.ScreenToRayController;
+
+            Constraint switchSliderConstraint = scene.Factory.ConstraintManager.Find(switchSliderConstraintName);
+
+            string sceneName = demo.Scenes[sceneIndex].SceneName;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoMouseState oldMouseState = userData.OldMouseState;
+            int deltaX = mouseState.X - oldMouseState.X;
+            int deltaY = mouseState.Y - oldMouseState.Y;
+
+            if (switchSliderConstraint != null)
+            {
+                if (screenToRayController.IsHitPhysicsObject && (screenToRayController.HitPhysicsObject == objectBase))
+                {
+                    if (((switchPhysicsObject != objectBase) && !mouseState[MouseButton.Left] && !mouseState[MouseButton.Middle] && !mouseState[MouseButton.Right] && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)) || ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ < -4.95f)) || ((switchPhysicsObject == objectBase) && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)))
+                    {
+                        enableStartInfo = false;
+
+                        if (infoScreen != null)
+                            infoScreen.EnableDrawing = false;
+
+                        if (infoDescription != null)
+                            infoDescription.EnableDrawing = false;
+
+                        switchPhysicsObject = objectBase;
+
+                        Vector3.Multiply(ref unitZ, -10.0f, out switchVelocity);
+                        objectBase.MainWorldTransform.SetLinearVelocity(ref switchVelocity);
+                        objectBase.MainWorldTransform.SetAngularVelocity(ref vectorZero);
+                    }
+
+                    if ((switchPhysicsObject == objectBase) && mouseState[MouseButton.Left] && !oldMouseState[MouseButton.Left] && (switchSliderConstraint.ControlDistanceZ <= -0.5f))
+                        baseSceneIndex = Math.Min(baseSceneIndex + 1, Math.Max(demo.Scenes.Count - 10, 0));
+                }
+                else
+                {
+                    if ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ >= -0.05))
+                    {
+                        if (infoScreen != null)
+                            infoScreen.EnableDrawing = false;
+
+                        if (infoDescription != null)
+                            infoDescription.EnableDrawing = false;
+
+                        switchPhysicsObject = null;
+                    }
+                }
+            }
+
+            userData.OldMouseState = mouseState;
+            args.UserDataObj = userData;
+        }
+
+        void SwitchLeft(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            MenuData userData = (MenuData)args.UserDataObj;
+
+            string switchSliderConstraintName = userData.SwitchSliderConstraintName;
+            int sceneIndex = userData.SceneIndex;
+            int switchIndex = userData.SwitchIndex;
+
+            if (baseSceneIndex > 0)
+                objectBase.Material.SetAmbient(0.4f, 0.4f, 0.25f);
+            else
+                objectBase.Material.SetAmbient(0.4f, 0.4f, 0.4f);
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            Vector3 switchVelocity;
+
+            ScreenToRayController screenToRayController = physicsObjectWithActiveCamera.InternalControllers.ScreenToRayController;
+
+            Constraint switchSliderConstraint = scene.Factory.ConstraintManager.Find(switchSliderConstraintName);
+
+            string sceneName = demo.Scenes[sceneIndex].SceneName;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoMouseState oldMouseState = userData.OldMouseState;
+            int deltaX = mouseState.X - oldMouseState.X;
+            int deltaY = mouseState.Y - oldMouseState.Y;
+
+            if (switchSliderConstraint != null)
+            {
+                if (screenToRayController.IsHitPhysicsObject && (screenToRayController.HitPhysicsObject == objectBase))
+                {
+                    if (((switchPhysicsObject != objectBase) && !mouseState[MouseButton.Left] && !mouseState[MouseButton.Middle] && !mouseState[MouseButton.Right] && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)) || ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ < -4.95f)) || ((switchPhysicsObject == objectBase) && (Math.Abs(deltaX) + Math.Abs(deltaY) != 0)))
+                    {
+                        enableStartInfo = false;
+
+                        if (infoScreen != null)
+                            infoScreen.EnableDrawing = false;
+
+                        if (infoDescription != null)
+                            infoDescription.EnableDrawing = false;
+
+                        switchPhysicsObject = objectBase;
+
+                        Vector3.Multiply(ref unitZ, -10.0f, out switchVelocity);
+                        objectBase.MainWorldTransform.SetLinearVelocity(ref switchVelocity);
+                        objectBase.MainWorldTransform.SetAngularVelocity(ref vectorZero);
+                    }
+
+                    if ((switchPhysicsObject == objectBase) && mouseState[MouseButton.Left] && !oldMouseState[MouseButton.Left] && (switchSliderConstraint.ControlDistanceZ <= -0.5f))
+                        baseSceneIndex = Math.Max(baseSceneIndex - 1, 0);
+                }
+                else
+                {
+                    if ((switchPhysicsObject == objectBase) && (switchSliderConstraint.ControlDistanceZ >= -0.05))
+                    {
+                        if (infoScreen != null)
+                            infoScreen.EnableDrawing = false;
+
+                        if (infoDescription != null)
+                            infoDescription.EnableDrawing = false;
+
+                        switchPhysicsObject = null;
+                    }
+                }
+            }
+
+            userData.OldMouseState = mouseState;
+            args.UserDataObj = userData;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuData.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuData.cs
new file mode 100644
index 0000000..bc92c31
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/MenuData.cs
@@ -0,0 +1,24 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public struct MenuData
+    {
+        public string SwitchSliderConstraintName;
+        public DemoMouseState OldMouseState;
+        public int SceneIndex;
+        public int OldSceneIndex;
+        public int SwitchIndex;
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/PointLightAnimation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/PointLightAnimation1.cs
new file mode 100644
index 0000000..39af33a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/PointLightAnimation1.cs
@@ -0,0 +1,76 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class PointLightAnimation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        float intensity;
+        float minIntensity;
+        float maxIntensity;
+        float stepIntensity;
+
+        public PointLightAnimation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers(float minIntensity, float maxIntensity, float stepIntensity)
+        {
+            this.minIntensity = minIntensity;
+            this.maxIntensity = maxIntensity;
+            this.stepIntensity = stepIntensity;
+
+            intensity = minIntensity;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Light Point" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Flash);
+        }
+
+        public void Flash(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (objectBase.Light == null) return;
+
+            if ((intensity >= minIntensity) && (intensity <= maxIntensity))
+                intensity += stepIntensity;
+
+            if (intensity < minIntensity)
+            {
+                intensity = minIntensity;
+                stepIntensity = -stepIntensity;
+            }
+
+            if (intensity > maxIntensity)
+            {
+                intensity = maxIntensity;
+                stepIntensity = -stepIntensity;
+            }
+
+            objectBase.Light.Intensity = intensity;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/SimpleCameraAnimation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/SimpleCameraAnimation1.cs
new file mode 100644
index 0000000..171d485
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/SimpleCameraAnimation1.cs
@@ -0,0 +1,239 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class SimpleCameraAnimation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string shotName;
+        string shotBaseName;
+        string shotLightName;
+
+        Shape sphere;
+
+        DemoMouseState oldMouseState;
+        DemoKeyboardState oldKeyboardState;
+
+        Vector3 position;
+        Vector3 direction;
+        Matrix4 rotation;
+        Matrix4 cameraRotation;
+
+        Random random;
+
+        Vector3 vectorZero;
+        Matrix4 matrixIdentity;
+        Quaternion quaternionIdentity;
+
+        public SimpleCameraAnimation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+            shotName = "Simple Camera Shot" + instanceIndexName + " ";
+            shotBaseName = "Simple Camera Shot Object" + instanceIndexName + " ";
+            shotLightName = "Simple Camera Shot Light" + instanceIndexName + " ";
+
+            random = new Random();
+
+            vectorZero = Vector3.Zero;
+            matrixIdentity = Matrix4.Identity;
+            quaternionIdentity = Quaternion.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Simple Camera" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            oldMouseState = demo.GetMouseState();
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            float time = (float)args.Time;
+
+            Vector3 deltaRotation = vectorZero;
+            Vector3 deltaTranslation = vectorZero;
+            float rotationSpeed = 8.0f;
+            float translationSpeed = 8.0f;
+            bool enableShot = false;
+
+            DemoMouseState mouseState = demo.GetMouseState();
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (mouseState[MouseButton.Right])
+            {
+                deltaRotation.Y += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.X - oldMouseState.X) * time);
+                deltaRotation.X += MathHelper.DegreesToRadians(rotationSpeed * (mouseState.Y - oldMouseState.Y) * time);
+            }
+
+            if (mouseState[MouseButton.Middle] && !oldMouseState[MouseButton.Middle])
+                enableShot = true;
+
+            if ((keyboardState[Key.ControlRight] && !oldKeyboardState[Key.ControlRight]) ||
+               (keyboardState[Key.ControlLeft] && !oldKeyboardState[Key.ControlLeft]))
+                enableShot = true;
+
+            if (keyboardState[Key.W])
+                deltaTranslation.Z += translationSpeed * time;
+
+            if (keyboardState[Key.S])
+                deltaTranslation.Z -= translationSpeed * time;
+
+            if (keyboardState[Key.D])
+                deltaTranslation.X += translationSpeed * time;
+
+            if (keyboardState[Key.A])
+                deltaTranslation.X -= translationSpeed * time;
+
+            oldMouseState = mouseState;
+            oldKeyboardState = keyboardState;
+
+            if (deltaRotation.LengthSquared != 0.0f)
+            {
+                Vector3 euler = vectorZero;
+                objectBase.Camera.GetEuler(ref euler);
+                Vector3.Add(ref euler, ref deltaRotation, out euler);
+                objectBase.Camera.SetEuler(ref euler);
+
+                Matrix4 rotationX, rotationY;
+                Matrix4.CreateRotationX(-euler.X, out rotationX);
+                Matrix4.CreateRotationY(-euler.Y, out rotationY);
+                Matrix4.Mult(ref rotationY, ref rotationX, out cameraRotation);
+
+                objectBase.Camera.SetRotation(ref cameraRotation);
+
+                objectBase.MainWorldTransform.SetTransposeRotation(ref cameraRotation);
+                objectBase.RecalculateMainTransform();
+            }
+
+            if (deltaTranslation.LengthSquared != 0.0f)
+            {
+                objectBase.MainWorldTransform.GetRotation(ref rotation);
+                Vector3.TransformVector(ref deltaTranslation, ref rotation, out direction);
+
+                objectBase.MainWorldTransform.GetPosition(ref position);
+                Vector3.Add(ref position, ref direction, out position);
+                objectBase.MainWorldTransform.SetPosition(ref position);
+
+                objectBase.RecalculateMainTransform();
+            }
+
+            objectBase.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectBase.MainWorldTransform.GetPosition(ref position);
+            objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectBase.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectBase.Camera.UpdateFrustum();
+
+            if (enableShot)
+            {
+                Vector3 shotScale, shotColor;
+
+                string frameCountName = scene.SimulationFrameCount.ToString();
+                PhysicsObject shot = scene.Factory.PhysicsObjectManager.Create(shotName + frameCountName);
+                PhysicsObject shotBase = scene.Factory.PhysicsObjectManager.Create(shotBaseName + frameCountName);
+                PhysicsObject shotLight = scene.Factory.PhysicsObjectManager.Create(shotLightName + frameCountName);
+
+                shot.AddChildPhysicsObject(shotBase);
+                shot.AddChildPhysicsObject(shotLight);
+
+                shotScale = shotColor = vectorZero;
+
+                shotScale.X = shotScale.Y = shotScale.Z = 0.5f;
+
+                objectBase.MainWorldTransform.GetPosition(ref position);
+                objectBase.Camera.GetTransposeRotation(ref cameraRotation);
+
+                direction.X = cameraRotation.Row2.X;
+                direction.Y = cameraRotation.Row2.Y;
+                direction.Z = cameraRotation.Row2.Z;
+
+                Vector3.Multiply(ref direction, 300.0f, out direction);
+
+                shot.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot.InitLocalTransform.SetPosition(ref position);
+                shot.InitLocalTransform.SetLinearVelocity(ref direction);
+                shot.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot.MaxSimulationFrameCount = 200;
+                //shot.EnableLocalGravity = true;
+
+                shotBase.Shape = sphere;
+                shotBase.UserDataStr = sphereName;
+                shotBase.InitLocalTransform.SetScale(ref shotScale);
+                shotBase.Integral.SetDensity(10.0f);
+                shotBase.Material.RigidGroup = true;
+                shotBase.EnableBreakRigidGroup = false;
+                shotBase.EnableCollisions = true;
+                shotBase.DisableCollision(objectBase, true);
+                shotBase.MaxDisableCollisionFrameCount = 50;
+
+                shotLight.Shape = sphere;
+                shotLight.UserDataStr = sphereName;
+                shotLight.CreateLight(true);
+                shotLight.Light.Type = PhysicsLightType.Point;
+                shotLight.Light.Range = 20.0f;
+
+                shotColor.X = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Y = (float)Math.Max(random.NextDouble(), random.NextDouble());
+                shotColor.Z = (float)Math.Max(random.NextDouble(), random.NextDouble());
+
+                shotLight.Light.SetDiffuse(ref shotColor);
+                shotLight.InitLocalTransform.SetScale(20.0f);
+                shotLight.Material.RigidGroup = true;
+                shotLight.EnableBreakRigidGroup = false;
+                shotLight.EnableCollisions = false;
+                shotLight.EnableCursorInteraction = false;
+                shotLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                scene.UpdateFromInitLocalTransform(shot);
+            }
+
+            objectBase.Camera.UpdatePhysicsObjects(true, true, true);
+            objectBase.Camera.SortDrawPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+            objectBase.Camera.SortTransparentPhysicsObjects(PhysicsCameraSortOrderType.DrawPriorityShapePrimitiveType);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch1Animation1.cs
new file mode 100644
index 0000000..b49f453
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch1Animation1.cs
@@ -0,0 +1,66 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Switch1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        Switch1 switchObject;
+
+        string switchShapeName;
+
+        public Switch1Animation1(Demo demo, Switch1 switchObject)
+        {
+            this.demo = demo;
+            this.switchObject = switchObject;
+
+            switchShapeName = "Switch 1 Shape";
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch 1 Switch");
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Switch);
+        }
+
+        void Switch(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            objectBase.UpdateCollidingPhysicsObjects(false);
+
+            PhysicsObject switchShape = objectBase.RigidGroupOwner.FindChildPhysicsObject(switchShapeName, true, false);
+
+            if (switchShape != null)
+            {
+                if (objectBase.CollidingPhysicsObjectCount != 0)
+                    switchShape.Material.TransparencyFactor = 1.0f;
+                else
+                    switchShape.Material.TransparencyFactor = 0.5f;
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch2Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch2Animation1.cs
new file mode 100644
index 0000000..eec93ec
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Switch2Animation1.cs
@@ -0,0 +1,66 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Switch2Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        Switch2 switchObject;
+
+        string switchShapeName;
+
+        public Switch2Animation1(Demo demo, Switch2 switchObject)
+        {
+            this.demo = demo;
+            this.switchObject = switchObject;
+
+            switchShapeName = "Switch 2 Shape";
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Switch 2 Switch");
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Switch);
+        }
+
+        void Switch(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            objectBase.UpdateCollidingPhysicsObjects(false);
+
+            PhysicsObject switchShape = objectBase.RigidGroupOwner.FindChildPhysicsObject(switchShapeName, true, false);
+
+            if (switchShape != null)
+            {
+                if (objectBase.CollidingPhysicsObjectCount != 0)
+                    switchShape.Material.TransparencyFactor = 0.5f;
+                else
+                    switchShape.Material.TransparencyFactor = 1.0f;
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Vehicle1Animation1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Vehicle1Animation1.cs
new file mode 100644
index 0000000..3ba32d8
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Animation/Vehicle1Animation1.cs
@@ -0,0 +1,465 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Text;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Vehicle1Animation1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string sphereName;
+        string shot1Name;
+        string shot1BaseName;
+        string shot1LightName;
+        string shot2Name;
+        string shot2BaseName;
+        string shot2LightName;
+        string amphibian1BodyName;
+        string amphibian1TurretBodyDownName;
+        string amphibian1TurretConstraintName;
+        string yellowName;
+
+        Shape sphere;
+        PhysicsObject bodyUp;
+        PhysicsObject bodyDown;
+        PhysicsObject turretBodyUp;
+        PhysicsObject turretBodyDown;
+        PhysicsObject turretGun1;
+        PhysicsObject turretGun2;
+        Constraint turretConstraint;
+
+        double totalTime;
+        int frameCount;
+        int shotFrameCount;
+
+        PhysicsObject shot1;
+        PhysicsObject shot1Base;
+        PhysicsObject shot1Light;
+        PhysicsObject shot2;
+        PhysicsObject shot2Base;
+        PhysicsObject shot2Light;
+        StringBuilder shot1NameBuilder;
+        StringBuilder shot1BaseNameBuilder;
+        StringBuilder shot1LightNameBuilder;
+        StringBuilder shot2NameBuilder;
+        StringBuilder shot2BaseNameBuilder;
+        StringBuilder shot2LightNameBuilder;
+        string shotInstanceIndexName;
+        string shotBaseInstanceIndexName;
+        string shotLightInstanceIndexName;
+        int shot1NameLength;
+        int shot1BaseNameLength;
+        int shot1LightNameLength;
+        int shot2NameLength;
+        int shot2BaseNameLength;
+        int shot2LightNameLength;
+        int shotCount;
+        int maxShotSimulationFrameCount;
+        int maxShotFrameCount;
+        int maxShotCount;
+
+        Vector3 vectorZero;
+        Vector3 unitY;
+        Matrix4 matrixIdentity;
+
+        public Vehicle1Animation1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            sphereName = "Sphere";
+
+            shot1Name = "Vehicle 1 Gun 1 Shot" + instanceIndexName + " ";
+            shot1BaseName = "Vehicle 1 Gun 1 Shot Base" + instanceIndexName + " ";
+            shot1LightName = "Vehicle 1 Gun 1 Shot Light" + instanceIndexName + " ";
+
+            shot2Name = "Vehicle 1 Gun 2 Shot" + instanceIndexName + " ";
+            shot2BaseName = "Vehicle 1 Gun 2 Shot Base" + instanceIndexName + " ";
+            shot2LightName = "Vehicle 1 Gun 2 Shot Light" + instanceIndexName + " ";
+
+            amphibian1BodyName = "Amphibian 1 Body" + instanceIndexName;
+            amphibian1TurretBodyDownName = "Amphibian 1 Turret Body Down" + instanceIndexName;
+            amphibian1TurretConstraintName = "Amphibian 1 Turret Constraint" + instanceIndexName;
+            yellowName = "Yellow";
+
+            shot1NameBuilder = new StringBuilder(shot1Name);
+            shot1BaseNameBuilder = new StringBuilder(shot1BaseName);
+            shot1LightNameBuilder = new StringBuilder(shot1LightName);
+
+            shot2NameBuilder = new StringBuilder(shot2Name);
+            shot2BaseNameBuilder = new StringBuilder(shot2BaseName);
+            shot2LightNameBuilder = new StringBuilder(shot2LightName);
+
+            shot1NameLength = shot1NameBuilder.Length;
+            shot1BaseNameLength = shot1BaseNameBuilder.Length;
+            shot1LightNameLength = shot1LightNameBuilder.Length;
+
+            shot2NameLength = shot2NameBuilder.Length;
+            shot2BaseNameLength = shot2BaseNameBuilder.Length;
+            shot2LightNameLength = shot2LightNameBuilder.Length;
+
+            maxShotSimulationFrameCount = 100;
+            maxShotFrameCount = 10;
+            maxShotCount = maxShotSimulationFrameCount / maxShotFrameCount;
+
+            vectorZero = Vector3.Zero;
+            unitY = Vector3.UnitY;
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            sphere = scene.Factory.ShapeManager.Find("Sphere");
+            bodyUp = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Body Up" + instanceIndexName);
+            bodyDown = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Body Down" + instanceIndexName);
+            turretBodyUp = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Turret Body Up" + instanceIndexName);
+            turretBodyDown = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Turret Body Down" + instanceIndexName);
+            turretGun1 = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Turret Gun 1" + instanceIndexName);
+            turretGun2 = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Turret Gun 2" + instanceIndexName);
+            turretConstraint = scene.Factory.ConstraintManager.Find("Vehicle 1 Turret Constraint" + instanceIndexName);
+
+            totalTime = 0.0;
+            frameCount = 0;
+            shotFrameCount = 0;
+            shotCount = -1;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Body" + instanceIndexName);
+            if (objectBase != null)
+                objectBase.UserControllers.PostTransformMethods += new SimulateMethod(Move);
+        }
+
+        public void Move(SimulateMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            float time = args.Time;
+
+            if ((bodyUp == null) || (bodyDown == null) || (turretBodyUp == null) || (turretBodyDown == null) || (turretGun1 == null) || (turretGun2 == null) || (turretConstraint == null))
+                return;
+
+            totalTime += time;
+
+            PhysicsObject turret = turretBodyUp.RigidGroupOwner;
+
+            if (objectBase.IsBrokenRigidGroup || turret.IsBrokenRigidGroup || turretConstraint.IsBroken)
+                return;
+
+            Vector3 gravityDirection = vectorZero;
+            Vector3 upObjectForce = vectorZero;
+            Vector3 upTurretForce = vectorZero;
+            Vector3 distance = vectorZero;
+            Vector3 direction = vectorZero;
+
+            scene.GetGravityDirection(ref gravityDirection);
+
+            Vector3.Multiply(ref gravityDirection, -scene.GravityAcceleration * objectBase.Integral.Mass, out upObjectForce);
+            Vector3.Multiply(ref gravityDirection, -scene.GravityAcceleration * turret.Integral.Mass, out upTurretForce);
+
+            objectBase.WorldAccumulator.AddWorldForce(ref upObjectForce);
+            turret.WorldAccumulator.AddWorldForce(ref upTurretForce);
+
+            PhysicsObject amphibian1Body = scene.Factory.PhysicsObjectManager.Find(amphibian1BodyName);
+            PhysicsObject amphibian1TurretBodyDown = scene.Factory.PhysicsObjectManager.Find(amphibian1TurretBodyDownName);
+            Constraint amphibian1TurretConstraint = scene.Factory.ConstraintManager.Find(amphibian1TurretConstraintName);
+            Vector3 bodyDownPosition = vectorZero;
+
+            if ((amphibian1Body != null) && (amphibian1TurretBodyDown != null) && (amphibian1TurretConstraint != null) && !amphibian1Body.IsBrokenRigidGroup && !amphibian1TurretConstraint.IsBroken)
+            {
+                Vector3 amphibianTurretPosition = vectorZero;
+
+                amphibian1TurretBodyDown.RigidGroupOwner.MainWorldTransform.GetPosition(ref amphibianTurretPosition);
+                bodyDown.MainWorldTransform.GetPosition(ref bodyDownPosition);
+
+                Vector3.Subtract(ref amphibianTurretPosition, ref bodyDownPosition, out distance);
+                Vector3.Normalize(ref distance, out direction);
+            }
+
+            Vector3 force = vectorZero;
+            Vector3 right = vectorZero;
+
+            Vector3.Cross(ref direction, ref unitY, out right);
+            Vector3.Multiply(ref right, 100.0f, out right);
+
+            if (frameCount < 200)
+                Vector3.Subtract(ref force, ref right, out force);
+            else
+                Vector3.Add(ref force, ref right, out force);
+
+            if (frameCount > 400)
+                frameCount = 0;
+
+            if (distance.Length > 100.0f)
+            {
+                Vector3.Multiply(ref direction, 1000.0f, out right);
+                Vector3.Add(ref force, ref right, out force);
+            }
+
+            if (distance.Y > 0.0f)
+                force.Y += distance.Y * 100.0f;
+
+            objectBase.WorldAccumulator.AddWorldForce(ref force);
+            turret.WorldAccumulator.AddWorldForce(ref force);
+
+            frameCount++;
+            shotFrameCount++;
+
+            Vector3 turretAxis = vectorZero;
+            Vector3 turretDirection = vectorZero;
+            Vector3 turretGunPosition = vectorZero;
+
+            Vector3 turretBodyDownPosition = vectorZero;
+            Vector3 turretGun1Position = vectorZero;
+            Vector3 turretGun2Position = vectorZero;
+
+            turretBodyDown.MainWorldTransform.GetPosition(ref turretBodyDownPosition);
+            turretGun1.MainWorldTransform.GetPosition(ref turretGun1Position);
+            turretGun2.MainWorldTransform.GetPosition(ref turretGun2Position);
+
+            Vector3.Add(ref turretGun1Position, ref turretGun2Position, out turretGunPosition);
+            Vector3.Multiply(ref turretGunPosition, 0.5f, out turretGunPosition);
+            Vector3.Subtract(ref turretGunPosition, ref turretBodyDownPosition, out turretDirection);
+            turretDirection.Normalize();
+            Vector3.Cross(ref turretDirection, ref direction, out turretAxis);
+
+            turretDirection.Y = 0.0f;
+            direction.Y = 0.0f;
+            float turretAngle = 0.0f;
+
+            Vector3.Dot(ref turretDirection, ref direction, out turretAngle);
+            turretAngle = (float)Math.Acos(turretAngle);
+            Vector3.Multiply(ref turretAxis, turretAngle, out turretAxis);
+
+            Vector3 velocity = vectorZero;
+
+            turret.MainWorldTransform.GetAngularVelocity(ref velocity);
+            Vector3.Subtract(ref velocity, ref turretAxis, out velocity);
+            turret.MainWorldTransform.SetAngularVelocity(ref velocity);
+
+            if ((Math.Abs(turretAngle) < 0.1f) && (distance.Length < 100.0f) && (shotFrameCount > maxShotFrameCount))
+            {
+                shotFrameCount = 0;
+
+                shotCount = (shotCount + 1) % maxShotCount;
+                shot1NameBuilder.Remove(shot1NameLength, shot1NameBuilder.Length - shot1NameLength);
+                shot1NameBuilder.Append(shotCount);
+                shotInstanceIndexName = shot1NameBuilder.ToString();
+
+                shot1BaseNameBuilder.Remove(shot1BaseNameLength, shot1BaseNameBuilder.Length - shot1BaseNameLength);
+                shot1BaseNameBuilder.Append(shotCount);
+                shotBaseInstanceIndexName = shot1BaseNameBuilder.ToString();
+
+                shot1LightNameBuilder.Remove(shot1LightNameLength, shot1LightNameBuilder.Length - shot1LightNameLength);
+                shot1LightNameBuilder.Append(shotCount);
+                shotLightInstanceIndexName = shot1LightNameBuilder.ToString();
+
+                shot1 = scene.Factory.PhysicsObjectManager.FindOrCreate(shotInstanceIndexName);
+                shot1Base = scene.Factory.PhysicsObjectManager.FindOrCreate(shotBaseInstanceIndexName);
+                shot1Light = scene.Factory.PhysicsObjectManager.FindOrCreate(shotLightInstanceIndexName);
+
+                shot1.AddChildPhysicsObject(shot1Base);
+                shot1.AddChildPhysicsObject(shot1Light);
+
+                Matrix4 turretGun1Rotation = matrixIdentity;
+                Vector3 shot1Position = vectorZero;
+                Vector3 shot1LocalPosition = vectorZero;
+
+                turretGun1.MainWorldTransform.GetRotation(ref turretGun1Rotation);
+
+                shot1LocalPosition.X = 0.0f;
+                shot1LocalPosition.Y = 2.0f;
+                shot1LocalPosition.Z = 0.0f;
+
+                Vector3.TransformVector(ref shot1LocalPosition, ref turretGun1Rotation, out shot1Position);
+                Vector3.Add(ref shot1Position, ref turretGun1Position, out shot1Position);
+                Vector3 shot1Direction = vectorZero;
+                Vector3 shot1Scale = vectorZero;
+
+                shot1Direction.X = turretGun1Rotation.Row1.X;
+                shot1Direction.Y = turretGun1Rotation.Row1.Y;
+                shot1Direction.Z = turretGun1Rotation.Row1.Z;
+
+                shot1Scale.X = shot1Scale.Y = shot1Scale.Z = 0.5f;
+
+                shot1.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot1.InitLocalTransform.SetPosition(ref shot1Position);
+
+                Vector3.Multiply(ref shot1Direction, 200.0f, out shot1Direction);
+
+                shot1.InitLocalTransform.SetLinearVelocity(ref shot1Direction);
+                shot1.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot1.MaxSimulationFrameCount = maxShotSimulationFrameCount;
+                shot1.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+
+                shot1Base.Shape = sphere;
+                shot1Base.UserDataStr = sphereName;
+                shot1Base.Material.RigidGroup = true;
+                shot1Base.InitLocalTransform.SetScale(ref shot1Scale);
+                shot1Base.Integral.SetDensity(1.0f);
+                shot1Base.EnableCollisions = true;
+                shot1Base.DisableCollision(turretGun1, true);
+                shot1Base.MaxDisableCollisionFrameCount = 10;
+                shot1Base.EnableBreakRigidGroup = false;
+                shot1Base.CreateSound(true);
+
+                shot1Light.Shape = sphere;
+                shot1Light.UserDataStr = sphereName;
+                shot1Light.CreateLight(true);
+                shot1Light.Light.Type = PhysicsLightType.Point;
+                shot1Light.Light.Range = 20.0f;
+                shot1Light.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                shot1Light.InitLocalTransform.SetScale(20.0f);
+                shot1Light.Material.RigidGroup = true;
+                shot1Light.Material.UserDataStr = yellowName;
+                shot1Light.EnableBreakRigidGroup = false;
+                shot1Light.EnableCollisions = false;
+                shot1Light.EnableCursorInteraction = false;
+                shot1Light.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                scene.UpdateFromInitLocalTransform(shot1);
+
+                shot2NameBuilder.Remove(shot2NameLength, shot2NameBuilder.Length - shot2NameLength);
+                shot2NameBuilder.Append(shotCount);
+                shotInstanceIndexName = shot2NameBuilder.ToString();
+
+                shot2BaseNameBuilder.Remove(shot2BaseNameLength, shot2BaseNameBuilder.Length - shot2BaseNameLength);
+                shot2BaseNameBuilder.Append(shotCount);
+                shotBaseInstanceIndexName = shot2BaseNameBuilder.ToString();
+
+                shot2LightNameBuilder.Remove(shot2LightNameLength, shot2LightNameBuilder.Length - shot2LightNameLength);
+                shot2LightNameBuilder.Append(shotCount);
+                shotLightInstanceIndexName = shot2LightNameBuilder.ToString();
+
+                shot2 = scene.Factory.PhysicsObjectManager.FindOrCreate(shotInstanceIndexName);
+                shot2Base = scene.Factory.PhysicsObjectManager.FindOrCreate(shotBaseInstanceIndexName);
+                shot2Light = scene.Factory.PhysicsObjectManager.FindOrCreate(shotLightInstanceIndexName);
+
+                shot2.AddChildPhysicsObject(shot2Base);
+                shot2.AddChildPhysicsObject(shot2Light);
+
+                Matrix4 turretGun2Rotation = matrixIdentity;
+                Vector3 shot2Position = vectorZero;
+                Vector3 shot2LocalPosition = vectorZero;
+
+                turretGun2.MainWorldTransform.GetRotation(ref turretGun2Rotation);
+
+                shot2LocalPosition.X = 0.0f;
+                shot2LocalPosition.Y = 2.0f;
+                shot2LocalPosition.Z = 0.0f;
+
+                Vector3.TransformVector(ref shot2LocalPosition, ref turretGun2Rotation, out shot2Position);
+                Vector3.Add(ref shot2Position, ref turretGun1Position, out shot2Position);
+                Vector3 shot2Direction = vectorZero;
+                Vector3 shot2Scale = vectorZero;
+
+                shot2Direction.X = turretGun2Rotation.Row1.X;
+                shot2Direction.Y = turretGun2Rotation.Row1.Y;
+                shot2Direction.Z = turretGun2Rotation.Row1.Z;
+
+                shot2Scale.X = shot2Scale.Y = shot2Scale.Z = 0.5f;
+
+                shot2.InitLocalTransform.SetRotation(ref matrixIdentity);
+                shot2.InitLocalTransform.SetPosition(ref shot2Position);
+
+                Vector3.Multiply(ref shot2Direction, 200.0f, out shot2Direction);
+
+                shot2.InitLocalTransform.SetLinearVelocity(ref shot2Direction);
+                shot2.InitLocalTransform.SetAngularVelocity(ref vectorZero);
+                shot2.MaxSimulationFrameCount = maxShotSimulationFrameCount;
+                shot2.EnableRemovePhysicsObjectsFromManagerAfterMaxSimulationFrameCount = false;
+
+                shot2Base.Shape = sphere;
+                shot2Base.UserDataStr = sphereName;
+                shot2Base.Material.RigidGroup = true;
+                shot2Base.InitLocalTransform.SetScale(ref shot2Scale);
+                shot2Base.Integral.SetDensity(10.0f);
+                shot2Base.EnableCollisions = true;
+                shot2Base.DisableCollision(turretGun2, true);
+                shot2Base.MaxDisableCollisionFrameCount = 10;
+                shot2Base.EnableBreakRigidGroup = false;
+                shot2Base.CreateSound(true);
+
+                shot2Light.Shape = sphere;
+                shot2Light.UserDataStr = sphereName;
+                shot2Light.CreateLight(true);
+                shot2Light.Light.Type = PhysicsLightType.Point;
+                shot2Light.Light.Range = 20.0f;
+                shot2Light.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                shot2Light.InitLocalTransform.SetScale(20.0f);
+                shot2Light.Material.RigidGroup = true;
+                shot2Light.Material.UserDataStr = yellowName;
+                shot2Light.EnableBreakRigidGroup = false;
+                shot2Light.EnableCollisions = false;
+                shot2Light.EnableCursorInteraction = false;
+                shot2Light.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                scene.UpdateFromInitLocalTransform(shot2);
+            }
+
+            Vector3 bodyUpPosition = vectorZero;
+            Vector3 upDirection = vectorZero;
+
+            bodyDown.MainWorldTransform.GetPosition(ref bodyDownPosition);
+            bodyUp.MainWorldTransform.GetPosition(ref bodyUpPosition);
+
+            Vector3.Subtract(ref bodyDownPosition, ref bodyUpPosition, out upDirection);
+            upDirection.Normalize();
+
+            float bodyAngle = 0.0f;
+            Vector3 axis = vectorZero;
+
+            Vector3.Dot(ref upDirection, ref gravityDirection, out bodyAngle);
+            bodyAngle = (float)Math.Acos(bodyAngle);
+
+            if (Math.Abs(bodyAngle) > 0.005f)
+                bodyAngle *= 0.005f / Math.Abs(bodyAngle);
+
+            Vector3.Cross(ref gravityDirection, ref upDirection, out axis);
+
+            objectBase.MainWorldTransform.GetAngularVelocity(ref velocity);
+            Vector3.Multiply(ref velocity, 0.98f, out velocity);
+            Vector3.Multiply(ref axis, bodyAngle * 400.0f, out axis);
+            Vector3.Add(ref velocity, ref axis, out velocity);
+            objectBase.MainWorldTransform.SetAngularVelocity(ref velocity);
+
+            Vector3 turretBodyUpPosition = vectorZero;
+
+            turretBodyUp.MainWorldTransform.GetPosition(ref turretBodyUpPosition);
+
+            Vector3.Subtract(ref turretBodyDownPosition, ref turretBodyUpPosition, out upDirection);
+            upDirection.Normalize();
+
+            Vector3.Dot(ref upDirection, ref gravityDirection, out bodyAngle);
+            bodyAngle = (float)Math.Acos(bodyAngle);
+
+            if (Math.Abs(bodyAngle) > 0.005f)
+                bodyAngle *= 0.005f / Math.Abs(bodyAngle);
+
+            Vector3.Cross(ref gravityDirection, ref upDirection, out axis);
+
+            turret.MainWorldTransform.GetAngularVelocity(ref velocity);
+            Vector3.Multiply(ref velocity, 0.98f, out velocity);
+            Vector3.Multiply(ref axis, bodyAngle * 400.0f, out axis);
+            Vector3.Add(ref velocity, ref axis, out velocity);
+            turret.MainWorldTransform.SetAngularVelocity(ref velocity);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera1Draw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera1Draw1.cs
new file mode 100644
index 0000000..5ec8eb7
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera1Draw1.cs
@@ -0,0 +1,839 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera1Draw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string quadName;
+
+        DemoKeyboardState oldKeyboardState;
+
+        bool enableDrawBoundingBoxes;
+        bool enableDrawContactPoints;
+        bool enableDrawSlipingObjects;
+        bool enableDrawImpactFactors;
+        bool enableDrawLights;
+        bool enableWireframe;
+
+        DrawBuffersEnum[] targets;
+
+        RenderClearDeferredQuadP renderClear;
+        RenderLightDirectionalDeferredQuadP renderLightDirectional;
+        RenderLightPointDeferredP renderLightPoint;
+        RenderLightSpotDeferredP renderLightSpot;
+        RenderScreenDeferredQuadP renderScreen;
+
+        RenderPC render;
+        VertexPositionColor[] cameraVertices;
+
+        Vector3 position;
+        Vector3 direction;
+        Vector3 lightDiffuse;
+        Vector3 lightSpecular;
+        BoundingBox boundingBox;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        Matrix4 matrixIdentity;
+
+        public Camera1Draw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            quadName = "Quad";
+
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            targets = new DrawBuffersEnum[4];
+
+            cameraVertices = new VertexPositionColor[24];
+
+            renderClear = new RenderClearDeferredQuadP();
+            renderLightDirectional = new RenderLightDirectionalDeferredQuadP();
+            renderLightPoint = new RenderLightPointDeferredP();
+            renderLightSpot = new RenderLightSpotDeferredP();
+            renderScreen = new RenderScreenDeferredQuadP();
+
+            render = new RenderPC();
+        }
+
+        public void SetControllers(bool enableDrawBoundingBoxes, bool enableDrawContactPoints, bool enableDrawSlipingObjects, bool enableDrawImpactFactors, bool enableDrawLights, bool enableWireframe)
+        {
+            oldKeyboardState = demo.GetKeyboardState();
+
+            this.enableDrawBoundingBoxes = enableDrawBoundingBoxes;
+            this.enableDrawContactPoints = enableDrawContactPoints;
+            this.enableDrawSlipingObjects = enableDrawSlipingObjects;
+            this.enableDrawImpactFactors = enableDrawImpactFactors;
+            this.enableDrawLights = enableDrawLights;
+            this.enableWireframe = enableWireframe;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 1" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawBoundingBoxes);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawContactPoints);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawImpactFactors);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (keyboardState[Key.B] && !oldKeyboardState[Key.B])
+                enableDrawBoundingBoxes = !enableDrawBoundingBoxes;
+
+            if (keyboardState[Key.C] && !oldKeyboardState[Key.C])
+                enableDrawContactPoints = !enableDrawContactPoints;
+
+            if (keyboardState[Key.V] && !oldKeyboardState[Key.V])
+                enableDrawSlipingObjects = !enableDrawSlipingObjects;
+
+            if (keyboardState[Key.I] && !oldKeyboardState[Key.I])
+                enableDrawImpactFactors = !enableDrawImpactFactors;
+
+            if (keyboardState[Key.G] && !oldKeyboardState[Key.G])
+                enableDrawLights = !enableDrawLights;
+
+            if (keyboardState[Key.N] && !oldKeyboardState[Key.N])
+                enableWireframe = !enableWireframe;
+
+            oldKeyboardState = keyboardState;
+
+            demo.EnableWireframe = enableWireframe;
+
+            PhysicsObject menuPhysicsObjectWithCamera = demo.MenuScene.PhysicsScene.GetPhysicsObjectWithCamera(0);
+
+            if (menuPhysicsObjectWithCamera != null)
+            {
+                if (menuPhysicsObjectWithCamera.Camera.UserDataObj != null)
+                {
+                    Camera3Draw1 menuCamera = menuPhysicsObjectWithCamera.Camera.UserDataObj as Camera3Draw1;
+
+                    if (menuCamera != null)
+                    {
+                        menuCamera.EnableDrawBoundingBoxes = enableDrawBoundingBoxes;
+                        menuCamera.EnableDrawContactPoints = enableDrawContactPoints;
+                        menuCamera.EnableDrawSlipingObjects = enableDrawSlipingObjects;
+                        menuCamera.EnableDrawLights = enableDrawLights;
+                        menuCamera.EnableWireframe = enableWireframe;
+                    }
+                }
+            }
+
+            float time = args.Time;
+
+            PhysicsObject drawPhysicsObject, transparentPhysicsObject, lightPhysicsObject;
+            PhysicsLight sceneLight, drawLight;
+            DemoMesh mesh, quad;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            sceneLight = scene.Light;
+
+            quad = demo.Meshes[quadName];
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.SceneFrameBuffer);
+
+            targets[0] = DrawBuffersEnum.ColorAttachment0;
+            targets[1] = DrawBuffersEnum.ColorAttachment1;
+            targets[2] = DrawBuffersEnum.ColorAttachment2;
+            targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+            GL.DrawBuffers(4, targets);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+            GL.Disable(EnableCap.CullFace);
+
+            renderClear.SetClearScreenColor(ref demo.ClearScreenColor);
+
+            quad.Draw(renderClear);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+
+            for (int i = 0; i < objectBase.Camera.DrawPhysicsObjectCount; i++)
+            {
+                drawPhysicsObject = objectBase.Camera.GetDrawPhysicsObject(i);
+
+                if ((drawPhysicsObject.UserControllers.DrawMethods == null) || (drawPhysicsObject == objectBase))
+                {
+                    if (drawPhysicsObject.UserDataStr == null)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                    mesh = demo.Meshes[drawPhysicsObject.UserDataStr];
+
+                    mesh.Draw(ref world, ref view, ref projection, sceneLight, drawPhysicsObject.Material, objectBase.Camera, drawPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                }
+                else
+                {
+                    if (drawPhysicsObject.UserControllers.EnableDraw)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = drawPhysicsObject.Index;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                    drawPhysicsObject.UserControllers.DrawMethods(drawPhysicsObject.UserControllers.DrawMethodArgs);
+                }
+            }
+
+            if (objectBase.Camera.TransparentPhysicsObjectCount != 0)
+            {
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.ColorAttachment1;
+                targets[2] = DrawBuffersEnum.None;
+                targets[3] = DrawBuffersEnum.None;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(false);
+                GL.Enable(EnableCap.Blend);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcAlpha);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+
+                targets[0] = DrawBuffersEnum.None;
+                targets[1] = DrawBuffersEnum.None;
+                targets[2] = DrawBuffersEnum.ColorAttachment2;
+                targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(true);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+                GL.Disable(EnableCap.Blend);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if (!transparentPhysicsObject.Material.TransparencySecondPass)
+                        continue;
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+            }
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.LightFrameBuffer);
+
+            GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+
+            GL.ClearColor(demo.ClearLightColor);
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.SrcAlpha);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+            if ((sceneLight != null) && sceneLight.Enabled)
+            {
+                GL.Disable(EnableCap.CullFace);
+
+                sceneLight.GetDirection(ref direction);
+                sceneLight.GetDiffuse(ref lightDiffuse);
+                sceneLight.GetSpecular(ref lightSpecular);
+
+                renderLightDirectional.Enable = true;
+
+                renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                renderLightDirectional.SetView(ref view);
+                renderLightDirectional.SetProjection(ref projection);
+
+                renderLightDirectional.SetLightDirection(ref direction);
+                renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                renderLightDirectional.Intensity = sceneLight.Intensity;
+
+                renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                renderLightDirectional.NormalTexture = demo.NormalTexture;
+                renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                quad.Draw(renderLightDirectional);
+            }
+
+            for (int i = 0; i < objectBase.Camera.LightPhysicsObjectCount; i++)
+            {
+                lightPhysicsObject = objectBase.Camera.GetLightPhysicsObject(i);
+
+                drawLight = lightPhysicsObject.Light;
+
+                if ((drawLight == null) || !drawLight.Enabled)
+                    continue;
+
+                if (drawLight.Type == PhysicsLightType.Directional)
+                {
+                    GL.Disable(EnableCap.CullFace);
+
+                    drawLight.GetDirection(ref direction);
+                    drawLight.GetDiffuse(ref lightDiffuse);
+                    drawLight.GetSpecular(ref lightSpecular);
+
+                    renderLightDirectional.Enable = true;
+
+                    renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                    renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                    renderLightDirectional.SetView(ref view);
+                    renderLightDirectional.SetProjection(ref projection);
+
+                    renderLightDirectional.SetLightDirection(ref direction);
+                    renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                    renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                    renderLightDirectional.Intensity = drawLight.Intensity;
+
+                    renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                    renderLightDirectional.NormalTexture = demo.NormalTexture;
+                    renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                    quad.Draw(renderLightDirectional);
+                }
+                else
+                    if (drawLight.Type == PhysicsLightType.Point)
+                    {
+                        lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                        if (enableDrawLights)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                            lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                            lightPhysicsObject.Material.TransparencySecondPass = false;
+                        }
+
+                        GL.Enable(EnableCap.CullFace);
+                        GL.CullFace(CullFaceMode.Front);
+
+                        lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                        lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                        drawLight.GetDiffuse(ref lightDiffuse);
+                        drawLight.GetSpecular(ref lightSpecular);
+
+                        renderLightPoint.Enable = true;
+
+                        renderLightPoint.Width = objectBase.Camera.Projection.Width;
+                        renderLightPoint.Height = objectBase.Camera.Projection.Height;
+
+                        renderLightPoint.SetWorld(ref world);
+                        renderLightPoint.SetView(ref view);
+                        renderLightPoint.SetProjection(ref projection);
+
+                        renderLightPoint.SetLightPosition(ref position);
+                        renderLightPoint.SetLightDiffuse(ref lightDiffuse);
+                        renderLightPoint.SetLightSpecular(ref lightSpecular);
+                        renderLightPoint.Range = drawLight.Range;
+                        renderLightPoint.Intensity = drawLight.Intensity;
+
+                        renderLightPoint.SpecularTexture = demo.SpecularTexture;
+                        renderLightPoint.NormalTexture = demo.NormalTexture;
+                        renderLightPoint.DepthTexture = demo.DepthTexture;
+
+                        mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                        mesh.Draw(renderLightPoint);
+                    }
+                    else
+                        if (drawLight.Type == PhysicsLightType.Spot)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                            if (enableDrawLights)
+                            {
+                                lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                                lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                                lightPhysicsObject.Material.TransparencySecondPass = false;
+                            }
+
+                            GL.Enable(EnableCap.CullFace);
+                            GL.CullFace(CullFaceMode.Front);
+
+                            lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                            lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                            drawLight.GetDiffuse(ref lightDiffuse);
+                            drawLight.GetSpecular(ref lightSpecular);
+                            direction.X = -world.Row2.X;
+                            direction.Y = -world.Row2.Y;
+                            direction.Z = -world.Row2.Z;
+                            Vector3.Subtract(ref position, ref direction, out position);
+
+                            renderLightSpot.Enable = true;
+
+                            renderLightSpot.Width = objectBase.Camera.Projection.Width;
+                            renderLightSpot.Height = objectBase.Camera.Projection.Height;
+
+                            renderLightSpot.SetWorld(ref world);
+                            renderLightSpot.SetView(ref view);
+                            renderLightSpot.SetProjection(ref projection);
+
+                            renderLightSpot.SetLightPosition(ref position);
+                            renderLightSpot.SetLightDirection(ref direction);
+                            renderLightSpot.SetLightDiffuse(ref lightDiffuse);
+                            renderLightSpot.SetLightSpecular(ref lightSpecular);
+                            renderLightSpot.Range = drawLight.Range;
+                            renderLightSpot.Intensity = drawLight.Intensity;
+                            renderLightSpot.InnerRadAngle = drawLight.SpotInnerRadAngle;
+                            renderLightSpot.OuterRadAngle = drawLight.SpotOuterRadAngle;
+
+                            renderLightSpot.SpecularTexture = demo.SpecularTexture;
+                            renderLightSpot.NormalTexture = demo.NormalTexture;
+                            renderLightSpot.DepthTexture = demo.DepthTexture;
+
+                            mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                            mesh.Draw(renderLightSpot);
+                        }
+            }
+
+            if (!demo.EnableMenu)
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+            }
+            else
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.ScreenFrameBuffer);
+                GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+            }
+
+            GL.Disable(EnableCap.CullFace);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+
+            renderScreen.Width = objectBase.Camera.Projection.Width;
+            renderScreen.Height = objectBase.Camera.Projection.Height;
+            renderScreen.ColorTexture = demo.ColorTexture;
+            renderScreen.LightTexture = demo.LightTexture;
+
+            quad.Draw(renderScreen);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+        }
+
+        public void DrawBoundingBoxes(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawBoundingBoxes) return;
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            Vector3 min, max;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            GL.Color3(1.0f, 1.0f, 1.0f);
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                visiblePhysicsObject.GetBoundingBox(ref boundingBox);
+                min = boundingBox.Min;
+                max = boundingBox.Max;
+
+                cameraVertices[0].Position.X = min.X;
+                cameraVertices[0].Position.Y = min.Y;
+                cameraVertices[0].Position.Z = min.Z;
+
+                cameraVertices[1].Position.X = max.X;
+                cameraVertices[1].Position.Y = min.Y;
+                cameraVertices[1].Position.Z = min.Z;
+
+                cameraVertices[2].Position.X = min.X;
+                cameraVertices[2].Position.Y = min.Y;
+                cameraVertices[2].Position.Z = min.Z;
+
+                cameraVertices[3].Position.X = min.X;
+                cameraVertices[3].Position.Y = max.Y;
+                cameraVertices[3].Position.Z = min.Z;
+
+                cameraVertices[4].Position.X = min.X;
+                cameraVertices[4].Position.Y = min.Y;
+                cameraVertices[4].Position.Z = min.Z;
+
+                cameraVertices[5].Position.X = min.X;
+                cameraVertices[5].Position.Y = min.Y;
+                cameraVertices[5].Position.Z = max.Z;
+
+                cameraVertices[6].Position.X = max.X;
+                cameraVertices[6].Position.Y = max.Y;
+                cameraVertices[6].Position.Z = max.Z;
+
+                cameraVertices[7].Position.X = min.X;
+                cameraVertices[7].Position.Y = max.Y;
+                cameraVertices[7].Position.Z = max.Z;
+
+                cameraVertices[8].Position.X = max.X;
+                cameraVertices[8].Position.Y = max.Y;
+                cameraVertices[8].Position.Z = max.Z;
+
+                cameraVertices[9].Position.X = max.X;
+                cameraVertices[9].Position.Y = min.Y;
+                cameraVertices[9].Position.Z = max.Z;
+
+                cameraVertices[10].Position.X = max.X;
+                cameraVertices[10].Position.Y = max.Y;
+                cameraVertices[10].Position.Z = max.Z;
+
+                cameraVertices[11].Position.X = max.X;
+                cameraVertices[11].Position.Y = max.Y;
+                cameraVertices[11].Position.Z = min.Z;
+
+                cameraVertices[12].Position.X = min.X;
+                cameraVertices[12].Position.Y = max.Y;
+                cameraVertices[12].Position.Z = min.Z;
+
+                cameraVertices[13].Position.X = min.X;
+                cameraVertices[13].Position.Y = max.Y;
+                cameraVertices[13].Position.Z = max.Z;
+
+                cameraVertices[14].Position.X = min.X;
+                cameraVertices[14].Position.Y = max.Y;
+                cameraVertices[14].Position.Z = min.Z;
+
+                cameraVertices[15].Position.X = max.X;
+                cameraVertices[15].Position.Y = max.Y;
+                cameraVertices[15].Position.Z = min.Z;
+
+                cameraVertices[16].Position.X = max.X;
+                cameraVertices[16].Position.Y = min.Y;
+                cameraVertices[16].Position.Z = max.Z;
+
+                cameraVertices[17].Position.X = max.X;
+                cameraVertices[17].Position.Y = min.Y;
+                cameraVertices[17].Position.Z = min.Z;
+
+                cameraVertices[18].Position.X = max.X;
+                cameraVertices[18].Position.Y = min.Y;
+                cameraVertices[18].Position.Z = max.Z;
+
+                cameraVertices[19].Position.X = min.X;
+                cameraVertices[19].Position.Y = min.Y;
+                cameraVertices[19].Position.Z = max.Z;
+
+                cameraVertices[20].Position.X = min.X;
+                cameraVertices[20].Position.Y = max.Y;
+                cameraVertices[20].Position.Z = max.Z;
+
+                cameraVertices[21].Position.X = min.X;
+                cameraVertices[21].Position.Y = min.Y;
+                cameraVertices[21].Position.Z = max.Z;
+
+                cameraVertices[22].Position.X = max.X;
+                cameraVertices[22].Position.Y = max.Y;
+                cameraVertices[22].Position.Z = min.Z;
+
+                cameraVertices[23].Position.X = max.X;
+                cameraVertices[23].Position.Y = min.Y;
+                cameraVertices[23].Position.Z = min.Z;
+
+                GL.Begin(PrimitiveType.Lines);
+
+                for (int j = 0; j < 24; j += 2)
+                {
+                    GL.Vertex3(cameraVertices[j].Position);
+                    GL.Vertex3(cameraVertices[j + 1].Position);
+                }
+
+                GL.End();
+            }
+        }
+
+        public void DrawContactPoints(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawContactPoints) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            int contactPointCount;
+            Vector3 start1, end1, start2, end2;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                for (int j = 0; j < visiblePhysicsObject.CollisionPairCount; j++)
+                {
+                    contactPointCount = visiblePhysicsObject.GetCollisionPairContactPointCount(j);
+
+                    for (int k = 0; k < contactPointCount; k++)
+                    {
+                        visiblePhysicsObject.GetCollisionPairContactPointAnchor2(j, k, ref position);
+                        visiblePhysicsObject.GetCollisionPairContactPointNormal(j, k, ref direction);
+
+                        Vector3.Multiply(ref direction, 0.5f, out direction);
+
+                        start1 = position;
+                        end1 = direction;
+                        Vector3.Add(ref start1, ref end1, out end1);
+
+                        start2 = end1;
+                        end2 = direction;
+                        Vector3.Add(ref start2, ref end2, out end2);
+
+                        GL.Begin(PrimitiveType.Lines);
+
+                        GL.Color3(1.0f, 1.0f, 1.0f);
+                        GL.Vertex3(start1);
+                        GL.Vertex3(end1);
+
+                        GL.Color3(0.6f, 0.8f, 0.2f);
+                        GL.Vertex3(start2);
+                        GL.Vertex3(end2);
+
+                        GL.End();
+                    }
+                }
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public void DrawImpactFactors(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawImpactFactors) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            int contactPointCount;
+            Vector3 start1, end1, start2, end2;
+            float impactFactor, velocityMagnitude;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                for (int j = 0; j < visiblePhysicsObject.CollisionPairCount; j++)
+                {
+                    contactPointCount = visiblePhysicsObject.GetCollisionPairContactPointCount(j);
+
+                    for (int k = 0; k < contactPointCount; k++)
+                    {
+                        visiblePhysicsObject.GetCollisionPairContactPointAnchor2(j, k, ref position);
+                        visiblePhysicsObject.GetCollisionPairContactPointNormal(j, k, ref direction);
+
+                        impactFactor = visiblePhysicsObject.GetCollisionPairContactPointImpactFactor(j, k);
+                        velocityMagnitude = Math.Min(Math.Max(visiblePhysicsObject.MainWorldTransform.GetLinearVelocityMagnitude() - visiblePhysicsObject.MaxSleepLinearVelocity, 0.0f) + Math.Max(visiblePhysicsObject.MainWorldTransform.GetAngularVelocityMagnitude() - visiblePhysicsObject.MaxSleepAngularVelocity, 0.0f), 1.0f);
+                        impactFactor *= velocityMagnitude;
+
+                        if (impactFactor < 0.001f)
+                            continue;
+
+                        Vector3.Multiply(ref direction, (float)impactFactor, out direction);
+                        Vector3.Multiply(ref direction, 0.5f, out direction);
+
+                        start1 = position;
+                        end1 = direction;
+                        Vector3.Add(ref start1, ref end1, out end1);
+
+                        start2 = end1;
+                        end2 = direction;
+                        Vector3.Add(ref start2, ref end2, out end2);
+
+                        GL.Begin(PrimitiveType.Lines);
+
+                        GL.Color3(1.0f, 1.0f, 1.0f);
+                        GL.Vertex3(start1);
+                        GL.Vertex3(end1);
+
+                        GL.Color3(0.6f, 0.8f, 0.2f);
+                        GL.Vertex3(start2);
+                        GL.Vertex3(end2);
+
+                        GL.End();
+                    }
+                }
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera2Draw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera2Draw1.cs
new file mode 100644
index 0000000..46270ea
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera2Draw1.cs
@@ -0,0 +1,839 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera2Draw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string quadName;
+
+        DemoKeyboardState oldKeyboardState;
+
+        bool enableDrawBoundingBoxes;
+        bool enableDrawContactPoints;
+        bool enableDrawSlipingObjects;
+        bool enableDrawImpactFactors;
+        bool enableDrawLights;
+        bool enableWireframe;
+
+        DrawBuffersEnum[] targets;
+
+        RenderClearDeferredQuadP renderClear;
+        RenderLightDirectionalDeferredQuadP renderLightDirectional;
+        RenderLightPointDeferredP renderLightPoint;
+        RenderLightSpotDeferredP renderLightSpot;
+        RenderScreenDeferredQuadP renderScreen;
+
+        RenderPC render;
+        VertexPositionColor[] cameraVertices;
+
+        Vector3 position;
+        Vector3 direction;
+        Vector3 lightDiffuse;
+        Vector3 lightSpecular;
+        BoundingBox boundingBox;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        Matrix4 matrixIdentity;
+
+        public Camera2Draw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            quadName = "Quad";
+
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            targets = new DrawBuffersEnum[4];
+
+            cameraVertices = new VertexPositionColor[24];
+
+            renderClear = new RenderClearDeferredQuadP();
+            renderLightDirectional = new RenderLightDirectionalDeferredQuadP();
+            renderLightPoint = new RenderLightPointDeferredP();
+            renderLightSpot = new RenderLightSpotDeferredP();
+            renderScreen = new RenderScreenDeferredQuadP();
+
+            render = new RenderPC();
+        }
+
+        public void SetControllers(bool enableDrawBoundingBoxes, bool enableDrawContactPoints, bool enableDrawSlipingObjects, bool enableDrawImpactFactors, bool enableDrawLights, bool enableWireframe)
+        {
+            oldKeyboardState = demo.GetKeyboardState();
+
+            this.enableDrawBoundingBoxes = enableDrawBoundingBoxes;
+            this.enableDrawContactPoints = enableDrawContactPoints;
+            this.enableDrawSlipingObjects = enableDrawSlipingObjects;
+            this.enableDrawImpactFactors = enableDrawImpactFactors;
+            this.enableDrawLights = enableDrawLights;
+            this.enableWireframe = enableWireframe;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 2 Up" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawBoundingBoxes);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawContactPoints);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawImpactFactors);
+            }
+        }
+
+        public void RefreshControllers()
+        {
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (keyboardState[Key.B] && !oldKeyboardState[Key.B])
+                enableDrawBoundingBoxes = !enableDrawBoundingBoxes;
+
+            if (keyboardState[Key.C] && !oldKeyboardState[Key.C])
+                enableDrawContactPoints = !enableDrawContactPoints;
+
+            if (keyboardState[Key.V] && !oldKeyboardState[Key.V])
+                enableDrawSlipingObjects = !enableDrawSlipingObjects;
+
+            if (keyboardState[Key.I] && !oldKeyboardState[Key.I])
+                enableDrawImpactFactors = !enableDrawImpactFactors;
+
+            if (keyboardState[Key.G] && !oldKeyboardState[Key.G])
+                enableDrawLights = !enableDrawLights;
+
+            if (keyboardState[Key.N] && !oldKeyboardState[Key.N])
+                enableWireframe = !enableWireframe;
+
+            oldKeyboardState = keyboardState;
+
+            demo.EnableWireframe = enableWireframe;
+
+            PhysicsObject menuPhysicsObjectWithCamera = demo.MenuScene.PhysicsScene.GetPhysicsObjectWithCamera(0);
+
+            if (menuPhysicsObjectWithCamera != null)
+            {
+                if (menuPhysicsObjectWithCamera.Camera.UserDataObj != null)
+                {
+                    Camera3Draw1 menuCamera = menuPhysicsObjectWithCamera.Camera.UserDataObj as Camera3Draw1;
+
+                    if (menuCamera != null)
+                    {
+                        menuCamera.EnableDrawBoundingBoxes = enableDrawBoundingBoxes;
+                        menuCamera.EnableDrawContactPoints = enableDrawContactPoints;
+                        menuCamera.EnableDrawSlipingObjects = enableDrawSlipingObjects;
+                        menuCamera.EnableDrawLights = enableDrawLights;
+                        menuCamera.EnableWireframe = enableWireframe;
+                    }
+                }
+            }
+
+            float time = args.Time;
+
+            PhysicsObject drawPhysicsObject, transparentPhysicsObject, lightPhysicsObject;
+            PhysicsLight sceneLight, drawLight;
+            DemoMesh mesh, quad;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            sceneLight = scene.Light;
+
+            quad = demo.Meshes[quadName];
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.SceneFrameBuffer);
+
+            targets[0] = DrawBuffersEnum.ColorAttachment0;
+            targets[1] = DrawBuffersEnum.ColorAttachment1;
+            targets[2] = DrawBuffersEnum.ColorAttachment2;
+            targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+            GL.DrawBuffers(4, targets);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+            GL.Disable(EnableCap.CullFace);
+
+            renderClear.SetClearScreenColor(ref demo.ClearScreenColor);
+
+            quad.Draw(renderClear);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+
+            for (int i = 0; i < objectBase.Camera.DrawPhysicsObjectCount; i++)
+            {
+                drawPhysicsObject = objectBase.Camera.GetDrawPhysicsObject(i);
+
+                if ((drawPhysicsObject.UserControllers.DrawMethods == null) || (drawPhysicsObject == objectBase))
+                {
+                    if (drawPhysicsObject.UserDataStr == null)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                    mesh = demo.Meshes[drawPhysicsObject.UserDataStr];
+
+                    mesh.Draw(ref world, ref view, ref projection, sceneLight, drawPhysicsObject.Material, objectBase.Camera, drawPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                }
+                else
+                {
+                    if (drawPhysicsObject.UserControllers.EnableDraw)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = drawPhysicsObject.Index;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                    drawPhysicsObject.UserControllers.DrawMethods(drawPhysicsObject.UserControllers.DrawMethodArgs);
+                }
+            }
+
+            if (objectBase.Camera.TransparentPhysicsObjectCount != 0)
+            {
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.ColorAttachment1;
+                targets[2] = DrawBuffersEnum.None;
+                targets[3] = DrawBuffersEnum.None;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(false);
+                GL.Enable(EnableCap.Blend);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcAlpha);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+
+                targets[0] = DrawBuffersEnum.None;
+                targets[1] = DrawBuffersEnum.None;
+                targets[2] = DrawBuffersEnum.ColorAttachment2;
+                targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(true);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+                GL.Disable(EnableCap.Blend);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if (!transparentPhysicsObject.Material.TransparencySecondPass)
+                        continue;
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && enableDrawSlipingObjects, enableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+            }
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.LightFrameBuffer);
+
+            GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+
+            GL.ClearColor(demo.ClearLightColor);
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.SrcAlpha);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+            if ((sceneLight != null) && sceneLight.Enabled)
+            {
+                GL.Disable(EnableCap.CullFace);
+
+                sceneLight.GetDirection(ref direction);
+                sceneLight.GetDiffuse(ref lightDiffuse);
+                sceneLight.GetSpecular(ref lightSpecular);
+
+                    renderLightDirectional.Enable = true;
+
+                    renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                    renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                    renderLightDirectional.SetView(ref view);
+                    renderLightDirectional.SetProjection(ref projection);
+
+                    renderLightDirectional.SetLightDirection(ref direction);
+                    renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                    renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                    renderLightDirectional.Intensity = sceneLight.Intensity;
+
+                    renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                    renderLightDirectional.NormalTexture = demo.NormalTexture;
+                    renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                    quad.Draw(renderLightDirectional);
+            }
+
+            for (int i = 0; i < objectBase.Camera.LightPhysicsObjectCount; i++)
+            {
+                lightPhysicsObject = objectBase.Camera.GetLightPhysicsObject(i);
+
+                drawLight = lightPhysicsObject.Light;
+
+                if ((drawLight == null) || !drawLight.Enabled)
+                    continue;
+
+                if (drawLight.Type == PhysicsLightType.Directional)
+                {
+                    GL.Disable(EnableCap.CullFace);
+
+                    drawLight.GetDirection(ref direction);
+                    drawLight.GetDiffuse(ref lightDiffuse);
+                    drawLight.GetSpecular(ref lightSpecular);
+
+                        renderLightDirectional.Enable = true;
+
+                        renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                        renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                        renderLightDirectional.SetView(ref view);
+                        renderLightDirectional.SetProjection(ref projection);
+
+                        renderLightDirectional.SetLightDirection(ref direction);
+                        renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                        renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                        renderLightDirectional.Intensity = drawLight.Intensity;
+
+                        renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                        renderLightDirectional.NormalTexture = demo.NormalTexture;
+                        renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                        quad.Draw(renderLightDirectional);
+                }
+                else
+                    if (drawLight.Type == PhysicsLightType.Point)
+                    {
+                        lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                        if (enableDrawLights)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                            lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                            lightPhysicsObject.Material.TransparencySecondPass = false;
+                        }
+
+                        GL.Enable(EnableCap.CullFace);
+                        GL.CullFace(CullFaceMode.Front);
+
+                        lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                        lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                        drawLight.GetDiffuse(ref lightDiffuse);
+                        drawLight.GetSpecular(ref lightSpecular);
+
+                        renderLightPoint.Enable = true;
+
+                        renderLightPoint.Width = objectBase.Camera.Projection.Width;
+                        renderLightPoint.Height = objectBase.Camera.Projection.Height;
+
+                        renderLightPoint.SetWorld(ref world);
+                        renderLightPoint.SetView(ref view);
+                        renderLightPoint.SetProjection(ref projection);
+
+                        renderLightPoint.SetLightPosition(ref position);
+                        renderLightPoint.SetLightDiffuse(ref lightDiffuse);
+                        renderLightPoint.SetLightSpecular(ref lightSpecular);
+                        renderLightPoint.Range = drawLight.Range;
+                        renderLightPoint.Intensity = drawLight.Intensity;
+
+                        renderLightPoint.SpecularTexture = demo.SpecularTexture;
+                        renderLightPoint.NormalTexture = demo.NormalTexture;
+                        renderLightPoint.DepthTexture = demo.DepthTexture;
+
+                        mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                        mesh.Draw(renderLightPoint);
+                    }
+                    else
+                        if (drawLight.Type == PhysicsLightType.Spot)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                            if (enableDrawLights)
+                            {
+                                lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                                lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                                lightPhysicsObject.Material.TransparencySecondPass = false;
+                            }
+
+                            GL.Enable(EnableCap.CullFace);
+                            GL.CullFace(CullFaceMode.Front);
+
+                            lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                            lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                            drawLight.GetDiffuse(ref lightDiffuse);
+                            drawLight.GetSpecular(ref lightSpecular);
+                            direction.X = -world.Row2.X;
+                            direction.Y = -world.Row2.Y;
+                            direction.Z = -world.Row2.Z;
+                            Vector3.Subtract(ref position, ref direction, out position);
+
+                            renderLightSpot.Enable = true;
+
+                            renderLightSpot.Width = objectBase.Camera.Projection.Width;
+                            renderLightSpot.Height = objectBase.Camera.Projection.Height;
+
+                            renderLightSpot.SetWorld(ref world);
+                            renderLightSpot.SetView(ref view);
+                            renderLightSpot.SetProjection(ref projection);
+
+                            renderLightSpot.SetLightPosition(ref position);
+                            renderLightSpot.SetLightDirection(ref direction);
+                            renderLightSpot.SetLightDiffuse(ref lightDiffuse);
+                            renderLightSpot.SetLightSpecular(ref lightSpecular);
+                            renderLightSpot.Range = drawLight.Range;
+                            renderLightSpot.Intensity = drawLight.Intensity;
+                            renderLightSpot.InnerRadAngle = drawLight.SpotInnerRadAngle;
+                            renderLightSpot.OuterRadAngle = drawLight.SpotOuterRadAngle;
+
+                            renderLightSpot.SpecularTexture = demo.SpecularTexture;
+                            renderLightSpot.NormalTexture = demo.NormalTexture;
+                            renderLightSpot.DepthTexture = demo.DepthTexture;
+
+                            mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                            mesh.Draw(renderLightSpot);
+                        }
+            }
+
+            if (!demo.EnableMenu)
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+            }
+            else
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.ScreenFrameBuffer);
+                GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+            }
+
+            GL.Disable(EnableCap.CullFace);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+
+            renderScreen.Width = objectBase.Camera.Projection.Width;
+            renderScreen.Height = objectBase.Camera.Projection.Height;
+            renderScreen.ColorTexture = demo.ColorTexture;
+            renderScreen.LightTexture = demo.LightTexture;
+
+            quad.Draw(renderScreen);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+        }
+
+        public void DrawBoundingBoxes(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawBoundingBoxes) return;
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            Vector3 min, max;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            GL.Color3(1.0f, 1.0f, 1.0f);
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                visiblePhysicsObject.GetBoundingBox(ref boundingBox);
+                min = boundingBox.Min;
+                max = boundingBox.Max;
+
+                cameraVertices[0].Position.X = min.X;
+                cameraVertices[0].Position.Y = min.Y;
+                cameraVertices[0].Position.Z = min.Z;
+
+                cameraVertices[1].Position.X = max.X;
+                cameraVertices[1].Position.Y = min.Y;
+                cameraVertices[1].Position.Z = min.Z;
+
+                cameraVertices[2].Position.X = min.X;
+                cameraVertices[2].Position.Y = min.Y;
+                cameraVertices[2].Position.Z = min.Z;
+
+                cameraVertices[3].Position.X = min.X;
+                cameraVertices[3].Position.Y = max.Y;
+                cameraVertices[3].Position.Z = min.Z;
+
+                cameraVertices[4].Position.X = min.X;
+                cameraVertices[4].Position.Y = min.Y;
+                cameraVertices[4].Position.Z = min.Z;
+
+                cameraVertices[5].Position.X = min.X;
+                cameraVertices[5].Position.Y = min.Y;
+                cameraVertices[5].Position.Z = max.Z;
+
+                cameraVertices[6].Position.X = max.X;
+                cameraVertices[6].Position.Y = max.Y;
+                cameraVertices[6].Position.Z = max.Z;
+
+                cameraVertices[7].Position.X = min.X;
+                cameraVertices[7].Position.Y = max.Y;
+                cameraVertices[7].Position.Z = max.Z;
+
+                cameraVertices[8].Position.X = max.X;
+                cameraVertices[8].Position.Y = max.Y;
+                cameraVertices[8].Position.Z = max.Z;
+
+                cameraVertices[9].Position.X = max.X;
+                cameraVertices[9].Position.Y = min.Y;
+                cameraVertices[9].Position.Z = max.Z;
+
+                cameraVertices[10].Position.X = max.X;
+                cameraVertices[10].Position.Y = max.Y;
+                cameraVertices[10].Position.Z = max.Z;
+
+                cameraVertices[11].Position.X = max.X;
+                cameraVertices[11].Position.Y = max.Y;
+                cameraVertices[11].Position.Z = min.Z;
+
+                cameraVertices[12].Position.X = min.X;
+                cameraVertices[12].Position.Y = max.Y;
+                cameraVertices[12].Position.Z = min.Z;
+
+                cameraVertices[13].Position.X = min.X;
+                cameraVertices[13].Position.Y = max.Y;
+                cameraVertices[13].Position.Z = max.Z;
+
+                cameraVertices[14].Position.X = min.X;
+                cameraVertices[14].Position.Y = max.Y;
+                cameraVertices[14].Position.Z = min.Z;
+
+                cameraVertices[15].Position.X = max.X;
+                cameraVertices[15].Position.Y = max.Y;
+                cameraVertices[15].Position.Z = min.Z;
+
+                cameraVertices[16].Position.X = max.X;
+                cameraVertices[16].Position.Y = min.Y;
+                cameraVertices[16].Position.Z = max.Z;
+
+                cameraVertices[17].Position.X = max.X;
+                cameraVertices[17].Position.Y = min.Y;
+                cameraVertices[17].Position.Z = min.Z;
+
+                cameraVertices[18].Position.X = max.X;
+                cameraVertices[18].Position.Y = min.Y;
+                cameraVertices[18].Position.Z = max.Z;
+
+                cameraVertices[19].Position.X = min.X;
+                cameraVertices[19].Position.Y = min.Y;
+                cameraVertices[19].Position.Z = max.Z;
+
+                cameraVertices[20].Position.X = min.X;
+                cameraVertices[20].Position.Y = max.Y;
+                cameraVertices[20].Position.Z = max.Z;
+
+                cameraVertices[21].Position.X = min.X;
+                cameraVertices[21].Position.Y = min.Y;
+                cameraVertices[21].Position.Z = max.Z;
+
+                cameraVertices[22].Position.X = max.X;
+                cameraVertices[22].Position.Y = max.Y;
+                cameraVertices[22].Position.Z = min.Z;
+
+                cameraVertices[23].Position.X = max.X;
+                cameraVertices[23].Position.Y = min.Y;
+                cameraVertices[23].Position.Z = min.Z;
+
+                GL.Begin(PrimitiveType.Lines);
+
+                for (int j = 0; j < 24; j += 2)
+                {
+                    GL.Vertex3(cameraVertices[j].Position);
+                    GL.Vertex3(cameraVertices[j + 1].Position);
+                }
+
+                GL.End();
+            }
+        }
+
+        public void DrawContactPoints(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawContactPoints) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            int contactPointCount;
+            Vector3 start1, end1, start2, end2;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                for (int j = 0; j < visiblePhysicsObject.CollisionPairCount; j++)
+                {
+                    contactPointCount = visiblePhysicsObject.GetCollisionPairContactPointCount(j);
+
+                    for (int k = 0; k < contactPointCount; k++)
+                    {
+                        visiblePhysicsObject.GetCollisionPairContactPointAnchor2(j, k, ref position);
+                        visiblePhysicsObject.GetCollisionPairContactPointNormal(j, k, ref direction);
+
+                        Vector3.Multiply(ref direction, 0.5f, out direction);
+
+                        start1 = position;
+                        end1 = direction;
+                        Vector3.Add(ref start1, ref end1, out end1);
+
+                        start2 = end1;
+                        end2 = direction;
+                        Vector3.Add(ref start2, ref end2, out end2);
+
+                        GL.Begin(PrimitiveType.Lines);
+
+                        GL.Color3(1.0f, 1.0f, 1.0f);
+                        GL.Vertex3(start1);
+                        GL.Vertex3(end1);
+
+                        GL.Color3(0.6f, 0.8f, 0.2f);
+                        GL.Vertex3(start2);
+                        GL.Vertex3(end2);
+
+                        GL.End();
+                    }
+                }
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public void DrawImpactFactors(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!enableDrawImpactFactors) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            int contactPointCount;
+            Vector3 start1, end1, start2, end2;
+            float impactFactor, velocityMagnitude;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                for (int j = 0; j < visiblePhysicsObject.CollisionPairCount; j++)
+                {
+                    contactPointCount = visiblePhysicsObject.GetCollisionPairContactPointCount(j);
+
+                    for (int k = 0; k < contactPointCount; k++)
+                    {
+                        visiblePhysicsObject.GetCollisionPairContactPointAnchor2(j, k, ref position);
+                        visiblePhysicsObject.GetCollisionPairContactPointNormal(j, k, ref direction);
+
+                        impactFactor = visiblePhysicsObject.GetCollisionPairContactPointImpactFactor(j, k);
+                        velocityMagnitude = Math.Min(Math.Max(visiblePhysicsObject.MainWorldTransform.GetLinearVelocityMagnitude() - visiblePhysicsObject.MaxSleepLinearVelocity, 0.0f) + Math.Max(visiblePhysicsObject.MainWorldTransform.GetAngularVelocityMagnitude() - visiblePhysicsObject.MaxSleepAngularVelocity, 0.0f), 1.0f);
+                        impactFactor *= velocityMagnitude;
+
+                        if (impactFactor < 0.001f)
+                            continue;
+
+                        Vector3.Multiply(ref direction, (float)impactFactor, out direction);
+                        Vector3.Multiply(ref direction, 0.5f, out direction);
+
+                        start1 = position;
+                        end1 = direction;
+                        Vector3.Add(ref start1, ref end1, out end1);
+
+                        start2 = end1;
+                        end2 = direction;
+                        Vector3.Add(ref start2, ref end2, out end2);
+
+                        GL.Begin(PrimitiveType.Lines);
+
+                        GL.Color3(1.0f, 1.0f, 1.0f);
+                        GL.Vertex3(start1);
+                        GL.Vertex3(end1);
+
+                        GL.Color3(0.6f, 0.8f, 0.2f);
+                        GL.Vertex3(start2);
+                        GL.Vertex3(end2);
+
+                        GL.End();
+                    }
+                }
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera3Draw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera3Draw1.cs
new file mode 100644
index 0000000..a089dcf
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/Camera3Draw1.cs
@@ -0,0 +1,705 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera3Draw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string quadName;
+
+        public bool EnableDrawBoundingBoxes;
+        public bool EnableDrawContactPoints;
+        public bool EnableDrawSlipingObjects;
+        public bool EnableDrawLights;
+        public bool EnableWireframe;
+
+        DrawBuffersEnum[] targets;
+
+        RenderClearTextureDeferredQuadP renderClearTexture;
+        RenderLightDirectionalDeferredQuadP renderLightDirectional;
+        RenderLightPointDeferredP renderLightPoint;
+        RenderLightSpotDeferredP renderLightSpot;
+        RenderScreenDeferredQuadP renderScreen;
+
+        RenderPC render;
+        VertexPositionColor[] cameraVertices;
+
+        Vector3 position;
+        Vector3 direction;
+        Vector3 lightDiffuse;
+        Vector3 lightSpecular;
+        BoundingBox boundingBox;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        Matrix4 matrixIdentity;
+
+        public Camera3Draw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            quadName = "Quad";
+
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            EnableDrawBoundingBoxes = false;
+            EnableDrawContactPoints = false;
+            EnableDrawSlipingObjects = false;
+            EnableDrawLights = false;
+            EnableWireframe = false;
+
+            targets = new DrawBuffersEnum[4];
+
+            cameraVertices = new VertexPositionColor[24];
+
+            renderClearTexture = new RenderClearTextureDeferredQuadP();
+            renderLightDirectional = new RenderLightDirectionalDeferredQuadP();
+            renderLightPoint = new RenderLightPointDeferredP();
+            renderLightSpot = new RenderLightSpotDeferredP();
+            renderScreen = new RenderScreenDeferredQuadP();
+
+            render = new RenderPC();
+        }
+
+        public void SetControllers(bool enableDrawBoundingBoxes, bool enableDrawContactPoints, bool enableDrawSlipingObjects, bool enableDrawLights, bool enableWireframe)
+        {
+            this.EnableDrawBoundingBoxes = enableDrawBoundingBoxes;
+            this.EnableDrawContactPoints = enableDrawContactPoints;
+            this.EnableDrawSlipingObjects = enableDrawSlipingObjects;
+            this.EnableDrawLights = enableDrawLights;
+            this.EnableWireframe = enableWireframe;
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Camera 3" + instanceIndexName);
+
+            if (objectBase != null)
+            {
+                objectBase.Camera.UserDataObj = this;
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawBoundingBoxes);
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawContactPoints);
+            }
+        }
+
+        void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+
+            float time = args.Time;
+
+            PhysicsObject drawPhysicsObject, transparentPhysicsObject, lightPhysicsObject;
+            PhysicsLight sceneLight, drawLight;
+            DemoMesh mesh, quad;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            sceneLight = scene.Light;
+
+            quad = demo.Meshes[quadName];
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.SceneFrameBuffer);
+
+            targets[0] = DrawBuffersEnum.ColorAttachment0;
+            targets[1] = DrawBuffersEnum.ColorAttachment1;
+            targets[2] = DrawBuffersEnum.ColorAttachment2;
+            targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+            GL.DrawBuffers(4, targets);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+            GL.Disable(EnableCap.CullFace);
+
+            renderClearTexture.Width = objectBase.Camera.Projection.Width;
+            renderClearTexture.Height = objectBase.Camera.Projection.Height;
+            renderClearTexture.ColorTexture = demo.ScreenTexture;
+
+            quad.Draw(renderClearTexture);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+
+            for (int i = 0; i < objectBase.Camera.DrawPhysicsObjectCount; i++)
+            {
+                drawPhysicsObject = objectBase.Camera.GetDrawPhysicsObject(i);
+
+                if ((drawPhysicsObject.UserControllers.DrawMethods == null) || (drawPhysicsObject == objectBase))
+                {
+                    if (drawPhysicsObject.UserDataStr == null)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                    mesh = demo.Meshes[drawPhysicsObject.UserDataStr];
+
+                    mesh.Draw(ref world, ref view, ref projection, sceneLight, drawPhysicsObject.Material, objectBase.Camera, drawPhysicsObject.RigidGroupOwner.IsSleeping && EnableDrawSlipingObjects, EnableWireframe);
+                }
+                else
+                {
+                    if (drawPhysicsObject.UserControllers.EnableDraw)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = drawPhysicsObject.Index;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                    drawPhysicsObject.UserControllers.DrawMethods(drawPhysicsObject.UserControllers.DrawMethodArgs);
+                }
+            }
+
+            if (objectBase.Camera.TransparentPhysicsObjectCount != 0)
+            {
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.ColorAttachment1;
+                targets[2] = DrawBuffersEnum.None;
+                targets[3] = DrawBuffersEnum.None;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(false);
+                GL.Enable(EnableCap.Blend);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcAlpha);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && EnableDrawSlipingObjects, EnableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+
+                targets[0] = DrawBuffersEnum.None;
+                targets[1] = DrawBuffersEnum.None;
+                targets[2] = DrawBuffersEnum.ColorAttachment2;
+                targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(true);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+                GL.Disable(EnableCap.Blend);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if (!transparentPhysicsObject.Material.TransparencySecondPass)
+                        continue;
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, transparentPhysicsObject.RigidGroupOwner.IsSleeping && EnableDrawSlipingObjects, EnableWireframe);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+            }
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.LightFrameBuffer);
+
+            GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+
+            GL.ClearColor(demo.ClearLightColor);
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.SrcAlpha);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+            for (int i = 0; i < objectBase.Camera.LightPhysicsObjectCount; i++)
+            {
+                lightPhysicsObject = objectBase.Camera.GetLightPhysicsObject(i);
+
+                drawLight = lightPhysicsObject.Light;
+
+                if ((drawLight == null) || !drawLight.Enabled)
+                    continue;
+
+                if (drawLight.Type == PhysicsLightType.Directional)
+                {
+                    GL.Disable(EnableCap.CullFace);
+
+                    drawLight.GetDirection(ref direction);
+                    drawLight.GetDiffuse(ref lightDiffuse);
+                    drawLight.GetSpecular(ref lightSpecular);
+
+                    renderLightDirectional.Enable = true;
+
+                    renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                    renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                    renderLightDirectional.SetView(ref view);
+                    renderLightDirectional.SetProjection(ref projection);
+
+                    renderLightDirectional.SetLightDirection(ref direction);
+                    renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                    renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                    renderLightDirectional.Intensity = drawLight.Intensity;
+
+                    renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                    renderLightDirectional.NormalTexture = demo.NormalTexture;
+                    renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                    quad.Draw(renderLightDirectional);
+                }
+                else
+                    if (drawLight.Type == PhysicsLightType.Point)
+                    {
+                        lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                        if (EnableDrawLights)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                            lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                            lightPhysicsObject.Material.TransparencySecondPass = false;
+                        }
+
+                        GL.Enable(EnableCap.CullFace);
+                        GL.CullFace(CullFaceMode.Front);
+
+                        lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                        lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                        drawLight.GetDiffuse(ref lightDiffuse);
+                        drawLight.GetSpecular(ref lightSpecular);
+
+                        renderLightPoint.Enable = true;
+
+                        renderLightPoint.Width = objectBase.Camera.Projection.Width;
+                        renderLightPoint.Height = objectBase.Camera.Projection.Height;
+
+                        renderLightPoint.SetWorld(ref world);
+                        renderLightPoint.SetView(ref view);
+                        renderLightPoint.SetProjection(ref projection);
+
+                        renderLightPoint.SetLightPosition(ref position);
+                        renderLightPoint.SetLightDiffuse(ref lightDiffuse);
+                        renderLightPoint.SetLightSpecular(ref lightSpecular);
+                        renderLightPoint.Range = drawLight.Range;
+                        renderLightPoint.Intensity = drawLight.Intensity;
+
+                        renderLightPoint.SpecularTexture = demo.SpecularTexture;
+                        renderLightPoint.NormalTexture = demo.NormalTexture;
+                        renderLightPoint.DepthTexture = demo.DepthTexture;
+
+                        mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                        mesh.Draw(renderLightPoint);
+                    }
+                    else
+                        if (drawLight.Type == PhysicsLightType.Spot)
+                        {
+                            lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+                            if (EnableDrawLights)
+                            {
+                                lightPhysicsObject.EnableAddToCameraDrawTransparentPhysicsObjects = true;
+                                lightPhysicsObject.Material.TransparencyFactor = 0.5f;
+                                lightPhysicsObject.Material.TransparencySecondPass = false;
+                            }
+
+                            GL.Enable(EnableCap.CullFace);
+                            GL.CullFace(CullFaceMode.Front);
+
+                            lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                            lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                            drawLight.GetDiffuse(ref lightDiffuse);
+                            drawLight.GetSpecular(ref lightSpecular);
+                            direction.X = -world.Row1.X;
+                            direction.Y = -world.Row1.Y;
+                            direction.Z = -world.Row1.Z;
+                            Vector3.Subtract(ref position, ref direction, out position);
+
+                            renderLightSpot.Enable = true;
+
+                            renderLightSpot.Width = objectBase.Camera.Projection.Width;
+                            renderLightSpot.Height = objectBase.Camera.Projection.Height;
+
+                            renderLightSpot.SetWorld(ref world);
+                            renderLightSpot.SetView(ref view);
+                            renderLightSpot.SetProjection(ref projection);
+
+                            renderLightSpot.SetLightPosition(ref position);
+                            renderLightSpot.SetLightDirection(ref direction);
+                            renderLightSpot.SetLightDiffuse(ref lightDiffuse);
+                            renderLightSpot.SetLightSpecular(ref lightSpecular);
+                            renderLightSpot.Range = drawLight.Range;
+                            renderLightSpot.Intensity = drawLight.Intensity;
+                            renderLightSpot.InnerRadAngle = drawLight.SpotInnerRadAngle;
+                            renderLightSpot.OuterRadAngle = drawLight.SpotOuterRadAngle;
+
+                            renderLightSpot.SpecularTexture = demo.SpecularTexture;
+                            renderLightSpot.NormalTexture = demo.NormalTexture;
+                            renderLightSpot.DepthTexture = demo.DepthTexture;
+
+                            mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                            mesh.Draw(renderLightSpot);
+                        }
+            }
+
+            if ((sceneLight != null) && sceneLight.Enabled)
+            {
+                GL.Disable(EnableCap.CullFace);
+
+                sceneLight.GetDirection(ref direction);
+                sceneLight.GetDiffuse(ref lightDiffuse);
+                sceneLight.GetSpecular(ref lightSpecular);
+
+                renderLightDirectional.Enable = true;
+
+                renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                renderLightDirectional.SetView(ref view);
+                renderLightDirectional.SetProjection(ref projection);
+
+                renderLightDirectional.SetLightDirection(ref direction);
+                renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                renderLightDirectional.Intensity = sceneLight.Intensity;
+
+                renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                renderLightDirectional.NormalTexture = demo.NormalTexture;
+                renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                quad.Draw(renderLightDirectional);
+            }
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+
+            GL.Disable(EnableCap.CullFace);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+
+            renderScreen.Width = objectBase.Camera.Projection.Width;
+            renderScreen.Height = objectBase.Camera.Projection.Height;
+            renderScreen.ColorTexture = demo.ColorTexture;
+            renderScreen.LightTexture = demo.LightTexture;
+
+            quad.Draw(renderScreen);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+        }
+
+        public void DrawBoundingBoxes(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!EnableDrawBoundingBoxes) return;
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            Vector3 min, max;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            GL.Color3(1.0f, 1.0f, 1.0f);
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                visiblePhysicsObject.GetBoundingBox(ref boundingBox);
+                min = boundingBox.Min;
+                max = boundingBox.Max;
+
+                cameraVertices[0].Position.X = min.X;
+                cameraVertices[0].Position.Y = min.Y;
+                cameraVertices[0].Position.Z = min.Z;
+
+                cameraVertices[1].Position.X = max.X;
+                cameraVertices[1].Position.Y = min.Y;
+                cameraVertices[1].Position.Z = min.Z;
+
+                cameraVertices[2].Position.X = min.X;
+                cameraVertices[2].Position.Y = min.Y;
+                cameraVertices[2].Position.Z = min.Z;
+
+                cameraVertices[3].Position.X = min.X;
+                cameraVertices[3].Position.Y = max.Y;
+                cameraVertices[3].Position.Z = min.Z;
+
+                cameraVertices[4].Position.X = min.X;
+                cameraVertices[4].Position.Y = min.Y;
+                cameraVertices[4].Position.Z = min.Z;
+
+                cameraVertices[5].Position.X = min.X;
+                cameraVertices[5].Position.Y = min.Y;
+                cameraVertices[5].Position.Z = max.Z;
+
+                cameraVertices[6].Position.X = max.X;
+                cameraVertices[6].Position.Y = max.Y;
+                cameraVertices[6].Position.Z = max.Z;
+
+                cameraVertices[7].Position.X = min.X;
+                cameraVertices[7].Position.Y = max.Y;
+                cameraVertices[7].Position.Z = max.Z;
+
+                cameraVertices[8].Position.X = max.X;
+                cameraVertices[8].Position.Y = max.Y;
+                cameraVertices[8].Position.Z = max.Z;
+
+                cameraVertices[9].Position.X = max.X;
+                cameraVertices[9].Position.Y = min.Y;
+                cameraVertices[9].Position.Z = max.Z;
+
+                cameraVertices[10].Position.X = max.X;
+                cameraVertices[10].Position.Y = max.Y;
+                cameraVertices[10].Position.Z = max.Z;
+
+                cameraVertices[11].Position.X = max.X;
+                cameraVertices[11].Position.Y = max.Y;
+                cameraVertices[11].Position.Z = min.Z;
+
+                cameraVertices[12].Position.X = min.X;
+                cameraVertices[12].Position.Y = max.Y;
+                cameraVertices[12].Position.Z = min.Z;
+
+                cameraVertices[13].Position.X = min.X;
+                cameraVertices[13].Position.Y = max.Y;
+                cameraVertices[13].Position.Z = max.Z;
+
+                cameraVertices[14].Position.X = min.X;
+                cameraVertices[14].Position.Y = max.Y;
+                cameraVertices[14].Position.Z = min.Z;
+
+                cameraVertices[15].Position.X = max.X;
+                cameraVertices[15].Position.Y = max.Y;
+                cameraVertices[15].Position.Z = min.Z;
+
+                cameraVertices[16].Position.X = max.X;
+                cameraVertices[16].Position.Y = min.Y;
+                cameraVertices[16].Position.Z = max.Z;
+
+                cameraVertices[17].Position.X = max.X;
+                cameraVertices[17].Position.Y = min.Y;
+                cameraVertices[17].Position.Z = min.Z;
+
+                cameraVertices[18].Position.X = max.X;
+                cameraVertices[18].Position.Y = min.Y;
+                cameraVertices[18].Position.Z = max.Z;
+
+                cameraVertices[19].Position.X = min.X;
+                cameraVertices[19].Position.Y = min.Y;
+                cameraVertices[19].Position.Z = max.Z;
+
+                cameraVertices[20].Position.X = min.X;
+                cameraVertices[20].Position.Y = max.Y;
+                cameraVertices[20].Position.Z = max.Z;
+
+                cameraVertices[21].Position.X = min.X;
+                cameraVertices[21].Position.Y = min.Y;
+                cameraVertices[21].Position.Z = max.Z;
+
+                cameraVertices[22].Position.X = max.X;
+                cameraVertices[22].Position.Y = max.Y;
+                cameraVertices[22].Position.Z = min.Z;
+
+                cameraVertices[23].Position.X = max.X;
+                cameraVertices[23].Position.Y = min.Y;
+                cameraVertices[23].Position.Z = min.Z;
+
+                GL.Begin(PrimitiveType.Lines);
+
+                for (int j = 0; j < 24; j += 2)
+                {
+                    GL.Vertex3(cameraVertices[j].Position);
+                    GL.Vertex3(cameraVertices[j + 1].Position);
+                }
+
+                GL.End();
+            }
+        }
+
+        public void DrawContactPoints(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+            if (!EnableDrawContactPoints) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            PhysicsObject visiblePhysicsObject;
+            int contactPointCount;
+            Vector3 start1, end1, start2, end2;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+            world = matrixIdentity;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            render.Apply();
+
+            for (int i = 0; i < objectBase.Camera.VisiblePhysicsObjectCount; i++)
+            {
+                visiblePhysicsObject = objectBase.Camera.GetVisiblePhysicsObject(i);
+
+                for (int j = 0; j < visiblePhysicsObject.CollisionPairCount; j++)
+                {
+                    contactPointCount = visiblePhysicsObject.GetCollisionPairContactPointCount(j);
+
+                    for (int k = 0; k < contactPointCount; k++)
+                    {
+                        visiblePhysicsObject.GetCollisionPairContactPointAnchor2(j, k, ref position);
+                        visiblePhysicsObject.GetCollisionPairContactPointNormal(j, k, ref direction);
+
+                        Vector3.Multiply(ref direction, 0.5f, out direction);
+
+                        start1 = position;
+                        end1 = direction;
+                        Vector3.Add(ref start1, ref end1, out end1);
+
+                        start2 = end1;
+                        end2 = direction;
+                        Vector3.Add(ref start2, ref end2, out end2);
+
+                        GL.Begin(PrimitiveType.Lines);
+
+                        GL.Color3(1.0f, 1.0f, 1.0f);
+                        GL.Vertex3(start1);
+                        GL.Vertex3(end1);
+
+                        GL.Color3(0.6f, 0.8f, 0.2f);
+                        GL.Vertex3(start2);
+                        GL.Vertex3(end2);
+
+                        GL.End();
+                    }
+                }
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/CursorDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/CursorDraw1.cs
new file mode 100644
index 0000000..d29e630
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/CursorDraw1.cs
@@ -0,0 +1,162 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class CursorDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        RenderPC render;
+
+        Matrix4 projection;
+        Matrix4 view;
+        Matrix4 world;
+
+        Vector3 localLightDirection;
+        Vector3 lightDirection;
+
+        Vector3 startPosition;
+        Vector3 endPosition;
+
+        Matrix4 matrixIdentity;
+
+        public CursorDraw1(Demo demo)
+        {
+            this.demo = demo;
+
+            matrixIdentity = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            render = new RenderPC();
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Cursor A");
+            if (objectBase != null)
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Cursor B");
+            if (objectBase != null)
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Cursor");
+            if (objectBase != null)
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawLine);
+        }
+
+        public void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.EnableDrawing) return;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            float time = args.Time;
+
+            activeCamera.GetTransposeRotation(ref world);
+            Vector3.TransformVector(ref demo.CursorLightDirection, ref world, out localLightDirection);
+
+            activeCamera.View.GetViewMatrix(ref view);
+            activeCamera.Projection.GetProjectionMatrix(ref projection);
+            objectBase.MainWorldTransform.GetTransformMatrix(ref world);
+
+            if (objectBase.UserDataStr != null)
+            {
+                GL.Disable(EnableCap.DepthTest);
+                GL.DepthMask(false);
+
+                DemoMesh mesh = demo.Meshes[objectBase.UserDataStr];
+                PhysicsLight sceneLight = scene.Light;
+
+                sceneLight.GetDirection(ref lightDirection);
+                sceneLight.SetDirection(ref localLightDirection);
+
+                mesh.Draw(ref world, ref view, ref projection, sceneLight, objectBase.Material, activeCamera, false, demo.EnableWireframe);
+
+                sceneLight.SetDirection(ref lightDirection);
+
+                GL.DepthMask(true);
+                GL.Enable(EnableCap.DepthTest);
+            }
+        }
+
+        public void DrawLine(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.EnableDrawing) return;
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            float time = args.Time;
+
+            CursorController cursorController = physicsObjectWithActiveCamera.InternalControllers.CursorController;
+
+            if ((cursorController != null) && cursorController.IsDragging)
+            {
+                activeCamera.View.GetViewMatrix(ref view);
+                activeCamera.Projection.GetProjectionMatrix(ref projection);
+                world = matrixIdentity;
+
+                cursorController.GetAnchor1(ref startPosition);
+                cursorController.GetAnchor2(ref endPosition);
+
+                render.SetWorld(ref world);
+                render.SetView(ref view);
+                render.SetProjection(ref projection);
+
+                render.Apply();
+
+                GL.Begin(PrimitiveType.Lines);
+
+                GL.Color3(0.0f, 1.0f, 0.6f);
+                GL.Vertex3(startPosition);
+                GL.Color3(1.0f, 1.0f, 1.0f);
+                GL.Vertex3(endPosition);
+
+                GL.End();
+            }
+
+            GL.DepthMask(true);
+            GL.Enable(EnableCap.DepthTest);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/LakeDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/LakeDraw1.cs
new file mode 100644
index 0000000..3f93690
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/LakeDraw1.cs
@@ -0,0 +1,106 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class LakeDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+        string lakeInstanceName;
+
+        int partCountX;
+        int partCountZ;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        public LakeDraw1(Demo demo, int instanceIndex, int partCountX, int partCountZ)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+            lakeInstanceName = "Lake" + instanceIndexName;
+            this.partCountX = partCountX;
+            this.partCountZ = partCountZ;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            string partIndexName;
+            PhysicsObject objectBase;
+
+            for (int i = 0; i < partCountX; i++)
+                for (int j = 0; j < partCountZ; j++)
+                {
+                    partIndexName = " " + i.ToString() + " " + j.ToString();
+
+                    objectBase = scene.Factory.PhysicsObjectManager.Find("Lake" + instanceIndexName + partIndexName);
+                    if (objectBase != null)
+                    {
+                        objectBase.UserControllers.EnableDraw = false;
+                        objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+                    }
+                }
+        }
+
+        void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            DemoMesh mesh = demo.Meshes[objectBase.UserDataStr];
+
+            if ((mesh == null) || (mesh.Vertices == null)) return;
+
+            if (mesh.Dynamic && objectBase.Shape.ShapePrimitive.DynamicUpdate)
+            {
+                objectBase.Shape.GetMeshVertices(1.0f, 1.0f, false, true, mesh.Vertices);
+                mesh.SetVertices(mesh.Vertices);
+            }
+
+            float time = args.Time;
+
+            objectBase.MainWorldTransform.GetTransformMatrix(ref world);
+            activeCamera.View.GetViewMatrix(ref view);
+            activeCamera.Projection.GetProjectionMatrix(ref projection);
+
+            PhysicsLight sceneLight = scene.Light;
+
+            if (objectBase.Shape.ShapePrimitive.DynamicUpdateState)
+            {
+                mesh.Draw(ref world, ref view, ref projection, sceneLight, objectBase.Material, activeCamera, false, demo.EnableWireframe);
+            }
+            else
+            {
+                mesh = demo.Meshes[lakeInstanceName];
+
+                mesh.Draw(ref world, ref view, ref projection, sceneLight, objectBase.Material, activeCamera, false, demo.EnableWireframe);
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/MenuDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/MenuDraw1.cs
new file mode 100644
index 0000000..7401366
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/MenuDraw1.cs
@@ -0,0 +1,113 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class MenuDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        PhysicsObject infoScreen;
+        PhysicsObject infoDescription;
+
+        Color whiteColor;
+
+        Vector3 position;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        public MenuDraw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            whiteColor = Color.White;
+
+            world = Matrix4.Identity;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            infoScreen = scene.Factory.PhysicsObjectManager.Find("Info Screen" + instanceIndexName);
+            infoDescription = scene.Factory.PhysicsObjectManager.Find("Info Description" + instanceIndexName);
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Info" + instanceIndexName);
+
+            if (objectBase != null)
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+        }
+
+        void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            PhysicsObject physicsObjectWithCamera = scene.GetPhysicsObjectWithCamera(0);
+
+            if (physicsObjectWithCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            float time = args.Time;
+
+            if ((infoScreen == null) || (infoDescription == null)) return;
+            if (!infoDescription.EnableDrawing) return;
+
+            string sceneScreenName = infoScreen.Material.UserDataStr;
+
+            if (sceneScreenName == null) return;
+            if (!demo.Descriptions.ContainsKey(sceneScreenName)) return;
+
+            List<string> Descriptions = demo.Descriptions[sceneScreenName];
+
+            string info = null;
+
+            infoDescription.MainWorldTransform.GetPosition(ref position);
+            activeCamera.View.GetViewMatrix(ref view);
+            activeCamera.Projection.GetProjectionMatrix(ref projection);
+
+            RenderPCT render = demo.DemoFont3D.Render;
+
+            render.SetWorld(ref world);
+            render.SetView(ref view);
+            render.SetProjection(ref projection);
+
+            GL.CullFace(CullFaceMode.Back);
+
+            demo.DemoFont3D.Begin();
+
+            for (int i = 0; i < Descriptions.Count; i++)
+            {
+                info = Descriptions[i];
+
+                if (info != null)
+                    demo.DemoFont3D.Draw(position.X - 25.0f, position.Y + 12.0f - 1.4f * i, position.Z - 0.5f, 0.08125f, 0.12125f, info, whiteColor);
+            }
+
+            demo.DemoFont3D.End();
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SimpleCameraDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SimpleCameraDraw1.cs
new file mode 100644
index 0000000..1d22e05
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SimpleCameraDraw1.cs
@@ -0,0 +1,467 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class SimpleCameraDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        string quadName;
+
+        DrawBuffersEnum[] targets;
+
+        RenderClearDeferredQuadP renderClear;
+        RenderLightDirectionalDeferredQuadP renderLightDirectional;
+        RenderLightPointDeferredP renderLightPoint;
+        RenderLightSpotDeferredP renderLightSpot;
+        RenderScreenDeferredQuadP renderScreen;
+
+        Vector3 position;
+        Vector3 direction;
+        Vector3 lightDiffuse;
+        Vector3 lightSpecular;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        public SimpleCameraDraw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+
+            quadName = "Quad";
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            targets = new DrawBuffersEnum[4];
+
+            renderClear = new RenderClearDeferredQuadP();
+            renderLightDirectional = new RenderLightDirectionalDeferredQuadP();
+            renderLightPoint = new RenderLightPointDeferredP();
+            renderLightSpot = new RenderLightSpotDeferredP();
+            renderScreen = new RenderScreenDeferredQuadP();
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Simple Camera" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+            }
+        }
+
+        public void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            if (!objectBase.Camera.Enabled) return;
+            if (!objectBase.Camera.Active) return;
+
+            PhysicsObject menuPhysicsObjectWithCamera = demo.MenuScene.PhysicsScene.GetPhysicsObjectWithCamera(0);
+
+            if (menuPhysicsObjectWithCamera != null)
+            {
+                if (menuPhysicsObjectWithCamera.Camera.UserDataObj != null)
+                {
+                    Camera3Draw1 menuCamera = menuPhysicsObjectWithCamera.Camera.UserDataObj as Camera3Draw1;
+
+                    if (menuCamera != null)
+                    {
+                        menuCamera.EnableDrawBoundingBoxes = false;
+                        menuCamera.EnableDrawContactPoints = false;
+                        menuCamera.EnableDrawSlipingObjects = false;
+                        menuCamera.EnableDrawLights = false;
+                        menuCamera.EnableWireframe = false;
+                    }
+                }
+            }
+
+            float time = args.Time;
+
+            PhysicsObject drawPhysicsObject, transparentPhysicsObject, lightPhysicsObject;
+            PhysicsLight sceneLight, drawLight;
+            DemoMesh mesh, quad;
+
+            objectBase.Camera.View.GetViewMatrix(ref view);
+            objectBase.Camera.Projection.GetProjectionMatrix(ref projection);
+
+            sceneLight = scene.Light;
+
+            quad = demo.Meshes[quadName];
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.SceneFrameBuffer);
+
+            targets[0] = DrawBuffersEnum.ColorAttachment0;
+            targets[1] = DrawBuffersEnum.ColorAttachment1;
+            targets[2] = DrawBuffersEnum.ColorAttachment2;
+            targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+            GL.DrawBuffers(4, targets);
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+            GL.Disable(EnableCap.CullFace);
+
+            renderClear.SetClearScreenColor(ref demo.ClearScreenColor);
+
+            quad.Draw(renderClear);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+
+            for (int i = 0; i < objectBase.Camera.DrawPhysicsObjectCount; i++)
+            {
+                drawPhysicsObject = objectBase.Camera.GetDrawPhysicsObject(i);
+
+                if ((drawPhysicsObject.UserControllers.DrawMethods == null) || (drawPhysicsObject == objectBase))
+                {
+                    if (drawPhysicsObject.UserDataStr == null)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                    mesh = demo.Meshes[drawPhysicsObject.UserDataStr];
+
+                    mesh.Draw(ref world, ref view, ref projection, sceneLight, drawPhysicsObject.Material, objectBase.Camera, false, false);
+                }
+                else
+                {
+                    if (drawPhysicsObject.UserControllers.EnableDraw)
+                        continue;
+
+                    if ((drawPhysicsObject.Shape == null) && drawPhysicsObject.IsBrokenRigidGroup)
+                        continue;
+
+                    if ((drawPhysicsObject.RigidGroupOwner != drawPhysicsObject) && (drawPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                        continue;
+
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = drawPhysicsObject.Index;
+                    drawPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                    drawPhysicsObject.UserControllers.DrawMethods(drawPhysicsObject.UserControllers.DrawMethodArgs);
+                }
+            }
+
+            if (objectBase.Camera.TransparentPhysicsObjectCount != 0)
+            {
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.ColorAttachment1;
+                targets[2] = DrawBuffersEnum.None;
+                targets[3] = DrawBuffersEnum.None;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(false);
+                GL.Enable(EnableCap.Blend);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcAlpha);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, false, false);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+
+                targets[0] = DrawBuffersEnum.None;
+                targets[1] = DrawBuffersEnum.None;
+                targets[2] = DrawBuffersEnum.ColorAttachment2;
+                targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.DepthMask(true);
+                GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+                GL.BlendEquation(BlendEquationMode.FuncAdd);
+                GL.Disable(EnableCap.Blend);
+
+                for (int i = 0; i < objectBase.Camera.TransparentPhysicsObjectCount; i++)
+                {
+                    transparentPhysicsObject = objectBase.Camera.GetTransparentPhysicsObject(i);
+
+                    if (!transparentPhysicsObject.Material.TransparencySecondPass)
+                        continue;
+
+                    if ((transparentPhysicsObject.UserControllers.DrawMethods == null) || (transparentPhysicsObject == objectBase))
+                    {
+                        if (transparentPhysicsObject.UserDataStr == null)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+
+                        mesh = demo.Meshes[transparentPhysicsObject.UserDataStr];
+
+                        mesh.Draw(ref world, ref view, ref projection, sceneLight, transparentPhysicsObject.Material, objectBase.Camera, false, false);
+                    }
+                    else
+                    {
+                        if (transparentPhysicsObject.UserControllers.EnableDraw)
+                            continue;
+
+                        if ((transparentPhysicsObject.Shape == null) && transparentPhysicsObject.IsBrokenRigidGroup)
+                            continue;
+
+                        if ((transparentPhysicsObject.RigidGroupOwner != transparentPhysicsObject) && (transparentPhysicsObject.RigidGroupOwner.UserDataStr != null))
+                            continue;
+
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.Time = time;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerIndex = transparentPhysicsObject.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethodArgs.OwnerSceneIndex = scene.Index;
+                        transparentPhysicsObject.UserControllers.DrawMethods(transparentPhysicsObject.UserControllers.DrawMethodArgs);
+                    }
+                }
+            }
+
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.LightFrameBuffer);
+
+            GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+
+            GL.ClearColor(demo.ClearLightColor);
+            GL.Clear(ClearBufferMask.ColorBufferBit);
+
+            GL.Disable(EnableCap.DepthTest);
+            GL.DepthMask(false);
+
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.SrcAlpha);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+
+            for (int i = 0; i < objectBase.Camera.LightPhysicsObjectCount; i++)
+            {
+                lightPhysicsObject = objectBase.Camera.GetLightPhysicsObject(i);
+
+                drawLight = lightPhysicsObject.Light;
+
+                if ((drawLight == null) || !drawLight.Enabled)
+                    continue;
+
+                if (drawLight.Type == PhysicsLightType.Directional)
+                {
+                    GL.Disable(EnableCap.CullFace);
+
+                    drawLight.GetDirection(ref direction);
+                    drawLight.GetDiffuse(ref lightDiffuse);
+                    drawLight.GetSpecular(ref lightSpecular);
+
+                    renderLightDirectional.Enable = true;
+
+                    renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                    renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                    renderLightDirectional.SetView(ref view);
+                    renderLightDirectional.SetProjection(ref projection);
+
+                    renderLightDirectional.SetLightDirection(ref direction);
+                    renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                    renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                    renderLightDirectional.Intensity = drawLight.Intensity;
+
+                    renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                    renderLightDirectional.NormalTexture = demo.NormalTexture;
+                    renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                    quad.Draw(renderLightDirectional);
+                }
+                else
+                    if (drawLight.Type == PhysicsLightType.Point)
+                    {
+                        GL.Enable(EnableCap.CullFace);
+                        GL.CullFace(CullFaceMode.Front);
+
+                        lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                        lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                        drawLight.GetDiffuse(ref lightDiffuse);
+                        drawLight.GetSpecular(ref lightSpecular);
+
+                        renderLightPoint.Enable = true;
+
+                        renderLightPoint.Width = objectBase.Camera.Projection.Width;
+                        renderLightPoint.Height = objectBase.Camera.Projection.Height;
+
+                        renderLightPoint.SetWorld(ref world);
+                        renderLightPoint.SetView(ref view);
+                        renderLightPoint.SetProjection(ref projection);
+
+                        renderLightPoint.SetLightPosition(ref position);
+                        renderLightPoint.SetLightDiffuse(ref lightDiffuse);
+                        renderLightPoint.SetLightSpecular(ref lightSpecular);
+                        renderLightPoint.Range = drawLight.Range;
+                        renderLightPoint.Intensity = drawLight.Intensity;
+
+                        renderLightPoint.SpecularTexture = demo.SpecularTexture;
+                        renderLightPoint.NormalTexture = demo.NormalTexture;
+                        renderLightPoint.DepthTexture = demo.DepthTexture;
+
+                        mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                        mesh.Draw(renderLightPoint);
+                    }
+                    else
+                        if (drawLight.Type == PhysicsLightType.Spot)
+                        {
+                            GL.Enable(EnableCap.CullFace);
+                            GL.CullFace(CullFaceMode.Front);
+
+                            lightPhysicsObject.MainWorldTransform.GetPosition(ref position);
+                            lightPhysicsObject.MainWorldTransform.GetTransformMatrix(ref world);
+                            drawLight.GetDiffuse(ref lightDiffuse);
+                            drawLight.GetSpecular(ref lightSpecular);
+                            direction.X = -world.Row1.X;
+                            direction.Y = -world.Row1.Y;
+                            direction.Z = -world.Row1.Z;
+                            Vector3.Subtract(ref position, ref direction, out position);
+
+                            renderLightSpot.Enable = true;
+
+                            renderLightSpot.Width = objectBase.Camera.Projection.Width;
+                            renderLightSpot.Height = objectBase.Camera.Projection.Height;
+
+                            renderLightSpot.SetWorld(ref world);
+                            renderLightSpot.SetView(ref view);
+                            renderLightSpot.SetProjection(ref projection);
+
+                            renderLightSpot.SetLightPosition(ref position);
+                            renderLightSpot.SetLightDirection(ref direction);
+                            renderLightSpot.SetLightDiffuse(ref lightDiffuse);
+                            renderLightSpot.SetLightSpecular(ref lightSpecular);
+                            renderLightSpot.Range = drawLight.Range;
+                            renderLightSpot.Intensity = drawLight.Intensity;
+                            renderLightSpot.InnerRadAngle = drawLight.SpotInnerRadAngle;
+                            renderLightSpot.OuterRadAngle = drawLight.SpotOuterRadAngle;
+
+                            renderLightSpot.SpecularTexture = demo.SpecularTexture;
+                            renderLightSpot.NormalTexture = demo.NormalTexture;
+                            renderLightSpot.DepthTexture = demo.DepthTexture;
+
+                            mesh = demo.Meshes[lightPhysicsObject.UserDataStr];
+
+                            mesh.Draw(renderLightSpot);
+                        }
+            }
+
+            if ((sceneLight != null) && sceneLight.Enabled)
+            {
+                GL.Disable(EnableCap.CullFace);
+
+                sceneLight.GetDirection(ref direction);
+                sceneLight.GetDiffuse(ref lightDiffuse);
+                sceneLight.GetSpecular(ref lightSpecular);
+
+                renderLightDirectional.Enable = true;
+
+                renderLightDirectional.Width = objectBase.Camera.Projection.Width;
+                renderLightDirectional.Height = objectBase.Camera.Projection.Height;
+
+                renderLightDirectional.SetView(ref view);
+                renderLightDirectional.SetProjection(ref projection);
+
+                renderLightDirectional.SetLightDirection(ref direction);
+                renderLightDirectional.SetLightDiffuse(ref lightDiffuse);
+                renderLightDirectional.SetLightSpecular(ref lightSpecular);
+                renderLightDirectional.Intensity = sceneLight.Intensity;
+
+                renderLightDirectional.SpecularTexture = demo.SpecularTexture;
+                renderLightDirectional.NormalTexture = demo.NormalTexture;
+                renderLightDirectional.DepthTexture = demo.DepthTexture;
+
+                quad.Draw(renderLightDirectional);
+            }
+
+            if (!demo.EnableMenu)
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+            }
+            else
+            {
+                GL.BindFramebuffer(FramebufferTarget.Framebuffer, demo.ScreenFrameBuffer);
+                GL.DrawBuffer(DrawBufferMode.ColorAttachment0);
+            }
+
+            GL.Disable(EnableCap.CullFace);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.BlendEquation(BlendEquationMode.FuncAdd);
+            GL.Disable(EnableCap.Blend);
+
+            renderScreen.Width = objectBase.Camera.Projection.Width;
+            renderScreen.Height = objectBase.Camera.Projection.Height;
+            renderScreen.ColorTexture = demo.ColorTexture;
+            renderScreen.LightTexture = demo.LightTexture;
+
+            quad.Draw(renderScreen);
+
+            GL.Enable(EnableCap.CullFace);
+            GL.Enable(EnableCap.DepthTest);
+            GL.DepthMask(true);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SkyDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SkyDraw1.cs
new file mode 100644
index 0000000..17250f0
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/SkyDraw1.cs
@@ -0,0 +1,194 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class SkyDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        DrawBuffersEnum[] targets;
+
+        //RenderCubeP render;
+        RenderSkyPNT render;
+
+        Vector3 position;
+        Vector3 direction;
+        Vector3 diffuse;
+        Vector3 specular;
+
+        Matrix4 translation;
+        Matrix4 transform;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        int curTime;
+        int oldTime;
+
+        public SkyDraw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+
+            targets = new DrawBuffersEnum[4];
+
+            //render = new RenderCubeP();
+            render = new RenderSkyPNT();
+
+            // Sun position update based on the current time
+            //oldTime = curTime = DateTime.Now.Hour * 60 + DateTime.Now.Minute;
+            //scene.Light.RotationDegAngleX = curTime * 0.25f - 90.0f;
+
+            scene.Light.RotationDegAngleX = 138.0f;
+            scene.Light.RotationDegAngleZ = 10.0f;
+
+            render.SunRotationDegAngleX = scene.Light.RotationDegAngleX;
+            render.SunRotationDegAngleZ = scene.Light.RotationDegAngleZ;
+            render.UpdateSunParameters();
+
+            render.GetLightDirection(ref direction);
+            scene.Light.SetDirection(ref direction);
+        }
+
+        public void SetControllers()
+        {
+            render.SunRotationDegAngleX = scene.Light.RotationDegAngleX;
+            render.SunRotationDegAngleZ = scene.Light.RotationDegAngleZ;
+            render.UpdateSunParameters();
+
+            render.GetLightDirection(ref direction);
+            scene.Light.SetDirection(ref direction);
+
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Sky" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.EnableDraw = false;
+                objectBase.UserControllers.DrawMethods += new DrawMethod(DrawSky);
+            }
+        }
+
+        public void DrawSky(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (keyboardState[Key.J])
+            {
+                scene.Light.RotationDegAngleX += 0.5f;
+
+                render.SunRotationDegAngleX = scene.Light.RotationDegAngleX;
+                render.UpdateSunParameters();
+            }
+
+            if (keyboardState[Key.K])
+            {
+                scene.Light.RotationDegAngleX -= 0.5f;
+
+                render.SunRotationDegAngleX = scene.Light.RotationDegAngleX;
+                render.UpdateSunParameters();
+            }
+
+            curTime = DateTime.Now.Hour * 60 + DateTime.Now.Minute;
+
+            if (curTime != oldTime)
+            {
+                oldTime = curTime;
+
+                // Sun position update based on the current time
+                //scene.Light.RotationDegAngleX = curTime * 0.25f - 90.0f;
+
+                //render.SunRotationDegAngleX = scene.Light.RotationDegAngleX;
+                //render.UpdateSunParameters();
+            }
+
+            render.GetLightDirection(ref direction);
+            render.GetSunColor(ref diffuse);
+
+            Vector3.Multiply(ref diffuse, 0.5f, out diffuse);
+            Vector3.Multiply(ref diffuse, 0.4f, out specular);
+
+            scene.Light.SetDirection(ref direction);
+            scene.Light.SetDiffuse(ref diffuse);
+            scene.Light.SetSpecular(ref specular);
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            if (demo.EnableWireframe) return;
+
+            float time = args.Time;
+
+            activeCamera.View.GetViewMatrix(ref view);
+            activeCamera.Projection.GetProjectionMatrix(ref projection);
+
+            if (objectBase.UserDataStr != null)
+            {
+                DemoMesh mesh = demo.Meshes[objectBase.UserDataStr];
+
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.None;
+                targets[2] = DrawBuffersEnum.None;
+                targets[3] = DrawBuffersEnum.None;
+
+                GL.DrawBuffers(4, targets);
+
+                GL.CullFace(mesh.CullMode);
+                GL.Disable(EnableCap.Texture2D);
+                GL.DepthMask(false);
+
+                physicsObjectWithActiveCamera.MainWorldTransform.GetPosition(ref position);
+                Matrix4.CreateTranslation(ref position, out translation);
+                objectBase.MainWorldTransform.GetTransformMatrix(ref transform);
+                Matrix4.Mult(ref transform, ref translation, out world);
+                //Matrix4.Mult(ref world, ref view, out transform);
+                //Matrix4.Mult(ref transform, ref projection, out world);
+
+                //render.SetWorldViewProjection(ref world);
+                //render.Texture = mesh.DemoTexture.Handle;
+                render.SetWorld(ref world);
+                render.SetView(ref view);
+                render.SetProjection(ref projection);
+
+                mesh.Draw(render);
+
+                GL.DepthMask(true);
+                GL.Enable(EnableCap.Texture2D);
+
+                targets[0] = DrawBuffersEnum.ColorAttachment0;
+                targets[1] = DrawBuffersEnum.ColorAttachment1;
+                targets[2] = DrawBuffersEnum.ColorAttachment2;
+                targets[3] = DrawBuffersEnum.ColorAttachment3;
+
+                GL.DrawBuffers(4, targets);
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/TerrainDraw1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/TerrainDraw1.cs
new file mode 100644
index 0000000..6ac5ae4
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Controllers/Draw/TerrainDraw1.cs
@@ -0,0 +1,81 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class TerrainDraw1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        public TerrainDraw1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void SetControllers()
+        {
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Find("Terrain" + instanceIndexName);
+            if (objectBase != null)
+            {
+                objectBase.UserControllers.EnableDraw = false;
+                objectBase.UserControllers.DrawMethods += new DrawMethod(Draw);
+            }
+        }
+
+        public void Draw(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+            PhysicsObject objectBase = scene.Factory.PhysicsObjectManager.Get(args.OwnerIndex);
+
+            PhysicsObject physicsObjectWithActiveCamera = scene.GetPhysicsObjectWithActiveCamera(0);
+
+            if (physicsObjectWithActiveCamera == null) return;
+
+            PhysicsCamera activeCamera = physicsObjectWithActiveCamera.Camera;
+
+            if (activeCamera == null) return;
+
+            DemoMesh mesh = demo.Meshes[objectBase.UserDataStr];
+
+            if ((mesh == null) || (mesh.Vertices == null)) return;
+
+            if (mesh.Dynamic && objectBase.Shape.ShapePrimitive.DynamicUpdate)
+            {
+                objectBase.Shape.GetMeshVertices(1.0f, 1.0f, false, true, mesh.Vertices);
+                mesh.SetVertices(mesh.Vertices);
+            }
+
+            float time = args.Time;
+
+            objectBase.MainWorldTransform.GetTransformMatrix(ref world);
+            activeCamera.View.GetViewMatrix(ref view);
+            activeCamera.Projection.GetProjectionMatrix(ref projection);
+
+            PhysicsLight sceneLight = scene.Light;
+
+            mesh.Draw(ref world, ref view, ref projection, sceneLight, objectBase.Material, activeCamera, false, demo.EnableWireframe);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Demo.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Demo.cs
new file mode 100644
index 0000000..61795ac
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Demo.cs
@@ -0,0 +1,1208 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+using System.Drawing;
+using System.Drawing.Imaging;
+using OpenTK;
+using OpenTK.Audio;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Demo : GameWindow
+    {
+        DemoMouseState mouseState;
+        DemoKeyboardState keyboardState;
+
+        string infoDrawFPSName;
+        string infoPhysicsFPSName;
+        string infoPhysicsObjectsName;
+        string infoConstraintsName;
+        string infoContactPointsName;
+        string infoMenuName;
+
+        Color whiteColor;
+        public Color4 ClearLightColor;
+        public Vector3 ClearScreenColor;
+
+        StringBuilder infoDrawFPSNameBuilder;
+        StringBuilder infoPhysicsFPSNameBuilder;
+        StringBuilder infoPhysicsObjectsNameBuilder;
+        StringBuilder infoConstraintsNameBuilder;
+        StringBuilder infoContactPointsNameBuilder;
+        int infoDrawFPSNameLength;
+        int infoPhysicsFPSNameLength;
+        int infoPhysicsObjectsNameLength;
+        int infoConstraintsNameLength;
+        int infoContactPointsNameLength;
+
+        public DemoFont DemoFont;
+        public DemoFont3D DemoFont3D;
+
+        public int SceneFrameBuffer;
+        public int SceneDepthBuffer;
+        public int LightFrameBuffer;
+        public int ScreenFrameBuffer;
+
+        public int ColorTexture;
+        public int SpecularTexture;
+        public int NormalTexture;
+        public int DepthTexture;
+        public int LightTexture;
+        public int ScreenTexture;
+
+        public int WindowWidth;
+        public int WindowHeight;
+
+        public bool EnableVertexBuffer;
+        public bool EnableMipmapExtension;
+        public bool EnableCubeMapExtension;
+        public bool EnableWireframe;
+
+        public int SceneIndex;
+
+        // Declare physics engine
+        public PhysicsEngine Engine;
+
+        // Declare scene object
+        public IDemoScene Scene;
+
+        // Declare menu object
+        public MenuScene MenuScene;
+
+        // Declare list of scene objects
+        public List<IDemoScene> Scenes;
+
+        // Declare dictionary of meshes
+        public Dictionary<string, DemoMesh> Meshes;
+
+        // Declare dictionary of textures
+        public Dictionary<string, DemoTexture> Textures;
+
+        // Declare dictionary of menu descriptions
+        public Dictionary<string, List<string>> Descriptions;
+
+        // Declare dictionary of sound samples
+        public Dictionary<string, DemoSoundSample> SoundSamples;
+
+        // Declare dictionary of sound groups
+        public Dictionary<string, DemoSoundGroup> SoundGroups;
+
+        // Declare queue of sounds
+        public DemoSoundQueue SoundQueue;
+
+        AudioContext Audio;
+
+        public bool EnableMenu;
+        public Vector3 CursorLightDirection;
+
+        DemoKeyboardState oldKeyboardState;
+
+        public Demo()
+            : base(1280, 720, GraphicsMode.Default, "Matali Physics Demo (OpenTK)")
+        {
+            SetWindowSize(1280, 720);
+
+            Icon = Properties.Resources.MataliPhysicsDemo;
+
+            Mouse.ButtonUp += Mouse_ButtonUp;
+            Mouse.ButtonDown += Mouse_ButtonDown;
+            Mouse.Move += Mouse_Move;
+            Mouse.WheelChanged += Mouse_WheelChanged;
+            Keyboard.KeyUp += Keyboard_KeyUp;
+            Keyboard.KeyDown += Keyboard_KeyDown;
+
+            infoDrawFPSName = "Draw FPS: ";
+            infoPhysicsFPSName = "Physics FPS: ";
+            infoPhysicsObjectsName = "Physics objects: ";
+            infoConstraintsName = "Constraints: ";
+            infoContactPointsName = "Contact points: ";
+            infoMenuName = "M: Menu";
+
+            whiteColor = Color.White;
+            ClearLightColor = new Color4(0, 0, 0, 0);
+            ClearScreenColor = new Vector3(Color.CornflowerBlue.R / 255.0f, Color.CornflowerBlue.G / 255.0f, Color.CornflowerBlue.B / 255.0f);
+
+            infoDrawFPSNameBuilder = new StringBuilder(infoDrawFPSName);
+            infoPhysicsFPSNameBuilder = new StringBuilder(infoPhysicsFPSName);
+            infoPhysicsObjectsNameBuilder = new StringBuilder(infoPhysicsObjectsName);
+            infoConstraintsNameBuilder = new StringBuilder(infoConstraintsName);
+            infoContactPointsNameBuilder = new StringBuilder(infoContactPointsName);
+            infoDrawFPSNameLength = infoDrawFPSNameBuilder.Length;
+            infoPhysicsFPSNameLength = infoPhysicsFPSNameBuilder.Length;
+            infoPhysicsObjectsNameLength = infoPhysicsObjectsNameBuilder.Length;
+            infoConstraintsNameLength = infoConstraintsNameBuilder.Length;
+            infoContactPointsNameLength = infoContactPointsNameBuilder.Length;
+
+            DemoFont = null;
+            DemoFont3D = null;
+
+            WindowWidth = 1280;
+            WindowHeight = 720;
+
+            EnableVertexBuffer = false;
+            EnableMipmapExtension = false;
+            EnableCubeMapExtension = false;
+
+            // Create a new physics engine
+            Engine = new PhysicsEngine("Engine");
+
+            Scene = null;
+
+            // Create a new menu object
+            MenuScene = new MenuScene(this, "Menu", 1, null);
+
+            // Create a new list of scene objects
+            Scenes = new List<IDemoScene>();
+
+            // Create a new dictionary of meshes
+            Meshes = new Dictionary<string, DemoMesh>();
+
+            // Create a new dictionary of textures
+            Textures = new Dictionary<string, DemoTexture>();
+
+            // Create a new dictionary of menu descriptions
+            Descriptions = new Dictionary<string, List<string>>();
+
+            // Create a new dictionary of sound samples
+            SoundSamples = new Dictionary<string, DemoSoundSample>();
+
+            // Create a new dictionary of sound groups
+            SoundGroups = new Dictionary<string, DemoSoundGroup>();
+
+            // Create a new queue of sounds
+            SoundQueue = new DemoSoundQueue(50);
+
+            try
+            {
+                Audio = new AudioContext();
+            }
+            catch (System.TypeInitializationException e)
+            {
+                
+            }
+            SoundQueue.CreateSources(100);
+
+            EnableMenu = false;
+            CursorLightDirection = new Vector3(0.0f, 0.0f, 1.0f);
+
+            oldKeyboardState = GetKeyboardState();
+        }
+
+        void Mouse_ButtonUp(object sender, MouseButtonEventArgs e)
+        {
+            mouseState.Set(e.Button, false);
+        }
+
+        void Mouse_ButtonDown(object sender, MouseButtonEventArgs e)
+        {
+            mouseState.Set(e.Button, true);
+        }
+
+        void Mouse_Move(object sender, MouseMoveEventArgs e)
+        {
+            mouseState.Set(e.X, e.Y);
+        }
+
+        void Mouse_WheelChanged(object sender, MouseWheelEventArgs e)
+        {
+            mouseState.Set(e.Value);
+        }
+
+        void Keyboard_KeyUp(object sender, KeyboardKeyEventArgs e)
+        {
+            keyboardState.Set(e.Key, false);
+        }
+
+        void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs e)
+        {
+            keyboardState.Set(e.Key, true);
+        }
+
+        public DemoMouseState GetMouseState()
+        {
+            return mouseState;
+        }
+
+        public DemoKeyboardState GetKeyboardState()
+        {
+            return keyboardState;
+        }
+
+        public void SetWindowSize(int width, int height)
+        {
+            if ((Width != width) || (Height != height))
+            {
+                Width = width;
+                Height = height;
+
+                Context.Update(WindowInfo);
+
+                GL.Viewport(0, 0, Width, Height);
+            }
+        }
+
+        public void CreateResources()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out ColorTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ColorTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenTextures(1, out SpecularTexture);
+            GL.BindTexture(TextureTarget.Texture2D, SpecularTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenTextures(1, out NormalTexture);
+            GL.BindTexture(TextureTarget.Texture2D, NormalTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenTextures(1, out DepthTexture);
+            GL.BindTexture(TextureTarget.Texture2D, DepthTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenTextures(1, out LightTexture);
+            GL.BindTexture(TextureTarget.Texture2D, LightTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenTextures(1, out ScreenTexture);
+            GL.BindTexture(TextureTarget.Texture2D, ScreenTexture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba8, Width, Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Rgba, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
+            GL.BindTexture(TextureTarget.Texture2D, 0);
+
+            GL.GenFramebuffers(1, out SceneFrameBuffer);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, SceneFrameBuffer);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment0, TextureTarget.Texture2D, ColorTexture, 0);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment1, TextureTarget.Texture2D, SpecularTexture, 0);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment2, TextureTarget.Texture2D, NormalTexture, 0);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment3, TextureTarget.Texture2D, DepthTexture, 0);
+
+            GL.GenRenderbuffers(1, out SceneDepthBuffer);
+            GL.BindRenderbuffer(RenderbufferTarget.Renderbuffer, SceneDepthBuffer);
+            GL.RenderbufferStorage(RenderbufferTarget.Renderbuffer, RenderbufferStorage.DepthComponent24, Width, Height);
+            GL.FramebufferRenderbuffer(FramebufferTarget.Framebuffer, FramebufferAttachment.DepthAttachment, RenderbufferTarget.Renderbuffer, SceneDepthBuffer);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+
+            GL.GenFramebuffers(1, out LightFrameBuffer);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, LightFrameBuffer);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment0, TextureTarget.Texture2D, LightTexture, 0);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+
+            GL.GenFramebuffers(1, out ScreenFrameBuffer);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, ScreenFrameBuffer);
+            GL.FramebufferTexture2D(FramebufferTarget.Framebuffer, FramebufferAttachment.ColorAttachment0, TextureTarget.Texture2D, ScreenTexture, 0);
+            GL.BindFramebuffer(FramebufferTarget.Framebuffer, 0);
+        }
+
+        public void DisposeResources()
+        {
+            if (ColorTexture != 0)
+            {
+                GL.DeleteTextures(1, ref ColorTexture);
+                ColorTexture = 0;
+            }
+
+            if (SpecularTexture != 0)
+            {
+                GL.DeleteTextures(1, ref SpecularTexture);
+                SpecularTexture = 0;
+            }
+
+            if (NormalTexture != 0)
+            {
+                GL.DeleteTextures(1, ref NormalTexture);
+                NormalTexture = 0;
+            }
+
+            if (DepthTexture != 0)
+            {
+                GL.DeleteTextures(1, ref DepthTexture);
+                DepthTexture = 0;
+            }
+
+            if (LightTexture != 0)
+            {
+                GL.DeleteTextures(1, ref LightTexture);
+                LightTexture = 0;
+            }
+
+            if (ScreenTexture != 0)
+            {
+                GL.DeleteTextures(1, ref ScreenTexture);
+                ScreenTexture = 0;
+            }
+
+            if (SceneDepthBuffer != 0)
+            {
+                GL.DeleteRenderbuffers(1, ref SceneDepthBuffer);
+                SceneDepthBuffer = 0;
+            }
+
+            if (SceneFrameBuffer != 0)
+            {
+                GL.DeleteFramebuffers(1, ref SceneFrameBuffer);
+                SceneFrameBuffer = 0;
+            }
+
+            if (LightFrameBuffer != 0)
+            {
+                GL.DeleteFramebuffers(1, ref LightFrameBuffer);
+                LightFrameBuffer = 0;
+            }
+
+            if (ScreenFrameBuffer != 0)
+            {
+                GL.DeleteFramebuffers(1, ref ScreenFrameBuffer);
+                ScreenFrameBuffer = 0;
+            }
+        }
+
+        /// <summary>
+        /// Called when the user resizes the window.
+        /// </summary>
+        protected override void OnResize(EventArgs e)
+        {
+            Context.Update(WindowInfo);
+
+            if (Width > 0)
+                WindowWidth = Width;
+            if (Height > 0)
+                WindowHeight = Height;
+
+            GL.Viewport(0, 0, Width, Height);
+
+            DemoFont.Resize();
+
+            DisposeResources();
+
+            for (int i = 0; i < Scenes.Count; i++)
+                Scenes[i].DisposeResources();
+
+            MenuScene.DisposeResources();
+
+            CreateResources();
+
+            for (int i = 0; i < Scenes.Count; i++)
+                Scenes[i].CreateResources();
+
+            MenuScene.CreateResources();
+        }
+
+        /// <summary>
+        /// LoadContent will be called once per game and is the place to load
+        /// all of your content.
+        /// </summary>
+        protected override void OnLoad(EventArgs e)
+        {
+            string version = GL.GetString(StringName.Version);
+            int versionNumber = int.Parse(version[0].ToString()) * 10 + int.Parse(version[2].ToString());
+            if (versionNumber < 14)
+            {
+                Console.WriteLine("OpenGL version: " + version + "\nYou need at least OpenGL 1.4 to run this program.");
+                this.Exit();
+                return;
+            }
+
+            if (versionNumber >= 15)
+                EnableVertexBuffer = true;
+
+            string extensions = GL.GetString(StringName.Extensions);
+
+            if (extensions.Contains("GL_SGIS_generate_mipmap"))
+                EnableMipmapExtension = true;
+
+            if (extensions.Contains("GL_EXT_texture_cube_map"))
+                EnableCubeMapExtension = true;
+
+            CreateResources();
+
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.CullFace);
+            GL.ShadeModel(ShadingModel.Smooth);
+            GL.Disable(EnableCap.Dither);
+            GL.Disable(EnableCap.Lighting);
+
+            string soundPath = "Sounds";
+            SoundSamples.Add("Field", new DemoSoundSample(this, soundPath, ".wav"));
+            SoundSamples.Add("Footsteps", new DemoSoundSample(this, soundPath, ".wav"));
+            SoundSamples.Add("Hit1", new DemoSoundSample(this, soundPath, ".wav"));
+            SoundSamples.Add("Hit2", new DemoSoundSample(this, soundPath, ".wav"));
+            SoundSamples.Add("Roll", new DemoSoundSample(this, soundPath, ".wav"));
+            SoundSamples.Add("Slide", new DemoSoundSample(this, soundPath, ".wav"));
+
+            SoundGroups.Add("Default", new DemoSoundGroup(this, 4, SoundSamples["Hit1"], SoundSamples["Roll"], SoundSamples["Slide"], null));
+            SoundGroups.Add("Field", new DemoSoundGroup(this, 4, SoundSamples["Hit2"], SoundSamples["Roll"], SoundSamples["Slide"], SoundSamples["Field"]));
+            SoundGroups.Add("Footsteps", new DemoSoundGroup(this, 4, null, null, SoundSamples["Footsteps"], null));
+            SoundGroups.Add("Hit", new DemoSoundGroup(this, 10, SoundSamples["Hit1"], null, null, null));
+            SoundGroups.Add("Glass", new DemoSoundGroup(this, 4, SoundSamples["Hit2"], SoundSamples["Roll"], SoundSamples["Slide"], null));
+            SoundGroups.Add("Roll", new DemoSoundGroup(this, 4, null, SoundSamples["Roll"], SoundSamples["Roll"], null));
+            SoundGroups.Add("RollSlide", new DemoSoundGroup(this, 4, null, SoundSamples["Roll"], SoundSamples["Slide"], null));
+
+            string materialPath = "Materials";
+            Textures.Add("Default", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Iron", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Brass", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Rubber", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Plastic1", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Plastic2", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Wood1", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Wood2", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Paint1", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Paint2", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Ground", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Blue", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Yellow", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Green", new DemoTexture(this, materialPath, ".jpg", true));
+            Textures.Add("Leaf", new DemoTexture(this, materialPath, ".jpg", true));
+
+            string skycubePath = "Skycubes";
+            Textures.Add("SkyXZ", new DemoTexture(this, skycubePath, ".jpg", true));
+            Textures.Add("SkyPosY", new DemoTexture(this, skycubePath, ".jpg", true));
+            Textures.Add("SkyNegY", new DemoTexture(this, skycubePath, ".jpg", true));
+
+            string fontPath = "Fonts";
+            Textures.Add("DefaultFont", new DemoTexture(this, fontPath, ".png", false));
+
+            string terrainPath = "Terrains";
+            Textures.Add("DefaultHeights", new DemoTexture(this, terrainPath, ".png", false));
+            Textures.Add("DefaultFrictions", new DemoTexture(this, terrainPath, ".png", false));
+            Textures.Add("DefaultRestitutions", new DemoTexture(this, terrainPath, ".png", false));
+
+            string menuPath = "Menus";
+            string menuScreensPath = null;
+
+            menuPath = Path.Combine(menuPath, "Default");
+            menuScreensPath = Path.Combine(menuPath, "Screens");
+
+            Textures.Add("DefaultShapes", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("UserShapes", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Stacks", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Ragdolls", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Bridges", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Building", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("AI", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Helicopters", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Buildings", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("TerrainWithWater", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Animation", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Cloth", new DemoTexture(this, menuScreensPath, ".jpg", true));
+            Textures.Add("Meshes", new DemoTexture(this, menuScreensPath, ".jpg", true));
+
+            string path = null;
+            string directoryPath = null;
+            string changeDirectorySeparator = "..";
+            directoryPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, changeDirectorySeparator);
+            directoryPath = Path.Combine(directoryPath, "Data");
+            directoryPath = Path.GetFullPath(directoryPath);
+
+            Dictionary<string, DemoSoundSample>.Enumerator position1 = SoundSamples.GetEnumerator();
+            while (position1.MoveNext())
+            {
+                DemoSoundSample soundSample = position1.Current.Value;
+                string soundName = position1.Current.Key + soundSample.FileExt;
+
+                path = directoryPath;
+
+                if (soundSample.FileDirectory != null)
+                    path = Path.Combine(path, soundSample.FileDirectory);
+
+                path = Path.Combine(path, soundName);
+
+                if (File.Exists(path))
+                {
+                    soundSample.Set(File.OpenRead(path));
+                }
+                else
+                {
+                    Console.WriteLine("File " + path + " could not be found.");
+                    this.Exit();
+                    return;
+                }
+            }
+
+            Dictionary<string, DemoTexture>.Enumerator position2 = Textures.GetEnumerator();
+            while (position2.MoveNext())
+            {
+                DemoTexture texture = position2.Current.Value;
+                string textureName = position2.Current.Key + texture.FileExt;
+
+                path = directoryPath;
+
+                if (texture.FileDirectory != null)
+                    path = Path.Combine(path, texture.FileDirectory);
+
+                path = Path.Combine(path, textureName);
+
+                if (File.Exists(path))
+                {
+                    texture.Create(new Bitmap(path));
+                }
+                else
+                {
+                    Console.WriteLine("File " + path + " could not be found.");
+                    this.Exit();
+                    return;
+                }
+            }
+
+            Textures.Add("Sky", new DemoTexture(this, Textures["SkyXZ"].Bitmap, Textures["SkyPosY"].Bitmap, Textures["SkyNegY"].Bitmap, true));
+
+            DemoFont = new DemoFont(this, "DefaultFont", 150);
+            DemoFont3D = new DemoFont3D(this, "DefaultFont", 150);
+
+            // Create a new lists of menu descriptions
+            Descriptions.Add("DefaultShapes", new List<string>() {
+            "Scene:",      
+            "Default shapes",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A: Player control",
+            "Mouse right button: Camera control",
+            "J, K: Sun position control",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("UserShapes", new List<string>() {
+            "Scene:",
+            "User shapes, transparent objects, force fields, switches,",
+            "triangle meshes",
+            null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A: Player control",
+            "Mouse right button: Camera control",
+            "J, K: Sun position control",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Stacks", new List<string>() {
+            "Scene:",
+            "Stacking (Jenga, Pyramid, Wall)",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A: Player control",
+            "Mouse right button: Camera control",
+            "J, K: Sun position control",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors, ",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Ragdolls", new List<string>() {
+            "Scene:",
+            "Ragdolls",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Bridges", new List<string>() {
+            "Scene:",
+            "Bridges, vehicle, ragdoll",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A: Player control",
+            "Mouse right button: Camera control",
+            "J, K: Sun position control",
+            "Arrows up, down, right, left: Vehicle remote control",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Building", new List<string>() {
+            "Scene:",
+            "Building, vehicle, ragdoll, plant, particles",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "Arrows up, down, right, left: Vehicle remote control",
+            "Space + Collision with switch: Switch to driver seat",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("AI", new List<string>() {
+            "Scene:",
+            "Simple physical AI",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "Arrows up, down, right, left, PgUp/Down, F: Vehicle remote control, vehicle shoot",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Helicopters", new List<string>() {
+            "Scene:",
+            "Physical waypoints, vehicles in the air",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "Collision with switch: Run vehicle",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Buildings", new List<string>() {
+            "Scene:",
+            "Buildings, bridge",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("TerrainWithWater", new List<string>() {
+            "Scene:",
+            "Terrain, water, vehicles",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "Arrows up, down, right, left: Vehicle remote control",
+            "Space + Collision with switch: Switch to driver seat",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Animation", new List<string>() {
+            "Scene:",
+            "Physical animation",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Cloth", new List<string>() {
+            "Scene:",
+            "Point cloth",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "Collision with switch: Run machine",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            Descriptions.Add("Meshes", new List<string>() {
+            "Scene:",
+            "Triangle meshes",
+            null, null,
+            "Input:",
+            "+, -: Toggle scene",
+            "R: Reset scene",
+            "W, S, D, A, Space: Player control",
+            "Mouse right button: Camera control",
+            "J, K, Tab: Sun position control, Toggle camera mode",
+            "B, C, V, I, G, N: Show bounding boxes, contact points, sleeping objects, impact factors,",
+            "lights, wireframe objects",
+            "Mouse move: Cursor control",
+            "Mouse middle buton, ctrl: Shoot",
+            "Mouse move + mouse left button: Grab objects",
+            "Mouse wheel + mouse left button: Move objects to and from player",
+            "P: Print screen to file" });
+
+            // Create a new scene objects
+            Scenes.Add(new DefaultShapesScene(this, "DefaultShapes", 1, "Default shapes"));
+            Scenes.Add(new UserShapesScene(this, "UserShapes", 1, "User shapes, transparent objects, force fields, switches, triangle meshes"));
+            Scenes.Add(new StacksScene(this, "Stacks", 1, "Stacking (Jenga, Pyramid, Wall)"));
+            Scenes.Add(new RagdollsScene(this, "Ragdolls", 1, "Ragdolls"));
+            Scenes.Add(new BridgesScene(this, "Bridges", 1, "Bridges, vehicle, ragdoll"));
+            Scenes.Add(new BuildingScene(this, "Building", 1, "Building, vehicle, ragdoll, plant, particles"));
+            Scenes.Add(new AIScene(this, "AI", 1, "Simple physical AI"));
+            Scenes.Add(new HelicoptersScene(this, "Helicopters", 1, "Physical waypoints, vehicles in the air"));
+            Scenes.Add(new BuildingsScene(this, "Buildings", 1, "Buildings, bridge"));
+            Scenes.Add(new TerrainWithWaterScene(this, "TerrainWithWater", 1, "Terrain, water, vehicles"));
+            Scenes.Add(new AnimationScene(this, "Animation", 1, "Physical animation"));
+            Scenes.Add(new ClothScene(this, "Cloth", 1, "Point cloth"));
+            Scenes.Add(new MeshesScene(this, "Meshes", 1, "Triangle meshes"));
+            //Scenes.Add(new SimpleScene(this, "Simple", 1, "Simple scene"));
+
+            // Create a new physics scene for the menu object
+            MenuScene.Create();
+            MenuScene.Refresh(0.0);
+
+            // Create a new physics scene for the scene object
+            SceneIndex = 0;
+            Scene = Scenes[SceneIndex];
+            Scene.Create();
+            Scene.Refresh(0.0);
+        }
+
+        /// <summary>
+        /// UnloadContent will be called once per game and is the place to unload
+        /// all content.
+        /// </summary>
+        protected override void OnUnload(EventArgs e)
+        {
+            Meshes.Clear();
+            Scenes.Clear();
+            Textures.Clear();
+
+            Engine.Exit();
+        }
+
+        /// <summary>
+        /// Allows the game to run logic such as updating the world,
+        /// checking for collisions, gathering input, and playing audio.
+        /// </summary>
+        protected override void OnUpdateFrame(FrameEventArgs e)
+        {
+        }
+
+        protected void OnUpdateFrame(double time)
+        {
+            DemoKeyboardState keyboardState = GetKeyboardState();
+
+            if (keyboardState[Key.Escape])
+                this.Exit();
+
+            if (keyboardState[Key.M] && !oldKeyboardState[Key.M])
+            {
+                EnableMenu = !EnableMenu;
+
+                if (EnableMenu)
+                {
+                    MenuScene.Create();
+                    MenuScene.Refresh(0.0);
+                }
+            }
+
+            if (keyboardState[Key.R] && !oldKeyboardState[Key.R])
+            {
+                ClearAllSounds();
+
+                Scene.Remove();
+                Scene.Create();
+                Scene.Refresh(0.0);
+            }
+
+            if (keyboardState[Key.P] && !oldKeyboardState[Key.P])
+            {
+                int screenCount = 1;
+                while (File.Exists(AppDomain.CurrentDomain.BaseDirectory + "Screen" + screenCount.ToString("d3") + ".bmp"))
+                    screenCount++;
+
+                Bitmap texture = new Bitmap(Width, Height, System.Drawing.Imaging.PixelFormat.Format24bppRgb);
+                BitmapData data = texture.LockBits(new Rectangle(0, 0, texture.Width, texture.Height), ImageLockMode.WriteOnly, texture.PixelFormat);
+                GL.ReadPixels(0, 0, texture.Width, texture.Height, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                texture.UnlockBits(data);
+                texture.RotateFlip(RotateFlipType.RotateNoneFlipY);
+                texture.Save(AppDomain.CurrentDomain.BaseDirectory + "Screen" + screenCount.ToString("d3") + ".bmp", ImageFormat.Bmp);
+            }
+
+            if (keyboardState[Key.Plus] && !oldKeyboardState[Key.Plus])
+            {
+                ClearAllSounds();
+
+                SceneIndex = (SceneIndex + 1) % Scenes.Count;
+                Scene = Scenes[SceneIndex];
+                Scene.Create();
+                Scene.Refresh(0.0);
+            }
+
+            if (keyboardState[Key.Minus] && !oldKeyboardState[Key.Minus])
+            {
+                ClearAllSounds();
+
+                SceneIndex = (SceneIndex - 1) < 0 ? Scenes.Count - 1 : SceneIndex - 1;
+                Scene = Scenes[SceneIndex];
+                Scene.Create();
+                Scene.Refresh(0.0);
+            }
+
+            oldKeyboardState = keyboardState;
+
+            // Simulate with the synchronization
+            bool isSimulateSynchronized = Scene.PhysicsScene.IsSimulateSynchronized(time);
+
+            if (EnableMenu && isSimulateSynchronized)
+            {
+                int oldSceneIndex = SceneIndex;
+
+                MenuScene.PhysicsScene.Simulate(time);
+
+                if (SceneIndex != oldSceneIndex)
+                {
+                    ClearAllSounds();
+
+                    Scene = Scenes[SceneIndex];
+                    Scene.Create();
+                    Scene.Refresh(0.0);
+                }
+            }
+
+            Scene.PhysicsScene.SimulateWithSynchronization(time);
+
+            UpdateSoundQueue();
+        }
+
+        /// <summary>
+        /// This is called when the game should draw itself.
+        /// </summary>
+        protected override void OnRenderFrame(FrameEventArgs e)
+        {
+            double time = e.Time;
+
+            OnUpdateFrame(time);
+
+            // Draw with the synchronization
+            bool isDrawSynchronized = Scene.PhysicsScene.IsDrawSynchronized(time);
+
+            if (isDrawSynchronized) GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            Scene.PhysicsScene.DrawWithSynchronization(time);
+
+            if (EnableMenu && isDrawSynchronized)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                MenuScene.PhysicsScene.Draw(time);
+            }
+
+            if (isDrawSynchronized) SwapBuffers();
+        }
+
+        public void DrawInfo(DrawMethodArgs args)
+        {
+            PhysicsScene scene = Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+
+            int offsetX = 0;
+            int offsetY = 0;
+
+            int physicsObjectCount = scene.TotalPhysicsObjectCount;
+            int constraintCount = scene.TotalConstraintCount;
+            int contactPointCount = scene.TotalContactPointCount;
+
+            if (EnableMenu)
+            {
+                physicsObjectCount += MenuScene.PhysicsScene.TotalPhysicsObjectCount;
+                constraintCount += MenuScene.PhysicsScene.TotalConstraintCount;
+                contactPointCount += MenuScene.PhysicsScene.TotalContactPointCount;
+            }
+
+            infoDrawFPSNameBuilder.Remove(infoDrawFPSNameLength, infoDrawFPSNameBuilder.Length - infoDrawFPSNameLength);
+            infoDrawFPSNameBuilder.Append((int)(scene.DrawFPS + 0.5f));
+
+            infoPhysicsFPSNameBuilder.Remove(infoPhysicsFPSNameLength, infoPhysicsFPSNameBuilder.Length - infoPhysicsFPSNameLength);
+            infoPhysicsFPSNameBuilder.Append((int)(scene.SimulationFPS + 0.5f));
+
+            infoPhysicsObjectsNameBuilder.Remove(infoPhysicsObjectsNameLength, infoPhysicsObjectsNameBuilder.Length - infoPhysicsObjectsNameLength);
+            infoPhysicsObjectsNameBuilder.Append(physicsObjectCount);
+
+            infoConstraintsNameBuilder.Remove(infoConstraintsNameLength, infoConstraintsNameBuilder.Length - infoConstraintsNameLength);
+            infoConstraintsNameBuilder.Append(constraintCount);
+
+            infoContactPointsNameBuilder.Remove(infoContactPointsNameLength, infoContactPointsNameBuilder.Length - infoContactPointsNameLength);
+            infoContactPointsNameBuilder.Append(contactPointCount);
+
+            GL.CullFace(CullFaceMode.Back);
+
+            DemoFont.Begin();
+
+            DemoFont.Draw(offsetX + 15, offsetY + 15, 1.0f, 1.0f, Scene.SceneInfo, whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 30, 1.0f, 1.0f, infoDrawFPSNameBuilder.ToString(), whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 45, 1.0f, 1.0f, infoPhysicsFPSNameBuilder.ToString(), whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 60, 1.0f, 1.0f, infoPhysicsObjectsNameBuilder.ToString(), whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 75, 1.0f, 1.0f, infoConstraintsNameBuilder.ToString(), whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 90, 1.0f, 1.0f, infoContactPointsNameBuilder.ToString(), whiteColor);
+            DemoFont.Draw(offsetX + 15, offsetY + 105, 1.0f, 1.0f, infoMenuName, whiteColor);
+
+            DemoFont.End();
+        }
+
+        public void UpdateSoundQueue()
+        {
+            DemoSound sound;
+
+            while (SoundQueue.SoundCount > 0)
+            {
+                sound = SoundQueue.DequeueSound();
+                sound.Start();
+            }
+        }
+
+        public void ClearAllSounds()
+        {
+            SoundQueue.Clear();
+
+            Dictionary<string, DemoSoundGroup>.Enumerator position = SoundGroups.GetEnumerator();
+            while (position.MoveNext())
+                position.Current.Value.ClearAllSounds();
+        }
+
+        public static void CreateSharedShapes(Demo demo, PhysicsScene scene)
+        {
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Point");
+            shapePrimitive.CreatePoint(0.0f, 0.0f, 0.0f);
+            shape = scene.Factory.ShapeManager.Create("Point");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.1f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Edge");
+            shapePrimitive.CreateEdge(-Vector3.UnitY, Vector3.UnitY);
+            shape = scene.Factory.ShapeManager.Create("Edge");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.1f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Box");
+            shapePrimitive.CreateBox(1.0f);
+            shape = scene.Factory.ShapeManager.Create("Box");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("CylinderY");
+            shapePrimitive.CreateCylinderY(2.0f, 1.0f);
+            shape = scene.Factory.ShapeManager.Create("CylinderY");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Sphere");
+            shapePrimitive.CreateSphere(1.0f);
+            shape = scene.Factory.ShapeManager.Create("Sphere");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            // Declare and initialize the displacement vector of geometric center 
+            // with negated value returned by GetCenterTranslation function
+            // after use TranslateToCenter function in TriangleMesh class for hemisphere
+            Vector3 centerTranslation = new Vector3(0.0f, -0.03638184f, -0.4571095f);
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("HemisphereZ");
+            shapePrimitive.CreateHemisphereZ(1.0f);
+            shape = scene.Factory.ShapeManager.Create("HemisphereZ");
+            shape.Set(shapePrimitive, Matrix4.CreateTranslation(centerTranslation), 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("ConeY");
+            shapePrimitive.CreateConeY(2.0f, 1.0f);
+            shape = scene.Factory.ShapeManager.Create("ConeY");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("ConeZ");
+            shapePrimitive.CreateConeZ(2.0f, 1.0f);
+            shape = scene.Factory.ShapeManager.Create("ConeZ");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("CapsuleY");
+            shapePrimitive.CreateCapsuleY(2.0f, 1.0f);
+            shape = scene.Factory.ShapeManager.Create("CapsuleY");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            TriangleMesh triangleMesh = null;
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Point");
+            triangleMesh.CreateSphere(5, 10, 1.0f);
+            if (!demo.Meshes.ContainsKey("Point"))
+                demo.Meshes.Add("Point", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Edge");
+            triangleMesh.CreateCylinderY(1, 10, 2.2f, 1.0f);
+            if (!demo.Meshes.ContainsKey("Edge"))
+                demo.Meshes.Add("Edge", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Box");
+            triangleMesh.CreateBox(1.0f);
+            if (!demo.Meshes.ContainsKey("Box"))
+                demo.Meshes.Add("Box", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, false, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("CylinderY");
+            triangleMesh.CreateCylinderY(1, 15, 2.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("CylinderY"))
+                demo.Meshes.Add("CylinderY", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Sphere");
+            triangleMesh.CreateSphere(10, 15, 1.0f);
+            if (!demo.Meshes.ContainsKey("Sphere"))
+                demo.Meshes.Add("Sphere", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("HemisphereZ");
+            triangleMesh.CreateHemisphereZ(5, 15, 1.0f);
+            triangleMesh.TranslateToCenter();
+            if (!demo.Meshes.ContainsKey("HemisphereZ"))
+                demo.Meshes.Add("HemisphereZ", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("ConeY");
+            triangleMesh.CreateConeY(1, 15, 2.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("ConeY"))
+                demo.Meshes.Add("ConeY", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("ConeZ");
+            triangleMesh.CreateConeZ(1, 15, 2.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("ConeZ"))
+                demo.Meshes.Add("ConeZ", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("CapsuleY");
+            triangleMesh.CreateCapsuleY(10, 15, 2.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("CapsuleY"))
+                demo.Meshes.Add("CapsuleY", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Sky");
+            triangleMesh.CreateSphere(10, 10, 1.0f);
+            if (!demo.Meshes.ContainsKey("Sky"))
+                demo.Meshes.Add("Sky", new DemoMesh(demo, triangleMesh, demo.Textures["Sky"], Vector2.One, true, true, true, false, true, CullFaceMode.Front, false, false));
+
+            Vector3 point1, point2, point3;
+            point1 = new Vector3(-1.0f, -1.0f, 0.0f);
+            point2 = new Vector3(-1.0f, 1.0f, 0.0f);
+            point3 = new Vector3(1.0f, 1.0f, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Triangle1");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Triangle1"))
+                demo.Meshes.Add("Triangle1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, false));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Triangle1");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Triangle1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            point1 = new Vector3(1.0f, 1.0f, 0.0f);
+            point2 = new Vector3(1.0f, -1.0f, 0.0f);
+            point3 = new Vector3(-1.0f, -1.0f, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Triangle2");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Triangle2"))
+                demo.Meshes.Add("Triangle2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, false));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Triangle2");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Triangle2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Quad");
+
+            float[] positionsX = { -1.0f, -1.0f, 1.0f, 1.0f };
+            float[] positionsY = { -1.0f, 1.0f, 1.0f, -1.0f };
+
+            triangleMesh.CreateWall(Vector3.Zero, Vector3.UnitZ, positionsX, positionsY);
+
+            if (!demo.Meshes.ContainsKey("Quad"))
+                demo.Meshes.Add("Quad", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, false));
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont.cs
new file mode 100644
index 0000000..7dbdca9
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont.cs
@@ -0,0 +1,156 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoFont
+    {
+        Demo demo;
+        int textureHandle;
+        float[] fontTranslations = new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6, 11, 8, 13, 10, 4, 6, 6, 8, 11, 5, 6, 5, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 11, 11, 11, 7, 13, 9, 9, 9, 10, 8, 8, 10, 10, 6, 6, 9, 8, 11, 10, 10, 8, 10, 9, 8, 9, 10, 9, 13, 9, 9, 8, 6, 6, 6, 11, 8, 8, 8, 8, 7, 8, 8, 5, 8, 8, 4, 5, 8, 4, 12, 8, 8, 8, 8, 6, 7, 5, 8, 8, 11, 7, 8, 7, 7, 6, 7, 11, 13, 13, 13, 13, 13, 4, 1, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 4, 5, 8, 8, 8, 8, 6, 8, 8, 13, 7, 9, 11, 6, 13, 8, 7, 11, 7, 7, 8, 8, 8, 6, 8, 7, 7, 9, 13, 13, 13, 7, 9, 9, 9, 9, 9, 9, 13, 9, 8, 8, 8, 8, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 9, 8, 8, 8, 8, 8, 8, 8, 8, 13, 7, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 11, 8, 8, 8, 8, 8, 8, 8, 8 };
+        int fontVertexBuffer;
+        VertexPositionColorTexture[] fontVertices;
+
+        Matrix4 world;
+        Matrix4 view;
+        Matrix4 projection;
+
+        public RenderPCT Render;
+
+        public DemoFont(Demo demo, string fontTextureName, int maxTextLength)
+        {
+            this.demo = demo;
+            textureHandle = demo.Textures[fontTextureName].Handle;
+
+            fontVertices = new VertexPositionColorTexture[maxTextLength << 2];
+
+            GL.GenBuffers(1, out fontVertexBuffer);
+
+            Resize();
+
+            Render = new RenderPCT();
+        }
+
+        public void Resize()
+        {
+            world = view = Matrix4.Identity;
+            projection = Matrix4.CreateOrthographicOffCenter(0, demo.Width, 0, demo.Height, -1.0f, 1.0f);
+        }
+
+        public void Begin()
+        {
+            GL.Disable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.One);
+            GL.EnableClientState(ArrayCap.VertexArray);
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.TextureCoordArray);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, fontVertexBuffer);
+            GL.VertexPointer(3, VertexPointerType.Float, 24, IntPtr.Zero);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 24, (IntPtr)12);
+            GL.TexCoordPointer(2, TexCoordPointerType.Float, 24, (IntPtr)16);
+            Render.SetWorld(ref world);
+            Render.SetView(ref view);
+            Render.SetProjection(ref projection);
+            Render.EnableTexture = true;
+            Render.Texture = textureHandle;
+        }
+
+        public void End()
+        {
+            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
+            GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DisableClientState(ArrayCap.VertexArray);
+            GL.DisableClientState(ArrayCap.ColorArray);
+            GL.DisableClientState(ArrayCap.TextureCoordArray);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.Disable(EnableCap.Blend);
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        public void Draw(float x, float y, float scaleX, float scaleY, string text, Color color)
+        {
+            int fontValue, textLength, textBufferLength, fontColor;
+            float u, v, translation, fontSizeX, fontSizeY, fontWidth, fontHeight, fontMargin;
+            Matrix4 fontTranslation, fontWorld;
+
+            Render.GetWorld(ref world);
+
+            Matrix4.CreateTranslation(x, demo.Height - y - 16 * scaleY, 0.0f, out fontTranslation);
+            Matrix4.Mult(ref world, ref fontTranslation, out fontWorld);
+
+            Render.SetWorld(ref fontWorld);
+
+            translation = 0.0f;
+            fontSizeX = 16 * scaleX;
+            fontSizeY = 16 * scaleY;
+            fontWidth = 1.0f / 16.0f;
+            fontHeight = 1.0f / 16.0f;
+            fontMargin = 1.0f / 256.0f;
+            fontColor = color.ToArgb();
+
+            for (int i = 0, j = 0; i < text.Length; i++, j += 4)
+            {
+                fontValue = (int)text[i];
+                u = (float)(fontValue % 16) * fontWidth + fontMargin;
+                v = (float)(fontValue >> 4) * fontHeight + fontMargin;
+
+                fontVertices[j].Position.X = translation;
+                fontVertices[j].Position.Y = 0.0f;
+                fontVertices[j].Position.Z = 0.0f;
+                fontVertices[j].TextureCoordinate.X = u;
+                fontVertices[j].TextureCoordinate.Y = v + fontHeight;
+                fontVertices[j].Color = fontColor;
+
+                fontVertices[j + 1].Position.X = fontSizeX + translation;
+                fontVertices[j + 1].Position.Y = 0.0f;
+                fontVertices[j + 1].Position.Z = 0.0f;
+                fontVertices[j + 1].TextureCoordinate.X = u + fontWidth;
+                fontVertices[j + 1].TextureCoordinate.Y = v + fontHeight;
+                fontVertices[j + 1].Color = fontColor;
+
+                fontVertices[j + 2].Position.X = translation;
+                fontVertices[j + 2].Position.Y = fontSizeY;
+                fontVertices[j + 2].Position.Z = 0.0f;
+                fontVertices[j + 2].TextureCoordinate.X = u;
+                fontVertices[j + 2].TextureCoordinate.Y = v;
+                fontVertices[j + 2].Color = fontColor;
+
+                fontVertices[j + 3].Position.X = fontSizeX + translation;
+                fontVertices[j + 3].Position.Y = fontSizeY;
+                fontVertices[j + 3].Position.Z = 0.0f;
+                fontVertices[j + 3].TextureCoordinate.X = u + fontWidth;
+                fontVertices[j + 3].TextureCoordinate.Y = v;
+                fontVertices[j + 3].Color = fontColor;
+
+                translation += fontTranslations[fontValue] * scaleX;
+            }
+
+            textLength = text.Length << 2;
+            textBufferLength = 24 * textLength;
+
+            Render.Apply();
+
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)textBufferLength, IntPtr.Zero, BufferUsageHint.DynamicDraw);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)textBufferLength, fontVertices, BufferUsageHint.DynamicDraw);
+
+            GL.DrawArrays(PrimitiveType.TriangleStrip, 0, textLength);
+
+            Render.SetWorld(ref world);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont3D.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont3D.cs
new file mode 100644
index 0000000..1775592
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoFont3D.cs
@@ -0,0 +1,143 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoFont3D
+    {
+        Demo demo;
+        int textureHandle;
+        float[] fontTranslations = new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6, 11, 8, 13, 10, 4, 6, 6, 8, 11, 5, 6, 5, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 11, 11, 11, 7, 13, 9, 9, 9, 10, 8, 8, 10, 10, 6, 6, 9, 8, 11, 10, 10, 8, 10, 9, 8, 9, 10, 9, 13, 9, 9, 8, 6, 6, 6, 11, 8, 8, 8, 8, 7, 8, 8, 5, 8, 8, 4, 5, 8, 4, 12, 8, 8, 8, 8, 6, 7, 5, 8, 8, 11, 7, 8, 7, 7, 6, 7, 11, 13, 13, 13, 13, 13, 4, 1, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 4, 5, 8, 8, 8, 8, 6, 8, 8, 13, 7, 9, 11, 6, 13, 8, 7, 11, 7, 7, 8, 8, 8, 6, 8, 7, 7, 9, 13, 13, 13, 7, 9, 9, 9, 9, 9, 9, 13, 9, 8, 8, 8, 8, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 9, 8, 8, 8, 8, 8, 8, 8, 8, 13, 7, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 11, 8, 8, 8, 8, 8, 8, 8, 8 };
+        int fontVertexBuffer;
+        VertexPositionColorTexture[] fontVertices;
+
+        Matrix4 world;
+
+        public RenderPCT Render;
+
+        public DemoFont3D(Demo demo, string fontTextureName, int maxTextLength)
+        {
+            this.demo = demo;
+            textureHandle = demo.Textures[fontTextureName].Handle;
+
+            fontVertices = new VertexPositionColorTexture[maxTextLength << 2];
+
+            Render = new RenderPCT();
+
+            GL.GenBuffers(1, out fontVertexBuffer);
+        }
+
+        public void Begin()
+        {
+            GL.DepthMask(false);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.One);
+            GL.EnableClientState(ArrayCap.VertexArray);
+            GL.EnableClientState(ArrayCap.ColorArray);
+            GL.EnableClientState(ArrayCap.TextureCoordArray);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, fontVertexBuffer);
+            GL.VertexPointer(3, VertexPointerType.Float, 24, IntPtr.Zero);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 24, (IntPtr)12);
+            GL.TexCoordPointer(2, TexCoordPointerType.Float, 24, (IntPtr)16);
+            Render.EnableTexture = true;
+            Render.Texture = textureHandle;
+        }
+
+        public void End()
+        {
+            GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+            GL.ColorPointer(4, ColorPointerType.UnsignedByte, 0, IntPtr.Zero);
+            GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+            GL.DisableClientState(ArrayCap.VertexArray);
+            GL.DisableClientState(ArrayCap.ColorArray);
+            GL.DisableClientState(ArrayCap.TextureCoordArray);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.Zero);
+            GL.Disable(EnableCap.Blend);
+            GL.DepthMask(true);
+        }
+
+        public void Draw(float x, float y, float z, float scaleX, float scaleY, string text, Color color)
+        {
+            int fontValue, textLength, textBufferLength, fontColor;
+            float u, v, translation, fontSizeX, fontSizeY, fontWidth, fontHeight, fontMargin;
+            Matrix4 fontTranslation, fontWorld;
+
+            Render.GetWorld(ref world);
+
+            Matrix4.CreateTranslation(x, y, 0.0f, out fontTranslation);
+            Matrix4.Mult(ref world, ref fontTranslation, out fontWorld);
+
+            Render.SetWorld(ref fontWorld);
+
+            translation = 0.0f;
+            fontSizeX = 16 * scaleX;
+            fontSizeY = 16 * scaleY;
+            fontWidth = 1.0f / 16.0f;
+            fontHeight = 1.0f / 16.0f;
+            fontMargin = 1.0f / 256.0f;
+            fontColor = color.ToArgb();
+
+            for (int i = 0, j = 0; i < text.Length; i++, j += 4)
+            {
+                fontValue = (int)text[i];
+                u = (float)(fontValue % 16) * fontWidth + fontMargin;
+                v = (float)(fontValue >> 4) * fontHeight + fontMargin;
+
+                fontVertices[j].Position.X = translation;
+                fontVertices[j].Position.Y = 0.0f;
+                fontVertices[j].Position.Z = z;
+                fontVertices[j].TextureCoordinate.X = u;
+                fontVertices[j].TextureCoordinate.Y = v + fontHeight;
+                fontVertices[j].Color = fontColor;
+
+                fontVertices[j + 1].Position.X = fontSizeX + translation;
+                fontVertices[j + 1].Position.Y = 0.0f;
+                fontVertices[j + 1].Position.Z = z;
+                fontVertices[j + 1].TextureCoordinate.X = u + fontWidth;
+                fontVertices[j + 1].TextureCoordinate.Y = v + fontHeight;
+                fontVertices[j + 1].Color = fontColor;
+
+                fontVertices[j + 2].Position.X = translation;
+                fontVertices[j + 2].Position.Y = fontSizeY;
+                fontVertices[j + 2].Position.Z = z;
+                fontVertices[j + 2].TextureCoordinate.X = u;
+                fontVertices[j + 2].TextureCoordinate.Y = v;
+                fontVertices[j + 2].Color = fontColor;
+
+                fontVertices[j + 3].Position.X = fontSizeX + translation;
+                fontVertices[j + 3].Position.Y = fontSizeY;
+                fontVertices[j + 3].Position.Z = z;
+                fontVertices[j + 3].TextureCoordinate.X = u + fontWidth;
+                fontVertices[j + 3].TextureCoordinate.Y = v;
+                fontVertices[j + 3].Color = fontColor;
+
+                translation += fontTranslations[fontValue] * scaleX;
+            }
+
+            textLength = text.Length << 2;
+            textBufferLength = 24 * textLength;
+
+            Render.Apply();
+
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)textBufferLength, IntPtr.Zero, BufferUsageHint.DynamicDraw);
+            GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)textBufferLength, fontVertices, BufferUsageHint.DynamicDraw);
+
+            GL.DrawArrays(PrimitiveType.TriangleStrip, 0, textLength);
+
+            Render.SetWorld(ref world);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoKeyboardState.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoKeyboardState.cs
new file mode 100644
index 0000000..38630ab
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoKeyboardState.cs
@@ -0,0 +1,150 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public struct DemoKeyboardState
+    {
+        long keyState0;
+        long keyState1;
+        long keyState2;
+        long keyState3;
+        long keyState4;
+        long keyState5;
+        long keyState6;
+        long keyState7;
+        long keyState8;
+        long keyState9;
+        long keyState10;
+        long keyState11;
+        long keyState12;
+        long keyState13;
+        long keyState14;
+        long keyState15;
+
+        public bool this[Key key]
+        {
+            get
+            {
+                int intKey = (int)key;
+                int state = intKey & 15;
+                int value = intKey >> 4;
+                long bit = 1;
+                bit <<= value;
+
+                switch (state)
+                {
+                    case 0:
+                        return ((keyState0 & bit) != 0);
+                    case 1:
+                        return ((keyState1 & bit) != 0);
+                    case 2:
+                        return ((keyState2 & bit) != 0);
+                    case 3:
+                        return ((keyState3 & bit) != 0);
+                    case 4:
+                        return ((keyState4 & bit) != 0);
+                    case 5:
+                        return ((keyState5 & bit) != 0);
+                    case 6:
+                        return ((keyState6 & bit) != 0);
+                    case 7:
+                        return ((keyState7 & bit) != 0);
+                    case 8:
+                        return ((keyState8 & bit) != 0);
+                    case 9:
+                        return ((keyState9 & bit) != 0);
+                    case 10:
+                        return ((keyState10 & bit) != 0);
+                    case 11:
+                        return ((keyState11 & bit) != 0);
+                    case 12:
+                        return ((keyState12 & bit) != 0);
+                    case 13:
+                        return ((keyState13 & bit) != 0);
+                    case 14:
+                        return ((keyState14 & bit) != 0);
+                    case 15:
+                        return ((keyState15 & bit) != 0);
+                }
+
+                return false;
+            }
+        }
+
+        public void Set(Key key, bool keyState)
+        {
+            int intKey = (int)key;
+            int state = intKey & 15;
+            int value = intKey >> 4;
+            long bit = 1;
+            bit <<= value;
+
+            long bitSet = (keyState) ? bit : 0;
+            long bitClear = bit ^ (long)-1;
+
+            switch (state)
+            {
+                case 0:
+                    keyState0 = (keyState0 & bitClear) | bitSet;
+                    break;
+                case 1:
+                    keyState1 = (keyState1 & bitClear) | bitSet;
+                    break;
+                case 2:
+                    keyState2 = (keyState2 & bitClear) | bitSet;
+                    break;
+                case 3:
+                    keyState3 = (keyState3 & bitClear) | bitSet;
+                    break;
+                case 4:
+                    keyState4 = (keyState4 & bitClear) | bitSet;
+                    break;
+                case 5:
+                    keyState5 = (keyState5 & bitClear) | bitSet;
+                    break;
+                case 6:
+                    keyState6 = (keyState6 & bitClear) | bitSet;
+                    break;
+                case 7:
+                    keyState7 = (keyState7 & bitClear) | bitSet;
+                    break;
+                case 8:
+                    keyState8 = (keyState8 & bitClear) | bitSet;
+                    break;
+                case 9:
+                    keyState9 = (keyState9 & bitClear) | bitSet;
+                    break;
+                case 10:
+                    keyState10 = (keyState10 & bitClear) | bitSet;
+                    break;
+                case 11:
+                    keyState11 = (keyState11 & bitClear) | bitSet;
+                    break;
+                case 12:
+                    keyState12 = (keyState12 & bitClear) | bitSet;
+                    break;
+                case 13:
+                    keyState13 = (keyState13 & bitClear) | bitSet;
+                    break;
+                case 14:
+                    keyState14 = (keyState14 & bitClear) | bitSet;
+                    break;
+                case 15:
+                    keyState15 = (keyState15 & bitClear) | bitSet;
+                    break;
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMesh.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMesh.cs
new file mode 100644
index 0000000..25fbedc
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMesh.cs
@@ -0,0 +1,624 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+using Komires.MataliRender;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoMesh
+    {
+        Demo demo;
+        int meshVertexBuffer;
+        int meshIndexBuffer;
+        DemoTexture meshTexture;
+        CullFaceMode meshCullMode;
+        int vertexCount;
+        int indexCount;
+        bool dynamic;
+        bool scaleNormals;
+
+        VertexPositionNormalTexture[] meshVertices;
+        ushort[] meshIndices16Bit;
+        int[] meshIndices32Bit;
+        DrawElementsType meshIndicesType;
+
+        public int VertexBuffer { get { return meshVertexBuffer; } }
+        public int IndexBuffer { get { return meshIndexBuffer; } }
+        public DemoTexture DemoTexture { get { return meshTexture; } }
+        public CullFaceMode CullMode { get { return meshCullMode; } }
+
+        public int VertexCount { get { return vertexCount; } }
+        public int IndexCount { get { return indexCount; } }
+        public bool Dynamic { get { return dynamic; } }
+        public bool ScaleNormals { get { return scaleNormals; } set { scaleNormals = value; } }
+
+        public VertexPositionNormalTexture[] Vertices { get { return meshVertices; } }
+        public ushort[] Indices16Bit { get { return meshIndices16Bit; } }
+        public int[] Indices32Bit { get { return meshIndices32Bit; } }
+
+        public RenderMeshDeferredPNT Render;
+
+        Vector3 ambient;
+        Vector3 diffuse;
+        Vector3 emission;
+        Vector3 specular;
+
+        Vector3 lightDirection;
+        Vector3 lightDiffuse;
+        Vector3 lightSpecular;
+
+        public DemoMesh(Demo demo)
+        {
+            this.demo = demo;
+
+            Render = new RenderMeshDeferredPNT();
+
+            meshVertexBuffer = -1;
+            meshIndexBuffer = -1;
+            meshVertices = null;
+            meshIndices16Bit = null;
+            meshIndices32Bit = null;
+            meshIndicesType = 0;
+            meshCullMode = CullFaceMode.Back;
+            dynamic = false;
+            scaleNormals = false;
+
+            SetTexture(null);
+        }
+
+        public DemoMesh(Demo demo, Shape shape, DemoTexture texture, Vector2 textureScale, bool indices, bool indices16Bit, bool flipTriangles, bool flipNormals, bool smoothNormals, CullFaceMode cullMode, bool dynamic, bool scaleNormals)
+        {
+            this.demo = demo;
+
+            Render = new RenderMeshDeferredPNT();
+
+            meshVertexBuffer = -1;
+            meshIndexBuffer = -1;
+            meshVertices = null;
+            meshIndices16Bit = null;
+            meshIndices32Bit = null;
+            meshIndicesType = 0;
+            this.dynamic = dynamic;
+            this.scaleNormals = scaleNormals;
+
+            SetCullMode(cullMode);
+            SetTexture(texture);
+
+            if (indices)
+            {
+                meshVertices = new VertexPositionNormalTexture[shape.VertexCount];
+                shape.GetMeshVertices(textureScale.X, textureScale.Y, flipNormals, smoothNormals, meshVertices);
+                CreateVertexBuffer(meshVertices, dynamic);
+
+                if (indices16Bit)
+                {
+                    meshIndices16Bit = new ushort[shape.IndexCount];
+                    shape.GetMesh16BitIndices(flipTriangles, meshIndices16Bit);
+                    CreateIndexBuffer(meshIndices16Bit, false);
+                }
+                else
+                {
+                    meshIndices32Bit = new int[shape.IndexCount];
+                    shape.GetMesh32BitIndices(flipTriangles, meshIndices32Bit);
+                    CreateIndexBuffer(meshIndices32Bit, false);
+                }
+            }
+            else
+            {
+                meshVertices = new VertexPositionNormalTexture[shape.TriangleVertexCount];
+                shape.GetMesh(textureScale.X, textureScale.Y, flipTriangles, flipNormals, smoothNormals, meshVertices);
+                CreateVertexBuffer(meshVertices, dynamic);
+            }
+        }
+
+        public DemoMesh(Demo demo, TriangleMesh triangleMesh, DemoTexture texture, Vector2 textureScale, bool indices, bool indices16Bit, bool flipTriangles, bool flipNormals, bool smoothNormals, CullFaceMode cullMode, bool dynamic, bool scaleNormals)
+        {
+            this.demo = demo;
+
+            Render = new RenderMeshDeferredPNT();
+
+            meshVertexBuffer = -1;
+            meshIndexBuffer = -1;
+            meshVertices = null;
+            meshIndices16Bit = null;
+            meshIndices32Bit = null;
+            meshIndicesType = 0;
+            this.dynamic = dynamic;
+            this.scaleNormals = scaleNormals;
+
+            SetCullMode(cullMode);
+            SetTexture(texture);
+
+            if (indices)
+            {
+                triangleMesh.GetMeshVertices(flipNormals, smoothNormals, out meshVertices);
+                CreateVertexBuffer(meshVertices, dynamic);
+
+                if (indices16Bit)
+                {
+                    triangleMesh.GetMesh16BitIndices(flipTriangles, out meshIndices16Bit);
+                    CreateIndexBuffer(meshIndices16Bit, false);
+                }
+                else
+                {
+                    triangleMesh.GetMesh32BitIndices(flipTriangles, out meshIndices32Bit);
+                    CreateIndexBuffer(meshIndices32Bit, false);
+                }
+            }
+            else
+            {
+                triangleMesh.GetMesh(textureScale, flipTriangles, flipNormals, smoothNormals, out meshVertices);
+                CreateVertexBuffer(meshVertices, dynamic);
+            }
+        }
+
+        public void CreateVertexBuffer(VertexPositionNormalTexture[] vertices, bool dynamic)
+        {
+            if (vertices.Length == 0) return;
+
+            if (demo.EnableVertexBuffer)
+            {
+                GL.GenBuffers(1, out meshVertexBuffer);
+                GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+
+                if (dynamic)
+                    GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexPositionNormalTexture.SizeInBytes * vertices.Length), vertices, BufferUsageHint.DynamicDraw);
+                else
+                    GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexPositionNormalTexture.SizeInBytes * vertices.Length), vertices, BufferUsageHint.StaticDraw);
+            }
+
+            meshVertices = vertices;
+            vertexCount = vertices.Length;
+        }
+
+        public void CreateIndexBuffer(ushort[] indices, bool dynamic)
+        {
+            if (indices.Length == 0) return;
+
+            if (demo.EnableVertexBuffer)
+            {
+                GL.GenBuffers(1, out meshIndexBuffer);
+                GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+
+                if (dynamic)
+                    GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(sizeof(ushort) * indices.Length), indices, BufferUsageHint.DynamicDraw);
+                else
+                    GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(sizeof(ushort) * indices.Length), indices, BufferUsageHint.StaticDraw);
+            }
+
+            meshIndices16Bit = indices;
+            indexCount = indices.Length;
+            meshIndicesType = DrawElementsType.UnsignedShort;
+        }
+
+        public void CreateIndexBuffer(int[] indices, bool dynamic)
+        {
+            if (indices.Length == 0) return;
+
+            if (demo.EnableVertexBuffer)
+            {
+                GL.GenBuffers(1, out meshIndexBuffer);
+                GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+
+                if (dynamic)
+                    GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(sizeof(int) * indices.Length), indices, BufferUsageHint.DynamicDraw);
+                else
+                    GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(sizeof(int) * indices.Length), indices, BufferUsageHint.StaticDraw);
+            }
+
+            meshIndices32Bit = indices;
+            indexCount = indices.Length;
+            meshIndicesType = DrawElementsType.UnsignedInt;
+        }
+
+        public void SetVertices(VertexPositionNormalTexture[] vertices)
+        {
+            if (demo.EnableVertexBuffer)
+            {
+                GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+                GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexPositionNormalTexture.SizeInBytes * vertices.Length), IntPtr.Zero, BufferUsageHint.DynamicDraw);
+                GL.BufferData(BufferTarget.ArrayBuffer, (IntPtr)(VertexPositionNormalTexture.SizeInBytes * vertices.Length), vertices, BufferUsageHint.DynamicDraw);
+            }
+
+            meshVertices = vertices;
+            vertexCount = vertices.Length;
+        }
+
+        public void SetIndices(ushort[] indices)
+        {
+            if (demo.EnableVertexBuffer)
+            {
+                GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+                GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(indices.Length * sizeof(ushort)), IntPtr.Zero, BufferUsageHint.DynamicDraw);
+                GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(indices.Length * sizeof(ushort)), indices, BufferUsageHint.DynamicDraw);
+            }
+
+            meshIndices16Bit = indices;
+            indexCount = indices.Length;
+        }
+
+        public void SetIndices(int[] indices)
+        {
+            if (demo.EnableVertexBuffer)
+            {
+                GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+                GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(indices.Length * sizeof(int)), IntPtr.Zero, BufferUsageHint.DynamicDraw);
+                GL.BufferData(BufferTarget.ElementArrayBuffer, (IntPtr)(indices.Length * sizeof(int)), indices, BufferUsageHint.DynamicDraw);
+            }
+
+            meshIndices32Bit = indices;
+            indexCount = indices.Length;
+        }
+
+        public void SetTexture(DemoTexture texture)
+        {
+            meshTexture = texture;
+        }
+
+        public void SetCullMode(CullFaceMode cullMode)
+        {
+            meshCullMode = cullMode;
+        }
+
+        public void Draw(IRender render)
+        {
+            render.Apply();
+
+            if (demo.EnableVertexBuffer)
+            {
+                if (meshVertexBuffer != -1)
+                {
+                    if (meshIndexBuffer != -1)
+                    {
+                        GL.EnableClientState(ArrayCap.VertexArray);
+                        GL.EnableClientState(ArrayCap.NormalArray);
+                        GL.EnableClientState(ArrayCap.TextureCoordArray);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+                        GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+
+                        GL.VertexPointer(3, VertexPointerType.Float, VertexPositionNormalTexture.SizeInBytes, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)Vector3.SizeInBytes);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)(Vector3.SizeInBytes + Vector3.SizeInBytes));
+
+                        GL.DrawElements(PrimitiveType.Triangles, indexCount, meshIndicesType, 0);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+                        GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+                        GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, 0, IntPtr.Zero);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+
+                        GL.DisableClientState(ArrayCap.VertexArray);
+                        GL.DisableClientState(ArrayCap.NormalArray);
+                        GL.DisableClientState(ArrayCap.TextureCoordArray);
+                    }
+                    else
+                    {
+                        GL.EnableClientState(ArrayCap.VertexArray);
+                        GL.EnableClientState(ArrayCap.NormalArray);
+                        GL.EnableClientState(ArrayCap.TextureCoordArray);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+
+                        GL.VertexPointer(3, VertexPointerType.Float, VertexPositionNormalTexture.SizeInBytes, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)Vector3.SizeInBytes);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)(Vector3.SizeInBytes + Vector3.SizeInBytes));
+
+                        GL.DrawArrays(PrimitiveType.Triangles, 0, vertexCount);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+                        GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, 0, IntPtr.Zero);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+
+                        GL.DisableClientState(ArrayCap.VertexArray);
+                        GL.DisableClientState(ArrayCap.NormalArray);
+                        GL.DisableClientState(ArrayCap.TextureCoordArray);
+                    }
+                }
+            }
+            else
+            {
+                VertexPositionNormalTexture v1, v2, v3;
+
+                if (meshIndices16Bit != null)
+                {
+                    GL.Begin(PrimitiveType.Triangles);
+
+                    for (int i = 0; i < indexCount; i += 3)
+                    {
+                        v1 = meshVertices[meshIndices16Bit[i]];
+                        v2 = meshVertices[meshIndices16Bit[i + 1]];
+                        v3 = meshVertices[meshIndices16Bit[i + 2]];
+
+                        GL.TexCoord2(v1.TextureCoordinate);
+                        GL.Normal3(v1.Normal);
+                        GL.Vertex3(v1.Position);
+
+                        GL.TexCoord2(v2.TextureCoordinate);
+                        GL.Normal3(v2.Normal);
+                        GL.Vertex3(v2.Position);
+
+                        GL.TexCoord2(v3.TextureCoordinate);
+                        GL.Normal3(v3.Normal);
+                        GL.Vertex3(v3.Position);
+                    }
+
+                    GL.End();
+                }
+                else
+                    if (meshIndices32Bit != null)
+                    {
+                        GL.Begin(PrimitiveType.Triangles);
+
+                        for (int i = 0; i < indexCount; i += 3)
+                        {
+                            v1 = meshVertices[meshIndices32Bit[i]];
+                            v2 = meshVertices[meshIndices32Bit[i + 1]];
+                            v3 = meshVertices[meshIndices32Bit[i + 2]];
+
+                            GL.TexCoord2(v1.TextureCoordinate);
+                            GL.Normal3(v1.Normal);
+                            GL.Vertex3(v1.Position);
+
+                            GL.TexCoord2(v2.TextureCoordinate);
+                            GL.Normal3(v2.Normal);
+                            GL.Vertex3(v2.Position);
+
+                            GL.TexCoord2(v3.TextureCoordinate);
+                            GL.Normal3(v3.Normal);
+                            GL.Vertex3(v3.Position);
+                        }
+
+                        GL.End();
+                    }
+                    else
+                    {
+                        GL.Begin(PrimitiveType.Triangles);
+
+                        for (int i = 0; i < vertexCount; i += 3)
+                        {
+                            v1 = meshVertices[i];
+                            v2 = meshVertices[i + 1];
+                            v3 = meshVertices[i + 2];
+
+                            GL.TexCoord2(v1.TextureCoordinate);
+                            GL.Normal3(v1.Normal);
+                            GL.Vertex3(v1.Position);
+
+                            GL.TexCoord2(v2.TextureCoordinate);
+                            GL.Normal3(v2.Normal);
+                            GL.Vertex3(v2.Position);
+
+                            GL.TexCoord2(v3.TextureCoordinate);
+                            GL.Normal3(v3.Normal);
+                            GL.Vertex3(v3.Position);
+                        }
+
+                        GL.End();
+                    }
+            }
+        }
+
+        public void Draw(ref Matrix4 world, ref Matrix4 view, ref Matrix4 projection, PhysicsLight light, PhysicsMaterial material, PhysicsCamera camera, bool sleep, bool wireframe)
+        {
+            Render.SetWorld(ref world);
+            Render.SetView(ref view);
+            Render.SetProjection(ref projection);
+            Render.EnableScaleNormals = scaleNormals;
+
+            light.GetDirection(ref lightDirection);
+            light.GetDiffuse(ref lightDiffuse);
+            light.GetSpecular(ref lightSpecular);
+
+            if (meshCullMode == CullFaceMode.FrontAndBack)
+                GL.Disable(EnableCap.CullFace);
+
+            GL.CullFace(meshCullMode);
+
+            DemoTexture currentTexture = meshTexture;
+            if (material.UserDataStr != null)
+                currentTexture = demo.Textures[material.UserDataStr];
+
+            material.GetAmbient(ref ambient);
+            material.GetDiffuse(ref diffuse);
+            material.GetEmission(ref emission);
+            material.GetSpecular(ref specular);
+
+            if (sleep)
+            {
+                diffuse.X = 0.7f;
+                diffuse.Y = 1.0f;
+                diffuse.Z = 1.0f;
+            }
+
+            Render.SetAmbient(ref ambient);
+            Render.SetSpecular(ref specular);
+            Render.SetEmission(ref emission);
+            Render.SpecularPower = material.SpecularPower;
+            Render.Alpha = material.TransparencyFactor;
+            Render.EnableTwoSidedNormals = material.TwoSidedNormals;
+            
+            if (!wireframe)
+            {
+                Render.SetDiffuse(ref diffuse);
+
+                if (currentTexture != null)
+                {
+                    Render.EnableTexture = true;
+                    Render.Texture = currentTexture.Handle;
+                }
+                else
+                {
+                    Render.EnableTexture = false;
+                }
+            }
+            else
+            {
+                GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
+
+                diffuse.X *= 4.0f;
+                diffuse.Y *= 4.0f;
+                diffuse.Z *= 4.0f;
+
+                Render.SetDiffuse(ref diffuse);
+
+                Render.EnableTexture = false;
+            }
+
+            Render.Apply();
+
+            if (demo.EnableVertexBuffer)
+            {
+                if (meshVertexBuffer != -1)
+                {
+                    if (meshIndexBuffer != -1)
+                    {
+                        GL.EnableClientState(ArrayCap.VertexArray);
+                        GL.EnableClientState(ArrayCap.NormalArray);
+                        GL.EnableClientState(ArrayCap.TextureCoordArray);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+                        GL.BindBuffer(BufferTarget.ElementArrayBuffer, meshIndexBuffer);
+
+                        GL.VertexPointer(3, VertexPointerType.Float, VertexPositionNormalTexture.SizeInBytes, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)Vector3.SizeInBytes);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)(Vector3.SizeInBytes + Vector3.SizeInBytes));
+
+                        GL.DrawElements(PrimitiveType.Triangles, indexCount, meshIndicesType, 0);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+                        GL.BindBuffer(BufferTarget.ElementArrayBuffer, 0);
+                        GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, 0, IntPtr.Zero);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+
+                        GL.DisableClientState(ArrayCap.VertexArray);
+                        GL.DisableClientState(ArrayCap.NormalArray);
+                        GL.DisableClientState(ArrayCap.TextureCoordArray);
+                    }
+                    else
+                    {
+                        GL.EnableClientState(ArrayCap.VertexArray);
+                        GL.EnableClientState(ArrayCap.NormalArray);
+                        GL.EnableClientState(ArrayCap.TextureCoordArray);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, meshVertexBuffer);
+
+                        GL.VertexPointer(3, VertexPointerType.Float, VertexPositionNormalTexture.SizeInBytes, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)Vector3.SizeInBytes);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, VertexPositionNormalTexture.SizeInBytes, (IntPtr)(Vector3.SizeInBytes + Vector3.SizeInBytes));
+
+                        GL.DrawArrays(PrimitiveType.Triangles, 0, vertexCount);
+
+                        GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
+                        GL.VertexPointer(3, VertexPointerType.Float, 0, IntPtr.Zero);
+                        GL.NormalPointer(NormalPointerType.Float, 0, IntPtr.Zero);
+                        GL.TexCoordPointer(2, TexCoordPointerType.Float, 0, IntPtr.Zero);
+
+                        GL.DisableClientState(ArrayCap.VertexArray);
+                        GL.DisableClientState(ArrayCap.NormalArray);
+                        GL.DisableClientState(ArrayCap.TextureCoordArray);
+                    }
+                }
+            }
+            else
+            {
+                VertexPositionNormalTexture v1, v2, v3;
+
+                if (meshIndices16Bit != null)
+                {
+                    GL.Begin(PrimitiveType.Triangles);
+
+                    for (int i = 0; i < indexCount; i += 3)
+                    {
+                        v1 = meshVertices[meshIndices16Bit[i]];
+                        v2 = meshVertices[meshIndices16Bit[i + 1]];
+                        v3 = meshVertices[meshIndices16Bit[i + 2]];
+
+                        GL.TexCoord2(v1.TextureCoordinate);
+                        GL.Normal3(v1.Normal);
+                        GL.Vertex3(v1.Position);
+
+                        GL.TexCoord2(v2.TextureCoordinate);
+                        GL.Normal3(v2.Normal);
+                        GL.Vertex3(v2.Position);
+
+                        GL.TexCoord2(v3.TextureCoordinate);
+                        GL.Normal3(v3.Normal);
+                        GL.Vertex3(v3.Position);
+                    }
+
+                    GL.End();
+                }
+                else
+                    if (meshIndices32Bit != null)
+                    {
+                        GL.Begin(PrimitiveType.Triangles);
+
+                        for (int i = 0; i < indexCount; i += 3)
+                        {
+                            v1 = meshVertices[meshIndices32Bit[i]];
+                            v2 = meshVertices[meshIndices32Bit[i + 1]];
+                            v3 = meshVertices[meshIndices32Bit[i + 2]];
+
+                            GL.TexCoord2(v1.TextureCoordinate);
+                            GL.Normal3(v1.Normal);
+                            GL.Vertex3(v1.Position);
+
+                            GL.TexCoord2(v2.TextureCoordinate);
+                            GL.Normal3(v2.Normal);
+                            GL.Vertex3(v2.Position);
+
+                            GL.TexCoord2(v3.TextureCoordinate);
+                            GL.Normal3(v3.Normal);
+                            GL.Vertex3(v3.Position);
+                        }
+
+                        GL.End();
+                    }
+                    else
+                    {
+                        GL.Begin(PrimitiveType.Triangles);
+
+                        for (int i = 0; i < vertexCount; i += 3)
+                        {
+                            v1 = meshVertices[i];
+                            v2 = meshVertices[i + 1];
+                            v3 = meshVertices[i + 2];
+
+                            GL.TexCoord2(v1.TextureCoordinate);
+                            GL.Normal3(v1.Normal);
+                            GL.Vertex3(v1.Position);
+
+                            GL.TexCoord2(v2.TextureCoordinate);
+                            GL.Normal3(v2.Normal);
+                            GL.Vertex3(v2.Position);
+
+                            GL.TexCoord2(v3.TextureCoordinate);
+                            GL.Normal3(v3.Normal);
+                            GL.Vertex3(v3.Position);
+                        }
+
+                        GL.End();
+                    }
+            }
+
+            if (meshCullMode == CullFaceMode.FrontAndBack)
+                GL.Enable(EnableCap.CullFace);
+
+            if (wireframe)
+                GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMouseState.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMouseState.cs
new file mode 100644
index 0000000..ce65a43
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoMouseState.cs
@@ -0,0 +1,169 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public struct DemoMouseState
+    {
+        long buttonState0;
+        long buttonState1;
+        long buttonState2;
+        long buttonState3;
+        long buttonState4;
+        long buttonState5;
+        long buttonState6;
+        long buttonState7;
+        long buttonState8;
+        long buttonState9;
+        long buttonState10;
+        long buttonState11;
+        long buttonState12;
+        long buttonState13;
+        long buttonState14;
+        long buttonState15;
+
+        int positionX;
+        int positionY;
+        int scrollWheel;
+
+        public int X { get { return positionX; } }
+        public int Y { get { return positionY; } }
+        public int Wheel { get { return scrollWheel; } }
+
+        public bool this[MouseButton button]
+        {
+            get
+            {
+                int intButton = (int)button;
+                int state = intButton & 15;
+                int value = intButton >> 4;
+                long bit = 1;
+                bit <<= value;
+
+                switch (state)
+                {
+                    case 0:
+                        return ((buttonState0 & bit) != 0);
+                    case 1:
+                        return ((buttonState1 & bit) != 0);
+                    case 2:
+                        return ((buttonState2 & bit) != 0);
+                    case 3:
+                        return ((buttonState3 & bit) != 0);
+                    case 4:
+                        return ((buttonState4 & bit) != 0);
+                    case 5:
+                        return ((buttonState5 & bit) != 0);
+                    case 6:
+                        return ((buttonState6 & bit) != 0);
+                    case 7:
+                        return ((buttonState7 & bit) != 0);
+                    case 8:
+                        return ((buttonState8 & bit) != 0);
+                    case 9:
+                        return ((buttonState9 & bit) != 0);
+                    case 10:
+                        return ((buttonState10 & bit) != 0);
+                    case 11:
+                        return ((buttonState11 & bit) != 0);
+                    case 12:
+                        return ((buttonState12 & bit) != 0);
+                    case 13:
+                        return ((buttonState13 & bit) != 0);
+                    case 14:
+                        return ((buttonState14 & bit) != 0);
+                    case 15:
+                        return ((buttonState15 & bit) != 0);
+                }
+
+                return false;
+            }
+        }
+
+        public void Set(MouseButton button, bool buttonState)
+        {
+            int intButton = (int)button;
+            int state = intButton & 15;
+            int value = intButton >> 4;
+            long bit = 1;
+            bit <<= value;
+
+            long bitSet = (buttonState) ? bit : 0;
+            long bitClear = bit ^ (long)-1;
+
+            switch (state)
+            {
+                case 0:
+                    buttonState0 = (buttonState0 & bitClear) | bitSet;
+                    break;
+                case 1:
+                    buttonState1 = (buttonState1 & bitClear) | bitSet;
+                    break;
+                case 2:
+                    buttonState2 = (buttonState2 & bitClear) | bitSet;
+                    break;
+                case 3:
+                    buttonState3 = (buttonState3 & bitClear) | bitSet;
+                    break;
+                case 4:
+                    buttonState4 = (buttonState4 & bitClear) | bitSet;
+                    break;
+                case 5:
+                    buttonState5 = (buttonState5 & bitClear) | bitSet;
+                    break;
+                case 6:
+                    buttonState6 = (buttonState6 & bitClear) | bitSet;
+                    break;
+                case 7:
+                    buttonState7 = (buttonState7 & bitClear) | bitSet;
+                    break;
+                case 8:
+                    buttonState8 = (buttonState8 & bitClear) | bitSet;
+                    break;
+                case 9:
+                    buttonState9 = (buttonState9 & bitClear) | bitSet;
+                    break;
+                case 10:
+                    buttonState10 = (buttonState10 & bitClear) | bitSet;
+                    break;
+                case 11:
+                    buttonState11 = (buttonState11 & bitClear) | bitSet;
+                    break;
+                case 12:
+                    buttonState12 = (buttonState12 & bitClear) | bitSet;
+                    break;
+                case 13:
+                    buttonState13 = (buttonState13 & bitClear) | bitSet;
+                    break;
+                case 14:
+                    buttonState14 = (buttonState14 & bitClear) | bitSet;
+                    break;
+                case 15:
+                    buttonState15 = (buttonState15 & bitClear) | bitSet;
+                    break;
+            }
+        }
+
+        public void Set(int x, int y)
+        {
+            positionX = x;
+            positionY = y;
+        }
+
+        public void Set(int wheel)
+        {
+            scrollWheel = wheel;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSound.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSound.cs
new file mode 100644
index 0000000..d472a1a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSound.cs
@@ -0,0 +1,390 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Audio.OpenAL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoListener
+    {
+        public Vector3 Position;
+        public Vector3 TopDirection;
+        public Vector3 FrontDirection;
+    }
+
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoEmitter
+    {
+        public Vector3 Position;
+        public Vector3 FrontDirection;
+    }
+
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoSound
+    {
+        DemoSoundQueue soundQueue;
+        DemoSoundGroup soundGroup;
+
+        public PhysicsSound SoundData;
+        public DemoListener Listener;
+        public DemoEmitter Emitter;
+
+        public Vector3 HitPosition;
+        public Vector3 RollPosition;
+        public Vector3 SlidePosition;
+        public Vector3 BackgroundPosition;
+        public Vector3 FrontDirection;
+
+        public float HitVolume;
+        public float RollVolume;
+        public float SlideVolume;
+        public float BackgroundVolume;
+
+        bool enableHit;
+        bool enableRoll;
+        bool enableSlide;
+        bool enableBackground;
+
+        float hitRepeatTime;
+        float rollMuteTime;
+        float slideMuteTime;
+
+        DemoSoundUnit[] hitSoundUnits;
+        DemoSoundUnit rollSoundUnit;
+        DemoSoundUnit slideSoundUnit;
+        DemoSoundUnit backgroundSoundUnit;
+
+        public DemoSoundGroup SoundGroup { get { return soundGroup; } }
+
+        public DemoSound(DemoSoundQueue soundQueue, DemoSoundGroup soundGroup)
+        {
+            this.soundQueue = soundQueue;
+            this.soundGroup = soundGroup;
+
+            enableHit = soundGroup.EnableHit;
+            enableRoll = soundGroup.EnableRoll;
+            enableSlide = soundGroup.EnableSlide;
+            enableBackground = soundGroup.EnableBackground;
+
+            hitRepeatTime = 0.4f;
+
+            if (enableHit)
+            {
+                hitSoundUnits = new DemoSoundUnit[soundGroup.HitCount];
+                for (int i = 0; i < hitSoundUnits.Length; i++)
+                    hitSoundUnits[i] = soundGroup.Hit.CreateSoundUnit();
+            }
+
+            if (enableRoll)
+                rollSoundUnit = soundGroup.Roll.CreateSoundUnit();
+
+            if (enableSlide)
+                slideSoundUnit = soundGroup.Slide.CreateSoundUnit();
+
+            if (enableBackground)
+                backgroundSoundUnit = soundGroup.Background.CreateSoundUnit();
+        }
+
+        public void Update(float time)
+        {
+            if (enableHit)
+                hitRepeatTime += time;
+
+            if (enableRoll)
+                rollMuteTime += time;
+
+            if (enableSlide)
+                slideMuteTime += time;
+        }
+
+        public void Start()
+        {
+            DemoSoundUnit hitSoundUnit;
+
+            if (enableHit)
+            {
+                if (HitVolume != 0.0f && hitRepeatTime > soundGroup.MaxHitRepeatTime)
+                {
+                    hitSoundUnit = null;
+                    for (int i = 0; i < hitSoundUnits.Length; i++)
+                    {
+                        hitSoundUnit = hitSoundUnits[i];
+                        if (hitSoundUnit.State != ALSourceState.Playing)
+                            break;
+                    }
+
+                    if (hitSoundUnit != null)
+                    {
+                        if ((hitSoundUnit.SourceHandle == 0) && (soundQueue.SourceCount > 0))
+                            hitSoundUnit.SetSource(soundQueue.DequeueSource());
+
+                        if (hitSoundUnit.SourceHandle != 0)
+                        {
+                            Emitter.Position = HitPosition;
+                            Emitter.FrontDirection = FrontDirection;
+
+                            hitRepeatTime = 0.0f;
+                            hitSoundUnit.Volume = HitVolume;
+                            hitSoundUnit.Pitch = SoundData.HitPitch;
+                            hitSoundUnit.Start(Listener, Emitter);
+                        }
+                    }
+                }
+            }
+
+            if (enableRoll)
+            {
+                if (RollVolume != 0.0f)
+                {
+                    if ((rollSoundUnit.SourceHandle == 0) && (soundQueue.SourceCount > 0))
+                        rollSoundUnit.SetSource(soundQueue.DequeueSource());
+
+                    if (rollSoundUnit.SourceHandle != 0)
+                    {
+                        Emitter.Position = RollPosition;
+                        Emitter.FrontDirection = FrontDirection;
+
+                        rollMuteTime = 0.0f;
+                        rollSoundUnit.Volume = RollVolume;
+                        rollSoundUnit.Pitch = SoundData.RollPitch;
+                        rollSoundUnit.Start(Listener, Emitter);
+                    }
+                }
+                else
+                {
+                    RollStop();
+                }
+            }
+
+            if (enableSlide)
+            {
+                if (SlideVolume != 0.0f)
+                {
+                    if ((slideSoundUnit.SourceHandle == 0) && (soundQueue.SourceCount > 0))
+                        slideSoundUnit.SetSource(soundQueue.DequeueSource());
+
+                    if (slideSoundUnit.SourceHandle != 0)
+                    {
+                        Emitter.Position = SlidePosition;
+                        Emitter.FrontDirection = FrontDirection;
+
+                        slideMuteTime = 0.0f;
+                        slideSoundUnit.Volume = SlideVolume;
+                        slideSoundUnit.Pitch = SoundData.SlidePitch;
+                        slideSoundUnit.Start(Listener, Emitter);
+                    }
+                }
+                else
+                {
+                    SlideStop();
+                }
+            }
+
+            if (enableBackground)
+            {
+                if (BackgroundVolume != 0.0f)
+                {
+                    if ((backgroundSoundUnit.SourceHandle == 0) && (soundQueue.SourceCount > 0))
+                        backgroundSoundUnit.SetSource(soundQueue.DequeueSource());
+
+                    if (backgroundSoundUnit.SourceHandle != 0)
+                    {
+                        Emitter.Position = BackgroundPosition;
+                        Emitter.FrontDirection = FrontDirection;
+
+                        backgroundSoundUnit.Volume = BackgroundVolume;
+                        backgroundSoundUnit.Pitch = SoundData.BackgroundPitch;
+                        backgroundSoundUnit.Start(Listener, Emitter);
+                    }
+                }
+                else
+                {
+                    BackgroundStop();
+                }
+            }
+        }
+
+        public bool HitStop()
+        {
+            bool stop;
+            DemoSoundUnit hitSoundUnit;
+
+            stop = true;
+
+            for (int i = 0; i < hitSoundUnits.Length; i++)
+            {
+                hitSoundUnit = hitSoundUnits[i];
+
+                if (hitSoundUnit.State == ALSourceState.Playing)
+                {
+                    stop = false;
+                    hitSoundUnit.Start();
+                }
+            }
+
+            return stop;
+        }
+
+        public bool RollStop()
+        {
+            bool stop = true;
+
+            if (rollSoundUnit.State == ALSourceState.Playing)
+            {
+                if (rollMuteTime < soundGroup.MinRollMuteTime)
+                {
+                    stop = false;
+                    rollSoundUnit.Volume *= 0.5f;
+                    rollSoundUnit.Start();
+                }
+                else
+                {
+                    rollSoundUnit.Volume = 0.0f;
+                    rollSoundUnit.Stop();
+                }
+            }
+
+            return stop;
+        }
+
+        public bool SlideStop()
+        {
+            bool stop = true;
+
+            if (slideSoundUnit.State == ALSourceState.Playing)
+            {
+                if (slideMuteTime < soundGroup.MinSlideMuteTime)
+                {
+                    stop = false;
+                    slideSoundUnit.Volume *= 0.5f;
+                    slideSoundUnit.Start();
+                }
+                else
+                {
+                    slideSoundUnit.Volume = 0.0f;
+                    slideSoundUnit.Stop();
+                }
+            }
+
+            return stop;
+        }
+
+        public bool BackgroundStop()
+        {
+            if (backgroundSoundUnit.State == ALSourceState.Playing)
+            {
+                backgroundSoundUnit.Volume = 0.0f;
+                backgroundSoundUnit.Stop();
+            }
+
+            return true;
+        }
+
+        public bool Stop()
+        {
+            bool stop = true;
+
+            if (enableHit)
+                if (!HitStop())
+                    stop = false;
+
+            if (enableRoll)
+                if (!RollStop())
+                    stop = false;
+
+            if (enableSlide)
+                if (!SlideStop())
+                    stop = false;
+
+            if (enableBackground)
+                if (!BackgroundStop())
+                    stop = false;
+
+            return stop;
+        }
+
+        public void Clear()
+        {
+            DemoSoundUnit hitSoundUnit;
+
+            SoundData = null;
+
+            if (enableHit)
+            {
+                for (int i = 0; i < hitSoundUnits.Length; i++)
+                {
+                    hitSoundUnit = hitSoundUnits[i];
+
+                    if (hitSoundUnit.State == ALSourceState.Playing)
+                    {
+                        hitSoundUnit.Volume = 0.0f;
+                        hitSoundUnit.Stop();
+                    }
+
+                    if (hitSoundUnit.SourceHandle != 0)
+                    {
+                        soundQueue.EnqueueSource(hitSoundUnit.SourceHandle);
+                        hitSoundUnit.SourceHandle = 0;
+                    }
+                }
+            }
+
+            if (enableRoll)
+            {
+                if (rollSoundUnit.State == ALSourceState.Playing)
+                {
+                    rollSoundUnit.Volume = 0.0f;
+                    rollSoundUnit.Stop();
+                }
+
+                if (rollSoundUnit.SourceHandle != 0)
+                {
+                    soundQueue.EnqueueSource(rollSoundUnit.SourceHandle);
+                    rollSoundUnit.SourceHandle = 0;
+                }
+            }
+
+            if (enableSlide)
+            {
+                if (slideSoundUnit.State == ALSourceState.Playing)
+                {
+                    slideSoundUnit.Volume = 0.0f;
+                    slideSoundUnit.Stop();
+                }
+
+                if (slideSoundUnit.SourceHandle != 0)
+                {
+                    soundQueue.EnqueueSource(slideSoundUnit.SourceHandle);
+                    slideSoundUnit.SourceHandle = 0;
+                }
+            }
+
+            if (enableBackground)
+            {
+                if (backgroundSoundUnit.State == ALSourceState.Playing)
+                {
+                    backgroundSoundUnit.Volume = 0.0f;
+                    backgroundSoundUnit.Stop();
+                }
+
+                if (backgroundSoundUnit.SourceHandle != 0)
+                {
+                    soundQueue.EnqueueSource(backgroundSoundUnit.SourceHandle);
+                    backgroundSoundUnit.SourceHandle = 0;
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundGroup.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundGroup.cs
new file mode 100644
index 0000000..ce2dd98
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundGroup.cs
@@ -0,0 +1,111 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Audio.OpenAL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoSoundGroup
+    {
+        Demo demo;
+        List<DemoSound> totalSounds;
+        List<DemoSound> currentSounds;
+
+        public float MaxHitRepeatTime;
+        public float MinRollMuteTime;
+        public float MinSlideMuteTime;
+
+        public int HitCount;
+
+        public bool EnableHit;
+        public bool EnableRoll;
+        public bool EnableSlide;
+        public bool EnableBackground;
+
+        public DemoSoundSample Hit;
+        public DemoSoundSample Roll;
+        public DemoSoundSample Slide;
+        public DemoSoundSample Background;
+
+        public DemoSoundGroup(Demo demo, int hitCount, DemoSoundSample hit, DemoSoundSample roll, DemoSoundSample slide, DemoSoundSample background)
+        {
+            this.demo = demo;
+
+            totalSounds = new List<DemoSound>();
+            currentSounds = new List<DemoSound>();
+
+            MaxHitRepeatTime = 0.4f;
+            MinRollMuteTime = 0.2f;
+            MinSlideMuteTime = 0.2f;
+
+            HitCount = hitCount;
+
+            EnableHit = hit != null;
+            EnableRoll = roll != null;
+            EnableSlide = slide != null;
+            EnableBackground = background != null;
+
+            Hit = hit;
+            Roll = roll;
+            Slide = slide;
+            Background = background;
+        }
+
+        public DemoSound GetSound(PhysicsSound soundData, DemoListener listener, DemoEmitter emitter)
+        {
+            int index;
+            DemoSound sound;
+
+            if (currentSounds.Count > 0)
+            {
+                index = currentSounds.Count - 1;
+                sound = currentSounds[index];
+                currentSounds.RemoveAt(index);
+            }
+            else
+            {
+                sound = new DemoSound(demo.SoundQueue, this);
+                totalSounds.Add(sound);
+            }
+
+            sound.SoundData = soundData;
+            sound.Listener = listener;
+            sound.Emitter = emitter;
+
+            return sound;
+        }
+
+        public void SetSound(DemoSound demoSound)
+        {
+            demoSound.Clear();
+            currentSounds.Add(demoSound);
+        }
+
+        public void ClearAllSounds()
+        {
+            DemoSound sound;
+
+            if (totalSounds.Count > 0)
+            {
+                currentSounds.Clear();
+                for (int i = 0; i < totalSounds.Count; i++)
+                {
+                    sound = totalSounds[i];
+
+                    if (sound.SoundData != null)
+                        sound.SoundData.UserDataObj = null;
+
+                    SetSound(sound);
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundQueue.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundQueue.cs
new file mode 100644
index 0000000..caf9755
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundQueue.cs
@@ -0,0 +1,80 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Audio.OpenAL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoSoundQueue
+    {
+        Queue<DemoSound> sounds;
+        Queue<int> sources;
+
+        int maxSoundCount;
+        int maxSourceCount;
+
+        public int SoundCount { get { return sounds.Count; } }
+        public int SourceCount { get { return sources.Count; } }
+        public int MaxSoundCount { get { return maxSoundCount; } }
+        public int MaxSourceCount { get { return maxSourceCount; } }
+
+        public DemoSoundQueue(int maxSoundCount)
+        {
+            this.maxSoundCount = maxSoundCount;
+
+            sounds = new Queue<DemoSound>();
+            sources = new Queue<int>();
+        }
+
+        public void CreateSources(int maxSourceCount)
+        {
+            int source;
+
+            for (int i = 0; i < maxSourceCount; i++)
+            {
+                source = AL.GenSource();
+
+                if (source == 0)
+                    break;
+
+                sources.Enqueue(source);
+            }
+
+            this.maxSourceCount = sources.Count;
+        }
+
+        public void EnqueueSound(DemoSound sound)
+        {
+            sounds.Enqueue(sound);
+        }
+
+        public DemoSound DequeueSound()
+        {
+            return sounds.Dequeue();
+        }
+
+        public void EnqueueSource(int source)
+        {
+            sources.Enqueue(source);
+        }
+
+        public int DequeueSource()
+        {
+            return sources.Dequeue();
+        }
+
+        public void Clear()
+        {
+            if (sounds.Count > 0)
+                sounds.Clear();
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundSample.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundSample.cs
new file mode 100644
index 0000000..125e1b9
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundSample.cs
@@ -0,0 +1,73 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.IO;
+using OpenTK;
+using OpenTK.Audio.OpenAL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoSoundSample
+    {
+        Demo demo;
+
+        string dataFileDirectory;
+        string dataFileExt;
+
+        ContentWave soundSample;
+
+        int sampleHandle;
+
+        public string FileDirectory { get { return dataFileDirectory; } }
+        public string FileExt { get { return dataFileExt; } }
+
+        public DemoSoundSample(Demo demo, string fileDirectory, string fileExt)
+        {
+            this.demo = demo;
+
+            dataFileDirectory = fileDirectory;
+            dataFileExt = fileExt;
+
+            soundSample = new ContentWave();
+
+            sampleHandle = AL.GenBuffer();
+        }
+
+        public void Set(Stream stream)
+        {
+            ALFormat sampleFormat;
+
+            if (!soundSample.LoadFromStream(stream))
+                throw new Exception("File is not supported.");
+
+            if (soundSample.Channels == 1)
+            {
+                if (soundSample.SampleBits == 8)
+                    sampleFormat = ALFormat.Mono8;
+                else
+                    sampleFormat = ALFormat.Mono16;
+            }
+            else
+            {
+                if (soundSample.SampleBits == 8)
+                    sampleFormat = ALFormat.Stereo8;
+                else
+                    sampleFormat = ALFormat.Stereo16;
+            }
+
+            AL.BufferData(sampleHandle, sampleFormat, soundSample.Data, soundSample.Data.Length, soundSample.SampleRate);
+        }
+
+        public DemoSoundUnit CreateSoundUnit()
+        {
+            return new DemoSoundUnit(demo, sampleHandle);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundUnit.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundUnit.cs
new file mode 100644
index 0000000..8bff700
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoSoundUnit.cs
@@ -0,0 +1,65 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Audio.OpenAL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoSoundUnit
+    {
+        Demo demo;
+
+        int sampleHandle;
+        int sourceHandle;
+
+        float volume;
+        float pitch;
+
+        public float Volume { get { return volume; } set { volume = value; AL.Source(sourceHandle, ALSourcef.Gain, volume); } }
+        public ALSourceState State { get { return AL.GetSourceState(sourceHandle); } }
+        public float Pitch { get { return pitch; } set { pitch = value; AL.Source(sourceHandle, ALSourcef.Pitch, Math.Min(pitch + 1.5f, 2.0f)); } }
+        public int SourceHandle { get { return sourceHandle; } set { sourceHandle = value; } }
+
+        public DemoSoundUnit(Demo demo, int sampleHandle)
+        {
+            this.demo = demo;
+            this.sampleHandle = sampleHandle;
+        }
+
+        public void SetSource(int sourceHandle)
+        {
+            this.sourceHandle = sourceHandle;
+            AL.Source(sourceHandle, ALSourcei.Buffer, sampleHandle);
+        }
+
+        public void Start(DemoListener listener, DemoEmitter emitter)
+        {
+            AL.Listener(ALListener3f.Position, ref listener.Position);
+            AL.Listener(ALListenerfv.Orientation, ref listener.FrontDirection, ref listener.TopDirection);
+            AL.Source(sourceHandle, ALSource3f.Position, ref emitter.Position);
+            AL.Source(sourceHandle, ALSource3f.Direction, ref emitter.FrontDirection);
+
+            if (AL.GetSourceState(sourceHandle) != ALSourceState.Playing)
+                AL.SourcePlay(sourceHandle);
+        }
+
+        public void Start()
+        {
+            if (AL.GetSourceState(sourceHandle) != ALSourceState.Playing)
+                AL.SourcePlay(sourceHandle);
+        }
+
+        public void Stop()
+        {
+            AL.SourceStop(sourceHandle);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoTexture.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoTexture.cs
new file mode 100644
index 0000000..c9870c6
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/DemoTexture.cs
@@ -0,0 +1,193 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DemoTexture
+    {
+        Demo demo;
+        int textureHandle;
+        string dataFileDirectory;
+        string dataFileExt;
+        Bitmap texture;
+        Bitmap textureXZ;
+        Bitmap texturePosY;
+        Bitmap textureNegY;
+        bool enableMipmapTexture;
+
+        public int Handle { get { return textureHandle; } }
+        public string FileDirectory { get { return dataFileDirectory; } }
+        public string FileExt { get { return dataFileExt; } }
+        public Bitmap Bitmap { get { return texture; } }
+        public Bitmap BitmapXZ { get { return textureXZ; } }
+        public Bitmap BitmapPosY { get { return texturePosY; } }
+        public Bitmap BitmapNegY { get { return textureNegY; } }
+        public bool EnableMipmap { get { return enableMipmapTexture; } }
+
+        public DemoTexture(Demo demo, string fileExt, bool enableMipmap)
+        {
+            this.demo = demo;
+            enableMipmapTexture = enableMipmap;
+            textureHandle = -1;
+            texture = textureXZ = textureNegY = texturePosY = null;
+            dataFileDirectory = null;
+            dataFileExt = fileExt;
+        }
+
+        public DemoTexture(Demo demo, string fileExt, Bitmap texture, bool enableMipmap)
+        {
+            this.demo = demo;
+            enableMipmapTexture = enableMipmap;
+            dataFileDirectory = null;
+            dataFileExt = fileExt;
+
+            Create(texture);
+        }
+
+        public DemoTexture(Demo demo, string fileDirectory, string fileExt, bool enableMipmap)
+        {
+            this.demo = demo;
+            enableMipmapTexture = enableMipmap;
+            textureHandle = -1;
+            texture = textureXZ = textureNegY = texturePosY = null;
+            dataFileDirectory = fileDirectory;
+            dataFileExt = fileExt;
+        }
+
+        public DemoTexture(Demo demo, string fileDirectory, string fileExt, Bitmap texture, bool enableMipmap)
+        {
+            this.demo = demo;
+            enableMipmapTexture = enableMipmap;
+            dataFileDirectory = fileDirectory;
+            dataFileExt = fileExt;
+
+            Create(texture);
+        }
+
+        public DemoTexture(Demo demo, Bitmap textureXZ, Bitmap texturePosY, Bitmap textureNegY, bool enableMipmap)
+        {
+            this.demo = demo;
+            enableMipmapTexture = enableMipmap;
+            dataFileDirectory = null;
+            dataFileExt = ".bmp";
+
+            Create(textureXZ, texturePosY, textureNegY);
+        }
+
+        public void Create(Bitmap texture)
+        {
+            this.texture = texture;
+            textureXZ = texturePosY = textureNegY = null;
+
+            BitmapData data = null;
+
+            GL.Enable(EnableCap.Texture2D);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out textureHandle);
+            GL.BindTexture(TextureTarget.Texture2D, textureHandle);
+
+            if (enableMipmapTexture && demo.EnableMipmapExtension)
+            {
+                GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.GenerateMipmapSgis, 1);
+
+                data = texture.LockBits(new Rectangle(0, 0, texture.Width, texture.Height), ImageLockMode.ReadOnly, texture.PixelFormat);
+                GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                texture.UnlockBits(data);
+
+                GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.LinearMipmapLinear);
+                GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            }
+            else
+            {
+                data = texture.LockBits(new Rectangle(0, 0, texture.Width, texture.Height), ImageLockMode.ReadOnly, texture.PixelFormat);
+                GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                texture.UnlockBits(data);
+
+                GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+                GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+            }
+        }
+
+        public void Create(Bitmap textureXZ, Bitmap texturePosY, Bitmap textureNegY)
+        {
+            this.textureXZ = textureXZ;
+            this.texturePosY = texturePosY;
+            this.textureNegY = textureNegY;
+            texture = null;
+
+            BitmapData data = null;
+
+            GL.Enable(EnableCap.TextureCubeMap);
+
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+
+            GL.GenTextures(1, out textureHandle);
+            GL.BindTexture(TextureTarget.TextureCubeMap, textureHandle);
+
+            if (enableMipmapTexture && demo.EnableCubeMapExtension && demo.EnableMipmapExtension)
+            {
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.GenerateMipmapSgis, 1);
+
+                data = textureXZ.LockBits(new Rectangle(0, 0, textureXZ.Width, textureXZ.Height), ImageLockMode.ReadOnly, textureXZ.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeX, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeZ, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveZ, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                textureXZ.UnlockBits(data);
+
+                data = texturePosY.LockBits(new Rectangle(0, 0, texturePosY.Width, texturePosY.Height), ImageLockMode.ReadOnly, texturePosY.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveY, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                texturePosY.UnlockBits(data);
+
+                data = textureNegY.LockBits(new Rectangle(0, 0, textureNegY.Width, textureNegY.Height), ImageLockMode.ReadOnly, textureNegY.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeY, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                textureNegY.UnlockBits(data);
+
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.LinearMipmapLinear);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            }
+            else
+            {
+                data = textureXZ.LockBits(new Rectangle(0, 0, textureXZ.Width, textureXZ.Height), ImageLockMode.ReadOnly, textureXZ.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeX, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeZ, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveX, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveZ, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                textureXZ.UnlockBits(data);
+
+                data = texturePosY.LockBits(new Rectangle(0, 0, texturePosY.Width, texturePosY.Height), ImageLockMode.ReadOnly, texturePosY.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapPositiveY, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                texturePosY.UnlockBits(data);
+
+                data = textureNegY.LockBits(new Rectangle(0, 0, textureNegY.Width, textureNegY.Height), ImageLockMode.ReadOnly, textureNegY.PixelFormat);
+                GL.TexImage2D(TextureTarget.TextureCubeMapNegativeY, 0, PixelInternalFormat.Rgba, data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, data.Scan0);
+                textureNegY.UnlockBits(data);
+
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
+                GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
+            }
+
+            GL.Disable(EnableCap.TextureCubeMap);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/IDemoScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/IDemoScene.cs
new file mode 100644
index 0000000..0b3f7bc
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/IDemoScene.cs
@@ -0,0 +1,30 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public interface IDemoScene
+    {
+        string SceneName { get; }
+        string SceneInfo { get; }
+        PhysicsScene PhysicsScene { get; }
+
+        void Create();
+        void Initialize();
+        void SetControllers();
+        void Refresh(double time);
+        void Remove();
+        void CreateResources();
+        void DisposeResources();
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Amphibian1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Amphibian1.cs
new file mode 100644
index 0000000..ddbfcf8
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Amphibian1.cs
@@ -0,0 +1,446 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Amphibian1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Amphibian1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Amphibian 1" + instanceIndexName);
+            objectRoot.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(0.0f)));
+            objectRoot.InitLocalTransform.SetPosition(-10.0f, -7.5f, 20.0f);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Body" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+            objectA.MaxPreUpdateLinearVelocity = 50.0f;
+            objectA.MaxPostUpdateLinearVelocity = 50.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Body 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 11.8f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.4f, 2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Body 2" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.7f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(6.5f, 0.7f, 10.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Body 3" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 8.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(7.0f, 2.0f, 10.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Body 4" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 4.5f, -0.5f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 1.5f, 10.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+            objectB.MaxPreUpdateAngularVelocity = 10.0f;
+            objectB.MaxPostUpdateAngularVelocity = 10.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Body Up" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 14.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 0.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Body Down" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 13.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(4.0f, 1.0f, 4.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Gun" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Gun Control" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 13.0f, 3.3f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Gun 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-1.0f, 13.0f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 2.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Turret Gun 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(1.0f, 13.0f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 2.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(-6.0f, 3.0f, 8.4f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(-6.0f, 3.0f, 2.2f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(-6.0f, 3.0f, -3.6f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(-6.0f, 3.0f, -9.2f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 5" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(6.0f, 3.0f, 8.4f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 6" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(6.0f, 3.0f, 2.2f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 7" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(6.0f, 3.0f, -3.6f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Amphibian 1 Wheel 8" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.InitLocalTransform.SetPosition(6.0f, 3.0f, -9.2f);
+            objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 2.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Body Down" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun 1" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun 2" + instanceIndexName), true);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Turret Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Body Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Turret Gun Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Gun Control" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Turret Body Down" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 1" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 2" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 3" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 4 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 4" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(-2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 5 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 5" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 6 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 6" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 7 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 7" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Amphibian 1 Wheel 8 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Body 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Amphibian 1 Wheel 8" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(2.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Boat1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Boat1.cs
new file mode 100644
index 0000000..c379bf5
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Boat1.cs
@@ -0,0 +1,375 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Boat1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Boat1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape capsuleY = scene.Factory.ShapeManager.Find("CapsuleY");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Boat 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body" + instanceIndexName);
+            objectA.EnableFeedback = true;
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 0" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -92.5f, -319.0f);
+            objectBase.InitLocalTransform.SetScale(13.0f, 0.5f, 19.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -95.0f, -300.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f, 2.0f, 40.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 2" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(24.0f, -91.0f, -300.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 40.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 3" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(-4.0f, -91.0f, -300.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 40.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 4" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -91.0f, -259.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 5" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -91.0f, -339.0f);
+            objectBase.InitLocalTransform.SetScale(13.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(2.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 6" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -88.75f, -278.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f, 0.25f, 20.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Body Box 7" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -91.0f, -299.0f);
+            objectBase.InitLocalTransform.SetScale(13.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Capsule 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY;
+            objectBase.UserDataStr = "CapsuleY";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -85.0f, -340.0f);
+            objectBase.InitLocalTransform.SetScale(4.0f, 2.0f, 1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Box 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -87.6f, -340.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.8f, 3.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Box 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -86.2f, -340.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.6f, 3.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Cylinder 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -88.7f, -339.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.3f, 1.0f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Cylinder 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -87.6f, -335.2f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Cylinder 3" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -93.4f, -342.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 5.0f, 0.5f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Cylinder 4" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -98.0f, -342.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Cylinder 5" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -98.0f, -343.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Switch" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -87.6f, -335.0f);
+            objectBase.InitLocalTransform.SetScale(1.5f, 2.0f, 1.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Rotor" + instanceIndexName);
+            objectC.MaxPreUpdateAngularVelocity = 10.0f;
+            objectC.MaxPostUpdateAngularVelocity = 10.0f;
+            objectRoot.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Rotor Cylinder 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Brass";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -98.0f, -344.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Rotor Box 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Brass";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, -96.1f, -344.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.0f, 0.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Rotor Box 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Brass";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(11.6f, -98.9f, -344.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.0f, 0.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(120.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Boat 1 Engine Rotor Box 3" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Brass";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(8.4f, -98.9f, -344.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.0f, 0.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(240.0f)));
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Boat 1 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine Cylinder 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Boat 1 Body Box 5" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.3f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.3f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -15.0f;
+            constraint.MaxLimitDegAngleY = 15.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Boat 1 Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine Rotor Cylinder 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Boat 1 Engine Cylinder 5" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box1.cs
new file mode 100644
index 0000000..564f25a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box1.cs
@@ -0,0 +1,149 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Box1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Box1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, int maxPlank, Vector3 plankScale, float plankDistance)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Box 1" + instanceIndexName);
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Up " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance), 0.0f, maxPlank * (plankScale.X + plankDistance) + plankScale.Z - plankDistance);
+                objectBase.InitLocalTransform.SetScale(plankScale);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Down " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance), 0.0f, -maxPlank * (plankScale.X + plankDistance) - plankScale.Z + plankDistance);
+                objectBase.InitLocalTransform.SetScale(plankScale);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Right " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale.X + plankDistance) + plankScale.Z - plankDistance, 0.0f, i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance));
+                objectBase.InitLocalTransform.SetScale(plankScale.Z, plankScale.Y, plankScale.X);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Left " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale.X + plankDistance) - plankScale.Z + plankDistance, 0.0f, i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance));
+                objectBase.InitLocalTransform.SetScale(plankScale.Z, plankScale.Y, plankScale.X);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Top " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance), plankScale.Y + plankScale.Z - plankDistance, 0.0f);
+                objectBase.InitLocalTransform.SetScale(plankScale.X, plankScale.Z, maxPlank * (plankScale.X + plankDistance) - plankDistance);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1 Plank Bottom " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale.X + plankDistance) - maxPlank * (plankScale.X + plankDistance) + (plankScale.X + plankDistance), -plankScale.Y - plankScale.Z + plankDistance, 0.0f);
+                objectBase.InitLocalTransform.SetScale(plankScale.X, plankScale.Z, maxPlank * (plankScale.X + plankDistance) - plankDistance);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box2.cs
new file mode 100644
index 0000000..a255bde
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Box2.cs
@@ -0,0 +1,398 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Box2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Box2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            Vector3[] convexTab = new Vector3[8];
+            convexTab[0] = new Vector3(-1.0f, -1.0f, 1.0f);
+            convexTab[1] = new Vector3(-1.0f, 1.0f, 1.0f);
+            convexTab[2] = new Vector3(1.0f, 0.752f, 1.0f);
+            convexTab[3] = new Vector3(1.0f, -0.752f, 1.0f);
+            convexTab[4] = new Vector3(-1.0f, -1.0f, -1.0f);
+            convexTab[5] = new Vector3(-1.0f, 1.0f, -1.0f);
+            convexTab[6] = new Vector3(1.0f, 0.752f, -1.0f);
+            convexTab[7] = new Vector3(1.0f, -0.752f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Box2Convex1");
+            shapePrimitive.CreateConvex(convexTab);
+
+            shape = scene.Factory.ShapeManager.Create("Box2Convex1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Box2Convex1"))
+                demo.Meshes.Add("Box2Convex1", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, int maxPlank, Vector3 plankScale, float plankDistance)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape box2Convex1 = scene.Factory.ShapeManager.Find("Box2Convex1");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Box 2" + instanceIndexName);
+
+            Vector3 plankScale1 = plankScale;
+            Vector3 plankScale2 = plankScale;
+            plankScale2.X *= 0.5f;
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Up " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance), 0.0f, maxPlank * (plankScale1.X + plankDistance) - plankScale1.Z - plankDistance);
+                objectBase.InitLocalTransform.SetScale(plankScale1);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Down " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance), 0.0f, -maxPlank * (plankScale1.X + plankDistance) + plankScale1.Z + plankDistance);
+                objectBase.InitLocalTransform.SetScale(plankScale1);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Right " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale1.X + plankDistance) + plankScale1.Z - plankDistance, 0.0f, i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance));
+                objectBase.InitLocalTransform.SetScale(plankScale1.Z, plankScale1.Y, plankScale1.X);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Left " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale1.X + plankDistance) - plankScale1.Z + plankDistance, 0.0f, i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance));
+                objectBase.InitLocalTransform.SetScale(plankScale1.Z, plankScale1.Y, plankScale1.X);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Top " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance), plankScale1.Y - plankScale1.Z - plankDistance, 0.0f);
+                objectBase.InitLocalTransform.SetScale(plankScale1.X, plankScale1.Z, maxPlank * (plankScale1.X + plankDistance) - plankDistance);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            for (int i = 0; i < maxPlank; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Plank Bottom " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+                objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(i * 2.0f * (plankScale1.X + plankDistance) - maxPlank * (plankScale1.X + plankDistance) + (plankScale1.X + plankDistance), -plankScale1.Y + plankScale1.Z + plankDistance, 0.0f);
+                objectBase.InitLocalTransform.SetScale(plankScale1.X, plankScale1.Z, maxPlank * (plankScale1.X + plankDistance) - plankDistance);
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Up 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance, 0.0f, maxPlank * (plankScale1.X + plankDistance) + plankScale2.Z - plankDistance);
+            objectBase.InitLocalTransform.SetScale(ref plankScale2);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Up 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance, 0.0f, maxPlank * (plankScale1.X + plankDistance) + plankScale2.Z - plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.InitLocalTransform.SetScale(ref plankScale2);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Up 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, plankScale1.Y - plankScale2.X, maxPlank * (plankScale1.X + plankDistance) + plankScale2.Z - plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Up 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, -plankScale1.Y + plankScale2.X, maxPlank * (plankScale1.X + plankDistance) + plankScale2.Z - plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Down 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance, 0.0f, -maxPlank * (plankScale1.X + plankDistance) - plankScale2.Z + plankDistance);
+            objectBase.InitLocalTransform.SetScale(ref plankScale2);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Down 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance, 0.0f, -maxPlank * (plankScale1.X + plankDistance) - plankScale2.Z + plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.InitLocalTransform.SetScale(ref plankScale2);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Down 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, plankScale1.Y - plankScale2.X, -maxPlank * (plankScale1.X + plankDistance) - plankScale2.Z + plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Down 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, -plankScale1.Y + plankScale2.X, -maxPlank * (plankScale1.X + plankDistance) - plankScale2.Z + plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Top 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance, plankScale1.Y + plankScale2.Z, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Top 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance, plankScale1.Y + plankScale2.Z, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Top 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, plankScale1.Y + plankScale2.Z, maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Top 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, plankScale1.Y + plankScale2.Z, -maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Bottom 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance, -plankScale1.Y - plankScale2.Z, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Bottom 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance, -plankScale1.Y - plankScale2.Z, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Bottom 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, -plankScale1.Y - plankScale2.Z, maxPlank * (plankScale1.X + plankDistance) - plankScale2.X - plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 2 Convex Plank Bottom 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box2Convex1;
+            objectBase.UserDataStr = "Box2Convex1";
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, -plankScale1.Y - plankScale2.Z, -maxPlank * (plankScale1.X + plankDistance) + plankScale2.X + plankDistance);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(plankScale2.X, maxPlank * (plankScale1.X + plankDistance) - plankDistance, plankScale2.Z);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge1.cs
new file mode 100644
index 0000000..1a2d70c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge1.cs
@@ -0,0 +1,112 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Bridge1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Bridge1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, int boardCount, Vector3 boardScale)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Bridge 1 " + instanceIndexName);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 1 Board 0" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood1";
+            objectBase.InitLocalTransform.SetPosition(-boardCount * boardScale.X, 50.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(boardScale);
+
+            for (int i = 1; i < boardCount - 1; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 1 Board " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.InitLocalTransform.SetPosition(-boardCount * boardScale.X + i * 2.0f * boardScale.X, 50.0f, 20.0f);
+                objectBase.InitLocalTransform.SetScale(boardScale);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.CreateSound(true);
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 1 Board " + (boardCount - 1).ToString() + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood1";
+            objectBase.InitLocalTransform.SetPosition(-boardCount * boardScale.X + (boardCount - 1) * 2.0f * boardScale.X, 50.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(boardScale);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+
+            for (int i = 0; i < boardCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Bridge 1 Constraint " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Bridge 1 Board " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Bridge 1 Board " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(boardScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(boardScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableBreak = true;
+
+                if (i == 0 || i == boardCount - 2)
+                    constraint.AngularDamping = 0.1f;
+
+                constraint.Update();
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge2.cs
new file mode 100644
index 0000000..3d1eb3c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Bridge2.cs
@@ -0,0 +1,310 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Bridge2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Bridge2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(PhysicsObject startObject, PhysicsObject endObject, Vector3 startPosition, Vector3 endPosition, int boardCount, Vector2 boardXYScale)
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectTruss = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Vector3 scale1 = Vector3.One;
+            Vector3 scale2 = Vector3.One;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Bridge 2 " + instanceIndexName);
+
+            endPosition.Y = startPosition.Y;
+            Vector3 distance = startPosition - endPosition;
+            float length = distance.Length;
+            float boardLength = length / boardCount;
+            Vector3 boardScale = new Vector3(boardXYScale.X, boardXYScale.Y, boardLength * 0.5f);
+
+            for (int i = 0; i < boardCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Board " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.InitLocalTransform.SetPosition(startPosition.X, startPosition.Y, startPosition.Z + i * 2.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+                objectBase.InitLocalTransform.SetScale(boardLength * 0.5f, 0.4f, 15.0f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.CreateSound(true);
+            }
+
+            int trussCount = boardCount / 2;
+            for (int i = 0; i < trussCount; i++)
+            {
+                objectTruss = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Right " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectTruss);
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Right Base " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.InitLocalTransform.SetPosition(startPosition.X + 14.0f, startPosition.Y + boardLength * 0.25f + 0.4f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(0.4f, boardLength * 0.25f, 0.4f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.CreateSound(true);
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Right Light Base " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.TwoSidedNormals = true;
+                objectBase.Material.UserDataStr = "Yellow";
+                objectBase.InitLocalTransform.SetPosition(startPosition.X + 14.0f, startPosition.Y + boardLength * 0.5f + 1.0f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(0.6f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.CreateSound(true);
+                objectBase.Sound.UserDataStr = "Glass";
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Right Light " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = sphere;
+                objectBase.UserDataStr = "Sphere";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.UserDataStr = "Yellow";
+                objectBase.InitLocalTransform.SetPosition(startPosition.X + 14.0f, startPosition.Y + boardLength * 0.5f + 1.0f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(15.0f);
+                objectBase.CreateLight(true);
+                objectBase.Light.Type = PhysicsLightType.Point;
+                objectBase.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                objectBase.Light.Range = 15.0f;
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.EnableCollisions = false;
+                objectBase.EnableCursorInteraction = false;
+                objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+            }
+
+            for (int i = 0; i < trussCount; i++)
+            {
+                objectTruss = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Left " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectTruss);
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Left Base " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.RigidGroup = true;
+                objectBase.InitLocalTransform.SetPosition(startPosition.X - 14.0f, startPosition.Y + boardLength * 0.25f + 0.4f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(0.4f, boardLength * 0.25f, 0.4f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.CreateSound(true);
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Left Light Base " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.TwoSidedNormals = true;
+                objectBase.Material.UserDataStr = "Yellow";
+                objectBase.InitLocalTransform.SetPosition(startPosition.X - 14.0f, startPosition.Y + boardLength * 0.5f + 1.0f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(0.6f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.CreateSound(true);
+                objectBase.Sound.UserDataStr = "Glass";
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Bridge 2 Truss Left Light " + i.ToString() + instanceIndexName);
+                objectTruss.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = sphere;
+                objectBase.UserDataStr = "Sphere";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.UserDataStr = "Yellow";
+                objectBase.InitLocalTransform.SetPosition(startPosition.X - 14.0f, startPosition.Y + boardLength * 0.5f + 1.0f, startPosition.Z + i * 4.0f * boardScale.Z + boardScale.Z);
+                objectBase.InitLocalTransform.SetScale(15.0f);
+                objectBase.CreateLight(true);
+                objectBase.Light.Type = PhysicsLightType.Point;
+                objectBase.Light.SetDiffuse(1.0f, 0.7f, 0.0f);
+                objectBase.Light.Range = 15.0f;
+                objectBase.EnableBreakRigidGroup = false;
+                objectBase.EnableCollisions = false;
+                objectBase.EnableCursorInteraction = false;
+                objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+
+            for (int i = 0; i < trussCount; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Bridge 2 Truss Right Constraint " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Right Base " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board " + (i * 2).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 - new Vector3(0.0f, boardLength * 0.25f, 0.0f));
+                constraint.SetAnchor2(position1 - new Vector3(0.0f, boardLength * 0.25f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.Update();
+            }
+
+            for (int i = 0; i < trussCount; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Bridge 2 Truss Left Constraint " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Left Base " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board " + (i * 2).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 - new Vector3(0.0f, boardLength * 0.25f, 0.0f));
+                constraint.SetAnchor2(position1 - new Vector3(0.0f, boardLength * 0.25f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.Update();
+            }
+
+            constraint = scene.Factory.ConstraintManager.Create("Bridge 2 Constraint 0" + instanceIndexName);
+            constraint.PhysicsObject1 = startObject;
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board 0" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref startPosition);
+            constraint.SetAnchor2(ref startPosition);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.AngularDamping = 0.1f;
+            constraint.Update();
+
+            for (int i = 0; i < boardCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Bridge 2 Constraint " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, boardScale.Z));
+                constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, boardScale.Z));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.AngularDamping = 0.1f;
+                constraint.Update();
+            }
+
+            constraint = scene.Factory.ConstraintManager.Create("Bridge 2 Constraint " + (boardCount + 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Board " + (boardCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = endObject;
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref endPosition);
+            constraint.SetAnchor2(ref endPosition);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.AngularDamping = 0.1f;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+
+            Rope rope = null;
+            int ropeSegmentCount = 4;
+            PhysicsObject ropeStartObject = null;
+            PhysicsObject ropeEndObject = null;
+
+            for (int i = 0; i < trussCount - 1; i++)
+            {
+                ropeStartObject = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Left Base " + i.ToString() + instanceIndexName);
+                ropeEndObject = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Left Base " + (i + 1).ToString() + instanceIndexName);
+
+                ropeStartObject.MainWorldTransform.GetPosition(ref position1);
+                ropeEndObject.MainWorldTransform.GetPosition(ref position2);
+                ropeStartObject.MainWorldTransform.GetScale(ref scale1);
+                ropeEndObject.MainWorldTransform.GetScale(ref scale2);
+
+                position1 += new Vector3(0.0f, scale1.Y - scale1.Z, scale1.Z);
+                position2 += new Vector3(0.0f, scale2.Y - scale1.Z, -scale2.Z);
+
+                rope = new Rope(demo, i);
+                rope.Initialize(scene);
+                rope.Create(ropeStartObject, ropeEndObject, position1, position2, ropeSegmentCount);
+            }
+
+            for (int i = 0; i < trussCount - 1; i++)
+            {
+                ropeStartObject = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Right Base " + i.ToString() + instanceIndexName);
+                ropeEndObject = scene.Factory.PhysicsObjectManager.Find("Bridge 2 Truss Right Base " + (i + 1).ToString() + instanceIndexName);
+
+                ropeStartObject.MainWorldTransform.GetPosition(ref position1);
+                ropeEndObject.MainWorldTransform.GetPosition(ref position2);
+                ropeStartObject.MainWorldTransform.GetScale(ref scale1);
+                ropeEndObject.MainWorldTransform.GetScale(ref scale2);
+
+                position1 += new Vector3(0.0f, scale1.Y - scale1.Z, scale1.Z);
+                position2 += new Vector3(0.0f, scale2.Y - scale1.Z, -scale2.Z);
+
+                rope = new Rope(demo, i + trussCount);
+                rope.Initialize(scene);
+                rope.Create(ropeStartObject, ropeEndObject, position1, position2, ropeSegmentCount);
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building1.cs
new file mode 100644
index 0000000..7c09d1d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building1.cs
@@ -0,0 +1,472 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Building1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Building1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+            PhysicsObject objectD = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Building 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+            objectA.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Floor" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, -8.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 2" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 3" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 41" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 42" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 43" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 44" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Wall 45" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f, -6.9f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 0.1f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(10.4f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 1 Ceiling" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+            objectB.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 60.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 3" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 41" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 42" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 43" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Wall 44" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 2 Ceiling" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectC);
+            objectC.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 60.0f + 60.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 3" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 41" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 42" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 43" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Wall 44" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 3 Ceiling" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectD);
+            objectD.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 1" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 60.0f + 60.0f + 60.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 2" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f + 60.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 3" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f + 60.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 41" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f + 60.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 42" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f + 60.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 43" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f + 60.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Wall 44" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f + 60.0f + 60.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 1 Level 4 Ceiling" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f + 60.0f + 60.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building2.cs
new file mode 100644
index 0000000..7aad47e
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Building2.cs
@@ -0,0 +1,370 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Building2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Building2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Building 2" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+            objectA.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Floor" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, -8.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 100.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 2" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 3" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 41" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 42" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 43" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 44" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Wall 45" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f, -6.9f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 0.1f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(10.4f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Ceiling 11" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f, 120.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 40.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Ceiling 12" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 40.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Ceiling 13" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-40.0f, 50.0f, 180.0f);
+            objectBase.InitLocalTransform.SetScale(60.0f, 1.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Ceiling 14" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(80.0f, 50.0f, 180.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            for (int i = 0; i < 29; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 1 Stair " + i.ToString() + instanceIndexName);
+                objectA.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+                objectBase.InitLocalTransform.SetPosition(2.5f * i - 12.5f, -7.0f + i * 2.0f * 1.0f + 1.0f, 180.0f);
+                objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 20.0f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.CreateSound(true);
+            }
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+            objectB.Material.RigidGroup = true;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 60.0f, 201.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(101.0f, 21.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 3" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-101.0f, 21.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f, 1.0f, 102.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 41" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-60.0f, 21.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 42" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f + 15.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 15.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 43" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 21.0f - 29.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Wall 44" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(60.0f, 21.0f + 60.0f, -1.0f);
+            objectBase.InitLocalTransform.SetScale(40.0f, 1.0f, 30.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Ceiling 11" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f + 60.0f, 160.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 40.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Ceiling 12" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 50.0f + 60.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(100.0f, 1.0f, 40.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Ceiling 13" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(40.0f, 50.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(60.0f, 1.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Ceiling 14" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-80.0f, 50.0f + 60.0f, 100.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f, 1.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            for (int i = 0; i < 29; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Building 2 Level 2 Stair " + i.ToString() + instanceIndexName);
+                objectB.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+                objectBase.InitLocalTransform.SetPosition(-2.5f * i + 12.5f, 51.0f + i * 2.0f * 1.0f + 1.0f, 100.0f);
+                objectBase.InitLocalTransform.SetScale(2.5f, 1.0f, 20.0f);
+                objectBase.Integral.SetDensity(1.0f);
+                objectBase.CreateSound(true);
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera1.cs
new file mode 100644
index 0000000..0296d0a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera1.cs
@@ -0,0 +1,77 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Camera1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Quaternion objectOrientationX, Quaternion objectOrientationY, Quaternion objectOrientationZ, bool actived)
+        {
+            Quaternion objectOrientationXY, objectOrientation;
+
+            PhysicsObject objectRoot = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Camera 1" + instanceIndexName);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetOrientation(objectOrientationX * objectOrientationY * objectOrientationZ);
+            objectRoot.CreateCamera(true);
+            objectRoot.Camera.Active = actived;
+            objectRoot.InternalControllers.CreateCursorController(true);
+            objectRoot.PostTransformPriority = 1;
+            objectRoot.CreateSound(false);
+            objectRoot.Sound.Range = 100.0f;
+            objectRoot.Sound.HitPitch = -0.8f;
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Vector3 position = Vector3.Zero;
+            Matrix4 cameraRotation = Matrix4.Identity;
+
+            Quaternion.Multiply(ref objectOrientationX, ref objectOrientationY, out objectOrientationXY);
+            Quaternion.Multiply(ref objectOrientationXY, ref objectOrientationZ, out objectOrientation);
+            Matrix4 rotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+            objectRoot.Camera.SetOrientation(ref objectOrientation);
+            objectRoot.Camera.SetRotation(ref rotation);
+            objectRoot.Camera.SetEuler(ref rotation);
+            objectRoot.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectRoot.MainWorldTransform.GetPosition(ref position);
+            objectRoot.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectRoot.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectRoot.Camera.UpdateFrustum();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera2.cs
new file mode 100644
index 0000000..500b8a2
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera2.cs
@@ -0,0 +1,137 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Camera2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Quaternion objectOrientationX, Quaternion objectOrientationY, Quaternion objectOrientationZ, bool actived)
+        {
+            Quaternion objectOrientationXY, objectOrientation;
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectUp = null;
+            PhysicsObject objectBody = null;
+            PhysicsObject objectDown = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Camera 2" + instanceIndexName);
+            objectRoot.MaxPreUpdateAngularVelocity = 0.0f;
+            objectRoot.MaxPostUpdateAngularVelocity = 0.0f;
+            objectRoot.EnableBreakRigidGroup = false;
+            objectRoot.EnableCursorInteraction = false;
+            objectRoot.EnableDrawing = false;
+            objectRoot.MaxSleepLinearVelocity = 0.1f;
+            objectRoot.MaxSleepAngularVelocity = 0.1f;
+            objectRoot.FluidPressureFactor = 0.46f;
+            objectRoot.CreateSound(true);
+            objectRoot.Sound.UserDataStr = "Footsteps";
+
+            objectUp = scene.Factory.PhysicsObjectManager.Create("Camera 2 Up" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectUp);
+            objectUp.Material.RigidGroup = true;
+            objectUp.Shape = sphere;
+            objectUp.UserDataStr = "Sphere";
+            objectUp.InitLocalTransform.SetPosition(0.0f, 2.0f, 0.0f);
+            objectUp.InitLocalTransform.SetScale(1.5f, 1.0f, 1.5f);
+            objectUp.Integral.SetDensity(0.1f);
+            objectUp.EnableBreakRigidGroup = false;
+            objectUp.EnableCursorInteraction = false;
+            objectUp.EnableDrawing = false;
+            objectUp.PostTransformPriority = 1;
+            objectUp.MinResponseLinearVelocity = 0.005f;
+            objectUp.MinResponseAngularVelocity = 0.005f;
+
+            objectUp.CreateCamera(true);
+            objectUp.Camera.Active = actived;
+            objectUp.InternalControllers.CreateCursorController(true);
+            objectUp.CreateSound(false);
+            objectUp.Sound.Range = 100.0f;
+            objectUp.Sound.HitPitch = -0.8f;
+
+            objectBody = scene.Factory.PhysicsObjectManager.Create("Camera 2 Body" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBody);
+            objectBody.Material.RigidGroup = true;
+            objectBody.Shape = cylinderY;
+            objectBody.UserDataStr = "CylinderY";
+            objectBody.InitLocalTransform.SetPosition(0.0f, 0.0f, 0.0f);
+            objectBody.InitLocalTransform.SetScale(2.0f);
+            objectBody.Integral.SetDensity(1.0f);
+            objectBody.EnableBreakRigidGroup = false;
+            objectBody.EnableCursorInteraction = false;
+            objectBody.EnableDrawing = false;
+            objectBody.MinResponseLinearVelocity = 0.005f;
+            objectBody.MinResponseAngularVelocity = 0.005f;
+
+            objectDown = scene.Factory.PhysicsObjectManager.Create("Camera 2 Down" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectDown);
+            objectDown.Material.RigidGroup = true;
+            objectDown.Shape = sphere;
+            objectDown.UserDataStr = "Sphere";
+            objectDown.InitLocalTransform.SetPosition(0.0f, -2.0f, 0.0f);
+            objectDown.InitLocalTransform.SetScale(1.5f, 2.0f, 1.5f);
+            objectDown.Integral.SetDensity(0.5f);
+            objectDown.EnableBreakRigidGroup = false;
+            objectDown.EnableCursorInteraction = false;
+            objectDown.EnableDrawing = false;
+            objectDown.MinResponseLinearVelocity = 0.005f;
+            objectDown.MinResponseAngularVelocity = 0.005f;
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientationY);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Vector3 position = Vector3.Zero;
+            Matrix4 cameraRotation = Matrix4.Identity;
+
+            Quaternion.Multiply(ref objectOrientationX, ref objectOrientationY, out objectOrientationXY);
+            Quaternion.Multiply(ref objectOrientationXY, ref objectOrientationZ, out objectOrientation);
+            Matrix4 rotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+            objectUp.Camera.SetOrientation(ref objectOrientation);
+            objectUp.Camera.SetRotation(ref rotation);
+            objectUp.Camera.SetEuler(ref rotation);
+            objectUp.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectUp.MainWorldTransform.GetPosition(ref position);
+            objectUp.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectUp.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectUp.Camera.UpdateFrustum();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera3.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera3.cs
new file mode 100644
index 0000000..a1846fc
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Camera3.cs
@@ -0,0 +1,72 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Camera3
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Camera3(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Quaternion objectOrientationX, Quaternion objectOrientationY, Quaternion objectOrientationZ)
+        {
+            Quaternion objectOrientationXY, objectOrientation;
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Camera 3" + instanceIndexName);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetOrientation(objectOrientationX * objectOrientationY * objectOrientationZ);
+            objectRoot.CreateCamera(true);
+            objectRoot.Camera.Active = false;
+            objectRoot.InternalControllers.CreateScreenToRayController(true);
+            objectRoot.PostTransformPriority = 1;
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Vector3 position = Vector3.Zero;
+            Matrix4 cameraRotation = Matrix4.Identity;
+
+            Quaternion.Multiply(ref objectOrientationX, ref objectOrientationY, out objectOrientationXY);
+            Quaternion.Multiply(ref objectOrientationXY, ref objectOrientationZ, out objectOrientation);
+            Matrix4 rotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+            objectRoot.Camera.SetOrientation(ref objectOrientation);
+            objectRoot.Camera.SetRotation(ref rotation);
+            objectRoot.Camera.SetEuler(ref rotation);
+            objectRoot.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectRoot.MainWorldTransform.GetPosition(ref position);
+            objectRoot.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectRoot.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectRoot.Camera.UpdateFrustum();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Car1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Car1.cs
new file mode 100644
index 0000000..1a8e50f
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Car1.cs
@@ -0,0 +1,1104 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Car1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Car1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = null;
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Car1Torus1");
+            triangleMesh.CreateTorusY(10, 15, 3.0f, 0.5f);
+            if (!demo.Meshes.ContainsKey("Car1Torus1"))
+                demo.Meshes.Add("Car1Torus1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Car1Torus1");
+            shapePrimitive.CreateConvex(triangleMesh);
+
+            shape = scene.Factory.ShapeManager.Create("Car1Torus1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            shape = scene.Factory.ShapeManager.Create("Car1Wheel");
+            shape.Add(cylinderY, Matrix4.CreateScale(0.5f, 1.0f, 0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Car1Wheel"))
+                demo.Meshes.Add("Car1Wheel", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape coneZ = scene.Factory.ShapeManager.Find("ConeZ");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape triangle1 = scene.Factory.ShapeManager.Find("Triangle1");
+            Shape triangle2 = scene.Factory.ShapeManager.Find("Triangle2");
+            Shape Torus1 = scene.Factory.ShapeManager.Find("Car1Torus1");
+            Shape Wheel = scene.Factory.ShapeManager.Find("Car1Wheel");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+            PhysicsObject objectD = null;
+            PhysicsObject objectE = null;
+            PhysicsObject objectF = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Car 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Car 1 Body" + instanceIndexName);
+            objectA.EnableFeedback = true;
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Back" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.0f, 26.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 1.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Middle Down" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 9.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 0.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Middle Front" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 11.0f, 17.1f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 1.5f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Up Panel" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(2.0f, 12.5f, 16.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)));
+            objectBase.InitLocalTransform.SetScale(1.5f, 0.6f, 0.6f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Down Panel" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(2.0f, 12.4f, 17.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)));
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.4f, 0.25f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Middle Back" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 11.0f, 22.9f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 1.5f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Chassis Front" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.0f, 14.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 1.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Body" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.0f, 10.5f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 1.5f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Back Body" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.0f, 29.5f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 1.5f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Down Back" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 12.0f, 26.5f);
+            objectBase.InitLocalTransform.SetScale(6.0f, 0.5f, 3.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Down Front" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 12.0f, 13.5f);
+            objectBase.InitLocalTransform.SetScale(6.0f, 0.5f, 3.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Front" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 13.0f, 23.2f);
+            objectBase.InitLocalTransform.SetScale(5.6f, 0.5f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Right" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.8f, 13.0f, 26.3f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.5f, 3.3f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Left" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(5.8f, 13.0f, 26.3f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.5f, 3.3f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Back" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 13.0f, 29.8f);
+            objectBase.InitLocalTransform.SetScale(6.0f, 0.5f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Up Body Spare Wheel" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(-1.0f, 12.0f, 30.2f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 1.0f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Right Lamp" + instanceIndexName);
+            objectB.Material.RigidGroup = true;
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Right Lamp Base" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(-3.5f, 11.0f, 9.9f);
+            objectBase.InitLocalTransform.SetScale(0.7f, 0.7f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Right Lamp Light" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = coneZ;
+            objectBase.UserDataStr = "ConeZ";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(-3.5f, 11.0f, -19.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f);
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Spot;
+            objectBase.Light.SetDiffuse(0.8f, 0.8f, 0.8f);
+            objectBase.Light.SpotInnerRadAngle = (float)Math.Atan(0.35);
+            objectBase.Light.SpotOuterRadAngle = (float)Math.Atan(0.5);
+            objectBase.Light.Range = 60.0f;
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Left Lamp" + instanceIndexName);
+            objectB.Material.RigidGroup = true;
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Left Lamp Base" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(3.5f, 11.0f, 9.9f);
+            objectBase.InitLocalTransform.SetScale(0.7f, 0.7f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Front Left Lamp Light" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = coneZ;
+            objectBase.UserDataStr = "ConeZ";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(3.5f, 11.0f, -19.0f);
+            objectBase.InitLocalTransform.SetScale(30.0f);
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Spot;
+            objectBase.Light.SetDiffuse(0.8f, 0.8f, 0.8f);
+            objectBase.Light.SpotInnerRadAngle = (float)Math.Atan(0.35);
+            objectBase.Light.SpotOuterRadAngle = (float)Math.Atan(0.5);
+            objectBase.Light.Range = 60.0f;
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Car 1 Right Door" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Right Door Body" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-5.2f, 10.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.0f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Right Door Switch" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-5.5f, 11.5f, 22.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Car 1 Left Door" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Left Door Body" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(5.2f, 10.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.0f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Left Door Switch" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(5.5f, 11.5f, 22.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Gear" + instanceIndexName);
+            objectD.InitLocalTransform.SetPosition(2.0f, 13.0f, 17.6f);
+            objectD.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            objectA.AddChildPhysicsObject(objectD);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Wheel" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Torus1;
+            objectBase.UserDataStr = "Car1Torus1";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.4f, 0.4f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Gear Left" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.6f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.05f, 0.15f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Gear Right" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.05f, 0.15f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Gear Down" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.Material.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, -0.26f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.34f, 0.4f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Steering Gear Switch" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.4f, 2.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            objectE = scene.Factory.PhysicsObjectManager.Create("Car 1 Windscreen" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectE);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Windscreen Up" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 16.3f, 15.0f);
+            objectBase.InitLocalTransform.SetScale(5.4f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Windscreen Down" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 12.7f, 15.0f);
+            objectBase.InitLocalTransform.SetScale(5.4f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Windscreen Right" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-5.2f, 14.5f, 15.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Windscreen Left" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(5.2f, 14.5f, 15.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectF = scene.Factory.PhysicsObjectManager.Create("Car 1 Pane" + instanceIndexName);
+            objectF.Material.RigidGroup = true;
+            objectE.AddChildPhysicsObject(objectF);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Pane 1" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.0f - 5.4f, 14.5f - 1.6f, 15.0f) + new Vector3(0.0f - 5.4f, 14.5f + 1.6f, 15.0f) + new Vector3(0.0f, 14.5f + 1.6f, 15.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(2.7f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Pane 2" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.0f, 14.5f + 1.6f, 15.0f) + new Vector3(0.0f, 14.5f - 1.6f, 15.0f) + new Vector3(0.0f - 5.4f, 14.5f - 1.6f, 15.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(2.7f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Pane 3" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.0f, 14.5f - 1.6f, 15.0f) + new Vector3(0.0f, 14.5f + 1.6f, 15.0f) + new Vector3(0.0f + 5.4f, 14.5f + 1.6f, 15.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(2.7f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Pane 4" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.0f + 5.4f, 14.5f + 1.6f, 15.0f) + new Vector3(0.0f + 5.4f, 14.5f - 1.6f, 15.0f) + new Vector3(0.0f, 14.5f - 1.6f, 15.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(2.7f, 1.6f, 0.2f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Spare Wheel" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Wheel;
+            objectBase.UserDataStr = "Car1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(-1.0f, 12.0f, 31.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Wheel 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Wheel;
+            objectBase.UserDataStr = "Car1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(5.0f, 9.0f, 14.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MaxPreUpdateAngularVelocity = 10.0f;
+            objectBase.MaxPostUpdateAngularVelocity = 10.0f;
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Axle 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.InitLocalTransform.SetPosition(4.0f, 9.0f, 14.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Wheel 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Wheel;
+            objectBase.UserDataStr = "Car1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 9.0f, 14.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MaxPreUpdateAngularVelocity = 10.0f;
+            objectBase.MaxPostUpdateAngularVelocity = 10.0f;
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Axle 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 9.0f, 14.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Wheel 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Wheel;
+            objectBase.UserDataStr = "Car1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(5.0f, 9.0f, 26.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MaxPreUpdateAngularVelocity = 10.0f;
+            objectBase.MaxPostUpdateAngularVelocity = 10.0f;
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Axle 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.InitLocalTransform.SetPosition(4.0f, 9.0f, 26.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Wheel 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = Wheel;
+            objectBase.UserDataStr = "Car1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 9.0f, 26.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MaxPreUpdateAngularVelocity = 10.0f;
+            objectBase.MaxPostUpdateAngularVelocity = 10.0f;
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Car 1 Axle 4" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 9.0f, 26.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.MinResponseLinearVelocity = 0.005f;
+            objectBase.MinResponseAngularVelocity = 0.005f;
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Right Door Body" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Front" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Back" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Front" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Back" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Left Door Body" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Front" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Back" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Front" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Back" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Front" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 1" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 2" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 1" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 2" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Back" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 3" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 4" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 3" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 4" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Front Body" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 1" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 2" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 1" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 2" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Back Body" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 3" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 4" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 3" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 4" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Car 1 Steering Gear Down" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Up Panel" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Down Panel" + instanceIndexName), true);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Windscreen Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Windscreen Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Front" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -0.2f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -0.2f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -20.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Right Door Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Right Door Body" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Front" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -2.95f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -2.95f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = 0.0f;
+            constraint.MaxLimitDegAngleY = 80.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Left Door Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Left Door Body" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Down Front" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -2.95f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -2.95f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -80.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Steering Gear Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Steering Gear Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Middle Front" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(orientation1 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)));
+            constraint.SetInitWorldOrientation2(orientation2 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)));
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -60.0f;
+            constraint.MaxLimitDegAngleY = 60.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 100.0f;
+            constraint.EnableControlAngleY = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Vehicle Spare Wheel Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Up Body Spare Wheel" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Spare Wheel" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 0.0f, 0.2f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 0.0f, 0.2f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Front" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 1" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinLimitDegAngleY = -30.0f;
+            constraint.MaxLimitDegAngleY = 30.0f;
+            constraint.EnableControlAngleY = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 1" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 3" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Front" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 1" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position2);
+            constraint.SetAnchor2(ref position2);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 4" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Front" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 2" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinLimitDegAngleY = -30.0f;
+            constraint.MaxLimitDegAngleY = 30.0f;
+            constraint.EnableControlAngleY = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 5" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 2" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 6" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Front" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 2" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position2);
+            constraint.SetAnchor2(ref position2);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 7" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Back" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 3" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 8" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 3" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 9" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Back" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 3" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position2);
+            constraint.SetAnchor2(ref position2);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 10" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Back" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 4" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 11" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Axle 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 4" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.5f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Car 1 Constraint 12" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Car 1 Chassis Back" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Car 1 Wheel 4" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position2);
+            constraint.SetAnchor2(ref position2);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.MaxLimitDistanceY = 0.5f;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreakRigidGroup = false;
+            constraint.MinResponseLinearVelocity = 0.005f;
+            constraint.MinResponseAngularVelocity = 0.005f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/CargoJack.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/CargoJack.cs
new file mode 100644
index 0000000..7a7438d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/CargoJack.cs
@@ -0,0 +1,341 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class CargoJack
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public CargoJack(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+            PhysicsObject objectD = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Cargo Jack" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Body" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Body Down" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 0.5f, 10.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Body Motor" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 1.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 0.5f, 2.0f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Motor" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 6.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 5.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Down" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 7.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 5.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Up" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 12.7f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Counterbalance" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-14.0f, 11.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectD);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel Body" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-6.4f, 5.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel Down" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-6.2f, 3.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 2.0f, 0.1f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel Button" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.SetAmbient(0.4f, 0.7f, 0.4f);
+            objectBase.Material.SetDiffuse(0.4f, 1.0f, 0.4f);
+            objectBase.InitLocalTransform.SetPosition(-6.6f, 5.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.1f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.Integral.InertiaScaleFactor = 10.0f;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel Button Switch" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(-6.7f, 5.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.2f, 0.2f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableDrawing = false;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Panel Button Light" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(-6.6f, 5.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Point;
+            objectBase.Light.SetDiffuse(0.2f, 1.0f, 0.2f);
+            objectBase.Light.Range = 2.0f;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Up" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 12.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.5f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Middle Bottom" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 9.8f, 7.5f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.5f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Middle" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 11.4f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.1f, 7.6f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Middle Top" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 9.8f, -7.5f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.5f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Bottom" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 8.2f, 7.5f);
+            objectBase.InitLocalTransform.SetScale(7.6f, 0.1f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cargo Jack Arm Handle Top" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(14.0f, 8.2f, -7.5f);
+            objectBase.InitLocalTransform.SetScale(7.6f, 0.1f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+
+            constraint = scene.Factory.ConstraintManager.Create("Cargo Jack Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Panel Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Body Motor" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 2.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 2.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 150.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Cargo Jack Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Arm Motor" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Body Motor" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 5.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 5.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.EnableControlAngleY = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Cargo Jack Constraint 3" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Arm Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Arm Motor" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 5.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 5.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDistanceY = 0.0f;
+            constraint.MaxLimitDistanceY = 9.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.EnableControlDistanceY = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Cargo Jack Constraint 4" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Arm Handle Up" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Cargo Jack Arm Up" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.5f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.5f, 0.0f));
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Column.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Column.cs
new file mode 100644
index 0000000..5342e36
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Column.cs
@@ -0,0 +1,68 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Column
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Column(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, string shapeName, int columnSize, Vector3 shapeSize, float density, bool enableSleeping, float soundTotalVelocityFactor, float soundAmplitudeFactor)
+        {
+            Shape shape = scene.Factory.ShapeManager.Find(shapeName);
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Column" + instanceIndexName);
+
+            for (int i = 0; i < columnSize; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Column " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = shape;
+                objectBase.UserDataStr = shapeName;
+                objectBase.CreateSound(true);
+                objectBase.Sound.TotalVelocityFactor = soundTotalVelocityFactor;
+                objectBase.Sound.AmplitudeFactor = soundAmplitudeFactor;
+                objectBase.InitLocalTransform.SetPosition(0.0f, i * shapeSize.Y + 0.5f * shapeSize.Y, 0.0f);
+                objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z);
+                objectBase.Integral.SetDensity(density);
+                objectBase.EnableSleeping = enableSleeping;
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Crab1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Crab1.cs
new file mode 100644
index 0000000..b9f9de2
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Crab1.cs
@@ -0,0 +1,1103 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Crab1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Crab1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            Vector3[] convexTab1 = new Vector3[12];
+            convexTab1[0] = new Vector3(-0.1f, -1.0f, -1.0f);
+            convexTab1[1] = new Vector3(-1.0f, -1.0f, -0.5f);
+            convexTab1[2] = new Vector3(-1.0f, -1.0f, 0.5f);
+            convexTab1[3] = new Vector3(-0.1f, -1.0f, 1.0f);
+            convexTab1[4] = new Vector3(0.1f, -1.0f, 1.0f);
+            convexTab1[5] = new Vector3(1.0f, -1.0f, 0.7f);
+            convexTab1[6] = new Vector3(1.0f, -1.0f, -0.7f);
+            convexTab1[7] = new Vector3(0.1f, -1.0f, -1.0f);
+            convexTab1[8] = new Vector3(0.0f, 1.0f, -0.2f);
+            convexTab1[9] = new Vector3(-0.2f, 1.0f, 0.0f);
+            convexTab1[10] = new Vector3(0.0f, 1.0f, 0.2f);
+            convexTab1[11] = new Vector3(0.2f, 1.0f, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Crab1Convex1");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            shape = scene.Factory.ShapeManager.Create("Crab1Convex1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape crab1Convex1 = scene.Factory.ShapeManager.Find("Crab1Convex1");
+
+            shape = scene.Factory.ShapeManager.Create("Crab1ConvexUp");
+            shape.Add(crab1Convex1, Matrix4.CreateScale(1.0f, 0.2f, 1.0f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(1.5f, 0.5f, 1.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Crab1ConvexUp"))
+                demo.Meshes.Add("Crab1ConvexUp", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            convexTab1[0] = new Vector3(-0.8f, -1.0f, -1.0f);
+            convexTab1[1] = new Vector3(-1.0f, -1.0f, -0.8f);
+            convexTab1[2] = new Vector3(-1.0f, -1.0f, 0.8f);
+            convexTab1[3] = new Vector3(-0.8f, -1.0f, 1.0f);
+            convexTab1[4] = new Vector3(0.8f, -1.0f, 1.0f);
+            convexTab1[5] = new Vector3(1.0f, -1.0f, 0.8f);
+            convexTab1[6] = new Vector3(1.0f, -1.0f, -0.8f);
+            convexTab1[7] = new Vector3(0.8f, -1.0f, -1.0f);
+            convexTab1[8] = new Vector3(-1.0f, 1.0f, -0.2f);
+            convexTab1[9] = new Vector3(-1.0f, 1.0f, 0.2f);
+            convexTab1[10] = new Vector3(0.2f, 1.0f, 0.2f);
+            convexTab1[11] = new Vector3(0.2f, 1.0f, -0.2f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Crab1Convex2");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            shape = scene.Factory.ShapeManager.Create("Crab1Convex2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            Shape crab1Convex2 = scene.Factory.ShapeManager.Find("Crab1Convex2");
+
+            shape = scene.Factory.ShapeManager.Create("Crab1ConvexDown");
+            shape.Add(crab1Convex2, Matrix4.CreateScale(1.0f, 0.2f, 1.0f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(1.5f, 0.5f, 1.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Crab1ConvexDown"))
+                demo.Meshes.Add("Crab1ConvexDown", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            convexTab1[0] = new Vector3(-4.0f, -6.0f, 1.0f);
+            convexTab1[1] = new Vector3(0.0f, -4.0f, 0.5f);
+            convexTab1[2] = new Vector3(1.0f, -1.0f, 0.2f);
+            convexTab1[3] = new Vector3(1.0f, -1.0f, -0.2f);
+            convexTab1[4] = new Vector3(0.0f, -4.0f, -0.5f);
+            convexTab1[5] = new Vector3(-4.0f, -6.0f, -1.0f);
+            convexTab1[6] = new Vector3(-4.0f, 6.0f, 1.0f);
+            convexTab1[7] = new Vector3(0.0f, 4.0f, 0.5f);
+            convexTab1[8] = new Vector3(1.0f, 1.0f, 0.2f);
+            convexTab1[9] = new Vector3(1.0f, 1.0f, -0.2f);
+            convexTab1[10] = new Vector3(0.0f, 4.0f, -0.5f);
+            convexTab1[11] = new Vector3(-4.0f, 6.0f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Crab1Convex3");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            shape = scene.Factory.ShapeManager.Create("Crab1Convex3");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            Shape crab1Convex3 = scene.Factory.ShapeManager.Find("Crab1Convex3");
+
+            shape = scene.Factory.ShapeManager.Create("Crab1ConvexTop");
+            shape.Add(crab1Convex3, Matrix4.CreateScale(1.0f, 0.2f, 1.0f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(1.5f, 0.5f, 1.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Crab1ConvexTop"))
+                demo.Meshes.Add("Crab1ConvexTop", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape crab1ConvexUp = scene.Factory.ShapeManager.Find("Crab1ConvexUp");
+            Shape crab1ConvexDown = scene.Factory.ShapeManager.Find("Crab1ConvexDown");
+            Shape crab1ConvexTop = scene.Factory.ShapeManager.Find("Crab1ConvexTop");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Crab 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Crab 1 Shell" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+            objectA.FluidPressureFactor = 0.4f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Front Shell" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = crab1ConvexTop;
+            objectBase.UserDataStr = "Crab1ConvexTop";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(2.5f, -0.3f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.4f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.FluidPressureFactor = 0.4f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "RollSlide";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Upper Shell" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = crab1ConvexUp;
+            objectBase.UserDataStr = "Crab1ConvexUp";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 0.0f, 0.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.FluidPressureFactor = 0.4f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "RollSlide";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Lower Shell" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = crab1ConvexDown;
+            objectBase.UserDataStr = "Crab1ConvexDown";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.2f, -0.7f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.9f, 1.0f, 0.6f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.FluidPressureFactor = 0.4f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "RollSlide";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Eye" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(2.6f, 0.0f, -0.8f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)));
+            objectBase.Integral.InertiaScaleFactor = 3.0f;
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.MinResponseLinearVelocity = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Eye" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(2.6f, 0.0f, 0.8f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            objectBase.Integral.InertiaScaleFactor = 3.0f;
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.MinResponseLinearVelocity = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Front 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, -1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Front 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, -3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Front 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, -4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Front 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, -1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Front 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, -3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Front 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, -4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Back 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, -1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Back 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, -3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Middle Back 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, -4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Back 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, -1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Back 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, -3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Right Limb Back 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, -4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Front 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, 1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Front 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, 3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Front 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, -1.2f, 4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Front 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, 1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Front 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, 3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Front 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.2f, 4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Back 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, 1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Back 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, 3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Middle Back 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, -1.2f, 4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Back 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, 1.5f);
+            objectBase.InitLocalTransform.SetScale(0.25f, 0.8f, 0.2f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Back 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, 3.1f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.8f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Crab 1 Left Limb Back 3" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-1.2f, -1.2f, 4.3f);
+            objectBase.InitLocalTransform.SetScale(0.15f, 0.4f, 0.1f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinFirstImpactForce = 5.0f;
+            objectBase.Sound.MinNextImpactForce = 100000.0f;
+            objectBase.Sound.RollVolume = 0.05f;
+            objectBase.Sound.SlideVolume = 0.05f;
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Eye 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Eye" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Front Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(orientation1 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.SetInitWorldOrientation2(orientation2 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Eye 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Eye" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Upper Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(orientation1 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.SetInitWorldOrientation2(orientation2 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Eye 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Eye" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Front Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(orientation1 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.SetInitWorldOrientation2(orientation2 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Eye 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Eye" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Upper Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(orientation1 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.SetInitWorldOrientation2(orientation2 * Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Front 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Front 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 90.0f;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 30.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.ControlDegAngleY = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Front 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Front 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Front 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 50.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Front 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Front 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Front 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 50.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Front 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Front 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 30.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Front 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Front 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Front 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Front 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Front 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Front 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Back 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Back 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 30.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Back 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Back 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Back 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Middle Back 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Back 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Middle Back 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Back 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Back 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 30.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Back 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Back 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Back 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Right Limb Back 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Back 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Right Limb Back 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 150.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = 20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Front 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Front 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -90.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -30.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.ControlDegAngleY = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Front 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Front 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Front 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -50.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Front 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Front 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Front 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -50.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Front 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Front 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -30.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Front 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Front 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Front 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Front 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Front 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Front 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Back 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Back 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -30.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Back 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Back 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Back 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Middle Back 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Back 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Middle Back 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Back 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Back 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Lower Shell" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -50.0f;
+            constraint.MaxLimitDegAngleY = 50.0f;
+            constraint.MinLimitDegAngleX = -30.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -10.0f;
+            constraint.ControlDegAngleY = 0.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Back 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Back 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Back 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.8f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Crab 1 Left Limb Back 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Back 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Crab 1 Left Limb Back 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -150.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableControlAngleX = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableControlAngleZ = true;
+            constraint.ControlDegAngleX = -20.0f;
+            constraint.LimitAngleForce = 1.5f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Cursor.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Cursor.cs
new file mode 100644
index 0000000..08622fa
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Cursor.cs
@@ -0,0 +1,75 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Cursor
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public Cursor(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape coneY = scene.Factory.ShapeManager.Find("ConeY");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Cursor");
+            objectRoot.InitLocalTransform.SetPosition(0.0f, -0.036f, 0.0f);
+            objectRoot.InitLocalTransform.SetRotation(Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(45.0f)));
+            objectRoot.InitLocalTransform.SetScale(0.018f, 0.036f, 0.009f);
+            objectRoot.EnableCollisions = false;
+            objectRoot.DrawPriority = 5;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cursor A");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = coneY;
+            objectBase.UserDataStr = "ConeY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 0.0f);
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.DrawPriority = 7;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cursor B");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 0.0f);
+            objectBase.InitLocalTransform.SetPosition(0.0f, -1.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.3f, 0.7f, 0.3f);
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.DrawPriority = 6;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/DefaultShapes.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/DefaultShapes.cs
new file mode 100644
index 0000000..070c36a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/DefaultShapes.cs
@@ -0,0 +1,384 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class DefaultShapes
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public DefaultShapes(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = null;
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("TorusMesh1");
+            triangleMesh.CreateTorusY(10, 15, 3.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("TorusMesh1"))
+                demo.Meshes.Add("TorusMesh1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            scene.Factory.CreatePhysicsObjectsFromConcave("ConcaveTorus1", triangleMesh);
+            scene.Factory.CreatePhysicsObjectsFromConcave("ConcaveTorus2", triangleMesh);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("ConvexTorus1");
+            shapePrimitive.CreateConvexHull(triangleMesh);
+
+            shape = scene.Factory.ShapeManager.Create("ConvexTorus1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("UserMesh1");
+
+            TriangleMeshRegion r01 = triangleMesh.TriangleMeshRegionManager.Create("r01");
+
+            Vertex v1 = r01.VertexManager.Create("v1");
+            v1.SetPosition(-1.0f, -1.0f, -1.0f);
+            Vertex v2 = r01.VertexManager.Create("v2");
+            v2.SetPosition(0.0f, -1.0f, 1.0f);
+            Vertex v3 = r01.VertexManager.Create("v3");
+            v3.SetPosition(1.0f, -1.0f, -1.0f);
+            Vertex v4 = r01.VertexManager.Create("v4");
+            v4.SetPosition(0.0f, 1.0f, 0.0f);
+
+            Triangle t01 = r01.TriangleManager.Create("t01");
+            t01.Index1 = 0;
+            t01.Index2 = 1;
+            t01.Index3 = 3;
+            Triangle t02 = r01.TriangleManager.Create("t02");
+            t02.Index1 = 0;
+            t02.Index2 = 3;
+            t02.Index3 = 2;
+            Triangle t03 = r01.TriangleManager.Create("t03");
+            t03.Index1 = 2;
+            t03.Index2 = 3;
+            t03.Index3 = 1;
+            Triangle t04 = r01.TriangleManager.Create("t04");
+            t04.Index1 = 0;
+            t04.Index2 = 2;
+            t04.Index3 = 1;
+
+            triangleMesh.Update(true, true);
+
+            if (!demo.Meshes.ContainsKey("UserMesh1"))
+                demo.Meshes.Add("UserMesh1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, false, CullFaceMode.Back, false, false));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("UserMesh1");
+            shapePrimitive.CreateConvex(triangleMesh);
+
+            shape = scene.Factory.ShapeManager.Create("UserMesh1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Cylinder2RY");
+            shapePrimitive.CreateCylinder2RY(2.0f, 2.0f, 1.0f);
+
+            shape = scene.Factory.ShapeManager.Create("Cylinder2RY");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Cylinder2RY");
+            triangleMesh.CreateCylinder2RY(1, 15, 2.0f, 2.0f, 1.0f);
+            if (!demo.Meshes.ContainsKey("Cylinder2RY"))
+                demo.Meshes.Add("Cylinder2RY", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("TubeMesh1");
+            triangleMesh.CreateTubeY(1, 15, 2.0f, 1.0f, 0.5f, 1.0f, 0.5f);
+            if (!demo.Meshes.ContainsKey("TubeMesh1"))
+                demo.Meshes.Add("TubeMesh1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create()
+        {
+            Shape point = scene.Factory.ShapeManager.Find("Point");
+            Shape edge = scene.Factory.ShapeManager.Find("Edge");
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape hemisphereZ = scene.Factory.ShapeManager.Find("HemisphereZ");
+            Shape coneY = scene.Factory.ShapeManager.Find("ConeY");
+            Shape capsuleY = scene.Factory.ShapeManager.Find("CapsuleY");
+            Shape triangle1 = scene.Factory.ShapeManager.Find("Triangle1");
+            Shape triangle2 = scene.Factory.ShapeManager.Find("Triangle2");
+            Shape convexTorus1 = scene.Factory.ShapeManager.Find("ConvexTorus1");
+            Shape userMesh1 = scene.Factory.ShapeManager.Find("UserMesh1");
+            Shape cylinder2RY = scene.Factory.ShapeManager.Find("Cylinder2RY");
+
+            PhysicsObject objectBase = null;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cylinder2R 1");
+            objectBase.Shape = cylinder2RY;
+            objectBase.UserDataStr = "Cylinder2RY";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitPitch = 0.5f;
+            objectBase.Sound.RollPitch = 0.5f;
+            objectBase.Sound.SlidePitch = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(10.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(1.5f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cylinder 1");
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cone 1");
+            objectBase.Shape = coneY;
+            objectBase.UserDataStr = "ConeY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-10.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Capsule 1");
+            objectBase.Shape = capsuleY;
+            objectBase.UserDataStr = "CapsuleY";
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 1500.0f;
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Sphere 1");
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-30.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cylinder 2");
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Cone 2");
+            objectBase.Shape = coneY;
+            objectBase.UserDataStr = "ConeY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-10.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 3.0f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Capsule 2");
+            objectBase.Shape = capsuleY;
+            objectBase.UserDataStr = "CapsuleY";
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Sphere 2");
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-30.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.Integral.EnableInertia = false;
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Box 1");
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-5.0f, 40.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 10.0f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Torus 1");
+            objectBase.Shape = convexTorus1;
+            objectBase.UserDataStr = "TorusMesh1";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-30.0f, 50.0f, 30.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Tube 1");
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "TubeMesh1";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 50.0f, 30.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Hemisphere 1");
+            objectBase.Shape = hemisphereZ;
+            objectBase.UserDataStr = "HemisphereZ";
+            objectBase.Material.SetSpecular(0.1f, 0.1f, 0.1f);
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-40.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Hemisphere 2");
+            objectBase.Shape = hemisphereZ;
+            objectBase.UserDataStr = "HemisphereZ";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-40.0f, 20.0f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("User TriangleMesh 1");
+            objectBase.Shape = userMesh1;
+            objectBase.UserDataStr = "UserMesh1";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-40.0f, 50.0f, 30.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.Integral.EnableInertia = false;
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Point");
+            objectBase.Shape = point;
+            objectBase.UserDataStr = "Point";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, 20.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f);
+            objectBase.Integral.SetDensity(2.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Edge");
+            objectBase.Shape = edge;
+            objectBase.UserDataStr = "Edge";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(10.0f, 20.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.0f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Triangle 1");
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "RollSlide";
+            objectBase.InitLocalTransform.SetPosition(-10.0f, 10.0f, 30.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 10.0f, 3.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(180.0f)));
+            objectBase.Integral.SetDensity(0.1f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Triangle 2");
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "RollSlide";
+            objectBase.InitLocalTransform.SetPosition(0.0f, 10.0f, 30.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 5.0f, 3.0f);
+            objectBase.Integral.SetDensity(0.1f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("ConcaveTorus1");
+            objectRoot.UserDataStr = "TorusMesh1";
+
+            int i = 1;
+            while ((objectBase = scene.Factory.PhysicsObjectManager.Find("ConcaveTorus1 " + i.ToString())) != null)
+            {
+                objectBase.Shape.CreateMesh(0.0f);
+
+                if (!demo.Meshes.ContainsKey("ConcaveTorus1 " + i.ToString()))
+                    demo.Meshes.Add("ConcaveTorus1 " + i.ToString(), new DemoMesh(demo, objectBase.Shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+                objectBase.UserDataStr = "ConcaveTorus1 " + i.ToString();
+                objectBase.Material.RigidGroup = true;
+                objectBase.CreateSound(true);
+                objectBase.Integral.SetMass(1.0f);
+
+                objectRoot.AddChildPhysicsObject(objectBase);
+
+                i++;
+            }
+
+            objectRoot.InitLocalTransform.SetScale(0.5f);
+            objectRoot.InitLocalTransform.SetPosition(18.0f, 20.0f, 10.0f);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("ConcaveTorus2");
+            objectRoot.UserDataStr = "TorusMesh1";
+
+            i = 1;
+            while ((objectBase = scene.Factory.PhysicsObjectManager.Find("ConcaveTorus2 " + i.ToString())) != null)
+            {
+                objectBase.Shape.CreateMesh(0.0f);
+
+                if (!demo.Meshes.ContainsKey("ConcaveTorus2 " + i.ToString()))
+                    demo.Meshes.Add("ConcaveTorus2 " + i.ToString(), new DemoMesh(demo, objectBase.Shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+                objectBase.UserDataStr = "ConcaveTorus2 " + i.ToString();
+                objectBase.Material.RigidGroup = true;
+                objectBase.CreateSound(true);
+                objectBase.Integral.SetMass(1.0f);
+
+                objectRoot.AddChildPhysicsObject(objectBase);
+
+                i++;
+            }
+
+            objectRoot.InitLocalTransform.SetScale(0.5f);
+            objectRoot.InitLocalTransform.SetPosition(19.0f, 20.0f, 10.0f);
+            objectRoot.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField1.cs
new file mode 100644
index 0000000..b052a87
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField1.cs
@@ -0,0 +1,74 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class ForceField1
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public ForceField1(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape userShape1 = scene.Factory.ShapeManager.Find("UserShape 1");
+            Shape userShape2 = scene.Factory.ShapeManager.Find("UserShape 2");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("ForceField 1");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("ForceField 1 Shape");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = userShape1;
+            objectBase.UserDataStr = "UserShape1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 70.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(100.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("ForceField 1 Field");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.UserDataStr = "Blue";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 70.0f);
+            objectBase.InitLocalTransform.SetScale(10.0f, 10.0f, 10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField2.cs
new file mode 100644
index 0000000..ab55b26
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/ForceField2.cs
@@ -0,0 +1,75 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class ForceField2
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public ForceField2(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape userShape1 = scene.Factory.ShapeManager.Find("UserShape 1");
+            Shape userShape2 = scene.Factory.ShapeManager.Find("UserShape 2");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("ForceField 2");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("ForceField 2 Shape");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = userShape2;
+            objectBase.UserDataStr = "UserShape2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(20.0f, 20.0f, 70.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(100.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 400000.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("ForceField 2 Field");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Blue";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(20.0f, 20.0f, 70.0f);
+            objectBase.InitLocalTransform.SetScale(10.0f, 10.0f, 10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Helicopter1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Helicopter1.cs
new file mode 100644
index 0000000..ab84ea4
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Helicopter1.cs
@@ -0,0 +1,1986 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Helicopter1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Helicopter1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = null;
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            Vector3 point1, point2, point3;
+            point1 = new Vector3(1.0f, -1.0f, 0.0f);
+            point2 = new Vector3(-1.0f, -1.0f, 0.0f);
+            point3 = new Vector3(-1.0f, 1.0f, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1DoorTriangle1");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1DoorTriangle1"))
+                demo.Meshes.Add("Helicopter1DoorTriangle1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1DoorTriangle1");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1DoorTriangle1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            point1 = new Vector3(-1.0f, 1.0f, 0.0f);
+            point2 = new Vector3(1.0f, 1.0f, 0.0f);
+            point3 = new Vector3(1.0f, -1.0f, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1DoorTriangle2");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1DoorTriangle2"))
+                demo.Meshes.Add("Helicopter1DoorTriangle2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1DoorTriangle2");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1DoorTriangle2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            Vector3[] convexTab1 = new Vector3[12];
+            convexTab1[0] = new Vector3(-1.1f, 1.0f, -1.0f);
+            convexTab1[1] = new Vector3(-1.1f, 1.0f, 1.0f);
+            convexTab1[2] = new Vector3(-0.3f, 1.0f, 1.0f);
+            convexTab1[3] = new Vector3(0.7f, 0.5f, 0.5f);
+            convexTab1[4] = new Vector3(0.7f, 0.5f, -0.5f);
+            convexTab1[5] = new Vector3(-0.3f, 1.0f, -1.0f);
+            convexTab1[6] = new Vector3(-1.0f, -1.0f, -1.0f);
+            convexTab1[7] = new Vector3(-1.0f, -1.0f, 1.0f);
+            convexTab1[8] = new Vector3(0.0f, -1.0f, 1.0f);
+            convexTab1[9] = new Vector3(1.0f, -1.0f, 0.5f);
+            convexTab1[10] = new Vector3(1.0f, -1.0f, -0.5f);
+            convexTab1[11] = new Vector3(0.0f, -1.0f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1ConvexUp");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1ConvexUp");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1ConvexUp"))
+                demo.Meshes.Add("Helicopter1ConvexUp", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+
+            Vector3[] convexTab2 = new Vector3[8];
+            convexTab2[0] = new Vector3(-1.0f, 1.0f, -1.0f);
+            convexTab2[1] = new Vector3(-1.0f, 1.0f, 1.0f);
+            convexTab2[2] = new Vector3(1.0f, 0.5f, 0.5f);
+            convexTab2[3] = new Vector3(1.0f, 0.5f, -0.5f);
+            convexTab2[4] = new Vector3(-1.1f, -1.0f, -1.0f);
+            convexTab2[5] = new Vector3(-1.1f, -1.0f, 1.0f);
+            convexTab2[6] = new Vector3(1.0f, -1.0f, 0.5f);
+            convexTab2[7] = new Vector3(1.0f, -1.0f, -0.5f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1ConvexDown");
+            shapePrimitive.CreateConvex(convexTab2);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1ConvexDown");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1ConvexDown"))
+                demo.Meshes.Add("Helicopter1ConvexDown", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+
+            convexTab2[0] = new Vector3(-0.82f, -1.0f, 1.0f);
+            convexTab2[1] = new Vector3(-0.82f, 1.0f, 1.0f);
+            convexTab2[2] = new Vector3(0.76f, 1.0f, 1.0f);
+            convexTab2[3] = new Vector3(0.76f, -0.74f, 1.0f);
+            convexTab2[4] = new Vector3(-1.0f, -1.0f, -1.0f);
+            convexTab2[5] = new Vector3(-1.0f, 1.0f, -1.0f);
+            convexTab2[6] = new Vector3(1.0f, 1.0f, -1.0f);
+            convexTab2[7] = new Vector3(1.0f, -0.74f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1ConvexRight");
+            shapePrimitive.CreateConvex(convexTab2);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1ConvexRight");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1ConvexRight"))
+                demo.Meshes.Add("Helicopter1ConvexRight", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+
+            convexTab2[0] = new Vector3(-1.0f, -1.0f, 1.0f);
+            convexTab2[1] = new Vector3(-1.0f, 1.0f, 1.0f);
+            convexTab2[2] = new Vector3(1.0f, 1.0f, 1.0f);
+            convexTab2[3] = new Vector3(1.0f, -0.74f, 1.0f);
+            convexTab2[4] = new Vector3(-0.82f, -1.0f, -1.0f);
+            convexTab2[5] = new Vector3(-0.82f, 1.0f, -1.0f);
+            convexTab2[6] = new Vector3(0.76f, 1.0f, -1.0f);
+            convexTab2[7] = new Vector3(0.76f, -0.74f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1ConvexLeft");
+            shapePrimitive.CreateConvex(convexTab2);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1ConvexLeft");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1ConvexLeft"))
+                demo.Meshes.Add("Helicopter1ConvexLeft", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+
+            convexTab2[0] = new Vector3(-1.0f, 0.5f, -1.5f);
+            convexTab2[1] = new Vector3(-1.0f, 0.5f, 1.5f);
+            convexTab2[2] = new Vector3(1.0f, 1.0f, 1.0f);
+            convexTab2[3] = new Vector3(1.0f, 1.0f, -1.0f);
+            convexTab2[4] = new Vector3(-1.0f, -1.2f, -1.5f);
+            convexTab2[5] = new Vector3(-1.0f, -1.2f, 1.5f);
+            convexTab2[6] = new Vector3(1.0f, -1.0f, 1.0f);
+            convexTab2[7] = new Vector3(1.0f, -1.0f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1ConvexFront");
+            shapePrimitive.CreateConvex(convexTab2);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1ConvexFront");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1ConvexFront"))
+                demo.Meshes.Add("Helicopter1ConvexFront", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, false, CullFaceMode.Back, false, false));
+
+            point1 = new Vector3(-0.8f, -2.5f, -7.0f);
+            point2 = new Vector3(-0.8f, 1.0f, -7.0f);
+            point3 = new Vector3(0.6f, 0.25f, -5.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1CabinTriangle1");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1CabinTriangle1"))
+                demo.Meshes.Add("Helicopter1CabinTriangle1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1CabinTriangle1");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1CabinTriangle1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            point1 = new Vector3(0.6f, 0.25f, -5.0f);
+            point2 = new Vector3(0.8f, -3.2f, -15.0f);
+            point3 = new Vector3(-0.8f, -2.5f, -7.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1CabinTriangle2");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1CabinTriangle2"))
+                demo.Meshes.Add("Helicopter1CabinTriangle2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1CabinTriangle2");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1CabinTriangle2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            point1 = new Vector3(-0.8f, -2.5f, 7.0f);
+            point2 = new Vector3(-0.8f, 1.0f, 7.0f);
+            point3 = new Vector3(0.6f, 0.25f, 5.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1CabinTriangle3");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1CabinTriangle3"))
+                demo.Meshes.Add("Helicopter1CabinTriangle3", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1CabinTriangle3");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1CabinTriangle3");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            point1 = new Vector3(0.6f, 0.25f, 5.0f);
+            point2 = new Vector3(0.8f, -3.2f, 15.0f);
+            point3 = new Vector3(-0.8f, -2.5f, 7.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("Helicopter1CabinTriangle4");
+            triangleMesh.CreateTriangle(point1, point2, point3);
+            if (!demo.Meshes.ContainsKey("Helicopter1CabinTriangle4"))
+                demo.Meshes.Add("Helicopter1CabinTriangle4", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, false, false, true, false, true, CullFaceMode.FrontAndBack, false, true));
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Helicopter1CabinTriangle4");
+            shapePrimitive.CreateTriangle(point1, point2, point3);
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1CabinTriangle4");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.01f);
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            shape = scene.Factory.ShapeManager.Create("Helicopter1Wheel");
+            shape.Add(cylinderY, Matrix4.CreateScale(0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Helicopter1Wheel"))
+                demo.Meshes.Add("Helicopter1Wheel", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape capsuleY = scene.Factory.ShapeManager.Find("CapsuleY");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape triangle1 = scene.Factory.ShapeManager.Find("Triangle1");
+            Shape triangle2 = scene.Factory.ShapeManager.Find("Triangle2");
+            Shape doorTriangle1 = scene.Factory.ShapeManager.Find("Helicopter1DoorTriangle1");
+            Shape doorTriangle2 = scene.Factory.ShapeManager.Find("Helicopter1DoorTriangle2");
+            Shape convexUp = scene.Factory.ShapeManager.Find("Helicopter1ConvexUp");
+            Shape convexDown = scene.Factory.ShapeManager.Find("Helicopter1ConvexDown");
+            Shape convexRight = scene.Factory.ShapeManager.Find("Helicopter1ConvexRight");
+            Shape convexLeft = scene.Factory.ShapeManager.Find("Helicopter1ConvexLeft");
+            Shape convexFront = scene.Factory.ShapeManager.Find("Helicopter1ConvexFront");
+            Shape cabinTriangle1 = scene.Factory.ShapeManager.Find("Helicopter1CabinTriangle1");
+            Shape cabinTriangle2 = scene.Factory.ShapeManager.Find("Helicopter1CabinTriangle2");
+            Shape cabinTriangle3 = scene.Factory.ShapeManager.Find("Helicopter1CabinTriangle3");
+            Shape cabinTriangle4 = scene.Factory.ShapeManager.Find("Helicopter1CabinTriangle4");
+            Shape wheel = scene.Factory.ShapeManager.Find("Helicopter1Wheel");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+            PhysicsObject objectC = null;
+            PhysicsObject objectD = null;
+            PhysicsObject objectE = null;
+            PhysicsObject objectF = null;
+            PhysicsObject objectG = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Helicopter 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Body" + instanceIndexName);
+            objectA.EnableFeedback = true;
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin" + instanceIndexName);
+            objectB.Material.RigidGroup = true;
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Up 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(2.85f, 13.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(2.75f, 0.5f, 4.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Up 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convexUp;
+            objectBase.UserDataStr = "Helicopter1ConvexUp";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(7.14f, 13.01f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(10.0f)));
+            objectBase.InitLocalTransform.SetScale(1.72f, 0.3f, 4.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Down 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(4.4f, 5.2f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(3.9f, 0.2f, 4.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Down 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convexDown;
+            objectBase.UserDataStr = "Helicopter1ConvexDown";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.5f, 5.4f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-12.0f)));
+            objectBase.InitLocalTransform.SetScale(1.2f, 0.2f, 4.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Right 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convexRight;
+            objectBase.UserDataStr = "Helicopter1ConvexRight";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.55f, 7.1f, -3.08f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(41.0f)));
+            objectBase.InitLocalTransform.SetScale(1.85f, 2.0f, 0.165f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Right 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(1.8f, 9.0f, -4.2f);
+            objectBase.InitLocalTransform.SetScale(1.7f, 4.0f, 0.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Left 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convexLeft;
+            objectBase.UserDataStr = "Helicopter1ConvexLeft";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.55f, 7.1f, 3.08f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-41.0f)));
+            objectBase.InitLocalTransform.SetScale(1.85f, 2.0f, 0.165f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Left 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(1.8f, 9.0f, 4.2f);
+            objectBase.InitLocalTransform.SetScale(1.7f, 4.0f, 0.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(10.9f, 7.22f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.75f, 2.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.7f, 10.7f, 1.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-31.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.26f, 0.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front 3" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.7f, 10.7f, -1.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-31.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.26f, 0.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Pane" + instanceIndexName);
+            objectC.Material.RigidGroup = true;
+            objectB.AddChildPhysicsObject(objectC);
+            objectC.InitLocalTransform.SetPosition(9.8f, 10.7f, 0.0f);
+            objectC.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-31.0f)));
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Pane 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(-1.8f, 0.0f, 0.0f) + new Vector3(-1.8f, 2.26f, 0.0f) + new Vector3(1.8f, 2.26f, 0.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.13f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Pane 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(1.8f, 2.26f, 0.0f) + new Vector3(1.8f, 0.0f, 0.0f) + new Vector3(-1.8f, 0.0f, 0.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.13f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Pane 3" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(-1.8f, -2.26f, 0.0f) + new Vector3(-1.8f, 0.0f, 0.0f) + new Vector3(1.8f, 0.0f, 0.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.13f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Pane 4" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(1.8f, 0.0f, 0.0f) + new Vector3(1.8f, -2.26f, 0.0f) + new Vector3(-1.8f, -2.26f, 0.0f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.13f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front Right" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(7.6f, 10.9f, -3.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.2f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Right Pane" + instanceIndexName);
+            objectC.Material.RigidGroup = true;
+            objectB.AddChildPhysicsObject(objectC);
+            objectC.InitLocalTransform.SetPosition(8.1f, 11.9f, -2.6f);
+            objectC.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(50.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Right Pane 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cabinTriangle1;
+            objectBase.UserDataStr = "Helicopter1CabinTriangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(-0.8f * 1.8f, -2.5f * 1.15f, -7.0f * 0.05f) + new Vector3(-0.8f * 1.8f, 1.0f * 1.15f, -7.0f * 0.05f) + new Vector3(0.6f * 1.8f, 0.25f * 1.15f, -5.0f * 0.05f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.15f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Right Pane 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cabinTriangle2;
+            objectBase.UserDataStr = "Helicopter1CabinTriangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.6f * 1.8f, 0.25f * 1.15f, -5.0f * 0.05f) + new Vector3(0.8f * 1.8f, -3.2f * 1.15f, -15.0f * 0.05f) + new Vector3(-0.8f * 1.8f, -2.5f * 1.15f, -7.0f * 0.05f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.15f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front Left" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(7.6f, 10.9f, 3.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.2f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Left Pane" + instanceIndexName);
+            objectC.Material.RigidGroup = true;
+            objectB.AddChildPhysicsObject(objectC);
+            objectC.InitLocalTransform.SetPosition(8.1f, 11.9f, 2.6f);
+            objectC.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-50.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Left Pane 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cabinTriangle3;
+            objectBase.UserDataStr = "Helicopter1CabinTriangle3";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(-0.8f * 1.8f, -2.5f * 1.15f, 7.0f * 0.05f) + new Vector3(-0.8f * 1.8f, 1.0f * 1.15f, 7.0f * 0.05f) + new Vector3(0.6f * 1.8f, 0.25f * 1.15f, 5.0f * 0.05f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.15f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Left Pane 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cabinTriangle4;
+            objectBase.UserDataStr = "Helicopter1CabinTriangle4";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(0.6f * 1.8f, 0.25f * 1.15f, 5.0f * 0.05f) + new Vector3(0.8f * 1.8f, -3.2f * 1.15f, 15.0f * 0.05f) + new Vector3(-0.8f * 1.8f, -2.5f * 1.15f, 7.0f * 0.05f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.8f, 1.15f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front Panel 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(10.6f, 7.37f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 1.6f, 2.0f);
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.Integral.SetDensity(2.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Front Panel 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convexFront;
+            objectBase.UserDataStr = "Helicopter1ConvexFront";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.9f, 7.16f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.6f, 2.0f);
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.Integral.SetDensity(2.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Button" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Button 1" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(8.95f, 7.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.05f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Button 2" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.2f, 7.5f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.1f);
+            objectBase.Integral.InertiaScaleFactor = 3.0f;
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Front Button Switch" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(8.8f, 7.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.3f, 0.3f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Body Back" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(0.3f, 9.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 4.0f, 4.0f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Lamp" + instanceIndexName);
+            objectC.Material.RigidGroup = true;
+            objectB.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Lamp Base" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.0f, 12.9f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.1f, 0.4f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Cabin Lamp Light" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.0f, 12.9f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(10.0f);
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Point;
+            objectBase.Light.SetDiffuse(1.0f, 0.9f, 0.8f);
+            objectBase.Light.Range = 10.0f;
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Up" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.2f, 12.9f, -4.2f);
+            objectBase.InitLocalTransform.SetScale(1.7f, 0.3f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Down" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.9f, 7.0f, -4.2f);
+            objectBase.InitLocalTransform.SetScale(2.4f, 2.0f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Left" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(3.7f, 10.8f, -4.2f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.8f, 0.15f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Right" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(7.4f, 10.9f, -4.2f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.1f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Switch" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(4.2f, 8.0f, -4.5f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.2f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane" + instanceIndexName);
+            objectD.Material.RigidGroup = true;
+            objectC.AddChildPhysicsObject(objectD);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 1" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.2f - 1.4f, 10.8f, -4.2f) + new Vector3(5.2f - 1.4f, 10.8f + 1.8f, -4.2f) + new Vector3(5.2f + 1.4f, 10.8f + 1.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 2" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.2f + 1.4f, 10.8f + 1.8f, -4.2f) + new Vector3(5.2f + 1.4f, 10.8f, -4.2f) + new Vector3(5.2f - 1.4f, 10.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 3" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.55f - 1.75f, 10.8f - 1.8f, -4.2f) + new Vector3(5.55f - 1.75f, 10.8f, -4.2f) + new Vector3(5.55f + 1.75f, 10.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.75f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 4" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.55f + 1.75f, 10.8f, -4.2f) + new Vector3(5.55f + 1.75f, 10.8f - 1.8f, -4.2f) + new Vector3(5.55f - 1.75f, 10.8f - 1.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.75f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 5" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = doorTriangle1;
+            objectBase.UserDataStr = "Helicopter1DoorTriangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(7.0f + 0.4f, 10.8f, -4.2f) + new Vector3(7.0f - 0.4f, 10.8f, -4.2f) + new Vector3(7.0f - 0.4f, 10.8f + 1.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Door Pane 6" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = doorTriangle1;
+            objectBase.UserDataStr = "Helicopter1DoorTriangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(7.7f + 0.4f, 10.8f - 1.8f, -4.2f) + new Vector3(7.7f - 0.4f, 10.8f - 1.8f, -4.2f) + new Vector3(7.7f - 0.4f, 10.8f, -4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectC = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectC);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Up" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.2f, 12.9f, 4.2f);
+            objectBase.InitLocalTransform.SetScale(1.7f, 0.3f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Down" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(5.9f, 7.0f, 4.2f);
+            objectBase.InitLocalTransform.SetScale(2.4f, 2.0f, 0.2f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Left" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(3.7f, 10.8f, 4.2f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.8f, 0.15f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Right" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(7.4f, 10.9f, 4.2f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.1f, 0.15f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-20.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Switch" + instanceIndexName);
+            objectC.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(4.2f, 8.0f, 4.5f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.2f, 0.1f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane" + instanceIndexName);
+            objectD.Material.RigidGroup = true;
+            objectC.AddChildPhysicsObject(objectD);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 1" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.2f - 1.4f, 10.8f, 4.2f) + new Vector3(5.2f - 1.4f, 10.8f + 1.8f, 4.2f) + new Vector3(5.2f + 1.4f, 10.8f + 1.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 2" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.2f + 1.4f, 10.8f + 1.8f, 4.2f) + new Vector3(5.2f + 1.4f, 10.8f, 4.2f) + new Vector3(5.2f - 1.4f, 10.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 3" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle1;
+            objectBase.UserDataStr = "Triangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.55f - 1.75f, 10.8f - 1.8f, 4.2f) + new Vector3(5.55f - 1.75f, 10.8f, 4.2f) + new Vector3(5.55f + 1.75f, 10.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.75f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 4" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = triangle2;
+            objectBase.UserDataStr = "Triangle2";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(5.55f + 1.75f, 10.8f, 4.2f) + new Vector3(5.55f + 1.75f, 10.8f - 1.8f, 4.2f) + new Vector3(5.55f - 1.75f, 10.8f - 1.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(1.75f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 5" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = doorTriangle1;
+            objectBase.UserDataStr = "Helicopter1DoorTriangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(7.0f + 0.4f, 10.8f, 4.2f) + new Vector3(7.0f - 0.4f, 10.8f, 4.2f) + new Vector3(7.0f - 0.4f, 10.8f + 1.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Door Pane 6" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = doorTriangle1;
+            objectBase.UserDataStr = "Helicopter1DoorTriangle1";
+            objectBase.Material.UserDataStr = "Green";
+            objectBase.Material.TransparencyFactor = 0.2f;
+            objectBase.Material.TransparencyRigidGroupSorting = true;
+            objectBase.Material.TransparencySecondPass = false;
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 50.0f;
+            objectBase.InitLocalTransform.SetPosition((new Vector3(7.7f + 0.4f, 10.8f - 1.8f, 4.2f) + new Vector3(7.7f - 0.4f, 10.8f - 1.8f, 4.2f) + new Vector3(7.7f - 0.4f, 10.8f, 4.2f)) / 3.0f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.9f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = "Glass";
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Axle 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(9.0f, 4.2f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.2f, 1.0f, 0.1f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Right Absorber" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Right Absorber 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 6.5f, -4.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-30.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.2f, 0.5f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Right Absorber 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 8.0f, -4.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.8f, 0.6f, 0.8f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Left Absorber" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Left Absorber 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 6.5f, 4.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(30.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.2f, 0.5f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Left Absorber 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 8.0f, 4.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.8f, 0.6f, 0.8f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Absorber" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Absorber Axle 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 3.8f, -6.5f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Absorber Axle 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.55f, 4.6f, -3.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(22.0f)));
+            objectBase.InitLocalTransform.SetScale(0.3f, 0.1f, 2.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Absorber 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 5.2f, -5.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-30.0f)));
+            objectBase.InitLocalTransform.SetScale(0.3f, 1.5f, 0.3f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Right Absorber 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 5.5f, -1.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.6f, 0.5f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Absorber" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Absorber Axle 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 3.8f, 6.5f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Absorber Axle 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.55f, 4.6f, 3.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-22.0f)));
+            objectBase.InitLocalTransform.SetScale(0.3f, 0.1f, 2.2f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Absorber 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 5.2f, 5.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(30.0f)));
+            objectBase.InitLocalTransform.SetScale(0.3f, 1.5f, 0.3f);
+            objectBase.Integral.SetDensity(5.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Left Absorber 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 5.5f, 1.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.6f, 0.5f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Wheel 1" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = wheel;
+            objectBase.UserDataStr = "Helicopter1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(9.0f, 3.7f, 0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.9f, 0.3f, 0.9f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.MinResponseLinearVelocity = 0.05f;
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 14000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Wheel 2" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = wheel;
+            objectBase.UserDataStr = "Helicopter1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(9.0f, 3.7f, -0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.9f, 0.3f, 0.9f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.MinResponseLinearVelocity = 0.05f;
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 14000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Wheel 3" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = wheel;
+            objectBase.UserDataStr = "Helicopter1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 3.8f, -7.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 1.0f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.MinResponseLinearVelocity = 0.05f;
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 14000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Wheel 4" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = wheel;
+            objectBase.UserDataStr = "Helicopter1Wheel";
+            objectBase.Material.UserDataStr = "Rubber";
+            objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+            objectBase.InitLocalTransform.SetPosition(-0.5f, 3.8f, 7.8f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 1.0f);
+            objectBase.Integral.SetDensity(40.0f);
+            objectBase.MinResponseLinearVelocity = 0.05f;
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 14000.0f;
+            objectBase.Sound.MinSlideVelocityMagnitude = 1.0f;
+
+            objectD = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail" + instanceIndexName);
+            objectD.Material.RigidGroup = true;
+            objectA.AddChildPhysicsObject(objectD);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 1" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-1.0f, 14.0f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(3.0f, 1.1f, 2.0f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 2" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-3.0f, 14.5f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(2.0f, 1.0f, 1.0f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 3" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-6.0f, 15.2f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 0.7f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 4" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 2000.0f;
+            objectBase.InitLocalTransform.SetPosition(-14.0f, 15.4f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.6f, 6.0f, 0.4f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 5" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-22.5f, 16.4f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-70.0f)));
+            objectBase.InitLocalTransform.SetScale(0.6f, 3.0f, 0.3f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Tail 6" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(-24.0f, 17.0f, -0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 0.2f, 0.2f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Stabilizer Right" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.InitLocalTransform.SetPosition(-18.0f, 15.4f, -1.2f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.1f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Stabilizer Left" + instanceIndexName);
+            objectD.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.InitLocalTransform.SetPosition(-18.0f, 15.4f, 1.2f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.1f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectE = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Body" + instanceIndexName);
+            objectE.Material.RigidGroup = true;
+            objectA.AddChildPhysicsObject(objectE);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Body 1" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(1.0f, 16.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.5f, 1.0f, 1.5f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Body 2" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(1.0f, 17.2f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.2f, 1.0f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Body 3" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(2.0f, 15.0f, -1.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.5f, 2.5f, 1.5f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Body 4" + instanceIndexName);
+            objectE.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 800.0f;
+            objectBase.InitLocalTransform.SetPosition(2.0f, 15.0f, 1.5f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(1.5f, 2.5f, 1.5f);
+            objectBase.Integral.SetDensity(3.0f);
+            objectBase.CreateSound(true);
+
+            objectF = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Rotor" + instanceIndexName);
+            objectF.MaxPreUpdateAngularVelocity = 20.0f;
+            objectF.MaxPostUpdateAngularVelocity = 20.0f;
+            objectA.AddChildPhysicsObject(objectF);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Rotor Body" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(1.0f, 17.9f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.5f, 0.5f, 1.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Rotor Airscrew 1" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(11.0f, 17.9f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)));
+            objectBase.InitLocalTransform.SetScale(9.0f, 0.05f, 0.5f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Rotor Airscrew 2" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 17.9f, 9.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(120.0f)));
+            objectBase.InitLocalTransform.SetScale(9.0f, 0.05f, 0.5f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Up Rotor Airscrew 3" + instanceIndexName);
+            objectF.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 17.9f, -9.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(240.0f)));
+            objectBase.InitLocalTransform.SetScale(9.0f, 0.05f, 0.5f);
+            objectBase.Integral.SetDensity(0.5f);
+            objectBase.CreateSound(true);
+
+            objectG = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Back Rotor" + instanceIndexName);
+            objectG.MaxPreUpdateAngularVelocity = 20.0f;
+            objectG.MaxPostUpdateAngularVelocity = 20.0f;
+            objectA.AddChildPhysicsObject(objectG);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Back Rotor Body" + instanceIndexName);
+            objectG.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-24.0f, 17.0f, -0.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.3f, 0.5f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Back Rotor Airscrew 1" + instanceIndexName);
+            objectG.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-24.0f, 19.0f, -0.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.0f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Back Rotor Airscrew 2" + instanceIndexName);
+            objectG.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-22.0f, 16.0f, -0.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(120.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.0f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Helicopter 1 Back Rotor Airscrew 3" + instanceIndexName);
+            objectG.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.InitLocalTransform.SetPosition(-26.0f, 16.0f, -0.9f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f)) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(240.0f)));
+            objectBase.InitLocalTransform.SetScale(0.2f, 2.0f, 0.05f);
+            objectBase.Integral.SetDensity(0.1f);
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 1" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Right" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Up 2" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Right" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Front Left" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Right" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 2" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Left" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 1" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Right" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Up 2" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Right" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Front Right" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Right" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 2" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Left" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Up 1" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Up" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Up" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Down 1" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName), true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Down 2" + instanceIndexName);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName), true);
+            objectBase.DisableCollision(scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName), true);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Up Rotor Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Rotor Body" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Body 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.5f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.5f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Back Rotor Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Back Rotor Body" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Tail 6" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.2f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.2f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Right Door Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Door Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(2.4f, 0.0f, -0.2f));
+            constraint.SetAnchor2(position1 + new Vector3(2.4f, 0.0f, -0.2f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = 0.0f;
+            constraint.MaxLimitDegAngleY = 80.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Left Door Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Door Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(2.4f, 0.0f, 0.2f));
+            constraint.SetAnchor2(position1 + new Vector3(2.4f, 0.0f, 0.2f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -80.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Stabilizer Right Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Stabilizer Right" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Tail 4" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 1.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 1.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 30.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Stabilizer Left Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Stabilizer Left" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Tail 4" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -1.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -1.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 30.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Up Right Absorber 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Right Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Back" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Up Left Absorber 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Left Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Back" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Up Right Absorber 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Right Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Right 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Up Left Absorber 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Left Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Left 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Right Absorber Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Back" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = 0.0f;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Left Absorber Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Absorber 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Back" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 0.0f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Right Absorber Absorber Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Right Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, -0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, -0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Distance = 0.5f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Left Absorber Absorber Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Left Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, 0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Distance = 0.5f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Right Absorber Absorber Spring Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Right Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, -0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, -0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Force = 0.2f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Left Absorber Absorber Spring Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Up Left Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Absorber 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, 0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Force = 0.2f;
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Wheel 1 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Axle 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.3f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.3f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Wheel 2 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Axle 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.3f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.3f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Wheel 12 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 1" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.4f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Wheel 3 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 3" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Right Absorber Axle 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, -0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, -0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.AngularDamping = 0.1f;
+            constraint.MinResponseLinearVelocity = 0.05f;
+            constraint.MinResponseAngularVelocity = 0.05f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Wheel 4 Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Wheel 4" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Left Absorber Axle 1" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, 0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.AngularDamping = 0.1f;
+            constraint.MinResponseLinearVelocity = 0.05f;
+            constraint.MinResponseAngularVelocity = 0.05f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Helicopter 1 Cabin Front Button Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Front Button 2" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Helicopter 1 Cabin Body Front Panel 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.2f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.2f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDistanceX = 0.4f;
+            constraint.EnableControlDistanceX = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Jenga.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Jenga.cs
new file mode 100644
index 0000000..5a16549
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Jenga.cs
@@ -0,0 +1,89 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Jenga
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Jenga(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, string shapeName, int jengaHeight, int jengaWidth, Vector3 shapeSize, float density, bool enableSleeping)
+        {
+            Shape shape = scene.Factory.ShapeManager.Find(shapeName);
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            int instanceIndexCount = 0;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Jenga " + instanceIndexName);
+
+            for (int i = 0; i < jengaHeight; i++)
+                if (i % 2 == 0)
+                {
+                    for (int j = 0; j < jengaWidth; j++)
+                    {
+                        objectBase = scene.Factory.PhysicsObjectManager.Create("Jenga " + instanceIndexCount.ToString() + instanceIndexName);
+                        objectRoot.AddChildPhysicsObject(objectBase);
+                        objectBase.Shape = shape;
+                        objectBase.UserDataStr = shapeName;
+                        objectBase.CreateSound(true);
+                        objectBase.InitLocalTransform.SetPosition((j - 0.5f * jengaWidth + 0.5f) * shapeSize.X, i * shapeSize.Y + 0.5f * shapeSize.Y, 0.0f);
+                        objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z * jengaWidth);
+                        objectBase.Integral.SetDensity(density);
+                        objectBase.EnableSleeping = enableSleeping;
+                        instanceIndexCount++;
+                    }
+                }
+                else
+                {
+                    for (int j = 0; j < jengaWidth; j++)
+                    {
+                        objectBase = scene.Factory.PhysicsObjectManager.Create("Jenga " + instanceIndexCount.ToString() + instanceIndexName);
+                        objectRoot.AddChildPhysicsObject(objectBase);
+                        objectBase.Shape = shape;
+                        objectBase.UserDataStr = shapeName;
+                        objectBase.CreateSound(true);
+                        objectBase.InitLocalTransform.SetPosition(0.0f, i * shapeSize.Y + 0.5f * shapeSize.Y, (j - 0.5f * jengaWidth + 0.5f) * shapeSize.Z);
+                        objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X * jengaWidth, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z);
+                        objectBase.Integral.SetDensity(density);
+                        objectBase.EnableSleeping = enableSleeping;
+                        instanceIndexCount++;
+                    }
+                }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lake.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lake.cs
new file mode 100644
index 0000000..b832c02
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lake.cs
@@ -0,0 +1,146 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Lake
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        int cellCountX;
+        int cellCountZ;
+
+        int partCountX;
+        int partCountZ;
+
+        public Lake(Demo demo, int instanceIndex, int partCountX, int partCountZ)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+            this.partCountX = partCountX;
+            this.partCountZ = partCountZ;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void CreateShapes(Demo demo, PhysicsScene scene, int cellCountX, int cellCountZ, float depth, float density, float linearDamping, float angularDamping, float surfaceDamping, float surfaceVelocityFactor, float surfaceAmplitudeFactor, float minSurfaceAmplitude, float maxSurfaceAmplitude, float margin, bool dynamic)
+        {
+            string partIndexName;
+            float halfCellCountX, halfCellCountZ;
+            ShapePrimitive shapePrimitive;
+            Shape shape;
+
+            this.cellCountX = cellCountX;
+            this.cellCountZ = cellCountZ;
+
+            halfCellCountX = 0.5f * cellCountX;
+            halfCellCountZ = 0.5f * cellCountZ;
+
+            float[] positionsX = { -halfCellCountX, -halfCellCountX, halfCellCountX, halfCellCountX };
+            float[] positionsY = { -halfCellCountZ, halfCellCountZ, halfCellCountZ, -halfCellCountZ };
+
+            TriangleMesh mesh = scene.Factory.TriangleMeshManager.Create("Lake" + instanceIndexName);
+            mesh.CreateWall(Vector3.Zero, Vector3.UnitY, positionsX, positionsY);
+
+            if (!demo.Meshes.ContainsKey("Lake" + instanceIndexName))
+                demo.Meshes.Add("Lake" + instanceIndexName, new DemoMesh(demo, mesh, null, Vector2.One, true, true, false, false, true, CullFaceMode.FrontAndBack, false, false));
+
+            for (int i = 0; i < partCountX; i++)
+                for (int j = 0; j < partCountZ; j++)
+                {
+                    partIndexName = " " + i.ToString() + " " + j.ToString();
+
+                    shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Lake" + instanceIndexName + partIndexName);
+                    shapePrimitive.CreateFluid(cellCountX, cellCountZ, depth, density, linearDamping, angularDamping, surfaceDamping, surfaceVelocityFactor, surfaceAmplitudeFactor, minSurfaceAmplitude, maxSurfaceAmplitude, dynamic);
+
+                    shape = scene.Factory.ShapeManager.Create("Lake" + instanceIndexName + partIndexName);
+                    shape.Set(shapePrimitive, Matrix4.Identity, margin);
+                    shape.CreateMesh(0.0f);
+
+                    if (!demo.Meshes.ContainsKey("Lake" + instanceIndexName + partIndexName))
+                        demo.Meshes.Add("Lake" + instanceIndexName + partIndexName, new DemoMesh(demo, shape, null, Vector2.One, true, true, false, false, true, CullFaceMode.FrontAndBack, dynamic, false));
+                }
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, float density)
+        {
+            string partIndexName;
+            float totalHalfScaleX, totalHalfScaleZ;
+            Vector3 minPosition, position, axisX, axisZ, deltaX, deltaZ;
+            Matrix4 rotation;
+            Shape shape;
+            PhysicsObject objectRoot;
+            minPosition = objectPosition;
+            rotation = Matrix4.Transpose(Matrix4.CreateFromQuaternion(objectOrientation));
+
+            axisX.X = rotation.Row0.X;
+            axisX.Y = rotation.Row0.Y;
+            axisX.Z = rotation.Row0.Z;
+
+            axisZ.X = rotation.Row2.X;
+            axisZ.Y = rotation.Row2.Y;
+            axisZ.Z = rotation.Row2.Z;
+
+            totalHalfScaleX = 0.5f * (partCountX - 1) * cellCountX * objectScale.X;
+            totalHalfScaleZ = 0.5f * (partCountZ - 1) * cellCountZ * objectScale.Z;
+
+            Vector3.Multiply(ref axisX, -totalHalfScaleX, out deltaX);
+            Vector3.Multiply(ref axisZ, -totalHalfScaleZ, out deltaZ);
+
+            Vector3.Add(ref minPosition, ref deltaX, out minPosition);
+            Vector3.Add(ref minPosition, ref deltaZ, out minPosition);
+
+            for (int i = 0; i < partCountX; i++)
+            {
+                Vector3.Multiply(ref axisX, objectScale.X * cellCountX * i, out deltaX);
+
+                for (int j = 0; j < partCountZ; j++)
+                {
+                    partIndexName = " " + i.ToString() + " " + j.ToString();
+
+                    Vector3.Multiply(ref axisZ, objectScale.Z * cellCountZ * j, out deltaZ);
+
+                    Vector3.Add(ref minPosition, ref deltaX, out position);
+                    Vector3.Add(ref position, ref deltaZ, out position);
+
+                    shape = scene.Factory.ShapeManager.Find("Lake" + instanceIndexName + partIndexName);
+
+                    objectRoot = scene.Factory.PhysicsObjectManager.Create("Lake" + instanceIndexName + partIndexName);
+                    objectRoot.EnableCursorInteraction = false;
+                    objectRoot.DrawPriority = 4;
+                    objectRoot.Material.SetAmbient(0.55f, 0.55f, 0.55f);
+                    objectRoot.Material.SetSpecular(0.25f, 0.25f, 0.55f);
+                    objectRoot.Material.SetDiffuse(0.0f, 0.45f, 0.15f);
+                    objectRoot.Material.SetEmission(0.0f, 0.2f, 0.5f);
+                    objectRoot.Material.TransparencyFactor = 0.4f;
+                    objectRoot.Material.TwoSidedNormals = true;
+                    objectRoot.Shape = shape;
+                    objectRoot.UserDataStr = "Lake" + instanceIndexName + partIndexName;
+                    objectRoot.InitLocalTransform.SetPosition(ref position);
+                    objectRoot.InitLocalTransform.SetScale(ref objectScale);
+                    objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+                    objectRoot.Integral.SetDensity(density);
+                    objectRoot.EnableLocalGravity = true;
+                    objectRoot.InternalControllers.CreateFluidController(true);
+
+                    scene.UpdateFromInitLocalTransform(objectRoot);
+                }
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lamp1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lamp1.cs
new file mode 100644
index 0000000..16e14c1
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lamp1.cs
@@ -0,0 +1,167 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Lamp1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Lamp1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            Vector3[] convexTab1 = new Vector3[16];
+            convexTab1[0] = new Vector3(-0.5f, 1.0f, -1.0f);
+            convexTab1[1] = new Vector3(-1.0f, 1.0f, -0.5f);
+            convexTab1[2] = new Vector3(-1.0f, 1.0f, 0.5f);
+            convexTab1[3] = new Vector3(-0.5f, 1.0f, 1.0f);
+            convexTab1[4] = new Vector3(0.5f, 1.0f, 1.0f);
+            convexTab1[5] = new Vector3(1.0f, 1.0f, 0.5f);
+            convexTab1[6] = new Vector3(1.0f, 1.0f, -0.5f);
+            convexTab1[7] = new Vector3(0.5f, 1.0f, -1.0f);
+            convexTab1[8] = new Vector3(-0.25f, -1.0f, -0.5f);
+            convexTab1[9] = new Vector3(-0.5f, -1.0f, -0.25f);
+            convexTab1[10] = new Vector3(-0.5f, -1.0f, 0.25f);
+            convexTab1[11] = new Vector3(-0.25f, -1.0f, 0.5f);
+            convexTab1[12] = new Vector3(0.25f, -1.0f, 0.5f);
+            convexTab1[13] = new Vector3(0.5f, -1.0f, 0.25f);
+            convexTab1[14] = new Vector3(0.5f, -1.0f, -0.25f);
+            convexTab1[15] = new Vector3(0.25f, -1.0f, -0.5f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Lamp1Convex");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            shape = scene.Factory.ShapeManager.Create("Lamp1Convex");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Lamp1Convex"))
+                demo.Meshes.Add("Lamp1Convex", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, PhysicsObject joinPhysicsObject)
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape convex = scene.Factory.ShapeManager.Find("Lamp1Convex");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Lamp 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Lamp 1 Body" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Lamp 1 Body Main" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = convex;
+            objectBase.UserDataStr = "Lamp1Convex";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 2.0f, 1.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Lamp 1 Body Emitter" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 2.2f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(0.1f, 0.2f, 0.1f);
+            objectBase.Integral.InertiaScaleFactor = 3.0f;
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.MinResponseAngularVelocity = 0.05f;
+            objectBase.MinResponseLinearVelocity = 0.05f;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Lamp 1 Body Light" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(0.0f, 2.2f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f);
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Point;
+            objectBase.Light.SetDiffuse(1.0f, 0.8f, 0.1f);
+            objectBase.Light.Range = 15.0f;
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Lamp 1 Body Handle" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 400.0f;
+            objectBase.InitLocalTransform.SetPosition(-2.0f, 0.0f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 2.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Lamp 1 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Lamp 1 Body Handle" + instanceIndexName);
+            constraint.PhysicsObject2 = joinPhysicsObject;
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.SetAnchor1(position1 + new Vector3(-2.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(-2.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(orientation1);
+            constraint.SetInitWorldOrientation2(orientation1);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.Update();
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lights.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lights.cs
new file mode 100644
index 0000000..01fba46
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Lights.cs
@@ -0,0 +1,137 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Lights
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public Lights(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void CreateLightPoint(int index, string soundGroup, Vector3 lightPosition, Vector3 lightColor, float lightRange, float minBreakRigidGroupMultiplier)
+        {
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectLight = null;
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Light Point Root " + index.ToString());
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Light Point Base " + index.ToString());
+            objectLight = scene.Factory.PhysicsObjectManager.Create("Light Point " + index.ToString());
+
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectRoot.AddChildPhysicsObject(objectLight);
+            objectRoot.InitLocalTransform.SetPosition(ref lightPosition);
+            objectRoot.EnableLocalGravity = true;
+
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.MinBreakRigidGroupVelocityMultiplier = minBreakRigidGroupMultiplier;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetScale(0.5f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = soundGroup;
+
+            objectLight.Shape = sphere;
+            objectLight.UserDataStr = "Sphere";
+            objectLight.Material.RigidGroup = true;
+            objectLight.Material.UserDataStr = "Yellow";
+
+            objectLight.CreateLight(true);
+            objectLight.Light.Type = PhysicsLightType.Point;
+            objectLight.Light.SetDiffuse(ref lightColor);
+            objectLight.Light.Range = lightRange * 0.92f;
+
+            objectLight.InitLocalTransform.SetScale(lightRange);
+
+            objectLight.EnableCollisions = false;
+            objectLight.EnableCursorInteraction = false;
+            objectLight.EnableBreakRigidGroup = false;
+            objectLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+
+        public void CreateLightSpot(int index, string soundGroup, Vector3 lightPosition, Vector3 lightColor, float lightRange, float minBreakRigidGroupMultiplier)
+        {
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectLight = null;
+
+            Shape coneZ = scene.Factory.ShapeManager.Find("ConeZ");
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Light Spot Root " + index.ToString());
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Light Spot Base " + index.ToString());
+            objectLight = scene.Factory.PhysicsObjectManager.Create("Light Spot " + index.ToString());
+
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectRoot.AddChildPhysicsObject(objectLight);
+            objectRoot.InitLocalTransform.SetPosition(ref lightPosition);
+            objectRoot.EnableLocalGravity = true;
+            objectRoot.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+
+            objectBase.Shape = coneZ;
+            objectBase.UserDataStr = "ConeZ";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TwoSidedNormals = true;
+            objectBase.Material.MinBreakRigidGroupVelocityMultiplier = minBreakRigidGroupMultiplier;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetScale(0.5f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.UserDataStr = soundGroup;
+
+            objectLight.Shape = coneZ;
+            objectLight.UserDataStr = "ConeZ";
+            objectLight.Material.RigidGroup = true;
+            objectLight.Material.UserDataStr = "Yellow";
+
+            objectLight.CreateLight(true);
+            objectLight.Light.Type = PhysicsLightType.Spot;
+            objectLight.Light.SetDiffuse(ref lightColor);
+            objectLight.Light.SpotInnerRadAngle = (float)Math.Atan(0.48);
+            objectLight.Light.SpotOuterRadAngle = (float)Math.Atan(0.48);
+            objectLight.Light.Range = 2.0f * lightRange;
+
+            objectLight.InitLocalTransform.SetScale(lightRange);
+            objectLight.InitLocalTransform.SetPosition(0.0f, 0.0f, -lightRange + 0.5f);
+
+            objectLight.EnableCollisions = false;
+            objectLight.EnableCursorInteraction = false;
+            objectLight.EnableBreakRigidGroup = false;
+            objectLight.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Menu.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Menu.cs
new file mode 100644
index 0000000..1b3b83f
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Menu.cs
@@ -0,0 +1,298 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Menu
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Menu(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape coneY = scene.Factory.ShapeManager.Find("ConeY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            Constraint constraint = null;
+            string switchInstanceName = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+
+            for (int i = 0; i < 5; i++)
+            {
+                switchInstanceName = "Switch " + i.ToString();
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create(switchInstanceName + instanceIndexName);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+                objectBase.Material.TransparencyFactor = 0.9f;
+                objectBase.InitLocalTransform.SetPosition(-22.0f + 11.0f * i, 25.0f, 20.0f);
+                objectBase.InitLocalTransform.SetScale(5.0f, 4.0f, 0.4f);
+                objectBase.Integral.SetDensity(10.0f);
+                objectBase.EnableScreenToRayInteraction = true;
+
+                objectBase.UpdateFromInitLocalTransform();
+
+                constraint = scene.Factory.ConstraintManager.Create(switchInstanceName + " Slider Constraint" + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+                constraint.PhysicsObject2 = null;
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.SetAnchor1(ref position1);
+                constraint.SetAnchor2(ref position1);
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.MinLimitDistanceZ = -5.0f;
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.Update();
+
+                constraint = scene.Factory.ConstraintManager.Create(switchInstanceName + " Spring Constraint" + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+                constraint.PhysicsObject2 = null;
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.SetAnchor1(ref position1);
+                constraint.SetAnchor2(ref position1);
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.EnableSpringMode = true;
+                constraint.Force = 0.01f;
+                constraint.Update();
+
+                scene.UpdateFromInitLocalTransform(objectBase);
+            }
+
+            for (int i = 0; i < 5; i++)
+            {
+                switchInstanceName = "Switch " + (i + 5).ToString();
+
+                objectBase = scene.Factory.PhysicsObjectManager.Create(switchInstanceName + instanceIndexName);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+                objectBase.Material.TransparencyFactor = 0.9f;
+                objectBase.InitLocalTransform.SetPosition(-22.0f + 11.0f * i, 16.0f, 20.0f);
+                objectBase.InitLocalTransform.SetScale(5.0f, 4.0f, 0.4f);
+                objectBase.Integral.SetDensity(10.0f);
+                objectBase.EnableScreenToRayInteraction = true;
+
+                objectBase.UpdateFromInitLocalTransform();
+
+                constraint = scene.Factory.ConstraintManager.Create(switchInstanceName + " Slider Constraint" + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+                constraint.PhysicsObject2 = null;
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.SetAnchor1(ref position1);
+                constraint.SetAnchor2(ref position1);
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.MinLimitDistanceZ = -5.0f;
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.Update();
+
+                constraint = scene.Factory.ConstraintManager.Create(switchInstanceName + " Spring Constraint" + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find(switchInstanceName + instanceIndexName);
+                constraint.PhysicsObject2 = null;
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.SetAnchor1(ref position1);
+                constraint.SetAnchor2(ref position1);
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.EnableSpringMode = true;
+                constraint.Force = 0.01f;
+                constraint.Update();
+
+                scene.UpdateFromInitLocalTransform(objectBase);
+            }
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch Right Light" + instanceIndexName);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Point;
+            objectBase.Light.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Light.Range = 20.0f;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(34.0f, 20.5f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f);
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch Right" + instanceIndexName);
+            objectBase.Shape = coneY;
+            objectBase.UserDataStr = "ConeY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+            objectBase.Material.TransparencyFactor = 0.9f;
+            objectBase.InitLocalTransform.SetPosition(32.0f, 20.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 3.0f, 0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-10.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableScreenToRayInteraction = true;
+
+            objectBase.UpdateFromInitLocalTransform();
+
+            constraint = scene.Factory.ConstraintManager.Create("Switch Right Slider Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Switch Right" + instanceIndexName);
+            constraint.PhysicsObject2 = null;
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.MinLimitDistanceZ = -5.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Switch Right Spring Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Switch Right" + instanceIndexName);
+            constraint.PhysicsObject2 = null;
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.EnableSpringMode = true;
+            constraint.Force = 0.01f;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch Left Light" + instanceIndexName);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.CreateLight(true);
+            objectBase.Light.Type = PhysicsLightType.Point;
+            objectBase.Light.SetDiffuse(0.5f, 0.5f, 0.5f);
+            objectBase.Light.Range = 20.0f;
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.InitLocalTransform.SetPosition(-34.0f, 20.5f, 10.0f);
+            objectBase.InitLocalTransform.SetScale(20.0f);
+            objectBase.EnableCollisions = false;
+            objectBase.EnableCursorInteraction = false;
+            objectBase.EnableAddToCameraDrawTransparentPhysicsObjects = false;
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch Left" + instanceIndexName);
+            objectBase.Shape = coneY;
+            objectBase.UserDataStr = "ConeY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+            objectBase.Material.TransparencyFactor = 0.9f;
+            objectBase.InitLocalTransform.SetPosition(-32.0f, 20.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(5.0f, 3.0f, 0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-90.0f)) * Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(10.0f)));
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableScreenToRayInteraction = true;
+
+            objectBase.UpdateFromInitLocalTransform();
+
+            constraint = scene.Factory.ConstraintManager.Create("Switch Left Slider Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Switch Left" + instanceIndexName);
+            constraint.PhysicsObject2 = null;
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.MinLimitDistanceZ = -5.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Switch Left Spring Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Switch Left" + instanceIndexName);
+            constraint.PhysicsObject2 = null;
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.SetAnchor1(ref position1);
+            constraint.SetAnchor2(ref position1);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.EnableSpringMode = true;
+            constraint.Force = 0.01f;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Info" + instanceIndexName);
+            objectRoot.EnableMoving = false;
+            objectRoot.DrawPriority = 1;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Info Description" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.SetAmbient(0.51f, 0.52f, 0.51f);
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+            objectBase.Material.TransparencyFactor = 0.9f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, -6.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(15.0f, 27.0f, 0.4f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableDrawing = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableMoving = false;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Info Screen" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Wood1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.SetDiffuse(1.0f, 1.0f, 1.0f);
+            objectBase.Material.TransparencyFactor = 0.9f;
+            objectBase.InitLocalTransform.SetPosition(18.2f, 1.6f, 20.0f - 0.4f - 0.01f);
+            objectBase.InitLocalTransform.SetScale(7.0f, 6.0f, 0.01f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.EnableDrawing = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableMoving = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pier.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pier.cs
new file mode 100644
index 0000000..3931d50
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pier.cs
@@ -0,0 +1,134 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Pier
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Pier(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Pier 1 Base" + instanceIndexName);
+
+            for (int i = 0; i < 25; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Pier 1 Base Cylinder Left " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = cylinderY;
+                objectBase.UserDataStr = "CylinderY";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(-50.0f, -110.0f, -400.0f + i * 10.0f);
+                objectBase.InitLocalTransform.SetScale(2.0f, 20.0f, 2.0f);
+            }
+
+            for (int i = 0; i < 25; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Pier 1 Base Cylinder Right " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = cylinderY;
+                objectBase.UserDataStr = "CylinderY";
+                objectBase.Material.UserDataStr = "Wood1";
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(-15.0f, -110.0f, -400.0f + i * 10.0f);
+                objectBase.InitLocalTransform.SetScale(2.0f, 20.0f, 2.0f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Pier 1 Platform" + instanceIndexName);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Pier 1 Platform Cylinder 1" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.InitLocalTransform.SetPosition(-42.0f, -91.0f, -282.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 122.0f, 1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Pier 1 Platform Cylinder 2" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+            objectBase.Material.UserDataStr = "Wood2";
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.InitLocalTransform.SetPosition(-13.0f, -91.0f, -285.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 118.0f, 1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.Integral.SetDensity(1.0f);
+
+            for (int i = 0; i < 21; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Pier 1 Platform Box " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.RigidGroup = true;
+                objectBase.Material.MinBreakRigidGroupVelocity = 200.0f;
+                objectBase.Material.UserDataStr = "Wood2";
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(-27.0f, -89.5f, -400.0f + i * 11.5f);
+                objectBase.InitLocalTransform.SetScale(5.0f, 0.5f, 25.0f);
+                objectBase.InitLocalTransform.SetRotation(Matrix4.CreateRotationY(MathHelper.DegreesToRadians(90.0f)));
+                objectBase.Integral.SetDensity(1.0f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant1.cs
new file mode 100644
index 0000000..8b9dee9
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant1.cs
@@ -0,0 +1,415 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Plant1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        Vector3 position1;
+        Quaternion orientation1;
+        Quaternion orientation2;
+
+        public Plant1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant" + instanceIndexName);
+
+            string leafInstanceIndexName1 = " 1";
+            string leafInstanceIndexName2 = " 2";
+            string leafInstanceIndexName3 = " 3";
+            string leafInstanceIndexName4 = " 4";
+
+            int trunkCount = 8;
+            Vector3 trunkScale = new Vector3(1.0f, 5.0f, 1.0f);
+
+            int leafCount = 4;
+            Vector3 leafScale = new Vector3(4.0f, 0.1f, 1.0f);
+
+            CreateTrunk(scene, instanceIndexName, trunkCount, trunkScale, Vector3.Zero, Vector3.One, Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName1, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName2, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName3, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName4, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(270.0f)));
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Trunk" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName1 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (trunkCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName2 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (trunkCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName3 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (trunkCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName4 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (trunkCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName1 + leafInstanceIndexName2 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName3 + leafInstanceIndexName4 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            PhysicsObject objectA = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + (leafCount - 1).ToString() + instanceIndexName);
+            PhysicsObject objectB = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + (leafCount - 1).ToString() + instanceIndexName);
+            PhysicsObject objectC = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + (leafCount - 1).ToString() + instanceIndexName);
+            PhysicsObject objectD = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + (leafCount - 1).ToString() + instanceIndexName);
+
+            if (objectA != null)
+            {
+                objectA.DisableCollision(objectB, true);
+                objectA.DisableCollision(objectC, true);
+                objectA.DisableCollision(objectD, true);
+            }
+
+            if (objectB != null)
+            {
+                objectB.DisableCollision(objectC, true);
+                objectB.DisableCollision(objectD, true);
+            }
+
+            if (objectC != null)
+                objectC.DisableCollision(objectD, true);
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            constraint = scene.Factory.ConstraintManager.Create("Trunk Constraint " + trunkCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 0" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Quad  1");
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 30.0f;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+
+        void CreateTrunk(PhysicsScene scene, string instanceIndexName, int trunkCount, Vector3 trunkScale, Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant Trunk" + instanceIndexName);
+
+            for (int i = 0; i < trunkCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Trunk " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                //objectBase.Material.RigidGroup = true;
+                objectBase.Shape = cylinderY;
+                objectBase.UserDataStr = "CylinderY";
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(new Vector3(0.0f, 0.5f * trunkScale.Y + i * trunkScale.Y, 0.0f) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(trunkScale.X * 0.1f + 0.1f * (trunkCount - i), 0.5f * trunkScale.Y, trunkScale.Z * 0.1f + 0.1f * (trunkCount - i));
+                objectBase.Integral.SetDensity(10.0f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            for (int i = 0; i < trunkCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Trunk Constraint " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 200.0f;
+                constraint.Update();
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+        }
+
+        void CreateLeaf(PhysicsScene scene, string instanceIndexName, string leafInstanceIndexName, int trunkCount, Vector3 trunkScale, int leafCount, Vector3 leafScale, Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant Leaf" + leafInstanceIndexName + instanceIndexName);
+
+            for (int i = 0; i < leafCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, 0.0f) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.X, leafScale.Y, leafScale.Z + (float)Math.Tan(1.0 / (leafCount - i + 1.0) - 0.9));
+                objectBase.Integral.SetDensity(0.1f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 300.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, -1.2f + (float)Math.Exp(10.0 / (leafCount - i + 5.8f))) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.Z + (float)Math.Tan(1.0f / (leafCount - i + 1.0) - 0.5), leafScale.Y, leafScale.X);
+                objectBase.InitLocalTransform.SetRotation(Matrix4.CreateFromAxisAngle(Vector3.UnitY, -MathHelper.DegreesToRadians(45.0f + (leafCount - i) * 6.0f)));
+                objectBase.Integral.SetDensity(0.001f);
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, 1.2f - (float)Math.Exp(10.0 / (leafCount - i + 5.8f))) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.Z + (float)Math.Tan(1.0f / (leafCount - i + 1.0) - 0.5), leafScale.Y, leafScale.X);
+                objectBase.InitLocalTransform.SetRotation(Matrix4.CreateFromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f + (leafCount - i) * 6.0f)));
+                objectBase.Integral.SetDensity(0.001f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 400.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 400.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectA = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectB = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectA.DisableCollision(objectB, true);
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant2.cs
new file mode 100644
index 0000000..6cf8740
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Plant2.cs
@@ -0,0 +1,543 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Plant2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        Vector3 position1;
+        Quaternion orientation1;
+        Quaternion orientation2;
+
+        public Plant2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant" + instanceIndexName);
+
+            string leafInstanceIndexName1 = " 1 ";
+            string leafInstanceIndexName2 = " 2 ";
+            string leafInstanceIndexName3 = " 3 ";
+            string leafInstanceIndexName4 = " 4 ";
+            string leafInstanceIndexName5 = " 5 ";
+            string leafInstanceIndexName6 = " 6 ";
+            string leafInstanceIndexName7 = " 7 ";
+            string leafInstanceIndexName8 = " 8 ";
+            string leafInstanceIndexName9 = " 9 ";
+            string leafInstanceIndexName10 = " 10 ";
+            string leafInstanceIndexName11 = " 11 ";
+            string leafInstanceIndexName12 = " 12 ";
+
+            int trunkCount = 8;
+            Vector3 trunkScale = new Vector3(1.0f, 5.0f, 1.0f);
+
+            int leafCount = 3;
+            Vector3 leafScale = new Vector3(4.0f, 0.1f, 1.0f);
+
+            CreateTrunk(scene, instanceIndexName, trunkCount, trunkScale, Vector3.Zero, Vector3.One, Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName1, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 16.0f, 0.0f), new Vector3(0.4f, 0.4f, 0.4f), Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName2, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 11.0f, 0.0f), new Vector3(0.5f, 0.5f, 0.5f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName3, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 5.0f, 0.0f), new Vector3(0.6f, 0.6f, 0.6f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName4, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 9.0f, 0.0f), new Vector3(0.5f, 0.5f, 0.5f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(270.0f)));
+
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName5, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.7f, 0.7f, 0.7f), Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName6, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -1.0f, 0.0f), new Vector3(0.7f, 0.7f, 0.7f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName7, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -3.0f, 0.0f), new Vector3(0.7f, 0.7f, 0.7f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName8, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -2.0f, 0.0f), new Vector3(0.7f, 0.7f, 0.7f), Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(270.0f)));
+
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName9, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -11.0f, 0.0f), Vector3.One, Quaternion.Identity);
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName10, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -12.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName11, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -14.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+            CreateLeaf(scene, instanceIndexName, leafInstanceIndexName12, trunkCount, trunkScale, leafCount, leafScale, new Vector3(0.0f, -13.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(270.0f)));
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Trunk" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName5 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName6 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName7 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName8 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName9 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName10 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName11 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName12 + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName1 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName1 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 7" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(leafScale.X * 0.4f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(leafScale.X * 0.4f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName2 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName2 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 7" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, leafScale.X * 0.5f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, leafScale.X * 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName3 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName3 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 6" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(leafScale.X * 0.6f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(leafScale.X * 0.6f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName4 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName4 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 6" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.0f, leafScale.X * 0.5f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.0f, leafScale.X * 0.5f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName5 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName5 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 5" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(leafScale.X * 0.7f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(leafScale.X * 0.7f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName6 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName6 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 5" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, leafScale.X * 0.7f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, leafScale.X * 0.7f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName7 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName7 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 4" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(leafScale.X * 0.7f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(leafScale.X * 0.7f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName8 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName8 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 4" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.0f, leafScale.X * 0.7f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.0f, leafScale.X * 0.7f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName9 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName9 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 3" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName10 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName10 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 3" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName11 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName11 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(leafScale.X, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("LeafC Constraint" + leafInstanceIndexName12 + leafCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName12 + (leafCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 2" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.0f, leafScale.X));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MaxLimitDegAngleX = 10.0f;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 200.0f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            constraint = scene.Factory.ConstraintManager.Create("Trunk Constraint " + trunkCount.ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk 0" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Quad  1");
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 30.0f;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+
+        void CreateTrunk(PhysicsScene scene, string instanceIndexName, int trunkCount, Vector3 trunkScale, Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant Trunk" + instanceIndexName);
+
+            for (int i = 0; i < trunkCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Trunk " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                //objectBase.Material.RigidGroup = true;
+                objectBase.Shape = cylinderY;
+                objectBase.UserDataStr = "CylinderY";
+                objectBase.CreateSound(true);
+                objectBase.InitLocalTransform.SetPosition(new Vector3(0.0f, 0.5f * trunkScale.Y + i * trunkScale.Y, 0.0f) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(trunkScale.X * 0.1f + 0.1f * (trunkCount - i), 0.5f * trunkScale.Y, trunkScale.Z * 0.1f + 0.1f * (trunkCount - i));
+                objectBase.Integral.SetDensity(5.0f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            for (int i = 0; i < trunkCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Trunk Constraint " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Trunk " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.5f * trunkScale.Y, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 100.0f;
+                constraint.Update();
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+        }
+
+        void CreateLeaf(PhysicsScene scene, string instanceIndexName, string leafInstanceIndexName, int trunkCount, Vector3 trunkScale, int leafCount, Vector3 leafScale, Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Plant Leaf" + leafInstanceIndexName + instanceIndexName);
+
+            for (int i = 0; i < leafCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, 0.0f) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.X, leafScale.Y, leafScale.Z + (float)Math.Tan(1.0 / (leafCount - i + 1.0) - 0.9));
+                objectBase.Integral.SetDensity(0.1f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 300.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, -1.2f + (float)Math.Exp(10.0 / (leafCount - i + 5.8f))) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.Z + (float)Math.Tan(1.0f / (leafCount - i + 1.0) - 0.5), leafScale.Y, leafScale.X);
+                objectBase.InitLocalTransform.SetRotation(Matrix4.CreateFromAxisAngle(Vector3.UnitY, -MathHelper.DegreesToRadians(45.0f + (leafCount - i) * 6.0f)));
+                objectBase.Integral.SetDensity(0.01f);
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = box;
+                objectBase.UserDataStr = "Box";
+                objectBase.Material.UserDataStr = "Leaf";
+                objectBase.InitLocalTransform.SetPosition(new Vector3(-leafScale.X * 2.0f * leafCount + leafScale.X + i * 2.0f * leafScale.X, trunkCount * trunkScale.Y, 1.2f - (float)Math.Exp(10.0 / (leafCount - i + 5.8f))) + objectPosition);
+                objectBase.InitLocalTransform.SetScale(leafScale.Z + (float)Math.Tan(1.0f / (leafCount - i + 1.0) - 0.5), leafScale.Y, leafScale.X);
+                objectBase.InitLocalTransform.SetRotation(Matrix4.CreateFromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(45.0f + (leafCount - i) * 6.0f)));
+                objectBase.Integral.SetDensity(0.01f);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 400.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Leaf Constraint Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Plant Leaf" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetAnchor2(position1 + new Vector3(leafScale.X, 0.0f, 0.0f));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.MinLimitDegAngleZ = -10.0f;
+                constraint.EnableBreak = true;
+                constraint.MinBreakVelocity = 400.0f;
+                constraint.LimitAngleForce = 0.5f;
+                constraint.Update();
+            }
+
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+
+            for (int i = 0; i < leafCount - 1; i++)
+            {
+                objectA = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub A" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectB = scene.Factory.PhysicsObjectManager.Find("Plant Leaf Sub B" + leafInstanceIndexName + i.ToString() + instanceIndexName);
+                objectA.DisableCollision(objectB, true);
+            }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            objectRoot.UpdateFromInitLocalTransform();
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/PointCloth.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/PointCloth.cs
new file mode 100644
index 0000000..fd4543c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/PointCloth.cs
@@ -0,0 +1,210 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class PointCloth
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        float pointWidth;
+        float pointHeight;
+
+        Vector3 position1;
+        Vector3 position2;
+
+        public PointCloth(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, int pointWidth, int pointHeight, float segmentWidth, float segmentHeight, bool rigidSegment, float density, float force)
+        {
+            Shape point = scene.Factory.ShapeManager.Find("Point");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Point Cloth " + instanceIndexName);
+
+            float halfLenghtWidth = 0.5f * ((pointWidth - 1) * segmentWidth);
+            float halfLenghtHeight = 0.5f * ((pointHeight - 1) * segmentHeight);
+            this.pointWidth = pointWidth;
+            this.pointHeight = pointHeight;
+
+            for (int i = 0; i < pointHeight; i++)
+                for (int j = 0; j < pointWidth; j++)
+                {
+
+                    objectBase = scene.Factory.PhysicsObjectManager.Create("Point Cloth Point " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    objectRoot.AddChildPhysicsObject(objectBase);
+                    objectBase.Shape = point;
+                    objectBase.UserDataStr = "Point";
+                    objectBase.InitLocalTransform.SetPosition(j * segmentWidth - halfLenghtWidth, 0.0f, -i * segmentHeight + halfLenghtHeight);
+                    objectBase.InitLocalTransform.SetScale(0.1f);
+                    objectBase.Integral.SetDensity(density);
+                }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+
+            for (int i = 0; i < pointHeight; i++)
+                for (int j = 0; j < pointWidth - 1; j++)
+                {
+                    constraint = scene.Factory.ConstraintManager.Create("Point Cloth Horizontal Constraint " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + i.ToString() + " " + (j + 1).ToString() + instanceIndexName);
+                    constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                    constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                    constraint.SetAnchor1(position1);
+                    constraint.SetAnchor2(position2);
+                    constraint.Distance = rigidSegment ? -segmentWidth : segmentWidth;
+                    constraint.Force = force;
+                    constraint.EnableBreak = true;
+                    constraint.MinBreakVelocity = 20.0f;
+                    constraint.Update();
+                }
+
+            for (int i = 0; i < pointHeight - 1; i++)
+                for (int j = 0; j < pointWidth; j++)
+                {
+                    constraint = scene.Factory.ConstraintManager.Create("Point Cloth Vertical Constraint " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + (i + 1).ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                    constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                    constraint.SetAnchor1(position1);
+                    constraint.SetAnchor2(position2);
+                    constraint.Distance = rigidSegment ? -segmentHeight : segmentHeight;
+                    constraint.Force = force;
+                    constraint.EnableBreak = true;
+                    constraint.MinBreakVelocity = 20.0f;
+                    constraint.Update();
+                }
+
+            float segmentDistance = 0.0f;
+            for (int i = 0; i < pointHeight - 1; i++)
+                for (int j = 0; j < pointWidth - 1; j++)
+                {
+                    segmentDistance = rigidSegment ? (float)-Math.Sqrt(segmentWidth * segmentWidth + segmentHeight * segmentHeight) : (float)Math.Sqrt(segmentWidth * segmentWidth + segmentHeight * segmentHeight);
+
+                    constraint = scene.Factory.ConstraintManager.Create("Point Cloth Diagonal 1 Constraint " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + (i + 1).ToString() + " " + (j + 1).ToString() + instanceIndexName);
+                    constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                    constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                    constraint.SetAnchor1(position1);
+                    constraint.SetAnchor2(position2);
+                    constraint.Distance = segmentDistance;
+                    constraint.Force = force;
+                    constraint.EnableBreak = true;
+                    constraint.MinBreakVelocity = 20.0f;
+                    constraint.Update();
+
+                    constraint = scene.Factory.ConstraintManager.Create("Point Cloth Diagonal 2 Constraint " + i.ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + i.ToString() + " " + (j + 1).ToString() + instanceIndexName);
+                    constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + (i + 1).ToString() + " " + j.ToString() + instanceIndexName);
+                    constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                    constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                    constraint.SetAnchor1(position1);
+                    constraint.SetAnchor2(position2);
+                    constraint.Distance = segmentDistance;
+                    constraint.Force = force;
+                    constraint.EnableBreak = true;
+                    constraint.MinBreakVelocity = 20.0f;
+                    constraint.Update();
+                }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+
+        public void Join(int physicsObjectInstanceIndex, string physicsObjectBottomLeftName, string physicsObjectBottomRightName, string physicsObjectTopRightName, string physicsObjectTopLeftName)
+        {
+            string physicsObjectInstanceIndexName = "";
+
+            if (physicsObjectInstanceIndex > 0)
+                physicsObjectInstanceIndexName = " " + physicsObjectInstanceIndex.ToString();
+
+            Constraint constraint = null;
+
+            PhysicsObject physicsObjectBottomLeft = scene.Factory.PhysicsObjectManager.Find(physicsObjectBottomLeftName + physicsObjectInstanceIndexName);
+
+            if (physicsObjectBottomLeft != null)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Point Cloth Bottom Left Constraint " + instanceIndexName);
+                constraint.PhysicsObject1 = physicsObjectBottomLeft;
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point 0 0" + instanceIndexName);
+                constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                constraint.SetAnchor1(position2);
+                constraint.SetAnchor2(position2);
+                constraint.Update();
+            }
+
+            PhysicsObject physicsObjectBottomRight = scene.Factory.PhysicsObjectManager.Find(physicsObjectBottomRightName + physicsObjectInstanceIndexName);
+
+            if (physicsObjectBottomRight != null)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Point Cloth Bottom Right Constraint " + instanceIndexName);
+                constraint.PhysicsObject1 = physicsObjectBottomRight;
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point 0 " + (pointWidth - 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                constraint.SetAnchor1(position2);
+                constraint.SetAnchor2(position2);
+                constraint.Update();
+            }
+
+            PhysicsObject physicsObjectTopRight = scene.Factory.PhysicsObjectManager.Find(physicsObjectTopRightName + physicsObjectInstanceIndexName);
+
+            if (physicsObjectTopRight != null)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Point Cloth Top Right Constraint " + instanceIndexName);
+                constraint.PhysicsObject1 = physicsObjectTopRight;
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + (pointHeight - 1).ToString() + " " + (pointWidth - 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                constraint.SetAnchor1(position2);
+                constraint.SetAnchor2(position2);
+                constraint.Update();
+            }
+
+            PhysicsObject physicsObjectTopLeft = scene.Factory.PhysicsObjectManager.Find(physicsObjectTopLeftName + physicsObjectInstanceIndexName);
+
+            if (physicsObjectTopLeft != null)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Point Cloth Top Left Constraint " + instanceIndexName);
+                constraint.PhysicsObject1 = physicsObjectTopLeft;
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Point Cloth Point " + (pointHeight - 1).ToString() + " 0" + instanceIndexName);
+                constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+                constraint.SetAnchor1(position2);
+                constraint.SetAnchor2(position2);
+                constraint.Update();
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pyramid.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pyramid.cs
new file mode 100644
index 0000000..0a8404d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Pyramid.cs
@@ -0,0 +1,70 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Pyramid
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Pyramid(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, string shapeName, int pyramidSize, Vector3 shapeSize, float density, bool enableSleeping)
+        {
+            Shape shape = scene.Factory.ShapeManager.Find(shapeName);
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Pyramid" + instanceIndexName);
+
+            int instanceIndexCount = 0;
+
+            for (int y = 0; y < pyramidSize; y++)
+                for (int x = 0; x < pyramidSize - y; x++)
+                {
+                    objectBase = scene.Factory.PhysicsObjectManager.Create("Pyramid " + instanceIndexCount.ToString() + instanceIndexName);
+                    objectRoot.AddChildPhysicsObject(objectBase);
+                    objectBase.Shape = shape;
+                    objectBase.UserDataStr = shapeName;
+                    objectBase.CreateSound(true);
+                    objectBase.InitLocalTransform.SetPosition(x * shapeSize.X + 0.5f * shapeSize.X * y - 0.5f * shapeSize.X * pyramidSize, 0.5f * shapeSize.Y + y * shapeSize.Y, 0);
+                    objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z);
+                    objectBase.Integral.SetDensity(density);
+                    objectBase.EnableSleeping = enableSleeping;
+                    instanceIndexCount++;
+                }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Quad.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Quad.cs
new file mode 100644
index 0000000..de7f817
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Quad.cs
@@ -0,0 +1,52 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Quad
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Quad(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Quad " + instanceIndexName);
+            objectRoot.Shape = box;
+            objectRoot.UserDataStr = "Box";
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.EnableCursorInteraction = false;
+            objectRoot.DrawPriority = 1;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll1.cs
new file mode 100644
index 0000000..2b0697d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll1.cs
@@ -0,0 +1,775 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Ragdoll1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Ragdoll1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, bool enableControl, bool enableControlWithDeformation, float minAngleDeformationVelocity)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1" + instanceIndexName);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Head" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(0.0f, 42.7f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.7f);
+            objectBase.Integral.SetDensity(1.64f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Upper Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 41.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.44f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Lower Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f; 
+            objectBase.InitLocalTransform.SetPosition(0.0f, 39.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.84f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(5.5f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(-2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f, 0.5f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.5f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 36.75f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 34.25f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Right Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.6f, 32.8f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 36.75f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 34.25f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 1 Left Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 32.8f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Head" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.7f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.7f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -20.0f;
+            constraint.MaxLimitDegAngleX = 20.0f;
+            constraint.MinLimitDegAngleY = -60.0f;
+            constraint.MaxLimitDegAngleY = 60.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 3" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 90.0f;
+            constraint.MinLimitDegAngleZ = -90.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 4" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -90.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 90.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 5" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 6" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 7" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -2.0f;
+            constraint.MaxLimitDegAngleY = 135.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 8" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 60.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 9" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -135.0f;
+            constraint.MaxLimitDegAngleY = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 10" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -60.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 11" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 12" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Right Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 13" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 1 Constraint 14" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 1 Left Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll2.cs
new file mode 100644
index 0000000..180f123
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll2.cs
@@ -0,0 +1,783 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Ragdoll2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Ragdoll2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, bool enableControl, bool enableControlWithDeformation, float minAngleDeformationVelocity)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2" + instanceIndexName);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Head" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.InitLocalTransform.SetPosition(0.0f, 43.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.9f, 0.9f, 0.9f);
+            objectBase.Integral.SetDensity(1.64f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Upper Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 41.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f);
+            objectBase.Integral.SetDensity(1.44f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Lower Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 39.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f);
+            objectBase.Integral.SetDensity(1.84f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.0f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.0f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(5.5f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.0f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.0f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.5f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 36.75f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 34.25f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Right Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.6f, 32.8f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 36.75f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 34.25f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 1.25f, 0.5f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 2 Left Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 32.8f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Head" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.9f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.9f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -20.0f;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.MinLimitDegAngleY = -45.0f;
+            constraint.MaxLimitDegAngleY = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 3" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 90.0f;
+            constraint.MinLimitDegAngleZ = -90.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 4" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -90.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 90.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 5" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 6" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 7" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -2.0f;
+            constraint.MaxLimitDegAngleY = 135.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 8" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 60.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 9" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -135.0f;
+            constraint.MaxLimitDegAngleY = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 10" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -60.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 11" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 12" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Right Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 13" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 2 Constraint 14" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 2 Left Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll3.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll3.cs
new file mode 100644
index 0000000..9580299
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Ragdoll3.cs
@@ -0,0 +1,811 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Ragdoll3
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Ragdoll3(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = null;
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("CapsuleY1");
+            shapePrimitive.CreateCapsuleY(1.5f, 1.0f);
+
+            shape = scene.Factory.ShapeManager.Create("CapsuleY1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("CapsuleY2");
+            shapePrimitive.CreateCapsuleY(2.0f, 0.5f);
+
+            shape = scene.Factory.ShapeManager.Create("CapsuleY2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("CapsuleY3");
+            shapePrimitive.CreateCapsuleY(2.5f, 0.5f);
+
+            shape = scene.Factory.ShapeManager.Create("CapsuleY3");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("CapsuleY1");
+            triangleMesh.CreateCapsuleY(10, 15, 1.5f, 1.0f);
+            if (!demo.Meshes.ContainsKey("CapsuleY1"))
+                demo.Meshes.Add("CapsuleY1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("CapsuleY2");
+            triangleMesh.CreateCapsuleY(10, 15, 2.0f, 0.5f);
+            if (!demo.Meshes.ContainsKey("CapsuleY2"))
+                demo.Meshes.Add("CapsuleY2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("CapsuleY3");
+            triangleMesh.CreateCapsuleY(10, 15, 2.5f, 0.5f);
+            if (!demo.Meshes.ContainsKey("CapsuleY3"))
+                demo.Meshes.Add("CapsuleY3", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, bool enableControl, bool enableControlWithDeformation, float minAngleDeformationVelocity)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape capsuleY1 = scene.Factory.ShapeManager.Find("CapsuleY1");
+            Shape capsuleY2 = scene.Factory.ShapeManager.Find("CapsuleY2");
+            Shape capsuleY3 = scene.Factory.ShapeManager.Find("CapsuleY3");
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Vector3 position2 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3" + instanceIndexName);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Head" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.InitLocalTransform.SetPosition(0.0f, 43.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.9f, 0.9f, 0.9f);
+            objectBase.Integral.SetDensity(1.64f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Upper Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY1;
+            objectBase.UserDataStr = "CapsuleY1";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 41.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.44f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Lower Torso" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY1;
+            objectBase.UserDataStr = "CapsuleY1";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 39.0f, 20.0f);
+            objectBase.Integral.SetDensity(1.84f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY2;
+            objectBase.UserDataStr = "CapsuleY2";
+            objectBase.InitLocalTransform.SetPosition(2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY2;
+            objectBase.UserDataStr = "CapsuleY2";
+            objectBase.InitLocalTransform.SetPosition(4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(5.8f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Upper Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY2;
+            objectBase.UserDataStr = "CapsuleY2";
+            objectBase.InitLocalTransform.SetPosition(-2.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Lower Arm" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY2;
+            objectBase.UserDataStr = "CapsuleY2";
+            objectBase.InitLocalTransform.SetPosition(-4.0f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Hand" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-5.8f, 41.5f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(0.5f, 0.4f, 0.2f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY3;
+            objectBase.UserDataStr = "CapsuleY3";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 36.75f, 20.0f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY3;
+            objectBase.UserDataStr = "CapsuleY3";
+            objectBase.InitLocalTransform.SetPosition(0.6f, 34.25f, 20.0f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Right Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(0.6f, 32.6f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Upper Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY3;
+            objectBase.UserDataStr = "CapsuleY3";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 36.75f, 20.0f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Lower Leg" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = capsuleY3;
+            objectBase.UserDataStr = "CapsuleY3";
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 34.25f, 20.0f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Ragdoll 3 Left Foot" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.CreateSound(true);
+            objectBase.Sound.HitVolume = 0.25f;
+            objectBase.Sound.RollVolume = 0.25f;
+            objectBase.Sound.SlideVolume = 0.25f;
+            objectBase.Sound.MinFirstImpactForce = 100.0f;
+            objectBase.InitLocalTransform.SetPosition(-0.6f, 32.6f, 19.7f);
+            objectBase.InitLocalTransform.SetScale(0.4f, 0.2f, 0.8f);
+            objectBase.Integral.SetDensity(2.145f);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 1" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Head" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 0.9f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 0.9f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -20.0f;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.MinLimitDegAngleY = -45.0f;
+            constraint.MaxLimitDegAngleY = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 2" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 45.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 3" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 90.0f;
+            constraint.MinLimitDegAngleZ = -90.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 4" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Upper Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -90.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 90.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 5" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 6" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Lower Torso" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2.MainWorldTransform.GetPosition(ref position2);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position2 + new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -10.0f;
+            constraint.MaxLimitDegAngleX = 100.0f;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 0.0f;
+            constraint.MinLimitDegAngleZ = -45.0f;
+            constraint.MaxLimitDegAngleZ = 45.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 7" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -2.0f;
+            constraint.MaxLimitDegAngleY = 135.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 8" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(1.4f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(1.4f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -20.0f;
+            constraint.MaxLimitDegAngleY = 60.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 9" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Upper Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.0f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -135.0f;
+            constraint.MaxLimitDegAngleY = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 10" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Lower Arm" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Hand" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(1.4f, 0.0f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(1.4f, 0.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleY = -60.0f;
+            constraint.MaxLimitDegAngleY = 20.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 11" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 12" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Right Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 13" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Upper Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -135.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            constraint = scene.Factory.ConstraintManager.Create("Ragdoll 3 Constraint 14" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Lower Leg" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Ragdoll 3 Left Foot" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetAnchor2(position1 - new Vector3(0.0f, 1.25f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 300.0f;
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleY = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.MinLimitDegAngleX = -45.0f;
+            constraint.MaxLimitDegAngleX = 2.0f;
+            constraint.MinLimitDegAngleZ = -10.0f;
+            constraint.MaxLimitDegAngleZ = 10.0f;
+            constraint.LimitAngleMode = LimitAngleMode.EulerYZX;
+
+            if (enableControl)
+            {
+                constraint.EnableControlAngleX = true;
+                constraint.EnableControlAngleY = true;
+                constraint.EnableControlAngleZ = true;
+            }
+            else
+                if (enableControlWithDeformation)
+                {
+                    constraint.EnableControlAngleX = true;
+                    constraint.EnableControlAngleY = true;
+                    constraint.EnableControlAngleZ = true;
+
+                    constraint.EnableControlAngleWithDeformation = true;
+                    constraint.MinAngleDeformationVelocity = minAngleDeformationVelocity;
+                    constraint.AngularDamping = 1.0f;
+                }
+
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Rope.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Rope.cs
new file mode 100644
index 0000000..dc40664
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Rope.cs
@@ -0,0 +1,122 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Rope
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Rope(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(PhysicsObject startObject, PhysicsObject endObject, Vector3 startPosition, Vector3 endPosition, int ropeSegmentCount)
+        {
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Rope " + instanceIndexName);
+
+            endPosition.Y = startPosition.Y;
+            Vector3 distance = startPosition - endPosition;
+            float length = distance.Length;
+            float ropeLength = length / ropeSegmentCount;
+            Vector3 scale = new Vector3(0.2f, 0.2f, ropeLength * 0.5f);
+
+            for (int i = 0; i < ropeSegmentCount; i++)
+            {
+                objectBase = scene.Factory.PhysicsObjectManager.Create("Rope Segment " + i.ToString() + instanceIndexName);
+                objectRoot.AddChildPhysicsObject(objectBase);
+                objectBase.Shape = cylinderY;
+                objectBase.UserDataStr = "CylinderY";
+                objectBase.Material.UserDataStr = "Plastic2";
+                objectBase.Material.SetSpecular(0.2f, 0.2f, 0.2f);
+                objectBase.InitLocalTransform.SetPosition(startPosition.X, startPosition.Y, startPosition.Z + i * 2.0f * scale.Z + scale.Z);
+                objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(90.0f)));
+                objectBase.InitLocalTransform.SetScale(0.2f, ropeLength * 0.5f, 0.2f);
+                objectBase.Integral.SetDensity(0.1f);
+                objectBase.CreateSound(true);
+            }
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Rope Constraint 0" + instanceIndexName);
+            constraint.PhysicsObject1 = startObject;
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Rope Segment 0" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref startPosition);
+            constraint.SetAnchor2(ref startPosition);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            for (int i = 0; i < ropeSegmentCount - 1; i++)
+            {
+                constraint = scene.Factory.ConstraintManager.Create("Rope Constraint " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Rope Segment " + i.ToString() + instanceIndexName);
+                constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Rope Segment " + (i + 1).ToString() + instanceIndexName);
+                constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+                constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+                constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+                constraint.SetAnchor1(position1 + new Vector3(0.0f, 0.0f, scale.Z));
+                constraint.SetAnchor2(position1 + new Vector3(0.0f, 0.0f, scale.Z));
+                constraint.SetInitWorldOrientation1(ref orientation1);
+                constraint.SetInitWorldOrientation2(ref orientation2);
+                constraint.EnableLimitAngleX = true;
+                constraint.EnableLimitAngleY = true;
+                constraint.EnableLimitAngleZ = true;
+                constraint.EnableBreak = true;
+                constraint.AngularDamping = 0.1f;
+                constraint.EnableLimitAngleSpringMode = true;
+                constraint.Update();
+            }
+
+            constraint = scene.Factory.ConstraintManager.Create("Rope Constraint " + (ropeSegmentCount + 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Rope Segment " + (ropeSegmentCount - 1).ToString() + instanceIndexName);
+            constraint.PhysicsObject2 = endObject;
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(ref endPosition);
+            constraint.SetAnchor2(ref endPosition);
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableBreak = true;
+            constraint.Update();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Shot.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Shot.cs
new file mode 100644
index 0000000..e1d471d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Shot.cs
@@ -0,0 +1,49 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Shot
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public Shot(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Shot");
+            objectRoot.Shape = sphere;
+            objectRoot.UserDataStr = "Sphere";
+            objectRoot.InitLocalTransform.SetPosition(0.0f, -1000.0f, 0.0f);
+            objectRoot.InitLocalTransform.SetScale(0.5f);
+            objectRoot.EnableCollisions = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/SimpleCamera.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/SimpleCamera.cs
new file mode 100644
index 0000000..d0b6367
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/SimpleCamera.cs
@@ -0,0 +1,71 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class SimpleCamera
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public SimpleCamera(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Quaternion objectOrientationX, Quaternion objectOrientationY, Quaternion objectOrientationZ, bool actived)
+        {
+            Quaternion objectOrientationXY, objectOrientation;
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Simple Camera" + instanceIndexName);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetOrientation(objectOrientationX * objectOrientationY * objectOrientationZ);
+            objectRoot.CreateCamera(true);
+            objectRoot.Camera.Active = actived;
+            objectRoot.PostTransformPriority = 1;
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Vector3 position = Vector3.Zero;
+            Matrix4 cameraRotation = Matrix4.Identity;
+
+            Quaternion.Multiply(ref objectOrientationX, ref objectOrientationY, out objectOrientationXY);
+            Quaternion.Multiply(ref objectOrientationXY, ref objectOrientationZ, out objectOrientation);
+            Matrix4 rotation = Matrix4.CreateFromQuaternion(objectOrientation);
+
+            objectRoot.Camera.SetOrientation(ref objectOrientation);
+            objectRoot.Camera.SetRotation(ref rotation);
+            objectRoot.Camera.SetEuler(ref rotation);
+            objectRoot.Camera.Projection.CreatePerspectiveLH(1.0f, 11000.0f, 70.0f, demo.WindowWidth, demo.WindowHeight);
+
+            objectRoot.MainWorldTransform.GetPosition(ref position);
+            objectRoot.Camera.GetTransposeRotation(ref cameraRotation);
+
+            objectRoot.Camera.View.CreateLookAtLH(ref position, ref cameraRotation, 0.0f);
+            objectRoot.Camera.UpdateFrustum();
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Sky.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Sky.cs
new file mode 100644
index 0000000..153d9fd
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Sky.cs
@@ -0,0 +1,54 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Sky
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Sky(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition)
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Sky" + instanceIndexName);
+            objectRoot.Shape = sphere;
+            objectRoot.UserDataStr = "Sky";
+            objectRoot.Material.SetDiffuse(Vector3.One);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetScale(5500.0f);
+            objectRoot.EnableCollisions = false;
+            objectRoot.EnableCursorInteraction = false;
+            objectRoot.DrawPriority = 3;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch1.cs
new file mode 100644
index 0000000..8ae87c7
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch1.cs
@@ -0,0 +1,74 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Switch1
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public Switch1(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape userShape1 = scene.Factory.ShapeManager.Find("UserShape 1");
+            Shape userShape2 = scene.Factory.ShapeManager.Find("UserShape 2");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Switch 1");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch 1 Shape");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = userShape1;
+            objectBase.UserDataStr = "UserShape1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-40.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch 1 Switch");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = sphere;
+            objectBase.UserDataStr = "Sphere";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(-36.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch2.cs
new file mode 100644
index 0000000..2ae2a35
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Switch2.cs
@@ -0,0 +1,76 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Switch2
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public Switch2(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create()
+        {
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+            Shape userShape1 = scene.Factory.ShapeManager.Find("UserShape 1");
+            Shape userShape2 = scene.Factory.ShapeManager.Find("UserShape 2");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Switch 2");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch 2 Shape");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = userShape2;
+            objectBase.UserDataStr = "UserShape2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(40.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(10.0f);
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 40000.0f;
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Switch 2 Switch");
+            objectRoot.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Yellow";
+            objectBase.Material.RigidGroup = true;
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.InitLocalTransform.SetPosition(37.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(1.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(90.0f)));
+            objectBase.EnableBreakRigidGroup = false;
+            objectBase.EnableCollisionResponse = false;
+            objectBase.EnableCursorInteraction = false;
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Terrain.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Terrain.cs
new file mode 100644
index 0000000..9fb356e
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Terrain.cs
@@ -0,0 +1,73 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Terrain
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Terrain(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public void CreateShapes(Demo demo, PhysicsScene scene, float margin, bool dynamic)
+        {
+            Bitmap heightmapHeights = demo.Textures["DefaultHeights"].Bitmap;
+            Bitmap heightmapFrictions = demo.Textures["DefaultFrictions"].Bitmap;
+            Bitmap heightmapRestitutions = demo.Textures["DefaultRestitutions"].Bitmap;
+
+            int cellCountX = heightmapHeights.Width;
+            int cellCountZ = heightmapHeights.Height;
+
+            ShapePrimitive shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Terrain" + instanceIndexName);
+            shapePrimitive.CreateHeightmap(0, 0, cellCountX, cellCountZ, heightmapHeights, heightmapFrictions, heightmapRestitutions, 1.0f, 0.0f, true, dynamic);
+
+            Shape shape = scene.Factory.ShapeManager.Create("Terrain" + instanceIndexName);
+            shape.Set(shapePrimitive, Matrix4.Identity, margin);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("Terrain" + instanceIndexName))
+                demo.Meshes.Add("Terrain" + instanceIndexName, new DemoMesh(demo, shape, demo.Textures["Ground"], Vector2.One, true, true, false, false, true, CullFaceMode.Back, dynamic, true));
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, float density)
+        {
+            Shape shape = scene.Factory.ShapeManager.Find("Terrain" + instanceIndexName);
+
+            PhysicsObject objectRoot = scene.Factory.PhysicsObjectManager.Create("Terrain" + instanceIndexName);
+            objectRoot.EnableCursorInteraction = true;
+            objectRoot.DrawPriority = 2;
+            objectRoot.Shape = shape;
+            objectRoot.UserDataStr = "Terrain" + instanceIndexName;
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.Integral.SetDensity(density);
+            objectRoot.EnableLocalGravity = true;
+            objectRoot.InternalControllers.CreateHeightmapController(true);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TorusMesh.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TorusMesh.cs
new file mode 100644
index 0000000..b0d3713
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TorusMesh.cs
@@ -0,0 +1,80 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class TorusMesh
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public TorusMesh(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = null;
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+
+            triangleMesh = scene.Factory.TriangleMeshManager.Create("TorusMesh2");
+            triangleMesh.CreateTorusY(10, 15, 5.0f, 1.5f);
+            if (!demo.Meshes.ContainsKey("TorusMesh2"))
+                demo.Meshes.Add("TorusMesh2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.Back, false, false));
+
+            int triangleCount = triangleMesh.GetTriangleCount();
+            float[] frictions = new float[triangleCount];
+            float[] restitutions = new float[triangleCount];
+
+            for (int i = 0; i < triangleCount; i++)
+            {
+                frictions[i] = 1.0f;
+                restitutions[i] = 0.0f;
+            }
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("TorusMesh");
+            shapePrimitive.CreateTriangleMesh(triangleMesh, false, 2, frictions, restitutions, 1.0f, 0.0f);
+
+            shape = scene.Factory.ShapeManager.Create("TorusMesh");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, float density)
+        {
+            PhysicsObject objectBase = null;
+
+            Shape torusShape = scene.Factory.ShapeManager.Find("TorusMesh");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("TorusMesh" + instanceIndexName);
+            objectBase.Shape = torusShape;
+            objectBase.UserDataStr = "TorusMesh2";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(ref objectPosition);
+            objectBase.InitLocalTransform.SetScale(ref objectScale);
+            objectBase.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectBase.Integral.SetDensity(density);
+            objectBase.InternalControllers.CreateTriangleMeshController(true);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh1.cs
new file mode 100644
index 0000000..4488d2a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh1.cs
@@ -0,0 +1,516 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class TriangleMesh1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        // Data generated with CreateBezier function of the Matali Physics Pro version
+        static ushort[] meshIndices = new ushort[] { 0, 1, 26, 26, 25, 0, 1, 2, 27, 27, 26, 1, 2, 3, 28, 28, 27, 2, 3, 4, 29, 29, 28, 3, 4, 5, 30, 30, 29, 4, 5, 6, 31, 31, 30, 5, 
+                                    6, 7, 32, 32, 31, 6, 7, 8, 33, 33, 32, 7, 8, 9, 34, 34, 33, 8, 9, 10, 35, 35, 34, 9, 10, 11, 36, 36, 35, 10, 11, 12, 37, 37, 36, 11, 
+                                    12, 13, 38, 38, 37, 12, 13, 14, 39, 39, 38, 13, 14, 15, 40, 40, 39, 14, 15, 16, 41, 41, 40, 15, 16, 17, 42, 42, 41, 16, 17, 18, 43, 43, 42, 17, 
+                                    18, 19, 44, 44, 43, 18, 19, 20, 45, 45, 44, 19, 20, 21, 46, 46, 45, 20, 21, 22, 47, 47, 46, 21, 22, 23, 48, 48, 47, 22, 23, 24, 49, 49, 48, 23, 
+                                    25, 26, 51, 51, 50, 25, 26, 27, 52, 52, 51, 26, 27, 28, 53, 53, 52, 27, 28, 29, 54, 54, 53, 28, 29, 30, 55, 55, 54, 29, 30, 31, 56, 56, 55, 30, 
+                                    31, 32, 57, 57, 56, 31, 32, 33, 58, 58, 57, 32, 33, 34, 59, 59, 58, 33, 34, 35, 60, 60, 59, 34, 35, 36, 61, 61, 60, 35, 36, 37, 62, 62, 61, 36, 
+                                    37, 38, 63, 63, 62, 37, 38, 39, 64, 64, 63, 38, 39, 40, 65, 65, 64, 39, 40, 41, 66, 66, 65, 40, 41, 42, 67, 67, 66, 41, 42, 43, 68, 68, 67, 42, 
+                                    43, 44, 69, 69, 68, 43, 44, 45, 70, 70, 69, 44, 45, 46, 71, 71, 70, 45, 46, 47, 72, 72, 71, 46, 47, 48, 73, 73, 72, 47, 48, 49, 74, 74, 73, 48, 
+                                    50, 51, 76, 76, 75, 50, 51, 52, 77, 77, 76, 51, 52, 53, 78, 78, 77, 52, 53, 54, 79, 79, 78, 53, 54, 55, 80, 80, 79, 54, 55, 56, 81, 81, 80, 55, 
+                                    56, 57, 82, 82, 81, 56, 57, 58, 83, 83, 82, 57, 58, 59, 84, 84, 83, 58, 59, 60, 85, 85, 84, 59, 60, 61, 86, 86, 85, 60, 61, 62, 87, 87, 86, 61, 
+                                    62, 63, 88, 88, 87, 62, 63, 64, 89, 89, 88, 63, 64, 65, 90, 90, 89, 64, 65, 66, 91, 91, 90, 65, 66, 67, 92, 92, 91, 66, 67, 68, 93, 93, 92, 67, 
+                                    68, 69, 94, 94, 93, 68, 69, 70, 95, 95, 94, 69, 70, 71, 96, 96, 95, 70, 71, 72, 97, 97, 96, 71, 72, 73, 98, 98, 97, 72, 73, 74, 99, 99, 98, 73, 
+                                    75, 76, 101, 101, 100, 75, 76, 77, 102, 102, 101, 76, 77, 78, 103, 103, 102, 77, 78, 79, 104, 104, 103, 78, 79, 80, 105, 105, 104, 79, 80, 81, 106, 106, 105, 80, 
+                                    81, 82, 107, 107, 106, 81, 82, 83, 108, 108, 107, 82, 83, 84, 109, 109, 108, 83, 84, 85, 110, 110, 109, 84, 85, 86, 111, 111, 110, 85, 86, 87, 112, 112, 111, 86, 
+                                    87, 88, 113, 113, 112, 87, 88, 89, 114, 114, 113, 88, 89, 90, 115, 115, 114, 89, 90, 91, 116, 116, 115, 90, 91, 92, 117, 117, 116, 91, 92, 93, 118, 118, 117, 92, 
+                                    93, 94, 119, 119, 118, 93, 94, 95, 120, 120, 119, 94, 95, 96, 121, 121, 120, 95, 96, 97, 122, 122, 121, 96, 97, 98, 123, 123, 122, 97, 98, 99, 124, 124, 123, 98, 
+                                    100, 101, 126, 126, 125, 100, 101, 102, 127, 127, 126, 101, 102, 103, 128, 128, 127, 102, 103, 104, 129, 129, 128, 103, 104, 105, 130, 130, 129, 104, 105, 106, 131, 131, 130, 105, 
+                                    106, 107, 132, 132, 131, 106, 107, 108, 133, 133, 132, 107, 108, 109, 134, 134, 133, 108, 109, 110, 135, 135, 134, 109, 110, 111, 136, 136, 135, 110, 111, 112, 137, 137, 136, 111, 
+                                    112, 113, 138, 138, 137, 112, 113, 114, 139, 139, 138, 113, 114, 115, 140, 140, 139, 114, 115, 116, 141, 141, 140, 115, 116, 117, 142, 142, 141, 116, 117, 118, 143, 143, 142, 117, 
+                                    118, 119, 144, 144, 143, 118, 119, 120, 145, 145, 144, 119, 120, 121, 146, 146, 145, 120, 121, 122, 147, 147, 146, 121, 122, 123, 148, 148, 147, 122, 123, 124, 149, 149, 148, 123, 
+                                    125, 126, 151, 151, 150, 125, 126, 127, 152, 152, 151, 126, 127, 128, 153, 153, 152, 127, 128, 129, 154, 154, 153, 128, 129, 130, 155, 155, 154, 129, 130, 131, 156, 156, 155, 130, 
+                                    131, 132, 157, 157, 156, 131, 132, 133, 158, 158, 157, 132, 133, 134, 159, 159, 158, 133, 134, 135, 160, 160, 159, 134, 135, 136, 161, 161, 160, 135, 136, 137, 162, 162, 161, 136, 
+                                    137, 138, 163, 163, 162, 137, 138, 139, 164, 164, 163, 138, 139, 140, 165, 165, 164, 139, 140, 141, 166, 166, 165, 140, 141, 142, 167, 167, 166, 141, 142, 143, 168, 168, 167, 142, 
+                                    143, 144, 169, 169, 168, 143, 144, 145, 170, 170, 169, 144, 145, 146, 171, 171, 170, 145, 146, 147, 172, 172, 171, 146, 147, 148, 173, 173, 172, 147, 148, 149, 174, 174, 173, 148, 
+                                    150, 151, 176, 176, 175, 150, 151, 152, 177, 177, 176, 151, 152, 153, 178, 178, 177, 152, 153, 154, 179, 179, 178, 153, 154, 155, 180, 180, 179, 154, 155, 156, 181, 181, 180, 155, 
+                                    156, 157, 182, 182, 181, 156, 157, 158, 183, 183, 182, 157, 158, 159, 184, 184, 183, 158, 159, 160, 185, 185, 184, 159, 160, 161, 186, 186, 185, 160, 161, 162, 187, 187, 186, 161, 
+                                    162, 163, 188, 188, 187, 162, 163, 164, 189, 189, 188, 163, 164, 165, 190, 190, 189, 164, 165, 166, 191, 191, 190, 165, 166, 167, 192, 192, 191, 166, 167, 168, 193, 193, 192, 167, 
+                                    168, 169, 194, 194, 193, 168, 169, 170, 195, 195, 194, 169, 170, 171, 196, 196, 195, 170, 171, 172, 197, 197, 196, 171, 172, 173, 198, 198, 197, 172, 173, 174, 199, 199, 198, 173, 
+                                    175, 176, 201, 201, 200, 175, 176, 177, 202, 202, 201, 176, 177, 178, 203, 203, 202, 177, 178, 179, 204, 204, 203, 178, 179, 180, 205, 205, 204, 179, 180, 181, 206, 206, 205, 180, 
+                                    181, 182, 207, 207, 206, 181, 182, 183, 208, 208, 207, 182, 183, 184, 209, 209, 208, 183, 184, 185, 210, 210, 209, 184, 185, 186, 211, 211, 210, 185, 186, 187, 212, 212, 211, 186, 
+                                    187, 188, 213, 213, 212, 187, 188, 189, 214, 214, 213, 188, 189, 190, 215, 215, 214, 189, 190, 191, 216, 216, 215, 190, 191, 192, 217, 217, 216, 191, 192, 193, 218, 218, 217, 192, 
+                                    193, 194, 219, 219, 218, 193, 194, 195, 220, 220, 219, 194, 195, 196, 221, 221, 220, 195, 196, 197, 222, 222, 221, 196, 197, 198, 223, 223, 222, 197, 198, 199, 224, 224, 223, 198, 
+                                    200, 201, 226, 226, 225, 200, 201, 202, 227, 227, 226, 201, 202, 203, 228, 228, 227, 202, 203, 204, 229, 229, 228, 203, 204, 205, 230, 230, 229, 204, 205, 206, 231, 231, 230, 205, 
+                                    206, 207, 232, 232, 231, 206, 207, 208, 233, 233, 232, 207, 208, 209, 234, 234, 233, 208, 209, 210, 235, 235, 234, 209, 210, 211, 236, 236, 235, 210, 211, 212, 237, 237, 236, 211, 
+                                    212, 213, 238, 238, 237, 212, 213, 214, 239, 239, 238, 213, 214, 215, 240, 240, 239, 214, 215, 216, 241, 241, 240, 215, 216, 217, 242, 242, 241, 216, 217, 218, 243, 243, 242, 217, 
+                                    218, 219, 244, 244, 243, 218, 219, 220, 245, 245, 244, 219, 220, 221, 246, 246, 245, 220, 221, 222, 247, 247, 246, 221, 222, 223, 248, 248, 247, 222, 223, 224, 249, 249, 248, 223, 
+                                    225, 226, 251, 251, 250, 225, 226, 227, 252, 252, 251, 226, 227, 228, 253, 253, 252, 227, 228, 229, 254, 254, 253, 228, 229, 230, 255, 255, 254, 229, 230, 231, 256, 256, 255, 230, 
+                                    231, 232, 257, 257, 256, 231, 232, 233, 258, 258, 257, 232, 233, 234, 259, 259, 258, 233, 234, 235, 260, 260, 259, 234, 235, 236, 261, 261, 260, 235, 236, 237, 262, 262, 261, 236, 
+                                    237, 238, 263, 263, 262, 237, 238, 239, 264, 264, 263, 238, 239, 240, 265, 265, 264, 239, 240, 241, 266, 266, 265, 240, 241, 242, 267, 267, 266, 241, 242, 243, 268, 268, 267, 242, 
+                                    243, 244, 269, 269, 268, 243, 244, 245, 270, 270, 269, 244, 245, 246, 271, 271, 270, 245, 246, 247, 272, 272, 271, 246, 247, 248, 273, 273, 272, 247, 248, 249, 274, 274, 273, 248, 
+                                    250, 251, 276, 276, 275, 250, 251, 252, 277, 277, 276, 251, 252, 253, 278, 278, 277, 252, 253, 254, 279, 279, 278, 253, 254, 255, 280, 280, 279, 254, 255, 256, 281, 281, 280, 255, 
+                                    256, 257, 282, 282, 281, 256, 257, 258, 283, 283, 282, 257, 258, 259, 284, 284, 283, 258, 259, 260, 285, 285, 284, 259, 260, 261, 286, 286, 285, 260, 261, 262, 287, 287, 286, 261, 
+                                    262, 263, 288, 288, 287, 262, 263, 264, 289, 289, 288, 263, 264, 265, 290, 290, 289, 264, 265, 266, 291, 291, 290, 265, 266, 267, 292, 292, 291, 266, 267, 268, 293, 293, 292, 267, 
+                                    268, 269, 294, 294, 293, 268, 269, 270, 295, 295, 294, 269, 270, 271, 296, 296, 295, 270, 271, 272, 297, 297, 296, 271, 272, 273, 298, 298, 297, 272, 273, 274, 299, 299, 298, 273, 
+                                    275, 276, 301, 301, 300, 275, 276, 277, 302, 302, 301, 276, 277, 278, 303, 303, 302, 277, 278, 279, 304, 304, 303, 278, 279, 280, 305, 305, 304, 279, 280, 281, 306, 306, 305, 280, 
+                                    281, 282, 307, 307, 306, 281, 282, 283, 308, 308, 307, 282, 283, 284, 309, 309, 308, 283, 284, 285, 310, 310, 309, 284, 285, 286, 311, 311, 310, 285, 286, 287, 312, 312, 311, 286, 
+                                    287, 288, 313, 313, 312, 287, 288, 289, 314, 314, 313, 288, 289, 290, 315, 315, 314, 289, 290, 291, 316, 316, 315, 290, 291, 292, 317, 317, 316, 291, 292, 293, 318, 318, 317, 292, 
+                                    293, 294, 319, 319, 318, 293, 294, 295, 320, 320, 319, 294, 295, 296, 321, 321, 320, 295, 296, 297, 322, 322, 321, 296, 297, 298, 323, 323, 322, 297, 298, 299, 324, 324, 323, 298, 
+                                    300, 301, 326, 326, 325, 300, 301, 302, 327, 327, 326, 301, 302, 303, 328, 328, 327, 302, 303, 304, 329, 329, 328, 303, 304, 305, 330, 330, 329, 304, 305, 306, 331, 331, 330, 305, 
+                                    306, 307, 332, 332, 331, 306, 307, 308, 333, 333, 332, 307, 308, 309, 334, 334, 333, 308, 309, 310, 335, 335, 334, 309, 310, 311, 336, 336, 335, 310, 311, 312, 337, 337, 336, 311, 
+                                    312, 313, 338, 338, 337, 312, 313, 314, 339, 339, 338, 313, 314, 315, 340, 340, 339, 314, 315, 316, 341, 341, 340, 315, 316, 317, 342, 342, 341, 316, 317, 318, 343, 343, 342, 317, 
+                                    318, 319, 344, 344, 343, 318, 319, 320, 345, 345, 344, 319, 320, 321, 346, 346, 345, 320, 321, 322, 347, 347, 346, 321, 322, 323, 348, 348, 347, 322, 323, 324, 349, 349, 348, 323, 
+                                    325, 326, 351, 351, 350, 325, 326, 327, 352, 352, 351, 326, 327, 328, 353, 353, 352, 327, 328, 329, 354, 354, 353, 328, 329, 330, 355, 355, 354, 329, 330, 331, 356, 356, 355, 330, 
+                                    331, 332, 357, 357, 356, 331, 332, 333, 358, 358, 357, 332, 333, 334, 359, 359, 358, 333, 334, 335, 360, 360, 359, 334, 335, 336, 361, 361, 360, 335, 336, 337, 362, 362, 361, 336, 
+                                    337, 338, 363, 363, 362, 337, 338, 339, 364, 364, 363, 338, 339, 340, 365, 365, 364, 339, 340, 341, 366, 366, 365, 340, 341, 342, 367, 367, 366, 341, 342, 343, 368, 368, 367, 342, 
+                                    343, 344, 369, 369, 368, 343, 344, 345, 370, 370, 369, 344, 345, 346, 371, 371, 370, 345, 346, 347, 372, 372, 371, 346, 347, 348, 373, 373, 372, 347, 348, 349, 374, 374, 373, 348, 
+                                    350, 351, 376, 376, 375, 350, 351, 352, 377, 377, 376, 351, 352, 353, 378, 378, 377, 352, 353, 354, 379, 379, 378, 353, 354, 355, 380, 380, 379, 354, 355, 356, 381, 381, 380, 355, 
+                                    356, 357, 382, 382, 381, 356, 357, 358, 383, 383, 382, 357, 358, 359, 384, 384, 383, 358, 359, 360, 385, 385, 384, 359, 360, 361, 386, 386, 385, 360, 361, 362, 387, 387, 386, 361, 
+                                    362, 363, 388, 388, 387, 362, 363, 364, 389, 389, 388, 363, 364, 365, 390, 390, 389, 364, 365, 366, 391, 391, 390, 365, 366, 367, 392, 392, 391, 366, 367, 368, 393, 393, 392, 367, 
+                                    368, 369, 394, 394, 393, 368, 369, 370, 395, 395, 394, 369, 370, 371, 396, 396, 395, 370, 371, 372, 397, 397, 396, 371, 372, 373, 398, 398, 397, 372, 373, 374, 399, 399, 398, 373, 
+                                    375, 376, 401, 401, 400, 375, 376, 377, 402, 402, 401, 376, 377, 378, 403, 403, 402, 377, 378, 379, 404, 404, 403, 378, 379, 380, 405, 405, 404, 379, 380, 381, 406, 406, 405, 380, 
+                                    381, 382, 407, 407, 406, 381, 382, 383, 408, 408, 407, 382, 383, 384, 409, 409, 408, 383, 384, 385, 410, 410, 409, 384, 385, 386, 411, 411, 410, 385, 386, 387, 412, 412, 411, 386, 
+                                    387, 388, 413, 413, 412, 387, 388, 389, 414, 414, 413, 388, 389, 390, 415, 415, 414, 389, 390, 391, 416, 416, 415, 390, 391, 392, 417, 417, 416, 391, 392, 393, 418, 418, 417, 392, 
+                                    393, 394, 419, 419, 418, 393, 394, 395, 420, 420, 419, 394, 395, 396, 421, 421, 420, 395, 396, 397, 422, 422, 421, 396, 397, 398, 423, 423, 422, 397, 398, 399, 424, 424, 423, 398, 
+                                    400, 401, 426, 426, 425, 400, 401, 402, 427, 427, 426, 401, 402, 403, 428, 428, 427, 402, 403, 404, 429, 429, 428, 403, 404, 405, 430, 430, 429, 404, 405, 406, 431, 431, 430, 405, 
+                                    406, 407, 432, 432, 431, 406, 407, 408, 433, 433, 432, 407, 408, 409, 434, 434, 433, 408, 409, 410, 435, 435, 434, 409, 410, 411, 436, 436, 435, 410, 411, 412, 437, 437, 436, 411, 
+                                    412, 413, 438, 438, 437, 412, 413, 414, 439, 439, 438, 413, 414, 415, 440, 440, 439, 414, 415, 416, 441, 441, 440, 415, 416, 417, 442, 442, 441, 416, 417, 418, 443, 443, 442, 417, 
+                                    418, 419, 444, 444, 443, 418, 419, 420, 445, 445, 444, 419, 420, 421, 446, 446, 445, 420, 421, 422, 447, 447, 446, 421, 422, 423, 448, 448, 447, 422, 423, 424, 449, 449, 448, 423, 
+                                    425, 426, 451, 451, 450, 425, 426, 427, 452, 452, 451, 426, 427, 428, 453, 453, 452, 427, 428, 429, 454, 454, 453, 428, 429, 430, 455, 455, 454, 429, 430, 431, 456, 456, 455, 430, 
+                                    431, 432, 457, 457, 456, 431, 432, 433, 458, 458, 457, 432, 433, 434, 459, 459, 458, 433, 434, 435, 460, 460, 459, 434, 435, 436, 461, 461, 460, 435, 436, 437, 462, 462, 461, 436, 
+                                    437, 438, 463, 463, 462, 437, 438, 439, 464, 464, 463, 438, 439, 440, 465, 465, 464, 439, 440, 441, 466, 466, 465, 440, 441, 442, 467, 467, 466, 441, 442, 443, 468, 468, 467, 442, 
+                                    443, 444, 469, 469, 468, 443, 444, 445, 470, 470, 469, 444, 445, 446, 471, 471, 470, 445, 446, 447, 472, 472, 471, 446, 447, 448, 473, 473, 472, 447, 448, 449, 474, 474, 473, 448, 
+                                    450, 451, 476, 476, 475, 450, 451, 452, 477, 477, 476, 451, 452, 453, 478, 478, 477, 452, 453, 454, 479, 479, 478, 453, 454, 455, 480, 480, 479, 454, 455, 456, 481, 481, 480, 455, 
+                                    456, 457, 482, 482, 481, 456, 457, 458, 483, 483, 482, 457, 458, 459, 484, 484, 483, 458, 459, 460, 485, 485, 484, 459, 460, 461, 486, 486, 485, 460, 461, 462, 487, 487, 486, 461, 
+                                    462, 463, 488, 488, 487, 462, 463, 464, 489, 489, 488, 463, 464, 465, 490, 490, 489, 464, 465, 466, 491, 491, 490, 465, 466, 467, 492, 492, 491, 466, 467, 468, 493, 493, 492, 467, 
+                                    468, 469, 494, 494, 493, 468, 469, 470, 495, 495, 494, 469, 470, 471, 496, 496, 495, 470, 471, 472, 497, 497, 496, 471, 472, 473, 498, 498, 497, 472, 473, 474, 499, 499, 498, 473, 
+                                    475, 476, 501, 501, 500, 475, 476, 477, 502, 502, 501, 476, 477, 478, 503, 503, 502, 477, 478, 479, 504, 504, 503, 478, 479, 480, 505, 505, 504, 479, 480, 481, 506, 506, 505, 480, 
+                                    481, 482, 507, 507, 506, 481, 482, 483, 508, 508, 507, 482, 483, 484, 509, 509, 508, 483, 484, 485, 510, 510, 509, 484, 485, 486, 511, 511, 510, 485, 486, 487, 512, 512, 511, 486, 
+                                    487, 488, 513, 513, 512, 487, 488, 489, 514, 514, 513, 488, 489, 490, 515, 515, 514, 489, 490, 491, 516, 516, 515, 490, 491, 492, 517, 517, 516, 491, 492, 493, 518, 518, 517, 492, 
+                                    493, 494, 519, 519, 518, 493, 494, 495, 520, 520, 519, 494, 495, 496, 521, 521, 520, 495, 496, 497, 522, 522, 521, 496, 497, 498, 523, 523, 522, 497, 498, 499, 524, 524, 523, 498, 
+                                    500, 501, 526, 526, 525, 500, 501, 502, 527, 527, 526, 501, 502, 503, 528, 528, 527, 502, 503, 504, 529, 529, 528, 503, 504, 505, 530, 530, 529, 504, 505, 506, 531, 531, 530, 505, 
+                                    506, 507, 532, 532, 531, 506, 507, 508, 533, 533, 532, 507, 508, 509, 534, 534, 533, 508, 509, 510, 535, 535, 534, 509, 510, 511, 536, 536, 535, 510, 511, 512, 537, 537, 536, 511, 
+                                    512, 513, 538, 538, 537, 512, 513, 514, 539, 539, 538, 513, 514, 515, 540, 540, 539, 514, 515, 516, 541, 541, 540, 515, 516, 517, 542, 542, 541, 516, 517, 518, 543, 543, 542, 517, 
+                                    518, 519, 544, 544, 543, 518, 519, 520, 545, 545, 544, 519, 520, 521, 546, 546, 545, 520, 521, 522, 547, 547, 546, 521, 522, 523, 548, 548, 547, 522, 523, 524, 549, 549, 548, 523, 
+                                    525, 526, 551, 551, 550, 525, 526, 527, 552, 552, 551, 526, 527, 528, 553, 553, 552, 527, 528, 529, 554, 554, 553, 528, 529, 530, 555, 555, 554, 529, 530, 531, 556, 556, 555, 530, 
+                                    531, 532, 557, 557, 556, 531, 532, 533, 558, 558, 557, 532, 533, 534, 559, 559, 558, 533, 534, 535, 560, 560, 559, 534, 535, 536, 561, 561, 560, 535, 536, 537, 562, 562, 561, 536, 
+                                    537, 538, 563, 563, 562, 537, 538, 539, 564, 564, 563, 538, 539, 540, 565, 565, 564, 539, 540, 541, 566, 566, 565, 540, 541, 542, 567, 567, 566, 541, 542, 543, 568, 568, 567, 542, 
+                                    543, 544, 569, 569, 568, 543, 544, 545, 570, 570, 569, 544, 545, 546, 571, 571, 570, 545, 546, 547, 572, 572, 571, 546, 547, 548, 573, 573, 572, 547, 548, 549, 574, 574, 573, 548, 
+                                    550, 551, 576, 576, 575, 550, 551, 552, 577, 577, 576, 551, 552, 553, 578, 578, 577, 552, 553, 554, 579, 579, 578, 553, 554, 555, 580, 580, 579, 554, 555, 556, 581, 581, 580, 555, 
+                                    556, 557, 582, 582, 581, 556, 557, 558, 583, 583, 582, 557, 558, 559, 584, 584, 583, 558, 559, 560, 585, 585, 584, 559, 560, 561, 586, 586, 585, 560, 561, 562, 587, 587, 586, 561, 
+                                    562, 563, 588, 588, 587, 562, 563, 564, 589, 589, 588, 563, 564, 565, 590, 590, 589, 564, 565, 566, 591, 591, 590, 565, 566, 567, 592, 592, 591, 566, 567, 568, 593, 593, 592, 567, 
+                                    568, 569, 594, 594, 593, 568, 569, 570, 595, 595, 594, 569, 570, 571, 596, 596, 595, 570, 571, 572, 597, 597, 596, 571, 572, 573, 598, 598, 597, 572, 573, 574, 599, 599, 598, 573, 
+                                    575, 576, 601, 601, 600, 575, 576, 577, 602, 602, 601, 576, 577, 578, 603, 603, 602, 577, 578, 579, 604, 604, 603, 578, 579, 580, 605, 605, 604, 579, 580, 581, 606, 606, 605, 580, 
+                                    581, 582, 607, 607, 606, 581, 582, 583, 608, 608, 607, 582, 583, 584, 609, 609, 608, 583, 584, 585, 610, 610, 609, 584, 585, 586, 611, 611, 610, 585, 586, 587, 612, 612, 611, 586, 
+                                    587, 588, 613, 613, 612, 587, 588, 589, 614, 614, 613, 588, 589, 590, 615, 615, 614, 589, 590, 591, 616, 616, 615, 590, 591, 592, 617, 617, 616, 591, 592, 593, 618, 618, 617, 592, 
+                                    593, 594, 619, 619, 618, 593, 594, 595, 620, 620, 619, 594, 595, 596, 621, 621, 620, 595, 596, 597, 622, 622, 621, 596, 597, 598, 623, 623, 622, 597, 598, 599, 624, 624, 623, 598 };
+
+        static Vector3[] meshPositions = new Vector3[] { new Vector3(-960f, -400f, 450f), new Vector3(-960f, -329.6736f, 570.1019f), new Vector3(-960f, -278.7889f, 680.8989f), 
+                                              new Vector3(-960f, -245.1447f, 781.9061f), new Vector3(-960f, -226.5392f, 872.6382f), new Vector3(-960f, -220.7711f, 952.6101f), 
+                                              new Vector3(-960f, -225.6388f, 1021.337f), new Vector3(-960f, -238.9407f, 1078.333f), new Vector3(-960f, -258.4754f, 1123.114f), 
+                                              new Vector3(-960f, -282.0414f, 1155.195f), new Vector3(-960f, -307.4372f, 1174.089f), new Vector3(-960f, -332.4612f, 1179.314f), 
+                                              new Vector3(-960f, -354.9118f, 1170.382f), new Vector3(-960f, -372.5878f, 1146.809f), new Vector3(-960f, -383.2874f, 1108.111f), 
+                                              new Vector3(-960f, -384.8093f, 1053.801f), new Vector3(-960f, -374.9518f, 983.3947f), new Vector3(-960f, -351.5135f, 896.4073f), 
+                                              new Vector3(-960f, -312.2928f, 792.3535f), new Vector3(-960f, -255.0883f, 670.748f), new Vector3(-960f, -177.6983f, 531.106f), 
+                                              new Vector3(-960f, -77.92139f, 372.9421f), new Vector3(-960f, 46.44388f, 195.7716f), new Vector3(-960f, 197.5991f, -0.8909912f), 
+                                              new Vector3(-960f, 377.7458f, -217.5306f), new Vector3(-896.8325f, -329.6736f, 450f), new Vector3(-894.2007f, -265.2335f, 575.1058f), 
+                                              new Vector3(-891.3425f, -220.563f, 690.519f), new Vector3(-888.2337f, -193.5138f, 795.7346f), new Vector3(-884.8499f, -181.9377f, 890.247f), 
+                                              new Vector3(-881.167f, -183.6864f, 973.5508f), new Vector3(-877.1607f, -196.6119f, 1045.141f), new Vector3(-872.8067f, -218.5657f, 1104.512f), 
+                                              new Vector3(-868.0807f, -247.3996f, 1151.159f), new Vector3(-862.9586f, -280.9656f, 1184.576f), new Vector3(-857.4161f, -317.1153f, 1204.258f), 
+                                              new Vector3(-851.4288f, -353.7005f, 1209.7f), new Vector3(-844.9726f, -388.573f, 1200.396f), new Vector3(-838.0231f, -419.5845f, 1175.841f), 
+                                              new Vector3(-830.5563f, -444.5869f, 1135.53f), new Vector3(-822.5476f, -461.4319f, 1078.958f), new Vector3(-813.973f, -467.9713f, 1005.618f), 
+                                              new Vector3(-804.8082f, -462.0569f, 915.0063f), new Vector3(-795.0288f, -441.5403f, 806.6172f), new Vector3(-784.6107f, -404.2734f, 679.9453f), 
+                                              new Vector3(-773.5297f, -348.108f, 534.4852f), new Vector3(-761.7614f, -270.8957f, 369.7316f), new Vector3(-749.2814f, -170.4886f, 185.1795f), 
+                                              new Vector3(-736.0657f, -44.73801f, -19.67697f), new Vector3(-722.0901f, 108.5038f, -245.3427f), new Vector3(-832.8026f, -278.7889f, 450f), 
+                                              new Vector3(-827.503f, -220.563f, 580.5402f), new Vector3(-821.7476f, -181.8032f, 700.9669f), new Vector3(-815.4874f, -160.4611f, 810.7527f), 
+                                              new Vector3(-808.6737f, -154.4882f, 909.3706f), new Vector3(-801.2576f, -161.8362f, 996.293f), new Vector3(-793.1902f, -180.4565f, 1070.993f), 
+                                              new Vector3(-784.4227f, -208.3005f, 1132.943f), new Vector3(-774.9063f, -243.3199f, 1181.616f), new Vector3(-764.5922f, -283.4662f, 1216.484f), 
+                                              new Vector3(-753.4314f, -326.691f, 1237.021f), new Vector3(-741.3751f, -370.9456f, 1242.7f), new Vector3(-728.3745f, -414.1818f, 1232.992f), 
+                                              new Vector3(-714.3807f, -454.3509f, 1207.37f), new Vector3(-699.345f, -489.4046f, 1165.308f), new Vector3(-683.2184f, -517.2945f, 1106.278f), 
+                                              new Vector3(-665.9521f, -535.9717f, 1029.753f), new Vector3(-647.4972f, -543.3882f, 935.2054f), new Vector3(-627.805f, -537.4953f, 822.108f), 
+                                              new Vector3(-606.8265f, -516.2445f, 689.9337f), new Vector3(-584.5131f, -477.5874f, 538.155f), new Vector3(-560.8157f, -419.4754f, 366.2449f), 
+                                              new Vector3(-535.6855f, -339.8604f, 173.6761f), new Vector3(-509.0738f, -236.6934f, -40.0788f), new Vector3(-480.9315f, -107.9263f, -275.5471f), 
+                                              new Vector3(-767.623f, -245.1447f, 450f), new Vector3(-759.6078f, -193.5138f, 586.4512f), new Vector3(-750.9031f, -160.4611f, 712.3307f), 
+                                              new Vector3(-741.4351f, -144.082f, 827.0878f), new Vector3(-731.1298f, -142.4718f, 930.171f), new Vector3(-719.9135f, -153.7258f, 1021.029f), 
+                                              new Vector3(-707.7122f, -175.9393f, 1099.112f), new Vector3(-694.452f, -207.2076f, 1163.867f), new Vector3(-680.0591f, -245.6261f, 1214.744f), 
+                                              new Vector3(-664.4597f, -289.2901f, 1251.191f), new Vector3(-647.5798f, -336.2949f, 1272.658f), new Vector3(-629.3455f, -384.7358f, 1278.594f), 
+                                              new Vector3(-609.683f, -432.7081f, 1268.446f), new Vector3(-588.5184f, -478.3073f, 1241.664f), new Vector3(-565.778f, -519.6285f, 1197.698f), 
+                                              new Vector3(-541.3876f, -554.7671f, 1135.995f), new Vector3(-515.2736f, -581.8184f, 1056.005f), new Vector3(-487.362f, -598.8778f, 957.1758f), 
+                                              new Vector3(-457.5789f, -604.0405f, 838.9573f), new Vector3(-425.8505f, -595.4019f, 700.7981f), new Vector3(-392.1028f, -571.0571f, 542.1468f), 
+                                              new Vector3(-356.2623f, -529.1017f, 362.4525f), new Vector3(-318.2548f, -467.6309f, 161.164f), new Vector3(-278.0063f, -384.7401f, -62.26984f), 
+                                              new Vector3(-235.4432f, -278.5243f, -308.4002f), new Vector3(-701.0068f, -226.5392f, 450f), new Vector3(-690.2162f, -181.9377f, 592.8848f), 
+                                              new Vector3(-678.4972f, -154.4882f, 724.6996f), new Vector3(-665.7506f, -142.4718f, 844.8674f), new Vector3(-651.8768f, -144.1688f, 952.811f), 
+                                              new Vector3(-636.7765f, -157.8604f, 1047.953f), new Vector3(-620.3502f, -181.8268f, 1129.717f), new Vector3(-602.4982f, -214.349f, 1197.526f), 
+                                              new Vector3(-583.1214f, -253.7078f, 1250.801f), new Vector3(-562.1201f, -298.1837f, 1288.967f), new Vector3(-539.3951f, -346.0575f, 1311.446f), 
+                                              new Vector3(-514.8466f, -395.61f, 1317.662f), new Vector3(-488.3755f, -445.1217f, 1307.036f), new Vector3(-459.8821f, -492.8735f, 1278.991f), 
+                                              new Vector3(-429.267f, -537.1461f, 1232.952f), new Vector3(-396.4309f, -576.2202f, 1168.34f), new Vector3(-361.274f, -608.3765f, 1084.578f), 
+                                              new Vector3(-323.6972f, -631.8957f, 981.089f), new Vector3(-283.601f, -645.0583f, 857.2966f), new Vector3(-240.8856f, -646.1454f, 712.623f), 
+                                              new Vector3(-195.452f, -633.4376f, 546.4915f), new Vector3(-147.2006f, -605.2153f, 358.3246f), new Vector3(-96.03168f, -559.7596f, 147.5455f), 
+                                              new Vector3(-41.84613f, -495.3511f, -86.42322f), new Vector3(15.45569f, -410.2704f, -344.1586f), new Vector3(-632.6671f, -220.7711f, 450f), 
+                                              new Vector3(-619.0291f, -183.6865f, 599.8872f), new Vector3(-604.2179f, -161.8362f, 738.1619f), new Vector3(-588.108f, -153.7258f, 864.2188f), 
+                                              new Vector3(-570.5733f, -157.8604f, 977.4525f), new Vector3(-551.4885f, -172.7453f, 1077.257f), new Vector3(-530.7278f, -196.8858f, 1163.028f), 
+                                              new Vector3(-508.1653f, -228.7872f, 1234.16f), new Vector3(-483.6756f, -266.9548f, 1290.047f), new Vector3(-457.1329f, -309.8938f, 1330.083f), 
+                                              new Vector3(-428.4114f, -356.1095f, 1353.664f), new Vector3(-397.3854f, -404.1073f, 1360.183f), new Vector3(-363.9294f, -452.3924f, 1349.037f), 
+                                              new Vector3(-327.9175f, -499.47f, 1319.618f), new Vector3(-289.2241f, -543.8455f, 1271.322f), new Vector3(-247.7236f, -584.0241f, 1203.543f), 
+                                              new Vector3(-203.2901f, -618.5112f, 1115.677f), new Vector3(-155.798f, -645.812f, 1007.116f), new Vector3(-105.1216f, -664.4316f, 877.2571f), 
+                                              new Vector3(-51.13519f, -672.8756f, 725.4936f), new Vector3(6.286865f, -669.6492f, 551.2203f), new Vector3(67.27039f, -653.2574f, 353.8318f), 
+                                              new Vector3(131.9409f, -622.2059f, 132.7229f), new Vector3(200.4244f, -574.9996f, -112.712f), new Vector3(272.8461f, -510.144f, -383.0782f), 
+                                              new Vector3(-562.3168f, -225.6388f, 450f), new Vector3(-545.7477f, -196.6118f, 607.5045f), new Vector3(-527.7532f, -180.4565f, 752.8064f), 
+                                              new Vector3(-508.1809f, -175.9393f, 885.2697f), new Vector3(-486.8777f, -181.8268f, 1004.258f), new Vector3(-463.6913f, -196.8858f, 1109.135f), 
+                                              new Vector3(-438.4687f, -219.8827f, 1199.265f), new Vector3(-411.0571f, -249.5841f, 1274.011f), new Vector3(-381.3041f, -284.7567f, 1332.738f), 
+                                              new Vector3(-349.0566f, -324.1669f, 1374.809f), new Vector3(-314.1625f, -366.5814f, 1399.588f), new Vector3(-276.4684f, -410.7669f, 1406.439f), 
+                                              new Vector3(-235.822f, -455.4897f, 1394.726f), new Vector3(-192.0705f, -499.5166f, 1363.812f), new Vector3(-145.0612f, -541.6143f, 1313.062f), 
+                                              new Vector3(-94.64124f, -580.5492f, 1241.839f), new Vector3(-40.6582f, -615.0879f, 1149.507f), new Vector3(17.04108f, -643.9969f, 1035.429f), 
+                                              new Vector3(78.60876f, -666.0431f, 898.9705f), new Vector3(144.1979f, -679.9927f, 739.4943f), new Vector3(213.9612f, -684.6125f, 556.3643f), 
+                                              new Vector3(288.0511f, -678.6691f, 348.9445f), new Vector3(366.6208f, -660.9291f, 116.5988f), new Vector3(449.8228f, -630.1589f, -141.3093f), 
+                                              new Vector3(537.8093f, -585.1252f, -425.4157f), new Vector3(-489.6687f, -238.9407f, 450f), new Vector3(-470.0728f, -218.5656f, 615.7829f), 
+                                              new Vector3(-448.7913f, -208.3005f, 768.7218f), new Vector3(-425.6436f, -207.2076f, 908.1472f), new Vector3(-400.4487f, -214.349f, 1033.389f), 
+                                              new Vector3(-373.0266f, -228.7872f, 1143.779f), new Vector3(-343.1962f, -249.5841f, 1238.646f), new Vector3(-310.7773f, -275.802f, 1317.321f), 
+                                              new Vector3(-275.589f, -306.5031f, 1379.135f), new Vector3(-237.4507f, -340.7496f, 1423.417f), new Vector3(-196.1822f, -377.6038f, 1449.498f), 
+                                              new Vector3(-151.6022f, -416.1277f, 1456.709f), new Vector3(-103.5305f, -455.3836f, 1444.381f), new Vector3(-51.78662f, -494.4338f, 1411.842f), 
+                                              new Vector3(3.810425f, -532.3405f, 1358.424f), new Vector3(63.44092f, -568.1658f, 1283.458f), new Vector3(127.2856f, -600.9718f, 1186.272f), 
+                                              new Vector3(195.525f, -629.8209f, 1066.199f), new Vector3(268.3398f, -653.7752f, 922.5681f), new Vector3(345.9108f, -671.897f, 754.71f), 
+                                              new Vector3(428.4182f, -683.2484f, 561.9548f), new Vector3(516.0427f, -686.8915f, 343.6331f), new Vector3(608.9652f, -681.8887f, 99.07532f), 
+                                              new Vector3(707.3661f, -667.3021f, -172.3883f), new Vector3(811.4263f, -642.194f, -471.4273f), new Vector3(-414.436f, -258.4754f, 450f), 
+                                              new Vector3(-391.7057f, -247.3996f, 624.7684f), new Vector3(-367.02f, -243.3199f, 785.9968f), new Vector3(-340.1696f, -245.6261f, 932.9791f), 
+                                              new Vector3(-310.9448f, -253.7078f, 1065.01f), new Vector3(-279.1362f, -266.9548f, 1181.382f), new Vector3(-244.5344f, -284.7567f, 1281.391f), 
+                                              new Vector3(-206.9297f, -306.5031f, 1364.331f), new Vector3(-166.1128f, -331.5838f, 1429.494f), new Vector3(-121.8741f, -359.3886f, 1476.177f), 
+                                              new Vector3(-74.00427f, -389.3071f, 1503.672f), new Vector3(-22.29352f, -420.7289f, 1511.274f), new Vector3(33.46759f, -453.0438f, 1498.277f), 
+                                              new Vector3(93.48828f, -485.6415f, 1463.974f), new Vector3(157.9784f, -517.9116f, 1407.661f), new Vector3(227.1472f, -549.244f, 1328.632f), 
+                                              new Vector3(301.2041f, -579.0281f, 1226.179f), new Vector3(380.359f, -606.6538f, 1099.598f), new Vector3(464.8212f, -631.5105f, 948.1818f), 
+                                              new Vector3(554.8f, -652.9883f, 771.2255f), new Vector3(650.505f, -670.4767f, 568.0228f), new Vector3(752.1458f, -683.3653f, 337.8679f), 
+                                              new Vector3(859.9318f, -691.0439f, 80.05496f), new Vector3(974.0726f, -692.9023f, -206.1222f), new Vector3(1094.778f, -688.3298f, -521.3693f), 
+                                              new Vector3(-336.3317f, -282.0414f, 450f), new Vector3(-310.3472f, -280.9655f, 634.5073f), new Vector3(-282.1275f, -283.4662f, 804.7198f), 
+                                              new Vector3(-251.433f, -289.2901f, 959.8927f), new Vector3(-218.0244f, -298.1837f, 1099.28f), new Vector3(-181.662f, -309.8937f, 1222.138f), 
+                                              new Vector3(-142.1065f, -324.1669f, 1327.719f), new Vector3(-99.11841f, -340.7496f, 1415.281f), new Vector3(-52.45789f, -359.3886f, 1484.076f), 
+                                              new Vector3(-1.885864f, -379.8306f, 1533.359f), new Vector3(52.8371f, -401.822f, 1562.387f), new Vector3(111.9509f, -425.1097f, 1570.412f), 
+                                              new Vector3(175.6948f, -449.44f, 1556.691f), new Vector3(244.3083f, -474.5598f, 1520.477f), new Vector3(318.0309f, -500.2157f, 1461.026f), 
+                                              new Vector3(397.1021f, -526.1542f, 1377.593f), new Vector3(481.7614f, -552.122f, 1269.431f), new Vector3(572.248f, -577.8657f, 1135.796f), 
+                                              new Vector3(668.8021f, -603.1319f, 975.9424f), new Vector3(771.6625f, -627.6672f, 789.1255f), new Vector3(881.0687f, -651.2183f, 574.5996f), 
+                                              new Vector3(997.2607f, -673.5317f, 331.6195f), new Vector3(1120.478f, -694.3542f, 59.44006f), new Vector3(1250.959f, -713.4325f, -242.684f), 
+                                              new Vector3(1388.945f, -730.5129f, -575.498f), new Vector3(-255.0688f, -307.4372f, 450f), new Vector3(-225.6985f, -317.1153f, 645.0454f), 
+                                              new Vector3(-193.8018f, -326.691f, 824.9799f), new Vector3(-159.108f, -336.2949f, 989.0154f), new Vector3(-121.3462f, -346.0575f, 1136.364f), 
+                                              new Vector3(-80.24585f, -356.1096f, 1266.239f), new Vector3(-35.53644f, -366.5815f, 1377.851f), new Vector3(13.0531f, -377.6037f, 1470.413f), 
+                                              new Vector3(65.79321f, -389.3071f, 1543.137f), new Vector3(122.9547f, -401.8221f, 1595.236f), new Vector3(184.808f, -415.2792f, 1625.921f), 
+                                              new Vector3(251.6244f, -429.809f, 1634.405f), new Vector3(323.674f, -445.5421f, 1619.9f), new Vector3(401.2275f, -462.6091f, 1581.618f), 
+                                              new Vector3(484.556f, -481.1404f, 1518.771f), new Vector3(573.9302f, -501.2668f, 1430.572f), new Vector3(669.6201f, -523.1188f, 1316.233f), 
+                                              new Vector3(771.8975f, -546.8269f, 1174.965f), new Vector3(881.0321f, -572.5217f, 1005.982f), new Vector3(997.2953f, -600.3337f, 808.4948f), 
+                                              new Vector3(1120.957f, -630.3936f, 581.7161f), new Vector3(1252.289f, -662.8319f, 324.8581f), new Vector3(1391.561f, -697.7792f, 37.13315f), 
+                                              new Vector3(1539.044f, -735.3659f, -282.2469f), new Vector3(1695.008f, -775.7228f, -634.0696f), new Vector3(-170.36f, -332.4612f, 450f), 
+                                              new Vector3(-137.4605f, -353.7005f, 656.4292f), new Vector3(-101.7308f, -370.9456f, 846.8654f), new Vector3(-62.86792f, -384.7358f, 1020.475f), 
+                                              new Vector3(-20.56848f, -395.61f, 1176.424f), new Vector3(25.47058f, -404.1073f, 1313.878f), new Vector3(75.55273f, -410.7669f, 1432.005f), 
+                                              new Vector3(129.9811f, -416.1277f, 1529.969f), new Vector3(189.0587f, -420.7289f, 1606.938f), new Vector3(253.0891f, -425.1096f, 1662.077f), 
+                                              new Vector3(322.375f, -429.809f, 1694.553f), new Vector3(397.2205f, -435.3659f, 1703.533f), new Vector3(477.9279f, -442.3196f, 1688.181f), 
+                                              new Vector3(564.8009f, -451.2092f, 1647.664f), new Vector3(658.1428f, -462.5737f, 1581.15f), new Vector3(758.2566f, -476.9522f, 1487.803f), 
+                                              new Vector3(865.4453f, -494.8838f, 1366.79f), new Vector3(980.0127f, -516.9076f, 1217.278f), new Vector3(1102.262f, -543.5627f, 1038.431f), 
+                                              new Vector3(1232.496f, -575.3883f, 829.4182f), new Vector3(1371.018f, -612.9233f, 589.4037f), new Vector3(1518.13f, -656.7067f, 317.5542f), 
+                                              new Vector3(1674.138f, -707.278f, 13.03625f), new Vector3(1839.344f, -765.1759f, -324.9842f), new Vector3(2014.05f, -830.9396f, -697.3408f), 
+                                              new Vector3(-81.91852f, -354.9118f, 450f), new Vector3(-45.33423f, -388.573f, 668.7046f), new Vector3(-5.602783f, -414.1818f, 870.4651f), 
+                                              new Vector3(37.61285f, -432.7081f, 1054.398f), new Vector3(84.6499f, -445.1217f, 1219.621f), new Vector3(135.8456f, -452.3924f, 1365.249f), 
+                                              new Vector3(191.537f, -455.4897f, 1490.4f), new Vector3(252.0615f, -455.3836f, 1594.19f), new Vector3(317.7561f, -453.0438f, 1675.736f), 
+                                              new Vector3(388.9578f, -449.44f, 1734.154f), new Vector3(466.0039f, -445.5421f, 1768.561f), new Vector3(549.2321f, -442.3196f, 1778.074f), 
+                                              new Vector3(638.9791f, -440.7425f, 1761.81f), new Vector3(735.582f, -441.7805f, 1718.884f), new Vector3(839.3785f, -446.4033f, 1648.414f), 
+                                              new Vector3(950.7053f, -455.5806f, 1549.516f), new Vector3(1069.899f, -470.2822f, 1421.307f), new Vector3(1197.299f, -491.478f, 1262.904f), 
+                                              new Vector3(1333.24f, -520.1377f, 1073.423f), new Vector3(1478.06f, -557.231f, 851.9805f), new Vector3(1632.097f, -603.7275f, 597.6934f), 
+                                              new Vector3(1795.687f, -660.5974f, 309.6783f), new Vector3(1969.168f, -728.8099f, -12.94794f), new Vector3(2152.877f, -809.3352f, -371.0689f), 
+                                              new Vector3(2347.15f, -903.1429f, -765.5679f), new Vector3(10.5426f, -372.5878f, 450f), new Vector3(50.97919f, -419.5845f, 681.9177f), 
+                                              new Vector3(94.89441f, -454.3509f, 895.8677f), new Vector3(142.6605f, -478.3073f, 1090.913f), new Vector3(194.6506f, -492.8735f, 1266.118f), 
+                                              new Vector3(251.2371f, -499.47f, 1420.544f), new Vector3(312.7927f, -499.5167f, 1553.256f), new Vector3(379.6903f, -494.4338f, 1663.316f), 
+                                              new Vector3(452.3025f, -485.6415f, 1749.789f), new Vector3(531.002f, -474.5598f, 1811.736f), new Vector3(616.1609f, -462.6091f, 1848.222f), 
+                                              new Vector3(708.153f, -451.2092f, 1858.31f), new Vector3(807.3502f, -441.7805f, 1841.063f), new Vector3(914.125f, -435.743f, 1795.544f), 
+                                              new Vector3(1028.851f, -434.5169f, 1720.817f), new Vector3(1151.901f, -439.5222f, 1615.944f), new Vector3(1283.646f, -452.1794f, 1479.989f), 
+                                              new Vector3(1424.46f, -473.9081f, 1312.016f), new Vector3(1574.716f, -506.1291f, 1111.087f), new Vector3(1734.786f, -550.262f, 876.2661f), 
+                                              new Vector3(1905.042f, -607.7271f, 606.6163f), new Vector3(2085.858f, -679.9447f, 301.2007f), new Vector3(2277.606f, -768.3347f, -40.91705f), 
+                                              new Vector3(2480.66f, -874.3173f, -420.674f), new Vector3(2695.39f, -999.3129f, -839.0068f), new Vector3(107.3107f, -383.2874f, 450f), 
+                                              new Vector3(151.7789f, -444.5869f, 696.1147f), new Vector3(200.0726f, -489.4046f, 923.1617f), new Vector3(252.6014f, -519.6285f, 1130.147f), 
+                                              new Vector3(309.7753f, -537.1461f, 1316.077f), new Vector3(372.0037f, -543.8455f, 1479.957f), new Vector3(439.6968f, -541.6143f, 1620.792f), 
+                                              new Vector3(513.2643f, -532.3405f, 1737.59f), new Vector3(593.1163f, -517.9116f, 1829.357f), new Vector3(679.6622f, -500.2157f, 1895.096f), 
+                                              new Vector3(773.3121f, -481.1405f, 1933.815f), new Vector3(874.4763f, -462.5737f, 1944.521f), new Vector3(983.564f, -446.4033f, 1926.218f), 
+                                              new Vector3(1100.985f, -434.5168f, 1877.913f), new Vector3(1227.15f, -428.8024f, 1798.611f), new Vector3(1362.468f, -431.1476f, 1687.318f), 
+                                              new Vector3(1507.349f, -443.4403f, 1543.041f), new Vector3(1662.203f, -467.5683f, 1364.785f), new Vector3(1827.44f, -505.4195f, 1151.556f), 
+                                              new Vector3(2003.469f, -558.8816f, 902.3604f), new Vector3(2190.701f, -629.8425f, 616.2037f), new Vector3(2389.545f, -720.1898f, 292.0919f), 
+                                              new Vector3(2600.412f, -831.8114f, -70.96887f), new Vector3(2823.711f, -966.5953f, -473.9731f), new Vector3(3059.852f, -1126.429f, -917.9146f), 
+                                              new Vector3(208.6725f, -384.8093f, 450f), new Vector3(257.364f, -461.4319f, 711.3417f), new Vector3(310.2441f, -517.2945f, 952.4361f), 
+                                              new Vector3(367.7614f, -554.7671f, 1172.228f), new Vector3(430.3651f, -576.2203f, 1369.661f), new Vector3(498.5032f, -584.0242f, 1543.68f), 
+                                              new Vector3(572.6251f, -580.5492f, 1693.229f), new Vector3(653.1793f, -568.1657f, 1817.253f), new Vector3(740.6149f, -549.244f, 1914.697f), 
+                                              new Vector3(835.38f, -526.1542f, 1984.504f), new Vector3(937.9237f, -501.2668f, 2025.618f), new Vector3(1048.695f, -476.9522f, 2036.987f), 
+                                              new Vector3(1168.143f, -455.5806f, 2017.551f), new Vector3(1296.716f, -439.5222f, 1966.257f), new Vector3(1434.862f, -431.1476f, 1882.049f), 
+                                              new Vector3(1583.031f, -432.8267f, 1763.871f), new Vector3(1741.671f, -446.9304f, 1610.667f), new Vector3(1911.232f, -475.8285f, 1421.382f), 
+                                              new Vector3(2092.161f, -521.8916f, 1194.961f), new Vector3(2284.908f, -587.4899f, 930.3478f), new Vector3(2489.921f, -674.9938f, 626.4867f), 
+                                              new Vector3(2707.65f, -786.7737f, 282.3222f), new Vector3(2938.542f, -925.1996f, -103.201f), new Vector3(3183.048f, -1092.642f, -531.1388f), 
+                                              new Vector3(3441.614f, -1291.472f, -1002.547f), new Vector3(314.9149f, -374.9518f, 450f), new Vector3(368.0328f, -467.9713f, 727.6448f), 
+                                              new Vector3(425.7205f, -535.9717f, 983.7792f), new Vector3(488.4664f, -581.8184f, 1217.282f), new Vector3(556.7612f, -608.3765f, 1427.031f), 
+                                              new Vector3(631.0938f, -618.5112f, 1611.906f), new Vector3(711.9537f, -615.0878f, 1770.785f), new Vector3(799.8314f, -600.9718f, 1902.546f), 
+                                              new Vector3(895.2156f, -579.0281f, 2006.068f), new Vector3(998.5957f, -552.122f, 2080.229f), new Vector3(1110.461f, -523.1188f, 2123.909f), 
+                                              new Vector3(1231.303f, -494.8838f, 2135.986f), new Vector3(1361.61f, -470.2823f, 2115.339f), new Vector3(1501.871f, -452.1794f, 2060.845f), 
+                                              new Vector3(1652.576f, -443.4403f, 1971.383f), new Vector3(1814.215f, -446.9305f, 1845.833f), new Vector3(1987.277f, -465.5149f, 1683.072f), 
+                                              new Vector3(2172.252f, -502.0591f, 1481.979f), new Vector3(2369.629f, -559.4282f, 1241.433f), new Vector3(2579.898f, -640.4875f, 960.3129f), 
+                                              new Vector3(2803.549f, -748.1023f, 637.4963f), new Vector3(3041.071f, -885.1376f, 271.862f), new Vector3(3292.953f, -1054.459f, -137.7109f), 
+                                              new Vector3(3559.687f, -1258.931f, -592.3446f), new Vector3(3841.76f, -1501.42f, -1093.16f), new Vector3(426.3254f, -351.5135f, 450f), 
+                                              new Vector3(484.0851f, -462.0568f, 745.0702f), new Vector3(546.8136f, -543.3882f, 1017.28f), new Vector3(615.043f, -598.8778f, 1265.438f), 
+                                              new Vector3(689.3058f, -631.8956f, 1488.351f), new Vector3(770.134f, -645.812f, 1684.828f), new Vector3(858.0602f, -643.997f, 1853.679f), 
+                                              new Vector3(953.6171f, -629.8209f, 1993.709f), new Vector3(1057.336f, -606.6537f, 2103.729f), new Vector3(1169.75f, -577.8657f, 2182.545f), 
+                                              new Vector3(1291.392f, -546.8269f, 2228.966f), new Vector3(1422.794f, -516.9076f, 2241.801f), new Vector3(1564.487f, -491.478f, 2219.857f), 
+                                              new Vector3(1717.005f, -473.9082f, 2161.943f), new Vector3(1880.88f, -467.5683f, 2066.867f), new Vector3(2056.644f, -475.8285f, 1933.437f), 
+                                              new Vector3(2244.829f, -502.0591f, 1760.461f), new Vector3(2445.969f, -549.63f, 1546.748f), new Vector3(2660.594f, -621.9119f, 1291.105f), 
+                                              new Vector3(2889.238f, -722.2742f, 992.3408f), new Vector3(3132.433f, -854.0877f, 649.2638f), new Vector3(3390.711f, -1020.722f, 260.6819f), 
+                                              new Vector3(3664.604f, -1225.548f, -174.5965f), new Vector3(3954.646f, -1471.936f, -657.7634f), new Vector3(4261.368f, -1763.255f, -1190.011f), 
+                                              new Vector3(543.1907f, -312.2928f, 450f), new Vector3(605.8193f, -441.5403f, 763.6639f), new Vector3(673.8359f, -537.4953f, 1053.027f), 
+                                              new Vector3(747.8169f, -604.0405f, 1316.822f), new Vector3(828.3401f, -645.0583f, 1553.782f), new Vector3(915.9818f, -664.4316f, 1762.641f), 
+                                              new Vector3(1011.32f, -666.0431f, 1942.131f), new Vector3(1114.932f, -653.7752f, 2090.985f), new Vector3(1227.395f, -631.5105f, 2207.938f), 
+                                              new Vector3(1349.285f, -603.1318f, 2291.72f), new Vector3(1481.181f, -572.5217f, 2341.067f), new Vector3(1623.66f, -543.5628f, 2354.71f), 
+                                              new Vector3(1777.298f, -520.1377f, 2331.384f), new Vector3(1942.673f, -506.129f, 2269.821f), new Vector3(2120.362f, -505.4195f, 2168.753f), 
+                                              new Vector3(2310.943f, -521.8917f, 2026.915f), new Vector3(2514.992f, -559.4282f, 1843.039f), new Vector3(2733.087f, -621.9118f, 1615.859f), 
+                                              new Vector3(2965.805f, -713.2252f, 1344.107f), new Vector3(3213.724f, -837.2505f, 1026.516f), new Vector3(3477.419f, -997.8711f, 661.8203f), 
+                                              new Vector3(3757.47f, -1198.969f, 248.7521f), new Vector3(4054.452f, -1444.427f, -213.9551f), new Vector3(4368.944f, -1738.129f, -727.5686f), 
+                                              new Vector3(4701.522f, -2083.955f, -1293.355f), new Vector3(665.7977f, -255.0883f, 450f), new Vector3(733.5349f, -404.2734f, 783.472f), 
+                                              new Vector3(807.0991f, -516.2445f, 1091.109f), new Vector3(887.1143f, -595.4019f, 1371.563f), new Vector3(974.2052f, -646.1454f, 1623.487f), 
+                                              new Vector3(1068.996f, -672.8757f, 1845.536f), new Vector3(1172.11f, -679.9928f, 2036.36f), new Vector3(1284.173f, -671.897f, 2194.615f), 
+                                              new Vector3(1405.809f, -652.9884f, 2318.953f), new Vector3(1537.642f, -627.6672f, 2408.027f), new Vector3(1680.295f, -600.3337f, 2460.489f), 
+                                              new Vector3(1834.395f, -575.3883f, 2474.995f), new Vector3(2000.564f, -557.231f, 2450.195f), new Vector3(2179.428f, -550.262f, 2384.744f), 
+                                              new Vector3(2371.611f, -558.8816f, 2277.294f), new Vector3(2577.736f, -587.4899f, 2126.499f), new Vector3(2798.428f, -640.4874f, 1931.011f), 
+                                              new Vector3(3034.312f, -722.2742f, 1689.484f), new Vector3(3286.012f, -837.2506f, 1400.571f), new Vector3(3554.151f, -989.8167f, 1062.924f), 
+                                              new Vector3(3839.355f, -1184.373f, 675.197f), new Vector3(4142.248f, -1425.319f, 236.0432f), new Vector3(4463.454f, -1717.056f, -255.8846f), 
+                                              new Vector3(4803.598f, -2063.983f, -801.9333f), new Vector3(5163.302f, -2470.501f, -1403.45f), new Vector3(794.4337f, -177.6983f, 450f), 
+                                              new Vector3(867.5303f, -348.108f, 804.5408f), new Vector3(946.915f, -477.5874f, 1131.614f), new Vector3(1033.261f, -571.0571f, 1429.787f), 
+                                              new Vector3(1127.243f, -633.4376f, 1697.628f), new Vector3(1229.533f, -669.6492f, 1933.705f), new Vector3(1340.806f, -684.6125f, 2136.586f), 
+                                              new Vector3(1461.736f, -683.2484f, 2304.84f), new Vector3(1592.996f, -670.4767f, 2437.034f), new Vector3(1735.259f, -651.2183f, 2531.735f), 
+                                              new Vector3(1889.2f, -630.3936f, 2587.512f), new Vector3(2055.492f, -612.9232f, 2602.934f), new Vector3(2234.81f, -603.7275f, 2576.568f), 
+                                              new Vector3(2427.825f, -607.7272f, 2506.981f), new Vector3(2635.214f, -629.8425f, 2392.743f), new Vector3(2857.648f, -674.9938f, 2232.42f), 
+                                              new Vector3(3095.801f, -748.1022f, 2024.581f), new Vector3(3350.349f, -854.0876f, 1767.795f), new Vector3(3621.964f, -997.8712f, 1460.627f), 
+                                              new Vector3(3911.319f, -1184.373f, 1101.648f), new Vector3(4219.089f, -1418.513f, 689.4248f), new Vector3(4545.947f, -1705.213f, 222.5253f), 
+                                              new Vector3(4892.567f, -2049.392f, -300.4824f), new Vector3(5259.624f, -2455.972f, -881.0305f), new Vector3(5647.789f, -2929.873f, -1520.551f), 
+                                              new Vector3(929.3855f, -77.92139f, 450f), new Vector3(1008.105f, -270.8958f, 826.9163f), new Vector3(1093.595f, -419.4755f, 1174.631f), 
+                                              new Vector3(1186.584f, -529.1018f, 1491.622f), new Vector3(1287.794f, -605.2153f, 1776.367f), new Vector3(1397.953f, -653.2574f, 2027.344f), 
+                                              new Vector3(1517.785f, -678.6691f, 2243.029f), new Vector3(1648.017f, -686.8915f, 2421.901f), new Vector3(1789.373f, -683.3653f, 2562.437f), 
+                                              new Vector3(1942.58f, -673.5318f, 2663.116f), new Vector3(2108.362f, -662.8319f, 2722.413f), new Vector3(2287.445f, -656.7067f, 2738.808f), 
+                                              new Vector3(2480.556f, -660.5974f, 2710.778f), new Vector3(2688.418f, -679.9446f, 2636.799f), new Vector3(2911.759f, -720.1898f, 2515.351f), 
+                                              new Vector3(3151.303f, -786.7738f, 2344.911f), new Vector3(3407.775f, -885.1376f, 2123.955f), new Vector3(3681.903f, -1020.722f, 1850.962f), 
+                                              new Vector3(3974.41f, -1198.969f, 1524.409f), new Vector3(4286.023f, -1425.319f, 1142.775f), new Vector3(4617.467f, -1705.213f, 704.5354f), 
+                                              new Vector3(4969.467f, -2044.092f, 208.1691f), new Vector3(5342.749f, -2447.397f, -347.8462f), new Vector3(5738.04f, -2920.569f, -965.0332f), 
+                                              new Vector3(6156.063f, -3469.05f, -1644.915f), new Vector3(1070.94f, 46.44388f, 450f), new Vector3(1155.557f, -170.4886f, 850.6446f), 
+                                              new Vector3(1247.453f, -339.8603f, 1220.249f), new Vector3(1347.408f, -467.6309f, 1557.196f), new Vector3(1456.202f, -559.7596f, 1859.867f), 
+                                              new Vector3(1574.613f, -622.2058f, 2126.643f), new Vector3(1703.424f, -660.9291f, 2355.907f), new Vector3(1843.412f, -681.8887f, 2546.04f), 
+                                              new Vector3(1995.359f, -691.0439f, 2695.423f), new Vector3(2160.044f, -694.3543f, 2802.44f), new Vector3(2338.246f, -697.7792f, 2865.47f), 
+                                              new Vector3(2530.748f, -707.278f, 2882.897f), new Vector3(2738.326f, -728.8099f, 2853.103f), new Vector3(2961.761f, -768.3347f, 2774.467f), 
+                                              new Vector3(3201.835f, -831.8114f, 2645.373f), new Vector3(3459.326f, -925.1996f, 2464.202f), new Vector3(3735.014f, -1054.459f, 2229.337f), 
+                                              new Vector3(4029.679f, -1225.548f, 1939.158f), new Vector3(4344.102f, -1444.427f, 1592.048f), new Vector3(4679.061f, -1717.056f, 1186.387f), 
+                                              new Vector3(5035.337f, -2049.392f, 720.5594f), new Vector3(5413.709f, -2447.397f, 192.9449f), new Vector3(5814.958f, -2917.029f, -398.0735f), 
+                                              new Vector3(6239.864f, -3464.248f, -1054.115f), new Vector3(6689.206f, -4095.012f, -1776.797f), new Vector3(1219.385f, 197.5991f, 450f), 
+                                              new Vector3(1310.187f, -44.73807f, 875.7719f), new Vector3(1408.8f, -236.6934f, 1268.557f), new Vector3(1516.061f, -384.7401f, 1626.637f), 
+                                              new Vector3(1632.806f, -495.3511f, 1948.29f), new Vector3(1759.873f, -574.9996f, 2231.797f), new Vector3(1898.098f, -630.1589f, 2475.44f), 
+                                              new Vector3(2048.318f, -667.3021f, 2677.497f), new Vector3(2211.372f, -692.9023f, 2836.25f), new Vector3(2388.093f, -713.4325f, 2949.978f), 
+                                              new Vector3(2579.321f, -735.366f, 3016.961f), new Vector3(2785.892f, -765.1758f, 3035.481f), new Vector3(3008.643f, -809.3352f, 3003.818f), 
+                                              new Vector3(3248.41f, -874.3174f, 2920.251f), new Vector3(3506.031f, -966.5953f, 2783.061f), new Vector3(3782.342f, -1092.642f, 2590.528f), 
+                                              new Vector3(4078.181f, -1258.931f, 2340.932f), new Vector3(4394.383f, -1471.936f, 2032.554f), new Vector3(4731.787f, -1738.129f, 1663.673f), 
+                                              new Vector3(5091.229f, -2063.983f, 1232.571f), new Vector3(5473.546f, -2455.972f, 737.528f), new Vector3(5879.574f, -2920.569f, 176.8232f), 
+                                              new Vector3(6310.151f, -3464.248f, -451.2623f), new Vector3(6766.114f, -4093.48f, -1148.449f), new Vector3(7248.299f, -4814.74f, -1916.456f), 
+                                              new Vector3(1375.007f, 377.7458f, 450f), new Vector3(1472.292f, 108.5038f, 902.3442f), new Vector3(1577.947f, -107.9262f, 1319.643f), 
+                                              new Vector3(1692.866f, -278.5244f, 1700.07f), new Vector3(1817.948f, -410.2704f, 2041.798f), new Vector3(1954.088f, -510.144f, 2342.999f), 
+                                              new Vector3(2102.184f, -585.1252f, 2601.847f), new Vector3(2263.131f, -642.194f, 2816.515f), new Vector3(2437.827f, -688.3298f, 2985.175f), 
+                                              new Vector3(2627.168f, -730.5129f, 3106.001f), new Vector3(2832.05f, -775.7228f, 3177.165f), new Vector3(3053.372f, -830.9396f, 3196.841f), 
+                                              new Vector3(3292.028f, -903.1429f, 3163.201f), new Vector3(3548.916f, -999.3129f, 3074.418f), new Vector3(3824.933f, -1126.429f, 2928.667f), 
+                                              new Vector3(4120.975f, -1291.472f, 2724.117f), new Vector3(4437.938f, -1501.42f, 2458.944f), new Vector3(4776.719f, -1763.255f, 2131.32f), 
+                                              new Vector3(5138.216f, -2083.955f, 1739.418f), new Vector3(5523.324f, -2470.501f, 1281.411f), new Vector3(5932.941f, -2929.873f, 755.4725f), 
+                                              new Vector3(6367.962f, -3469.05f, 159.7743f), new Vector3(6829.285f, -4095.012f, -507.51f), new Vector3(7317.807f, -4814.74f, -1248.208f), 
+                                              new Vector3(7834.423f, -5635.212f, -2064.146f) };
+
+        static Vector2[] meshTextures = new Vector2[] { new Vector2(0f, 0f), new Vector2(0f, 0.04f), new Vector2(0f, 0.08f), new Vector2(0f, 0.12f), new Vector2(0f, 0.16f), new Vector2(0f, 0.2f), 
+                                             new Vector2(0f, 0.24f), new Vector2(0f, 0.28f), new Vector2(0f, 0.32f), new Vector2(0f, 0.36f), new Vector2(0f, 0.4f), new Vector2(0f, 0.44f), 
+                                             new Vector2(0f, 0.48f), new Vector2(0f, 0.52f), new Vector2(0f, 0.56f), new Vector2(0f, 0.6f), new Vector2(0f, 0.64f), new Vector2(0f, 0.68f), 
+                                             new Vector2(0f, 0.72f), new Vector2(0f, 0.76f), new Vector2(0f, 0.8f), new Vector2(0f, 0.84f), new Vector2(0f, 0.88f), new Vector2(0f, 0.92f), 
+                                             new Vector2(0f, 0.96f), new Vector2(0.04f, 0f), new Vector2(0.04f, 0.04f), new Vector2(0.04f, 0.08f), new Vector2(0.04f, 0.12f), new Vector2(0.04f, 0.16f), 
+                                             new Vector2(0.04f, 0.2f), new Vector2(0.04f, 0.24f), new Vector2(0.04f, 0.28f), new Vector2(0.04f, 0.32f), new Vector2(0.04f, 0.36f), new Vector2(0.04f, 0.4f), 
+                                             new Vector2(0.04f, 0.44f), new Vector2(0.04f, 0.48f), new Vector2(0.04f, 0.52f), new Vector2(0.04f, 0.56f), new Vector2(0.04f, 0.6f), new Vector2(0.04f, 0.64f), 
+                                             new Vector2(0.04f, 0.68f), new Vector2(0.04f, 0.72f), new Vector2(0.04f, 0.76f), new Vector2(0.04f, 0.8f), new Vector2(0.04f, 0.84f), new Vector2(0.04f, 0.88f), 
+                                             new Vector2(0.04f, 0.92f), new Vector2(0.04f, 0.96f), new Vector2(0.08f, 0f), new Vector2(0.08f, 0.04f), new Vector2(0.08f, 0.08f), new Vector2(0.08f, 0.12f), 
+                                             new Vector2(0.08f, 0.16f), new Vector2(0.08f, 0.2f), new Vector2(0.08f, 0.24f), new Vector2(0.08f, 0.28f), new Vector2(0.08f, 0.32f), new Vector2(0.08f, 0.36f), 
+                                             new Vector2(0.08f, 0.4f), new Vector2(0.08f, 0.44f), new Vector2(0.08f, 0.48f), new Vector2(0.08f, 0.52f), new Vector2(0.08f, 0.56f), new Vector2(0.08f, 0.6f), 
+                                             new Vector2(0.08f, 0.64f), new Vector2(0.08f, 0.68f), new Vector2(0.08f, 0.72f), new Vector2(0.08f, 0.76f), new Vector2(0.08f, 0.8f), new Vector2(0.08f, 0.84f), 
+                                             new Vector2(0.08f, 0.88f), new Vector2(0.08f, 0.92f), new Vector2(0.08f, 0.96f), new Vector2(0.12f, 0f), new Vector2(0.12f, 0.04f), new Vector2(0.12f, 0.08f), 
+                                             new Vector2(0.12f, 0.12f), new Vector2(0.12f, 0.16f), new Vector2(0.12f, 0.2f), new Vector2(0.12f, 0.24f), new Vector2(0.12f, 0.28f), new Vector2(0.12f, 0.32f), 
+                                             new Vector2(0.12f, 0.36f), new Vector2(0.12f, 0.4f), new Vector2(0.12f, 0.44f), new Vector2(0.12f, 0.48f), new Vector2(0.12f, 0.52f), new Vector2(0.12f, 0.56f), 
+                                             new Vector2(0.12f, 0.6f), new Vector2(0.12f, 0.64f), new Vector2(0.12f, 0.68f), new Vector2(0.12f, 0.72f), new Vector2(0.12f, 0.76f), new Vector2(0.12f, 0.8f), 
+                                             new Vector2(0.12f, 0.84f), new Vector2(0.12f, 0.88f), new Vector2(0.12f, 0.92f), new Vector2(0.12f, 0.96f), new Vector2(0.16f, 0f), new Vector2(0.16f, 0.04f), 
+                                             new Vector2(0.16f, 0.08f), new Vector2(0.16f, 0.12f), new Vector2(0.16f, 0.16f), new Vector2(0.16f, 0.2f), new Vector2(0.16f, 0.24f), new Vector2(0.16f, 0.28f), 
+                                             new Vector2(0.16f, 0.32f), new Vector2(0.16f, 0.36f), new Vector2(0.16f, 0.4f), new Vector2(0.16f, 0.44f), new Vector2(0.16f, 0.48f), new Vector2(0.16f, 0.52f), 
+                                             new Vector2(0.16f, 0.56f), new Vector2(0.16f, 0.6f), new Vector2(0.16f, 0.64f), new Vector2(0.16f, 0.68f), new Vector2(0.16f, 0.72f), new Vector2(0.16f, 0.76f), 
+                                             new Vector2(0.16f, 0.8f), new Vector2(0.16f, 0.84f), new Vector2(0.16f, 0.88f), new Vector2(0.16f, 0.92f), new Vector2(0.16f, 0.96f), new Vector2(0.2f, 0f), 
+                                             new Vector2(0.2f, 0.04f), new Vector2(0.2f, 0.08f), new Vector2(0.2f, 0.12f), new Vector2(0.2f, 0.16f), new Vector2(0.2f, 0.2f), new Vector2(0.2f, 0.24f), 
+                                             new Vector2(0.2f, 0.28f), new Vector2(0.2f, 0.32f), new Vector2(0.2f, 0.36f), new Vector2(0.2f, 0.4f), new Vector2(0.2f, 0.44f), new Vector2(0.2f, 0.48f), 
+                                             new Vector2(0.2f, 0.52f), new Vector2(0.2f, 0.56f), new Vector2(0.2f, 0.6f), new Vector2(0.2f, 0.64f), new Vector2(0.2f, 0.68f), new Vector2(0.2f, 0.72f), 
+                                             new Vector2(0.2f, 0.76f), new Vector2(0.2f, 0.8f), new Vector2(0.2f, 0.84f), new Vector2(0.2f, 0.88f), new Vector2(0.2f, 0.92f), new Vector2(0.2f, 0.96f), 
+                                             new Vector2(0.24f, 0f), new Vector2(0.24f, 0.04f), new Vector2(0.24f, 0.08f), new Vector2(0.24f, 0.12f), new Vector2(0.24f, 0.16f), new Vector2(0.24f, 0.2f), 
+                                             new Vector2(0.24f, 0.24f), new Vector2(0.24f, 0.28f), new Vector2(0.24f, 0.32f), new Vector2(0.24f, 0.36f), new Vector2(0.24f, 0.4f), new Vector2(0.24f, 0.44f), 
+                                             new Vector2(0.24f, 0.48f), new Vector2(0.24f, 0.52f), new Vector2(0.24f, 0.56f), new Vector2(0.24f, 0.6f), new Vector2(0.24f, 0.64f), new Vector2(0.24f, 0.68f), 
+                                             new Vector2(0.24f, 0.72f), new Vector2(0.24f, 0.76f), new Vector2(0.24f, 0.8f), new Vector2(0.24f, 0.84f), new Vector2(0.24f, 0.88f), new Vector2(0.24f, 0.92f), 
+                                             new Vector2(0.24f, 0.96f), new Vector2(0.28f, 0f), new Vector2(0.28f, 0.04f), new Vector2(0.28f, 0.08f), new Vector2(0.28f, 0.12f), new Vector2(0.28f, 0.16f), 
+                                             new Vector2(0.28f, 0.2f), new Vector2(0.28f, 0.24f), new Vector2(0.28f, 0.28f), new Vector2(0.28f, 0.32f), new Vector2(0.28f, 0.36f), new Vector2(0.28f, 0.4f), 
+                                             new Vector2(0.28f, 0.44f), new Vector2(0.28f, 0.48f), new Vector2(0.28f, 0.52f), new Vector2(0.28f, 0.56f), new Vector2(0.28f, 0.6f), new Vector2(0.28f, 0.64f), 
+                                             new Vector2(0.28f, 0.68f), new Vector2(0.28f, 0.72f), new Vector2(0.28f, 0.76f), new Vector2(0.28f, 0.8f), new Vector2(0.28f, 0.84f), new Vector2(0.28f, 0.88f), 
+                                             new Vector2(0.28f, 0.92f), new Vector2(0.28f, 0.96f), new Vector2(0.32f, 0f), new Vector2(0.32f, 0.04f), new Vector2(0.32f, 0.08f), new Vector2(0.32f, 0.12f), 
+                                             new Vector2(0.32f, 0.16f), new Vector2(0.32f, 0.2f), new Vector2(0.32f, 0.24f), new Vector2(0.32f, 0.28f), new Vector2(0.32f, 0.32f), new Vector2(0.32f, 0.36f), 
+                                             new Vector2(0.32f, 0.4f), new Vector2(0.32f, 0.44f), new Vector2(0.32f, 0.48f), new Vector2(0.32f, 0.52f), new Vector2(0.32f, 0.56f), new Vector2(0.32f, 0.6f), 
+                                             new Vector2(0.32f, 0.64f), new Vector2(0.32f, 0.68f), new Vector2(0.32f, 0.72f), new Vector2(0.32f, 0.76f), new Vector2(0.32f, 0.8f), new Vector2(0.32f, 0.84f), 
+                                             new Vector2(0.32f, 0.88f), new Vector2(0.32f, 0.92f), new Vector2(0.32f, 0.96f), new Vector2(0.36f, 0f), new Vector2(0.36f, 0.04f), new Vector2(0.36f, 0.08f), 
+                                             new Vector2(0.36f, 0.12f), new Vector2(0.36f, 0.16f), new Vector2(0.36f, 0.2f), new Vector2(0.36f, 0.24f), new Vector2(0.36f, 0.28f), new Vector2(0.36f, 0.32f), 
+                                             new Vector2(0.36f, 0.36f), new Vector2(0.36f, 0.4f), new Vector2(0.36f, 0.44f), new Vector2(0.36f, 0.48f), new Vector2(0.36f, 0.52f), new Vector2(0.36f, 0.56f), 
+                                             new Vector2(0.36f, 0.6f), new Vector2(0.36f, 0.64f), new Vector2(0.36f, 0.68f), new Vector2(0.36f, 0.72f), new Vector2(0.36f, 0.76f), new Vector2(0.36f, 0.8f), 
+                                             new Vector2(0.36f, 0.84f), new Vector2(0.36f, 0.88f), new Vector2(0.36f, 0.92f), new Vector2(0.36f, 0.96f), new Vector2(0.4f, 0f), new Vector2(0.4f, 0.04f), 
+                                             new Vector2(0.4f, 0.08f), new Vector2(0.4f, 0.12f), new Vector2(0.4f, 0.16f), new Vector2(0.4f, 0.2f), new Vector2(0.4f, 0.24f), new Vector2(0.4f, 0.28f), 
+                                             new Vector2(0.4f, 0.32f), new Vector2(0.4f, 0.36f), new Vector2(0.4f, 0.4f), new Vector2(0.4f, 0.44f), new Vector2(0.4f, 0.48f), new Vector2(0.4f, 0.52f), 
+                                             new Vector2(0.4f, 0.56f), new Vector2(0.4f, 0.6f), new Vector2(0.4f, 0.64f), new Vector2(0.4f, 0.68f), new Vector2(0.4f, 0.72f), new Vector2(0.4f, 0.76f), 
+                                             new Vector2(0.4f, 0.8f), new Vector2(0.4f, 0.84f), new Vector2(0.4f, 0.88f), new Vector2(0.4f, 0.92f), new Vector2(0.4f, 0.96f), new Vector2(0.44f, 0f), 
+                                             new Vector2(0.44f, 0.04f), new Vector2(0.44f, 0.08f), new Vector2(0.44f, 0.12f), new Vector2(0.44f, 0.16f), new Vector2(0.44f, 0.2f), new Vector2(0.44f, 0.24f), 
+                                             new Vector2(0.44f, 0.28f), new Vector2(0.44f, 0.32f), new Vector2(0.44f, 0.36f), new Vector2(0.44f, 0.4f), new Vector2(0.44f, 0.44f), new Vector2(0.44f, 0.48f), 
+                                             new Vector2(0.44f, 0.52f), new Vector2(0.44f, 0.56f), new Vector2(0.44f, 0.6f), new Vector2(0.44f, 0.64f), new Vector2(0.44f, 0.68f), new Vector2(0.44f, 0.72f), 
+                                             new Vector2(0.44f, 0.76f), new Vector2(0.44f, 0.8f), new Vector2(0.44f, 0.84f), new Vector2(0.44f, 0.88f), new Vector2(0.44f, 0.92f), new Vector2(0.44f, 0.96f), 
+                                             new Vector2(0.48f, 0f), new Vector2(0.48f, 0.04f), new Vector2(0.48f, 0.08f), new Vector2(0.48f, 0.12f), new Vector2(0.48f, 0.16f), new Vector2(0.48f, 0.2f), 
+                                             new Vector2(0.48f, 0.24f), new Vector2(0.48f, 0.28f), new Vector2(0.48f, 0.32f), new Vector2(0.48f, 0.36f), new Vector2(0.48f, 0.4f), new Vector2(0.48f, 0.44f), 
+                                             new Vector2(0.48f, 0.48f), new Vector2(0.48f, 0.52f), new Vector2(0.48f, 0.56f), new Vector2(0.48f, 0.6f), new Vector2(0.48f, 0.64f), new Vector2(0.48f, 0.68f), 
+                                             new Vector2(0.48f, 0.72f), new Vector2(0.48f, 0.76f), new Vector2(0.48f, 0.8f), new Vector2(0.48f, 0.84f), new Vector2(0.48f, 0.88f), new Vector2(0.48f, 0.92f), 
+                                             new Vector2(0.48f, 0.96f), new Vector2(0.52f, 0f), new Vector2(0.52f, 0.04f), new Vector2(0.52f, 0.08f), new Vector2(0.52f, 0.12f), new Vector2(0.52f, 0.16f), 
+                                             new Vector2(0.52f, 0.2f), new Vector2(0.52f, 0.24f), new Vector2(0.52f, 0.28f), new Vector2(0.52f, 0.32f), new Vector2(0.52f, 0.36f), new Vector2(0.52f, 0.4f), 
+                                             new Vector2(0.52f, 0.44f), new Vector2(0.52f, 0.48f), new Vector2(0.52f, 0.52f), new Vector2(0.52f, 0.56f), new Vector2(0.52f, 0.6f), new Vector2(0.52f, 0.64f), 
+                                             new Vector2(0.52f, 0.68f), new Vector2(0.52f, 0.72f), new Vector2(0.52f, 0.76f), new Vector2(0.52f, 0.8f), new Vector2(0.52f, 0.84f), new Vector2(0.52f, 0.88f), 
+                                             new Vector2(0.52f, 0.92f), new Vector2(0.52f, 0.96f), new Vector2(0.56f, 0f), new Vector2(0.56f, 0.04f), new Vector2(0.56f, 0.08f), new Vector2(0.56f, 0.12f), 
+                                             new Vector2(0.56f, 0.16f), new Vector2(0.56f, 0.2f), new Vector2(0.56f, 0.24f), new Vector2(0.56f, 0.28f), new Vector2(0.56f, 0.32f), new Vector2(0.56f, 0.36f), 
+                                             new Vector2(0.56f, 0.4f), new Vector2(0.56f, 0.44f), new Vector2(0.56f, 0.48f), new Vector2(0.56f, 0.52f), new Vector2(0.56f, 0.56f), new Vector2(0.56f, 0.6f), 
+                                             new Vector2(0.56f, 0.64f), new Vector2(0.56f, 0.68f), new Vector2(0.56f, 0.72f), new Vector2(0.56f, 0.76f), new Vector2(0.56f, 0.8f), new Vector2(0.56f, 0.84f), 
+                                             new Vector2(0.56f, 0.88f), new Vector2(0.56f, 0.92f), new Vector2(0.56f, 0.96f), new Vector2(0.6f, 0f), new Vector2(0.6f, 0.04f), new Vector2(0.6f, 0.08f), 
+                                             new Vector2(0.6f, 0.12f), new Vector2(0.6f, 0.16f), new Vector2(0.6f, 0.2f), new Vector2(0.6f, 0.24f), new Vector2(0.6f, 0.28f), new Vector2(0.6f, 0.32f), 
+                                             new Vector2(0.6f, 0.36f), new Vector2(0.6f, 0.4f), new Vector2(0.6f, 0.44f), new Vector2(0.6f, 0.48f), new Vector2(0.6f, 0.52f), new Vector2(0.6f, 0.56f), 
+                                             new Vector2(0.6f, 0.6f), new Vector2(0.6f, 0.64f), new Vector2(0.6f, 0.68f), new Vector2(0.6f, 0.72f), new Vector2(0.6f, 0.76f), new Vector2(0.6f, 0.8f), 
+                                             new Vector2(0.6f, 0.84f), new Vector2(0.6f, 0.88f), new Vector2(0.6f, 0.92f), new Vector2(0.6f, 0.96f), new Vector2(0.64f, 0f), new Vector2(0.64f, 0.04f), 
+                                             new Vector2(0.64f, 0.08f), new Vector2(0.64f, 0.12f), new Vector2(0.64f, 0.16f), new Vector2(0.64f, 0.2f), new Vector2(0.64f, 0.24f), new Vector2(0.64f, 0.28f), 
+                                             new Vector2(0.64f, 0.32f), new Vector2(0.64f, 0.36f), new Vector2(0.64f, 0.4f), new Vector2(0.64f, 0.44f), new Vector2(0.64f, 0.48f), new Vector2(0.64f, 0.52f), 
+                                             new Vector2(0.64f, 0.56f), new Vector2(0.64f, 0.6f), new Vector2(0.64f, 0.64f), new Vector2(0.64f, 0.68f), new Vector2(0.64f, 0.72f), new Vector2(0.64f, 0.76f), 
+                                             new Vector2(0.64f, 0.8f), new Vector2(0.64f, 0.84f), new Vector2(0.64f, 0.88f), new Vector2(0.64f, 0.92f), new Vector2(0.64f, 0.96f), new Vector2(0.68f, 0f), 
+                                             new Vector2(0.68f, 0.04f), new Vector2(0.68f, 0.08f), new Vector2(0.68f, 0.12f), new Vector2(0.68f, 0.16f), new Vector2(0.68f, 0.2f), new Vector2(0.68f, 0.24f), 
+                                             new Vector2(0.68f, 0.28f), new Vector2(0.68f, 0.32f), new Vector2(0.68f, 0.36f), new Vector2(0.68f, 0.4f), new Vector2(0.68f, 0.44f), new Vector2(0.68f, 0.48f), 
+                                             new Vector2(0.68f, 0.52f), new Vector2(0.68f, 0.56f), new Vector2(0.68f, 0.6f), new Vector2(0.68f, 0.64f), new Vector2(0.68f, 0.68f), new Vector2(0.68f, 0.72f), 
+                                             new Vector2(0.68f, 0.76f), new Vector2(0.68f, 0.8f), new Vector2(0.68f, 0.84f), new Vector2(0.68f, 0.88f), new Vector2(0.68f, 0.92f), new Vector2(0.68f, 0.96f), 
+                                             new Vector2(0.72f, 0f), new Vector2(0.72f, 0.04f), new Vector2(0.72f, 0.08f), new Vector2(0.72f, 0.12f), new Vector2(0.72f, 0.16f), new Vector2(0.72f, 0.2f), 
+                                             new Vector2(0.72f, 0.24f), new Vector2(0.72f, 0.28f), new Vector2(0.72f, 0.32f), new Vector2(0.72f, 0.36f), new Vector2(0.72f, 0.4f), new Vector2(0.72f, 0.44f), 
+                                             new Vector2(0.72f, 0.48f), new Vector2(0.72f, 0.52f), new Vector2(0.72f, 0.56f), new Vector2(0.72f, 0.6f), new Vector2(0.72f, 0.64f), new Vector2(0.72f, 0.68f), 
+                                             new Vector2(0.72f, 0.72f), new Vector2(0.72f, 0.76f), new Vector2(0.72f, 0.8f), new Vector2(0.72f, 0.84f), new Vector2(0.72f, 0.88f), new Vector2(0.72f, 0.92f), 
+                                             new Vector2(0.72f, 0.96f), new Vector2(0.76f, 0f), new Vector2(0.76f, 0.04f), new Vector2(0.76f, 0.08f), new Vector2(0.76f, 0.12f), new Vector2(0.76f, 0.16f), 
+                                             new Vector2(0.76f, 0.2f), new Vector2(0.76f, 0.24f), new Vector2(0.76f, 0.28f), new Vector2(0.76f, 0.32f), new Vector2(0.76f, 0.36f), new Vector2(0.76f, 0.4f), 
+                                             new Vector2(0.76f, 0.44f), new Vector2(0.76f, 0.48f), new Vector2(0.76f, 0.52f), new Vector2(0.76f, 0.56f), new Vector2(0.76f, 0.6f), new Vector2(0.76f, 0.64f), 
+                                             new Vector2(0.76f, 0.68f), new Vector2(0.76f, 0.72f), new Vector2(0.76f, 0.76f), new Vector2(0.76f, 0.8f), new Vector2(0.76f, 0.84f), new Vector2(0.76f, 0.88f), 
+                                             new Vector2(0.76f, 0.92f), new Vector2(0.76f, 0.96f), new Vector2(0.8f, 0f), new Vector2(0.8f, 0.04f), new Vector2(0.8f, 0.08f), new Vector2(0.8f, 0.12f), 
+                                             new Vector2(0.8f, 0.16f), new Vector2(0.8f, 0.2f), new Vector2(0.8f, 0.24f), new Vector2(0.8f, 0.28f), new Vector2(0.8f, 0.32f), new Vector2(0.8f, 0.36f), 
+                                             new Vector2(0.8f, 0.4f), new Vector2(0.8f, 0.44f), new Vector2(0.8f, 0.48f), new Vector2(0.8f, 0.52f), new Vector2(0.8f, 0.56f), new Vector2(0.8f, 0.6f), 
+                                             new Vector2(0.8f, 0.64f), new Vector2(0.8f, 0.68f), new Vector2(0.8f, 0.72f), new Vector2(0.8f, 0.76f), new Vector2(0.8f, 0.8f), new Vector2(0.8f, 0.84f), 
+                                             new Vector2(0.8f, 0.88f), new Vector2(0.8f, 0.92f), new Vector2(0.8f, 0.96f), new Vector2(0.84f, 0f), new Vector2(0.84f, 0.04f), new Vector2(0.84f, 0.08f), 
+                                             new Vector2(0.84f, 0.12f), new Vector2(0.84f, 0.16f), new Vector2(0.84f, 0.2f), new Vector2(0.84f, 0.24f), new Vector2(0.84f, 0.28f), new Vector2(0.84f, 0.32f), 
+                                             new Vector2(0.84f, 0.36f), new Vector2(0.84f, 0.4f), new Vector2(0.84f, 0.44f), new Vector2(0.84f, 0.48f), new Vector2(0.84f, 0.52f), new Vector2(0.84f, 0.56f), 
+                                             new Vector2(0.84f, 0.6f), new Vector2(0.84f, 0.64f), new Vector2(0.84f, 0.68f), new Vector2(0.84f, 0.72f), new Vector2(0.84f, 0.76f), new Vector2(0.84f, 0.8f), 
+                                             new Vector2(0.84f, 0.84f), new Vector2(0.84f, 0.88f), new Vector2(0.84f, 0.92f), new Vector2(0.84f, 0.96f), new Vector2(0.88f, 0f), new Vector2(0.88f, 0.04f), 
+                                             new Vector2(0.88f, 0.08f), new Vector2(0.88f, 0.12f), new Vector2(0.88f, 0.16f), new Vector2(0.88f, 0.2f), new Vector2(0.88f, 0.24f), new Vector2(0.88f, 0.28f), 
+                                             new Vector2(0.88f, 0.32f), new Vector2(0.88f, 0.36f), new Vector2(0.88f, 0.4f), new Vector2(0.88f, 0.44f), new Vector2(0.88f, 0.48f), new Vector2(0.88f, 0.52f), 
+                                             new Vector2(0.88f, 0.56f), new Vector2(0.88f, 0.6f), new Vector2(0.88f, 0.64f), new Vector2(0.88f, 0.68f), new Vector2(0.88f, 0.72f), new Vector2(0.88f, 0.76f), 
+                                             new Vector2(0.88f, 0.8f), new Vector2(0.88f, 0.84f), new Vector2(0.88f, 0.88f), new Vector2(0.88f, 0.92f), new Vector2(0.88f, 0.96f), new Vector2(0.92f, 0f), 
+                                             new Vector2(0.92f, 0.04f), new Vector2(0.92f, 0.08f), new Vector2(0.92f, 0.12f), new Vector2(0.92f, 0.16f), new Vector2(0.92f, 0.2f), new Vector2(0.92f, 0.24f), 
+                                             new Vector2(0.92f, 0.28f), new Vector2(0.92f, 0.32f), new Vector2(0.92f, 0.36f), new Vector2(0.92f, 0.4f), new Vector2(0.92f, 0.44f), new Vector2(0.92f, 0.48f), 
+                                             new Vector2(0.92f, 0.52f), new Vector2(0.92f, 0.56f), new Vector2(0.92f, 0.6f), new Vector2(0.92f, 0.64f), new Vector2(0.92f, 0.68f), new Vector2(0.92f, 0.72f), 
+                                             new Vector2(0.92f, 0.76f), new Vector2(0.92f, 0.8f), new Vector2(0.92f, 0.84f), new Vector2(0.92f, 0.88f), new Vector2(0.92f, 0.92f), new Vector2(0.92f, 0.96f), 
+                                             new Vector2(0.96f, 0f), new Vector2(0.96f, 0.04f), new Vector2(0.96f, 0.08f), new Vector2(0.96f, 0.12f), new Vector2(0.96f, 0.16f), new Vector2(0.96f, 0.2f), 
+                                             new Vector2(0.96f, 0.24f), new Vector2(0.96f, 0.28f), new Vector2(0.96f, 0.32f), new Vector2(0.96f, 0.36f), new Vector2(0.96f, 0.4f), new Vector2(0.96f, 0.44f), 
+                                             new Vector2(0.96f, 0.48f), new Vector2(0.96f, 0.52f), new Vector2(0.96f, 0.56f), new Vector2(0.96f, 0.6f), new Vector2(0.96f, 0.64f), new Vector2(0.96f, 0.68f), 
+                                             new Vector2(0.96f, 0.72f), new Vector2(0.96f, 0.76f), new Vector2(0.96f, 0.8f), new Vector2(0.96f, 0.84f), new Vector2(0.96f, 0.88f), new Vector2(0.96f, 0.92f), 
+                                             new Vector2(0.96f, 0.96f) };
+
+        public TriangleMesh1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = scene.Factory.TriangleMeshManager.Create("TriangleMesh1");
+
+            TriangleMeshRegion r = triangleMesh.TriangleMeshRegionManager.Create(null);
+
+            for (int i = 0; i < meshPositions.Length; i++)
+            {
+                Vertex v = r.VertexManager.Create(null);
+
+                v.SetPosition(ref meshPositions[i]);
+                v.SetTexture(ref meshTextures[i]);
+            }
+
+            for (int i = 0; i < meshIndices.Length; i += 3)
+            {
+                Triangle t = r.TriangleManager.Create(null);
+
+                t.Index1 = meshIndices[i];
+                t.Index2 = meshIndices[i + 1];
+                t.Index3 = meshIndices[i + 2];
+            }
+
+            triangleMesh.Update(true, false);
+
+            if (!demo.Meshes.ContainsKey("TriangleMesh1"))
+                demo.Meshes.Add("TriangleMesh1", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.FrontAndBack, false, false));
+
+            int triangleCount = 0;
+            float[] frictions = null;
+            float[] restitutions = null;
+
+            triangleCount = triangleMesh.GetTriangleCount();
+            frictions = new float[triangleCount];
+            restitutions = new float[triangleCount];
+
+            for (int i = 0; i < triangleCount; i++)
+            {
+                frictions[i] = 1.0f;
+                restitutions[i] = 0.0f;
+            }
+
+            ShapePrimitive shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("TriangleMesh1");
+            shapePrimitive.CreateTriangleMesh(triangleMesh, false, 2, frictions, restitutions, 1.0f, 0.0f);
+
+            Shape shape = scene.Factory.ShapeManager.Create("TriangleMesh1");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.1f);
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, float density)
+        {
+            PhysicsObject objectBase = null;
+            Shape shape = scene.Factory.ShapeManager.Find("TriangleMesh1");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("TriangleMesh1" + instanceIndexName);
+            objectBase.Shape = shape;
+            objectBase.UserDataStr = "TriangleMesh1";
+            objectBase.InitLocalTransform.SetPosition(ref objectPosition);
+            objectBase.InitLocalTransform.SetScale(ref objectScale);
+            objectBase.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectBase.Integral.SetDensity(density);
+            objectBase.EnableLocalGravity = true;
+            objectBase.MaxSleepAngularVelocity = 0.05f;
+            objectBase.MaxSleepLinearVelocity = 0.05f;
+            objectBase.InternalControllers.CreateTriangleMeshController(true);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh2.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh2.cs
new file mode 100644
index 0000000..67c1c4d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/TriangleMesh2.cs
@@ -0,0 +1,516 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class TriangleMesh2
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        // Data generated with CreateNurbs function of the Matali Physics Pro version
+        static ushort[] meshIndices = new ushort[] { 0, 1, 26, 26, 25, 0, 1, 2, 27, 27, 26, 1, 2, 3, 28, 28, 27, 2, 3, 4, 29, 29, 28, 3, 4, 5, 30, 30, 29, 4, 5, 6, 31, 31, 30, 5, 
+                                    6, 7, 32, 32, 31, 6, 7, 8, 33, 33, 32, 7, 8, 9, 34, 34, 33, 8, 9, 10, 35, 35, 34, 9, 10, 11, 36, 36, 35, 10, 11, 12, 37, 37, 36, 11, 
+                                    12, 13, 38, 38, 37, 12, 13, 14, 39, 39, 38, 13, 14, 15, 40, 40, 39, 14, 15, 16, 41, 41, 40, 15, 16, 17, 42, 42, 41, 16, 17, 18, 43, 43, 42, 17, 
+                                    18, 19, 44, 44, 43, 18, 19, 20, 45, 45, 44, 19, 20, 21, 46, 46, 45, 20, 21, 22, 47, 47, 46, 21, 22, 23, 48, 48, 47, 22, 23, 24, 49, 49, 48, 23, 
+                                    25, 26, 51, 51, 50, 25, 26, 27, 52, 52, 51, 26, 27, 28, 53, 53, 52, 27, 28, 29, 54, 54, 53, 28, 29, 30, 55, 55, 54, 29, 30, 31, 56, 56, 55, 30, 
+                                    31, 32, 57, 57, 56, 31, 32, 33, 58, 58, 57, 32, 33, 34, 59, 59, 58, 33, 34, 35, 60, 60, 59, 34, 35, 36, 61, 61, 60, 35, 36, 37, 62, 62, 61, 36, 
+                                    37, 38, 63, 63, 62, 37, 38, 39, 64, 64, 63, 38, 39, 40, 65, 65, 64, 39, 40, 41, 66, 66, 65, 40, 41, 42, 67, 67, 66, 41, 42, 43, 68, 68, 67, 42, 
+                                    43, 44, 69, 69, 68, 43, 44, 45, 70, 70, 69, 44, 45, 46, 71, 71, 70, 45, 46, 47, 72, 72, 71, 46, 47, 48, 73, 73, 72, 47, 48, 49, 74, 74, 73, 48, 
+                                    50, 51, 76, 76, 75, 50, 51, 52, 77, 77, 76, 51, 52, 53, 78, 78, 77, 52, 53, 54, 79, 79, 78, 53, 54, 55, 80, 80, 79, 54, 55, 56, 81, 81, 80, 55, 
+                                    56, 57, 82, 82, 81, 56, 57, 58, 83, 83, 82, 57, 58, 59, 84, 84, 83, 58, 59, 60, 85, 85, 84, 59, 60, 61, 86, 86, 85, 60, 61, 62, 87, 87, 86, 61, 
+                                    62, 63, 88, 88, 87, 62, 63, 64, 89, 89, 88, 63, 64, 65, 90, 90, 89, 64, 65, 66, 91, 91, 90, 65, 66, 67, 92, 92, 91, 66, 67, 68, 93, 93, 92, 67, 
+                                    68, 69, 94, 94, 93, 68, 69, 70, 95, 95, 94, 69, 70, 71, 96, 96, 95, 70, 71, 72, 97, 97, 96, 71, 72, 73, 98, 98, 97, 72, 73, 74, 99, 99, 98, 73, 
+                                    75, 76, 101, 101, 100, 75, 76, 77, 102, 102, 101, 76, 77, 78, 103, 103, 102, 77, 78, 79, 104, 104, 103, 78, 79, 80, 105, 105, 104, 79, 80, 81, 106, 106, 105, 80, 
+                                    81, 82, 107, 107, 106, 81, 82, 83, 108, 108, 107, 82, 83, 84, 109, 109, 108, 83, 84, 85, 110, 110, 109, 84, 85, 86, 111, 111, 110, 85, 86, 87, 112, 112, 111, 86, 
+                                    87, 88, 113, 113, 112, 87, 88, 89, 114, 114, 113, 88, 89, 90, 115, 115, 114, 89, 90, 91, 116, 116, 115, 90, 91, 92, 117, 117, 116, 91, 92, 93, 118, 118, 117, 92, 
+                                    93, 94, 119, 119, 118, 93, 94, 95, 120, 120, 119, 94, 95, 96, 121, 121, 120, 95, 96, 97, 122, 122, 121, 96, 97, 98, 123, 123, 122, 97, 98, 99, 124, 124, 123, 98, 
+                                    100, 101, 126, 126, 125, 100, 101, 102, 127, 127, 126, 101, 102, 103, 128, 128, 127, 102, 103, 104, 129, 129, 128, 103, 104, 105, 130, 130, 129, 104, 105, 106, 131, 131, 130, 105, 
+                                    106, 107, 132, 132, 131, 106, 107, 108, 133, 133, 132, 107, 108, 109, 134, 134, 133, 108, 109, 110, 135, 135, 134, 109, 110, 111, 136, 136, 135, 110, 111, 112, 137, 137, 136, 111, 
+                                    112, 113, 138, 138, 137, 112, 113, 114, 139, 139, 138, 113, 114, 115, 140, 140, 139, 114, 115, 116, 141, 141, 140, 115, 116, 117, 142, 142, 141, 116, 117, 118, 143, 143, 142, 117, 
+                                    118, 119, 144, 144, 143, 118, 119, 120, 145, 145, 144, 119, 120, 121, 146, 146, 145, 120, 121, 122, 147, 147, 146, 121, 122, 123, 148, 148, 147, 122, 123, 124, 149, 149, 148, 123, 
+                                    125, 126, 151, 151, 150, 125, 126, 127, 152, 152, 151, 126, 127, 128, 153, 153, 152, 127, 128, 129, 154, 154, 153, 128, 129, 130, 155, 155, 154, 129, 130, 131, 156, 156, 155, 130, 
+                                    131, 132, 157, 157, 156, 131, 132, 133, 158, 158, 157, 132, 133, 134, 159, 159, 158, 133, 134, 135, 160, 160, 159, 134, 135, 136, 161, 161, 160, 135, 136, 137, 162, 162, 161, 136, 
+                                    137, 138, 163, 163, 162, 137, 138, 139, 164, 164, 163, 138, 139, 140, 165, 165, 164, 139, 140, 141, 166, 166, 165, 140, 141, 142, 167, 167, 166, 141, 142, 143, 168, 168, 167, 142, 
+                                    143, 144, 169, 169, 168, 143, 144, 145, 170, 170, 169, 144, 145, 146, 171, 171, 170, 145, 146, 147, 172, 172, 171, 146, 147, 148, 173, 173, 172, 147, 148, 149, 174, 174, 173, 148, 
+                                    150, 151, 176, 176, 175, 150, 151, 152, 177, 177, 176, 151, 152, 153, 178, 178, 177, 152, 153, 154, 179, 179, 178, 153, 154, 155, 180, 180, 179, 154, 155, 156, 181, 181, 180, 155, 
+                                    156, 157, 182, 182, 181, 156, 157, 158, 183, 183, 182, 157, 158, 159, 184, 184, 183, 158, 159, 160, 185, 185, 184, 159, 160, 161, 186, 186, 185, 160, 161, 162, 187, 187, 186, 161, 
+                                    162, 163, 188, 188, 187, 162, 163, 164, 189, 189, 188, 163, 164, 165, 190, 190, 189, 164, 165, 166, 191, 191, 190, 165, 166, 167, 192, 192, 191, 166, 167, 168, 193, 193, 192, 167, 
+                                    168, 169, 194, 194, 193, 168, 169, 170, 195, 195, 194, 169, 170, 171, 196, 196, 195, 170, 171, 172, 197, 197, 196, 171, 172, 173, 198, 198, 197, 172, 173, 174, 199, 199, 198, 173, 
+                                    175, 176, 201, 201, 200, 175, 176, 177, 202, 202, 201, 176, 177, 178, 203, 203, 202, 177, 178, 179, 204, 204, 203, 178, 179, 180, 205, 205, 204, 179, 180, 181, 206, 206, 205, 180, 
+                                    181, 182, 207, 207, 206, 181, 182, 183, 208, 208, 207, 182, 183, 184, 209, 209, 208, 183, 184, 185, 210, 210, 209, 184, 185, 186, 211, 211, 210, 185, 186, 187, 212, 212, 211, 186, 
+                                    187, 188, 213, 213, 212, 187, 188, 189, 214, 214, 213, 188, 189, 190, 215, 215, 214, 189, 190, 191, 216, 216, 215, 190, 191, 192, 217, 217, 216, 191, 192, 193, 218, 218, 217, 192, 
+                                    193, 194, 219, 219, 218, 193, 194, 195, 220, 220, 219, 194, 195, 196, 221, 221, 220, 195, 196, 197, 222, 222, 221, 196, 197, 198, 223, 223, 222, 197, 198, 199, 224, 224, 223, 198, 
+                                    200, 201, 226, 226, 225, 200, 201, 202, 227, 227, 226, 201, 202, 203, 228, 228, 227, 202, 203, 204, 229, 229, 228, 203, 204, 205, 230, 230, 229, 204, 205, 206, 231, 231, 230, 205, 
+                                    206, 207, 232, 232, 231, 206, 207, 208, 233, 233, 232, 207, 208, 209, 234, 234, 233, 208, 209, 210, 235, 235, 234, 209, 210, 211, 236, 236, 235, 210, 211, 212, 237, 237, 236, 211, 
+                                    212, 213, 238, 238, 237, 212, 213, 214, 239, 239, 238, 213, 214, 215, 240, 240, 239, 214, 215, 216, 241, 241, 240, 215, 216, 217, 242, 242, 241, 216, 217, 218, 243, 243, 242, 217, 
+                                    218, 219, 244, 244, 243, 218, 219, 220, 245, 245, 244, 219, 220, 221, 246, 246, 245, 220, 221, 222, 247, 247, 246, 221, 222, 223, 248, 248, 247, 222, 223, 224, 249, 249, 248, 223, 
+                                    225, 226, 251, 251, 250, 225, 226, 227, 252, 252, 251, 226, 227, 228, 253, 253, 252, 227, 228, 229, 254, 254, 253, 228, 229, 230, 255, 255, 254, 229, 230, 231, 256, 256, 255, 230, 
+                                    231, 232, 257, 257, 256, 231, 232, 233, 258, 258, 257, 232, 233, 234, 259, 259, 258, 233, 234, 235, 260, 260, 259, 234, 235, 236, 261, 261, 260, 235, 236, 237, 262, 262, 261, 236, 
+                                    237, 238, 263, 263, 262, 237, 238, 239, 264, 264, 263, 238, 239, 240, 265, 265, 264, 239, 240, 241, 266, 266, 265, 240, 241, 242, 267, 267, 266, 241, 242, 243, 268, 268, 267, 242, 
+                                    243, 244, 269, 269, 268, 243, 244, 245, 270, 270, 269, 244, 245, 246, 271, 271, 270, 245, 246, 247, 272, 272, 271, 246, 247, 248, 273, 273, 272, 247, 248, 249, 274, 274, 273, 248, 
+                                    250, 251, 276, 276, 275, 250, 251, 252, 277, 277, 276, 251, 252, 253, 278, 278, 277, 252, 253, 254, 279, 279, 278, 253, 254, 255, 280, 280, 279, 254, 255, 256, 281, 281, 280, 255, 
+                                    256, 257, 282, 282, 281, 256, 257, 258, 283, 283, 282, 257, 258, 259, 284, 284, 283, 258, 259, 260, 285, 285, 284, 259, 260, 261, 286, 286, 285, 260, 261, 262, 287, 287, 286, 261, 
+                                    262, 263, 288, 288, 287, 262, 263, 264, 289, 289, 288, 263, 264, 265, 290, 290, 289, 264, 265, 266, 291, 291, 290, 265, 266, 267, 292, 292, 291, 266, 267, 268, 293, 293, 292, 267, 
+                                    268, 269, 294, 294, 293, 268, 269, 270, 295, 295, 294, 269, 270, 271, 296, 296, 295, 270, 271, 272, 297, 297, 296, 271, 272, 273, 298, 298, 297, 272, 273, 274, 299, 299, 298, 273, 
+                                    275, 276, 301, 301, 300, 275, 276, 277, 302, 302, 301, 276, 277, 278, 303, 303, 302, 277, 278, 279, 304, 304, 303, 278, 279, 280, 305, 305, 304, 279, 280, 281, 306, 306, 305, 280, 
+                                    281, 282, 307, 307, 306, 281, 282, 283, 308, 308, 307, 282, 283, 284, 309, 309, 308, 283, 284, 285, 310, 310, 309, 284, 285, 286, 311, 311, 310, 285, 286, 287, 312, 312, 311, 286, 
+                                    287, 288, 313, 313, 312, 287, 288, 289, 314, 314, 313, 288, 289, 290, 315, 315, 314, 289, 290, 291, 316, 316, 315, 290, 291, 292, 317, 317, 316, 291, 292, 293, 318, 318, 317, 292, 
+                                    293, 294, 319, 319, 318, 293, 294, 295, 320, 320, 319, 294, 295, 296, 321, 321, 320, 295, 296, 297, 322, 322, 321, 296, 297, 298, 323, 323, 322, 297, 298, 299, 324, 324, 323, 298, 
+                                    300, 301, 326, 326, 325, 300, 301, 302, 327, 327, 326, 301, 302, 303, 328, 328, 327, 302, 303, 304, 329, 329, 328, 303, 304, 305, 330, 330, 329, 304, 305, 306, 331, 331, 330, 305, 
+                                    306, 307, 332, 332, 331, 306, 307, 308, 333, 333, 332, 307, 308, 309, 334, 334, 333, 308, 309, 310, 335, 335, 334, 309, 310, 311, 336, 336, 335, 310, 311, 312, 337, 337, 336, 311, 
+                                    312, 313, 338, 338, 337, 312, 313, 314, 339, 339, 338, 313, 314, 315, 340, 340, 339, 314, 315, 316, 341, 341, 340, 315, 316, 317, 342, 342, 341, 316, 317, 318, 343, 343, 342, 317, 
+                                    318, 319, 344, 344, 343, 318, 319, 320, 345, 345, 344, 319, 320, 321, 346, 346, 345, 320, 321, 322, 347, 347, 346, 321, 322, 323, 348, 348, 347, 322, 323, 324, 349, 349, 348, 323, 
+                                    325, 326, 351, 351, 350, 325, 326, 327, 352, 352, 351, 326, 327, 328, 353, 353, 352, 327, 328, 329, 354, 354, 353, 328, 329, 330, 355, 355, 354, 329, 330, 331, 356, 356, 355, 330, 
+                                    331, 332, 357, 357, 356, 331, 332, 333, 358, 358, 357, 332, 333, 334, 359, 359, 358, 333, 334, 335, 360, 360, 359, 334, 335, 336, 361, 361, 360, 335, 336, 337, 362, 362, 361, 336, 
+                                    337, 338, 363, 363, 362, 337, 338, 339, 364, 364, 363, 338, 339, 340, 365, 365, 364, 339, 340, 341, 366, 366, 365, 340, 341, 342, 367, 367, 366, 341, 342, 343, 368, 368, 367, 342, 
+                                    343, 344, 369, 369, 368, 343, 344, 345, 370, 370, 369, 344, 345, 346, 371, 371, 370, 345, 346, 347, 372, 372, 371, 346, 347, 348, 373, 373, 372, 347, 348, 349, 374, 374, 373, 348, 
+                                    350, 351, 376, 376, 375, 350, 351, 352, 377, 377, 376, 351, 352, 353, 378, 378, 377, 352, 353, 354, 379, 379, 378, 353, 354, 355, 380, 380, 379, 354, 355, 356, 381, 381, 380, 355, 
+                                    356, 357, 382, 382, 381, 356, 357, 358, 383, 383, 382, 357, 358, 359, 384, 384, 383, 358, 359, 360, 385, 385, 384, 359, 360, 361, 386, 386, 385, 360, 361, 362, 387, 387, 386, 361, 
+                                    362, 363, 388, 388, 387, 362, 363, 364, 389, 389, 388, 363, 364, 365, 390, 390, 389, 364, 365, 366, 391, 391, 390, 365, 366, 367, 392, 392, 391, 366, 367, 368, 393, 393, 392, 367, 
+                                    368, 369, 394, 394, 393, 368, 369, 370, 395, 395, 394, 369, 370, 371, 396, 396, 395, 370, 371, 372, 397, 397, 396, 371, 372, 373, 398, 398, 397, 372, 373, 374, 399, 399, 398, 373, 
+                                    375, 376, 401, 401, 400, 375, 376, 377, 402, 402, 401, 376, 377, 378, 403, 403, 402, 377, 378, 379, 404, 404, 403, 378, 379, 380, 405, 405, 404, 379, 380, 381, 406, 406, 405, 380, 
+                                    381, 382, 407, 407, 406, 381, 382, 383, 408, 408, 407, 382, 383, 384, 409, 409, 408, 383, 384, 385, 410, 410, 409, 384, 385, 386, 411, 411, 410, 385, 386, 387, 412, 412, 411, 386, 
+                                    387, 388, 413, 413, 412, 387, 388, 389, 414, 414, 413, 388, 389, 390, 415, 415, 414, 389, 390, 391, 416, 416, 415, 390, 391, 392, 417, 417, 416, 391, 392, 393, 418, 418, 417, 392, 
+                                    393, 394, 419, 419, 418, 393, 394, 395, 420, 420, 419, 394, 395, 396, 421, 421, 420, 395, 396, 397, 422, 422, 421, 396, 397, 398, 423, 423, 422, 397, 398, 399, 424, 424, 423, 398, 
+                                    400, 401, 426, 426, 425, 400, 401, 402, 427, 427, 426, 401, 402, 403, 428, 428, 427, 402, 403, 404, 429, 429, 428, 403, 404, 405, 430, 430, 429, 404, 405, 406, 431, 431, 430, 405, 
+                                    406, 407, 432, 432, 431, 406, 407, 408, 433, 433, 432, 407, 408, 409, 434, 434, 433, 408, 409, 410, 435, 435, 434, 409, 410, 411, 436, 436, 435, 410, 411, 412, 437, 437, 436, 411, 
+                                    412, 413, 438, 438, 437, 412, 413, 414, 439, 439, 438, 413, 414, 415, 440, 440, 439, 414, 415, 416, 441, 441, 440, 415, 416, 417, 442, 442, 441, 416, 417, 418, 443, 443, 442, 417, 
+                                    418, 419, 444, 444, 443, 418, 419, 420, 445, 445, 444, 419, 420, 421, 446, 446, 445, 420, 421, 422, 447, 447, 446, 421, 422, 423, 448, 448, 447, 422, 423, 424, 449, 449, 448, 423, 
+                                    425, 426, 451, 451, 450, 425, 426, 427, 452, 452, 451, 426, 427, 428, 453, 453, 452, 427, 428, 429, 454, 454, 453, 428, 429, 430, 455, 455, 454, 429, 430, 431, 456, 456, 455, 430, 
+                                    431, 432, 457, 457, 456, 431, 432, 433, 458, 458, 457, 432, 433, 434, 459, 459, 458, 433, 434, 435, 460, 460, 459, 434, 435, 436, 461, 461, 460, 435, 436, 437, 462, 462, 461, 436, 
+                                    437, 438, 463, 463, 462, 437, 438, 439, 464, 464, 463, 438, 439, 440, 465, 465, 464, 439, 440, 441, 466, 466, 465, 440, 441, 442, 467, 467, 466, 441, 442, 443, 468, 468, 467, 442, 
+                                    443, 444, 469, 469, 468, 443, 444, 445, 470, 470, 469, 444, 445, 446, 471, 471, 470, 445, 446, 447, 472, 472, 471, 446, 447, 448, 473, 473, 472, 447, 448, 449, 474, 474, 473, 448, 
+                                    450, 451, 476, 476, 475, 450, 451, 452, 477, 477, 476, 451, 452, 453, 478, 478, 477, 452, 453, 454, 479, 479, 478, 453, 454, 455, 480, 480, 479, 454, 455, 456, 481, 481, 480, 455, 
+                                    456, 457, 482, 482, 481, 456, 457, 458, 483, 483, 482, 457, 458, 459, 484, 484, 483, 458, 459, 460, 485, 485, 484, 459, 460, 461, 486, 486, 485, 460, 461, 462, 487, 487, 486, 461, 
+                                    462, 463, 488, 488, 487, 462, 463, 464, 489, 489, 488, 463, 464, 465, 490, 490, 489, 464, 465, 466, 491, 491, 490, 465, 466, 467, 492, 492, 491, 466, 467, 468, 493, 493, 492, 467, 
+                                    468, 469, 494, 494, 493, 468, 469, 470, 495, 495, 494, 469, 470, 471, 496, 496, 495, 470, 471, 472, 497, 497, 496, 471, 472, 473, 498, 498, 497, 472, 473, 474, 499, 499, 498, 473, 
+                                    475, 476, 501, 501, 500, 475, 476, 477, 502, 502, 501, 476, 477, 478, 503, 503, 502, 477, 478, 479, 504, 504, 503, 478, 479, 480, 505, 505, 504, 479, 480, 481, 506, 506, 505, 480, 
+                                    481, 482, 507, 507, 506, 481, 482, 483, 508, 508, 507, 482, 483, 484, 509, 509, 508, 483, 484, 485, 510, 510, 509, 484, 485, 486, 511, 511, 510, 485, 486, 487, 512, 512, 511, 486, 
+                                    487, 488, 513, 513, 512, 487, 488, 489, 514, 514, 513, 488, 489, 490, 515, 515, 514, 489, 490, 491, 516, 516, 515, 490, 491, 492, 517, 517, 516, 491, 492, 493, 518, 518, 517, 492, 
+                                    493, 494, 519, 519, 518, 493, 494, 495, 520, 520, 519, 494, 495, 496, 521, 521, 520, 495, 496, 497, 522, 522, 521, 496, 497, 498, 523, 523, 522, 497, 498, 499, 524, 524, 523, 498, 
+                                    500, 501, 526, 526, 525, 500, 501, 502, 527, 527, 526, 501, 502, 503, 528, 528, 527, 502, 503, 504, 529, 529, 528, 503, 504, 505, 530, 530, 529, 504, 505, 506, 531, 531, 530, 505, 
+                                    506, 507, 532, 532, 531, 506, 507, 508, 533, 533, 532, 507, 508, 509, 534, 534, 533, 508, 509, 510, 535, 535, 534, 509, 510, 511, 536, 536, 535, 510, 511, 512, 537, 537, 536, 511, 
+                                    512, 513, 538, 538, 537, 512, 513, 514, 539, 539, 538, 513, 514, 515, 540, 540, 539, 514, 515, 516, 541, 541, 540, 515, 516, 517, 542, 542, 541, 516, 517, 518, 543, 543, 542, 517, 
+                                    518, 519, 544, 544, 543, 518, 519, 520, 545, 545, 544, 519, 520, 521, 546, 546, 545, 520, 521, 522, 547, 547, 546, 521, 522, 523, 548, 548, 547, 522, 523, 524, 549, 549, 548, 523, 
+                                    525, 526, 551, 551, 550, 525, 526, 527, 552, 552, 551, 526, 527, 528, 553, 553, 552, 527, 528, 529, 554, 554, 553, 528, 529, 530, 555, 555, 554, 529, 530, 531, 556, 556, 555, 530, 
+                                    531, 532, 557, 557, 556, 531, 532, 533, 558, 558, 557, 532, 533, 534, 559, 559, 558, 533, 534, 535, 560, 560, 559, 534, 535, 536, 561, 561, 560, 535, 536, 537, 562, 562, 561, 536, 
+                                    537, 538, 563, 563, 562, 537, 538, 539, 564, 564, 563, 538, 539, 540, 565, 565, 564, 539, 540, 541, 566, 566, 565, 540, 541, 542, 567, 567, 566, 541, 542, 543, 568, 568, 567, 542, 
+                                    543, 544, 569, 569, 568, 543, 544, 545, 570, 570, 569, 544, 545, 546, 571, 571, 570, 545, 546, 547, 572, 572, 571, 546, 547, 548, 573, 573, 572, 547, 548, 549, 574, 574, 573, 548, 
+                                    550, 551, 576, 576, 575, 550, 551, 552, 577, 577, 576, 551, 552, 553, 578, 578, 577, 552, 553, 554, 579, 579, 578, 553, 554, 555, 580, 580, 579, 554, 555, 556, 581, 581, 580, 555, 
+                                    556, 557, 582, 582, 581, 556, 557, 558, 583, 583, 582, 557, 558, 559, 584, 584, 583, 558, 559, 560, 585, 585, 584, 559, 560, 561, 586, 586, 585, 560, 561, 562, 587, 587, 586, 561, 
+                                    562, 563, 588, 588, 587, 562, 563, 564, 589, 589, 588, 563, 564, 565, 590, 590, 589, 564, 565, 566, 591, 591, 590, 565, 566, 567, 592, 592, 591, 566, 567, 568, 593, 593, 592, 567, 
+                                    568, 569, 594, 594, 593, 568, 569, 570, 595, 595, 594, 569, 570, 571, 596, 596, 595, 570, 571, 572, 597, 597, 596, 571, 572, 573, 598, 598, 597, 572, 573, 574, 599, 599, 598, 573, 
+                                    575, 576, 601, 601, 600, 575, 576, 577, 602, 602, 601, 576, 577, 578, 603, 603, 602, 577, 578, 579, 604, 604, 603, 578, 579, 580, 605, 605, 604, 579, 580, 581, 606, 606, 605, 580, 
+                                    581, 582, 607, 607, 606, 581, 582, 583, 608, 608, 607, 582, 583, 584, 609, 609, 608, 583, 584, 585, 610, 610, 609, 584, 585, 586, 611, 611, 610, 585, 586, 587, 612, 612, 611, 586, 
+                                    587, 588, 613, 613, 612, 587, 588, 589, 614, 614, 613, 588, 589, 590, 615, 615, 614, 589, 590, 591, 616, 616, 615, 590, 591, 592, 617, 617, 616, 591, 592, 593, 618, 618, 617, 592, 
+                                    593, 594, 619, 619, 618, 593, 594, 595, 620, 620, 619, 594, 595, 596, 621, 621, 620, 595, 596, 597, 622, 622, 621, 596, 597, 598, 623, 623, 622, 597, 598, 599, 624, 624, 623, 598 };
+
+        static Vector3[] meshPositions = new Vector3[] { new Vector3(40f, -360f, -250f), new Vector3(-41.07951f, -306.2406f, -203.4692f), new Vector3(-98.84802f, -265.3345f, -158.1453f), 
+                                              new Vector3(-135.4338f, -236.0819f, -114.0591f), new Vector3(-152.9651f, -217.2832f, -71.24158f), new Vector3(-153.5702f, -207.7388f, -29.72374f), 
+                                              new Vector3(-139.3774f, -206.2488f, 10.4635f), new Vector3(-112.515f, -211.6137f, 49.28931f), new Vector3(-75.1113f, -222.6338f, 86.72263f), 
+                                              new Vector3(-29.29452f, -238.1094f, 122.7325f), new Vector3(22.80709f, -256.8408f, 157.2881f), new Vector3(79.06514f, -277.6284f, 190.3586f), 
+                                              new Vector3(137.3514f, -299.2724f, 221.9128f), new Vector3(195.5377f, -320.5732f, 251.9199f), new Vector3(251.4956f, -340.3311f, 280.3489f), 
+                                              new Vector3(303.0968f, -357.3465f, 307.1689f), new Vector3(348.2133f, -370.4196f, 332.3492f), new Vector3(384.7165f, -378.3507f, 355.8584f), 
+                                              new Vector3(410.4781f, -379.9402f, 377.6659f), new Vector3(423.3701f, -373.9885f, 397.7407f), new Vector3(421.264f, -359.2957f, 416.0518f), 
+                                              new Vector3(402.0315f, -334.6624f, 432.5682f), new Vector3(363.5445f, -298.8886f, 447.2592f), new Vector3(303.6745f, -250.7748f, 460.0938f), 
+                                              new Vector3(220.2934f, -189.1214f, 471.0408f), new Vector3(121.0795f, -306.2406f, -250f), new Vector3(40f, -258.7798f, -203.4692f), 
+                                              new Vector3(-20.45377f, -223.7637f, -158.1453f), new Vector3(-62.04771f, -200.0285f, -114.0591f), new Vector3(-86.5476f, -186.4102f, -71.24161f), 
+                                              new Vector3(-95.71942f, -181.7451f, -29.72379f), new Vector3(-91.32901f, -184.869f, 10.46344f), new Vector3(-75.14228f, -194.6183f, 49.28931f), 
+                                              new Vector3(-48.92507f, -209.8289f, 86.72263f), new Vector3(-14.4433f, -229.3372f, 122.7325f), new Vector3(26.53726f, -251.979f, 157.2881f), 
+                                              new Vector3(72.25062f, -276.5905f, 190.3586f), new Vector3(120.9309f, -302.0079f, 221.9128f), new Vector3(170.8124f, -327.0673f, 251.9198f), 
+                                              new Vector3(220.129f, -350.6047f, 280.3489f), new Vector3(267.1149f, -371.4563f, 307.169f), new Vector3(310.0043f, -388.4582f, 332.3491f), 
+                                              new Vector3(347.0313f, -400.4465f, 355.8585f), new Vector3(376.4299f, -406.2572f, 377.666f), new Vector3(396.4343f, -404.7266f, 397.7407f), 
+                                              new Vector3(405.2787f, -394.6907f, 416.0517f), new Vector3(401.1971f, -374.9857f, 432.5683f), new Vector3(382.4236f, -344.4475f, 447.2592f), 
+                                              new Vector3(347.1925f, -301.9124f, 460.0938f), new Vector3(293.7376f, -246.2165f, 471.0408f), new Vector3(178.848f, -265.3345f, -250f), 
+                                              new Vector3(100.4538f, -223.7637f, -203.4692f), new Vector3(40.00001f, -194.0645f, -158.1453f), new Vector3(-3.94701f, -175.1246f, -114.0591f), 
+                                              new Vector3(-32.82088f, -165.8319f, -71.24158f), new Vector3(-48.05535f, -165.0743f, -29.72372f), new Vector3(-51.08402f, -171.7395f, 10.46353f), 
+                                              new Vector3(-43.34065f, -184.7154f, 49.28928f), new Vector3(-26.25887f, -202.8897f, 86.72263f), new Vector3(-1.272408f, -225.1504f, 122.7326f), 
+                                              new Vector3(30.18517f, -250.3854f, 157.2881f), new Vector3(66.68011f, -277.4823f, 190.3585f), new Vector3(106.7787f, -305.329f, 221.9127f), 
+                                              new Vector3(149.0474f, -332.8135f, 251.9199f), new Vector3(192.0524f, -358.8235f, 280.3489f), new Vector3(234.3601f, -382.2468f, 307.1689f), 
+                                              new Vector3(274.5368f, -401.9713f, 332.3492f), new Vector3(311.1488f, -416.8848f, 355.8584f), new Vector3(342.7624f, -425.8751f, 377.6659f), 
+                                              new Vector3(367.9439f, -427.8301f, 397.7407f), new Vector3(385.2599f, -421.6376f, 416.0517f), new Vector3(393.2763f, -406.1854f, 432.5682f), 
+                                              new Vector3(390.5597f, -380.3613f, 447.2592f), new Vector3(375.6763f, -343.0533f, 460.0939f), new Vector3(347.1925f, -293.149f, 471.0408f), 
+                                              new Vector3(215.4338f, -236.0819f, -250f), new Vector3(142.0477f, -200.0285f, -203.4692f), new Vector3(83.94701f, -175.1246f, -158.1453f), 
+                                              new Vector3(40f, -160.3242f, -114.0591f), new Vector3(9.075048f, -154.5813f, -71.24156f), new Vector3(-9.959576f, -156.8497f, -29.72374f), 
+                                              new Vector3(-18.23549f, -166.0834f, 10.4635f), new Vector3(-16.88439f, -181.2364f, 49.28925f), new Vector3(-7.037994f, -201.2626f, 86.72266f), 
+                                              new Vector3(10.17208f, -225.1159f, 122.7325f), new Vector3(33.61413f, -251.7505f, 157.2881f), new Vector3(62.15649f, -280.12f, 190.3586f), 
+                                              new Vector3(94.66751f, -309.1785f, 221.9128f), new Vector3(130.0155f, -337.88f, 251.9199f), new Vector3(167.0687f, -365.1784f, 280.3489f), 
+                                              new Vector3(204.6956f, -390.0276f, 307.169f), new Vector3(241.7645f, -411.3817f, 332.3491f), new Vector3(277.1436f, -428.1945f, 355.8584f), 
+                                              new Vector3(309.7011f, -439.42f, 377.666f), new Vector3(338.3058f, -444.0121f, 397.7407f), new Vector3(361.8257f, -440.9247f, 416.0518f), 
+                                              new Vector3(379.129f, -429.1119f, 432.5682f), new Vector3(389.0842f, -407.5276f, 447.2593f), new Vector3(390.5597f, -375.1256f, 460.0938f), 
+                                              new Vector3(382.4237f, -330.8601f, 471.0408f), new Vector3(232.9651f, -217.2832f, -250f), new Vector3(166.5476f, -186.4102f, -203.4692f), 
+                                              new Vector3(112.8209f, -165.832f, -158.1452f), new Vector3(70.92494f, -154.5813f, -114.059f), new Vector3(40f, -151.6911f, -71.24153f), 
+                                              new Vector3(19.18611f, -156.1944f, -29.72372f), new Vector3(7.623432f, -167.1241f, 10.46353f), new Vector3(4.45211f, -183.513f, 49.28934f), 
+                                              new Vector3(8.81222f, -204.3941f, 86.72269f), new Vector3(19.84394f, -228.8004f, 122.7327f), new Vector3(36.68738f, -255.7647f, 157.2882f), 
+                                              new Vector3(58.48269f, -284.3199f, 190.3586f), new Vector3(84.3699f, -313.499f, 221.9128f), new Vector3(113.4893f, -342.3348f, 251.9199f), 
+                                              new Vector3(144.9809f, -369.8604f, 280.349f), new Vector3(177.9848f, -395.1086f, 307.1691f), new Vector3(211.6413f, -417.1123f, 332.3493f), 
+                                              new Vector3(245.0903f, -434.9045f, 355.8585f), new Vector3(277.472f, -447.518f, 377.6659f), new Vector3(307.9267f, -453.9858f, 397.7407f), 
+                                              new Vector3(335.5944f, -453.3407f, 416.0519f), new Vector3(359.6151f, -444.6158f, 432.5684f), new Vector3(379.129f, -426.8439f, 447.2593f), 
+                                              new Vector3(393.2764f, -399.0579f, 460.0939f), new Vector3(401.1971f, -360.2907f, 471.041f), new Vector3(233.5702f, -207.7388f, -250f), 
+                                              new Vector3(175.7194f, -181.745f, -203.4692f), new Vector3(128.0553f, -165.0743f, -158.1453f), new Vector3(89.95957f, -156.8497f, -114.0591f), 
+                                              new Vector3(60.81388f, -156.1944f, -71.24158f), new Vector3(40.00001f, -162.2318f, -29.72375f), new Vector3(26.89967f, -174.0848f, 10.4635f), 
+                                              new Vector3(20.89458f, -190.8768f, 49.28925f), new Vector3(21.36648f, -211.731f, 86.72263f), new Vector3(27.69709f, -235.7705f, 122.7325f), 
+                                              new Vector3(39.2682f, -262.1185f, 157.2882f), new Vector3(55.46146f, -289.8984f, 190.3586f), new Vector3(75.65858f, -318.2332f, 221.9128f), 
+                                              new Vector3(99.24142f, -346.2461f, 251.9198f), new Vector3(125.5916f, -373.0604f, 280.349f), new Vector3(154.0909f, -397.7993f, 307.1689f), 
+                                              new Vector3(184.121f, -419.586f, 332.3492f), new Vector3(215.0636f, -437.5435f, 355.8584f), new Vector3(246.3006f, -450.7953f, 377.6658f), 
+                                              new Vector3(277.2135f, -458.4644f, 397.7407f), new Vector3(307.1842f, -459.674f, 416.0518f), new Vector3(335.5943f, -453.5474f, 432.5683f), 
+                                              new Vector3(361.8256f, -439.2078f, 447.2593f), new Vector3(385.2599f, -415.7783f, 460.0938f), new Vector3(405.2788f, -382.3822f, 471.0408f), 
+                                              new Vector3(219.3774f, -206.2488f, -250f), new Vector3(171.329f, -184.869f, -203.4692f), new Vector3(131.084f, -171.7395f, -158.1453f), 
+                                              new Vector3(98.23549f, -166.0835f, -114.0591f), new Vector3(72.37656f, -167.1241f, -71.24161f), new Vector3(53.10033f, -174.0848f, -29.72375f), 
+                                              new Vector3(40f, -186.1888f, 10.4635f), new Vector3(32.66864f, -202.6593f, 49.28931f), new Vector3(30.69942f, -222.7195f, 86.72266f), 
+                                              new Vector3(33.68544f, -245.5929f, 122.7325f), new Vector3(41.21984f, -270.5025f, 157.2881f), new Vector3(52.89576f, -296.6717f, 190.3585f), 
+                                              new Vector3(68.30627f, -323.3237f, 221.9128f), new Vector3(87.04462f, -349.6819f, 251.9199f), new Vector3(108.7038f, -374.9694f, 280.3489f), 
+                                              new Vector3(132.8771f, -398.4095f, 307.169f), new Vector3(159.1575f, -419.2255f, 332.3491f), new Vector3(187.1383f, -436.6406f, 355.8584f), 
+                                              new Vector3(216.4124f, -449.878f, 377.6658f), new Vector3(246.5731f, -458.1611f, 397.7407f), new Vector3(277.2135f, -460.7131f, 416.0518f), 
+                                              new Vector3(307.9267f, -456.7573f, 432.5682f), new Vector3(338.3058f, -445.5169f, 447.2592f), new Vector3(367.944f, -426.2152f, 460.0937f), 
+                                              new Vector3(396.4344f, -398.0754f, 471.0408f), new Vector3(192.515f, -211.6137f, -250f), new Vector3(155.1423f, -194.6183f, -203.4692f), 
+                                              new Vector3(123.3407f, -184.7154f, -158.1453f), new Vector3(96.88437f, -181.2364f, -114.0591f), new Vector3(75.54788f, -183.513f, -71.24159f), 
+                                              new Vector3(59.10543f, -190.8768f, -29.72379f), new Vector3(47.33135f, -202.6593f, 10.4635f), new Vector3(40f, -218.1919f, 49.28928f), 
+                                              new Vector3(36.88571f, -236.8064f, 86.72263f), new Vector3(37.76277f, -257.8343f, 122.7325f), new Vector3(42.40555f, -280.607f, 157.2881f), 
+                                              new Vector3(50.58841f, -304.4562f, 190.3586f), new Vector3(62.08558f, -328.7134f, 221.9128f), new Vector3(76.67152f, -352.7103f, 251.9198f), 
+                                              new Vector3(94.12048f, -375.7782f, 280.349f), new Vector3(114.2068f, -397.2488f, 307.169f), new Vector3(136.7048f, -416.4537f, 332.3492f), 
+                                              new Vector3(161.3889f, -432.7244f, 355.8585f), new Vector3(188.0333f, -445.3923f, 377.6659f), new Vector3(216.4125f, -453.7892f, 397.7405f), 
+                                              new Vector3(246.3006f, -457.2466f, 416.0518f), new Vector3(277.472f, -455.0959f, 432.5682f), new Vector3(309.7013f, -446.6689f, 447.2592f), 
+                                              new Vector3(342.7625f, -431.2969f, 460.0938f), new Vector3(376.4301f, -408.3116f, 471.0409f), new Vector3(155.1113f, -222.6338f, -250f), 
+                                              new Vector3(128.9251f, -209.829f, -203.4692f), new Vector3(106.2589f, -202.8897f, -158.1452f), new Vector3(87.03801f, -201.2626f, -114.0591f), 
+                                              new Vector3(71.18777f, -204.3941f, -71.24155f), new Vector3(58.63352f, -211.731f, -29.72372f), new Vector3(49.30058f, -222.7195f, 10.46353f), 
+                                              new Vector3(43.11428f, -236.8064f, 49.28931f), new Vector3(40f, -253.4382f, 86.72266f), new Vector3(39.88301f, -272.0614f, 122.7326f), 
+                                              new Vector3(42.68866f, -292.1225f, 157.2882f), new Vector3(48.3423f, -313.0682f, 190.3586f), new Vector3(56.7692f, -334.3449f, 221.9128f), 
+                                              new Vector3(67.89478f, -355.3993f, 251.9199f), new Vector3(81.64436f, -375.6779f, 280.349f), new Vector3(97.94318f, -394.627f, 307.169f), 
+                                              new Vector3(116.7167f, -411.6935f, 332.3492f), new Vector3(137.8902f, -426.3238f, 355.8586f), new Vector3(161.3889f, -437.9644f, 377.666f), 
+                                              new Vector3(187.1384f, -446.0619f, 397.7407f), new Vector3(215.0637f, -450.0628f, 416.0518f), new Vector3(245.0903f, -449.4138f, 432.5684f), 
+                                              new Vector3(277.1437f, -443.5612f, 447.2593f), new Vector3(311.149f, -431.9517f, 460.0938f), new Vector3(347.0315f, -414.0318f, 471.0409f), 
+                                              new Vector3(109.2945f, -238.1094f, -250f), new Vector3(94.44331f, -229.3372f, -203.4692f), new Vector3(81.27242f, -225.1504f, -158.1453f), 
+                                              new Vector3(69.82793f, -225.116f, -114.0591f), new Vector3(60.15607f, -228.8004f, -71.24156f), new Vector3(52.3029f, -235.7704f, -29.72374f), 
+                                              new Vector3(46.31457f, -245.5929f, 10.46353f), new Vector3(42.23724f, -257.8343f, 49.28931f), new Vector3(40.11699f, -272.0614f, 86.72266f), 
+                                              new Vector3(40f, -287.8409f, 122.7325f), new Vector3(41.93238f, -304.7396f, 157.2882f), new Vector3(45.96027f, -322.324f, 190.3586f), 
+                                              new Vector3(52.1298f, -340.1609f, 221.9128f), new Vector3(60.4871f, -357.8171f, 251.9199f), new Vector3(71.07829f, -374.8592f, 280.3489f), 
+                                              new Vector3(83.94955f, -390.8539f, 307.169f), new Vector3(99.14699f, -405.3678f, 332.3492f), new Vector3(116.7167f, -417.9677f, 355.8585f), 
+                                              new Vector3(136.7049f, -428.2203f, 377.6659f), new Vector3(159.1576f, -435.6923f, 397.7407f), new Vector3(184.1211f, -439.9503f, 416.0519f), 
+                                              new Vector3(211.6413f, -440.5612f, 432.5682f), new Vector3(241.7646f, -437.0914f, 447.2593f), new Vector3(274.537f, -429.1079f, 460.0938f), 
+                                              new Vector3(310.0045f, -416.1772f, 471.0409f), new Vector3(57.19291f, -256.8408f, -250f), new Vector3(53.46273f, -251.979f, -203.4692f), 
+                                              new Vector3(49.81483f, -250.3854f, -158.1453f), new Vector3(46.38586f, -251.7505f, -114.0591f), new Vector3(43.31261f, -255.7647f, -71.24159f), 
+                                              new Vector3(40.73181f, -262.1185f, -29.72377f), new Vector3(38.78017f, -270.5025f, 10.46344f), new Vector3(37.59445f, -280.6071f, 49.28922f), 
+                                              new Vector3(37.31134f, -292.1226f, 86.72256f), new Vector3(38.06763f, -304.7396f, 122.7325f), new Vector3(40f, -318.1485f, 157.2881f), 
+                                              new Vector3(43.24524f, -332.0399f, 190.3585f), new Vector3(47.94f, -346.1042f, 221.9128f), new Vector3(54.2211f, -360.0318f, 251.9198f), 
+                                              new Vector3(62.22522f, -373.5132f, 280.3489f), new Vector3(72.08914f, -386.2389f, 307.1689f), new Vector3(83.94957f, -397.8993f, 332.3491f), 
+                                              new Vector3(97.94321f, -408.1849f, 355.8584f), new Vector3(114.2068f, -416.7862f, 377.6659f), new Vector3(132.8772f, -423.3936f, 397.7407f), 
+                                              new Vector3(154.0909f, -427.6976f, 416.0517f), new Vector3(177.9849f, -429.3887f, 432.5681f), new Vector3(204.6957f, -428.1572f, 447.2592f), 
+                                              new Vector3(234.3603f, -423.6938f, 460.0938f), new Vector3(267.1151f, -415.6888f, 471.0407f), new Vector3(0.9348564f, -277.6284f, -250f), 
+                                              new Vector3(7.749359f, -276.5906f, -203.4692f), new Vector3(13.31989f, -277.4823f, -158.1453f), new Vector3(17.84351f, -280.12f, -114.0591f), 
+                                              new Vector3(21.51731f, -284.3199f, -71.24156f), new Vector3(24.53855f, -289.8984f, -29.72375f), new Vector3(27.10423f, -296.6717f, 10.4635f), 
+                                              new Vector3(29.41159f, -304.4562f, 49.28928f), new Vector3(31.65771f, -313.0682f, 86.72266f), new Vector3(34.03973f, -322.324f, 122.7326f), 
+                                              new Vector3(36.75476f, -332.0399f, 157.2881f), new Vector3(40f, -342.0322f, 190.3585f), new Vector3(43.97252f, -352.1173f, 221.9128f), 
+                                              new Vector3(48.86949f, -362.1114f, 251.9199f), new Vector3(54.88803f, -371.8308f, 280.3489f), new Vector3(62.22525f, -381.0919f, 307.169f), 
+                                              new Vector3(71.07832f, -389.711f, 332.3492f), new Vector3(81.64436f, -397.5043f, 355.8584f), new Vector3(94.12054f, -404.2883f, 377.666f), 
+                                              new Vector3(108.7039f, -409.8791f, 397.7407f), new Vector3(125.5917f, -414.0932f, 416.0518f), new Vector3(144.981f, -416.7467f, 432.5682f), 
+                                              new Vector3(167.0689f, -417.6562f, 447.2592f), new Vector3(192.0526f, -416.6378f, 460.0938f), new Vector3(220.1292f, -413.5078f, 471.0408f), 
+                                              new Vector3(-57.35139f, -299.2724f, -250f), new Vector3(-40.9309f, -302.0079f, -203.4692f), new Vector3(-26.77869f, -305.329f, -158.1452f), 
+                                              new Vector3(-14.6675f, -309.1785f, -114.0591f), new Vector3(-4.369892f, -313.499f, -71.24158f), new Vector3(4.341415f, -318.2331f, -29.72371f), 
+                                              new Vector3(11.69373f, -323.3237f, 10.46353f), new Vector3(17.91441f, -328.7134f, 49.28928f), new Vector3(23.2308f, -334.3449f, 86.72269f), 
+                                              new Vector3(27.8702f, -340.1609f, 122.7326f), new Vector3(32.06001f, -346.1042f, 157.2882f), new Vector3(36.02748f, -352.1173f, 190.3586f), 
+                                              new Vector3(40f, -358.1429f, 221.9129f), new Vector3(44.20488f, -364.1239f, 251.9199f), new Vector3(48.86948f, -370.0029f, 280.349f), 
+                                              new Vector3(54.22112f, -375.7226f, 307.1691f), new Vector3(60.48712f, -381.2256f, 332.3492f), new Vector3(67.89483f, -386.4547f, 355.8585f), 
+                                              new Vector3(76.67159f, -391.3526f, 377.6659f), new Vector3(87.04471f, -395.862f, 397.7407f), new Vector3(99.24155f, -399.9255f, 416.0519f), 
+                                              new Vector3(113.4894f, -403.4859f, 432.5683f), new Vector3(130.0157f, -406.4858f, 447.2593f), new Vector3(149.0477f, -408.868f, 460.0939f), 
+                                              new Vector3(170.8126f, -410.5752f, 471.041f), new Vector3(-115.5377f, -320.5732f, -250f), new Vector3(-90.81239f, -327.0673f, -203.4692f), 
+                                              new Vector3(-69.0474f, -332.8135f, -158.1452f), new Vector3(-50.01547f, -337.88f, -114.0591f), new Vector3(-33.48928f, -342.3348f, -71.24158f), 
+                                              new Vector3(-19.24142f, -346.2462f, -29.72372f), new Vector3(-7.044621f, -349.6819f, 10.46353f), new Vector3(3.328484f, -352.7103f, 49.28931f), 
+                                              new Vector3(12.10522f, -355.3993f, 86.72263f), new Vector3(19.5129f, -357.8171f, 122.7326f), new Vector3(25.7789f, -360.0318f, 157.2881f), 
+                                              new Vector3(31.13051f, -362.1114f, 190.3586f), new Vector3(35.79511f, -364.1239f, 221.9128f), new Vector3(40f, -366.1376f, 251.9199f), 
+                                              new Vector3(43.97253f, -368.2205f, 280.349f), new Vector3(47.94001f, -370.4406f, 307.1689f), new Vector3(52.12982f, -372.8661f, 332.3492f), 
+                                              new Vector3(56.76925f, -375.5649f, 355.8585f), new Vector3(62.08566f, -378.6053f, 377.6658f), new Vector3(68.30634f, -382.0554f, 397.7407f), 
+                                              new Vector3(75.65869f, -385.983f, 416.0518f), new Vector3(84.37f, -390.4565f, 432.5682f), new Vector3(94.66762f, -395.5437f, 447.2593f), 
+                                              new Vector3(106.7789f, -401.3129f, 460.0939f), new Vector3(120.9311f, -407.8322f, 471.0409f), new Vector3(-171.4956f, -340.3311f, -250f), 
+                                              new Vector3(-140.129f, -350.6047f, -203.4692f), new Vector3(-112.0524f, -358.8235f, -158.1453f), new Vector3(-87.06871f, -365.1784f, -114.0591f), 
+                                              new Vector3(-64.98086f, -369.8604f, -71.24156f), new Vector3(-45.59158f, -373.0604f, -29.72374f), new Vector3(-28.70383f, -374.9694f, 10.4635f), 
+                                              new Vector3(-14.12048f, -375.7782f, 49.28928f), new Vector3(-1.644348f, -375.6778f, 86.72263f), new Vector3(8.921707f, -374.8592f, 122.7325f), 
+                                              new Vector3(17.77478f, -373.5132f, 157.2882f), new Vector3(25.11197f, -371.8308f, 190.3586f), new Vector3(31.13051f, -370.0029f, 221.9128f), 
+                                              new Vector3(36.02746f, -368.2205f, 251.92f), new Vector3(40f, -366.6744f, 280.3489f), new Vector3(43.24522f, -365.5557f, 307.1691f), 
+                                              new Vector3(45.96028f, -365.0552f, 332.3492f), new Vector3(48.3423f, -365.3639f, 355.8585f), new Vector3(50.58842f, -366.6727f, 377.6658f), 
+                                              new Vector3(52.89577f, -369.1725f, 397.7407f), new Vector3(55.4615f, -373.0543f, 416.0518f), new Vector3(58.48273f, -378.509f, 432.5682f), 
+                                              new Vector3(62.15658f, -385.7275f, 447.2592f), new Vector3(66.68022f, -394.9008f, 460.0938f), new Vector3(72.25075f, -406.2198f, 471.0408f), 
+                                              new Vector3(-223.0968f, -357.3465f, -250f), new Vector3(-187.1149f, -371.4563f, -203.4692f), new Vector3(-154.3601f, -382.2468f, -158.1453f), 
+                                              new Vector3(-124.6956f, -390.0276f, -114.0591f), new Vector3(-97.98483f, -395.1086f, -71.24156f), new Vector3(-74.09085f, -397.7993f, -29.72371f), 
+                                              new Vector3(-52.87712f, -398.4095f, 10.4635f), new Vector3(-34.20682f, -397.2488f, 49.28931f), new Vector3(-17.94319f, -394.627f, 86.72263f), 
+                                              new Vector3(-3.949562f, -390.8539f, 122.7326f), new Vector3(7.910851f, -386.2389f, 157.2881f), new Vector3(17.77475f, -381.0919f, 190.3585f), 
+                                              new Vector3(25.77888f, -375.7226f, 221.9128f), new Vector3(32.05999f, -370.4406f, 251.9199f), new Vector3(36.75478f, -365.5557f, 280.3489f), 
+                                              new Vector3(40f, -361.3776f, 307.169f), new Vector3(41.93239f, -358.2159f, 332.3492f), new Vector3(42.68867f, -356.3804f, 355.8585f), 
+                                              new Vector3(42.40556f, -356.1808f, 377.6659f), new Vector3(41.21984f, -357.9267f, 397.7406f), new Vector3(39.26823f, -361.9279f, 416.0518f), 
+                                              new Vector3(36.68742f, -368.494f, 432.5683f), new Vector3(33.61421f, -377.9348f, 447.2592f), new Vector3(30.18524f, -390.56f, 460.0938f), 
+                                              new Vector3(26.53735f, -406.6793f, 471.0408f), new Vector3(-268.2133f, -370.4196f, -250f), new Vector3(-230.0044f, -388.4582f, -203.4692f), 
+                                              new Vector3(-194.5368f, -401.9713f, -158.1452f), new Vector3(-161.7645f, -411.3817f, -114.0591f), new Vector3(-131.6413f, -417.1123f, -71.24158f), 
+                                              new Vector3(-104.121f, -419.5859f, -29.72374f), new Vector3(-79.15755f, -419.2255f, 10.46353f), new Vector3(-56.70483f, -416.4537f, 49.28928f), 
+                                              new Vector3(-36.71671f, -411.6935f, 86.72266f), new Vector3(-19.14699f, -405.3678f, 122.7325f), new Vector3(-3.94957f, -397.8993f, 157.2882f), 
+                                              new Vector3(8.921677f, -389.711f, 190.3586f), new Vector3(19.51287f, -381.2256f, 221.9128f), new Vector3(27.87018f, -372.8661f, 251.9199f), 
+                                              new Vector3(34.03972f, -365.0552f, 280.3489f), new Vector3(38.0676f, -358.2159f, 307.169f), new Vector3(40.00001f, -352.771f, 332.3492f), 
+                                              new Vector3(39.88301f, -349.1432f, 355.8585f), new Vector3(37.76276f, -347.7557f, 377.6659f), new Vector3(33.68543f, -349.031f, 397.7406f), 
+                                              new Vector3(27.6971f, -353.3921f, 416.0519f), new Vector3(19.84395f, -361.2619f, 432.5683f), new Vector3(10.17207f, -373.0631f, 447.2592f), 
+                                              new Vector3(-1.272381f, -389.2188f, 460.0938f), new Vector3(-14.4433f, -410.1516f, 471.0409f), new Vector3(-304.7165f, -378.3507f, -250f), 
+                                              new Vector3(-267.0313f, -400.4465f, -203.4692f), new Vector3(-231.1488f, -416.8848f, -158.1453f), new Vector3(-197.1436f, -428.1945f, -114.0591f), 
+                                              new Vector3(-165.0903f, -434.9045f, -71.24156f), new Vector3(-135.0636f, -437.5435f, -29.72371f), new Vector3(-107.1383f, -436.6405f, 10.46353f), 
+                                              new Vector3(-81.3889f, -432.7244f, 49.28931f), new Vector3(-57.89016f, -426.3238f, 86.72266f), new Vector3(-36.71671f, -417.9677f, 122.7326f), 
+                                              new Vector3(-17.94322f, -408.1849f, 157.2882f), new Vector3(-1.644363f, -397.5043f, 190.3586f), new Vector3(12.10517f, -386.4547f, 221.9128f), 
+                                              new Vector3(23.23076f, -375.5649f, 251.9199f), new Vector3(31.65769f, -365.3639f, 280.3489f), new Vector3(37.31133f, -356.3804f, 307.169f), 
+                                              new Vector3(40.117f, -349.1433f, 332.3492f), new Vector3(39.99999f, -344.1814f, 355.8585f), new Vector3(36.8857f, -342.0236f, 377.6659f), 
+                                              new Vector3(30.69939f, -343.1987f, 397.7407f), new Vector3(21.36646f, -348.2356f, 416.0518f), new Vector3(8.81221f, -357.6631f, 432.5684f), 
+                                              new Vector3(-7.038071f, -372.0101f, 447.2593f), new Vector3(-26.25895f, -391.8054f, 460.0938f), new Vector3(-48.92516f, -417.5778f, 471.0409f), 
+                                              new Vector3(-330.4781f, -379.9402f, -250f), new Vector3(-296.4298f, -406.2572f, -203.4692f), new Vector3(-262.7624f, -425.8751f, -158.1453f), 
+                                              new Vector3(-229.7011f, -439.42f, -114.0591f), new Vector3(-197.472f, -447.518f, -71.24158f), new Vector3(-166.3006f, -450.7953f, -29.72375f), 
+                                              new Vector3(-136.4124f, -449.878f, 10.4635f), new Vector3(-108.0333f, -445.3923f, 49.28928f), new Vector3(-81.38895f, -437.9644f, 86.7226f), 
+                                              new Vector3(-56.70486f, -428.2203f, 122.7325f), new Vector3(-34.20685f, -416.7862f, 157.2881f), new Vector3(-14.12054f, -404.2883f, 190.3586f), 
+                                              new Vector3(3.328407f, -391.3526f, 221.9128f), new Vector3(17.91434f, -378.6053f, 251.9199f), new Vector3(29.41158f, -366.6727f, 280.3489f), 
+                                              new Vector3(37.59443f, -356.1808f, 307.1689f), new Vector3(42.23724f, -347.7557f, 332.3491f), new Vector3(43.11429f, -342.0236f, 355.8584f), 
+                                              new Vector3(39.99999f, -339.6107f, 377.6659f), new Vector3(32.66864f, -341.143f, 397.7407f), new Vector3(20.89455f, -347.2468f, 416.0518f), 
+                                              new Vector3(4.452072f, -358.5482f, 432.5682f), new Vector3(-16.88447f, -375.6732f, 447.2592f), new Vector3(-43.34076f, -399.2482f, 460.0938f), 
+                                              new Vector3(-75.14243f, -429.8992f, 471.0408f), new Vector3(-343.3701f, -373.9885f, -250f), new Vector3(-316.4343f, -404.7266f, -203.4692f), 
+                                              new Vector3(-287.944f, -427.8301f, -158.1453f), new Vector3(-258.3058f, -444.0121f, -114.0591f), new Vector3(-227.9267f, -453.9858f, -71.24159f), 
+                                              new Vector3(-197.2135f, -458.4644f, -29.72375f), new Vector3(-166.5731f, -458.1611f, 10.4635f), new Vector3(-136.4125f, -453.7892f, 49.28928f), 
+                                              new Vector3(-107.1384f, -446.0619f, 86.72263f), new Vector3(-79.15763f, -435.6923f, 122.7325f), new Vector3(-52.8772f, -423.3936f, 157.2881f), 
+                                              new Vector3(-28.70394f, -409.8791f, 190.3586f), new Vector3(-7.044701f, -395.862f, 221.9128f), new Vector3(11.69365f, -382.0554f, 251.9199f), 
+                                              new Vector3(27.10423f, -369.1725f, 280.3489f), new Vector3(38.78015f, -357.9267f, 307.1689f), new Vector3(46.31456f, -349.031f, 332.3491f), 
+                                              new Vector3(49.3006f, -343.1987f, 355.8585f), new Vector3(47.33138f, -341.143f, 377.6659f), new Vector3(40f, -343.5771f, 397.7406f), 
+                                              new Vector3(26.89966f, -351.2142f, 416.0518f), new Vector3(7.623413f, -364.7675f, 432.5682f), new Vector3(-18.23554f, -384.9502f, 447.2592f), 
+                                              new Vector3(-51.08416f, -412.4756f, 460.0938f), new Vector3(-91.32919f, -448.0567f, 471.0408f), new Vector3(-341.264f, -359.2957f, -250f), 
+                                              new Vector3(-325.2787f, -394.6907f, -203.4692f), new Vector3(-305.2599f, -421.6376f, -158.1453f), new Vector3(-281.8256f, -440.9247f, -114.0591f), 
+                                              new Vector3(-255.5944f, -453.3407f, -71.24158f), new Vector3(-227.1842f, -459.674f, -29.72374f), new Vector3(-197.2135f, -460.7131f, 10.4635f), 
+                                              new Vector3(-166.3006f, -457.2466f, 49.28931f), new Vector3(-135.0637f, -450.0628f, 86.72263f), new Vector3(-104.1211f, -439.9503f, 122.7326f), 
+                                              new Vector3(-74.09093f, -427.6976f, 157.2881f), new Vector3(-45.59169f, -414.0932f, 190.3586f), new Vector3(-19.24155f, -399.9255f, 221.9128f), 
+                                              new Vector3(4.341309f, -385.983f, 251.9199f), new Vector3(24.5385f, -373.0543f, 280.3489f), new Vector3(40.73177f, -361.9279f, 307.169f), 
+                                              new Vector3(52.3029f, -353.3921f, 332.3492f), new Vector3(58.63353f, -348.2356f, 355.8585f), new Vector3(59.10545f, -347.2468f, 377.6659f), 
+                                              new Vector3(53.10036f, -351.2142f, 397.7406f), new Vector3(40f, -360.9263f, 416.0518f), new Vector3(19.18608f, -377.1716f, 432.5682f), 
+                                              new Vector3(-9.959648f, -400.7386f, 447.2593f), new Vector3(-48.05547f, -432.4157f, 460.0938f), new Vector3(-95.71965f, -472.9915f, 471.0409f), 
+                                              new Vector3(-322.0315f, -334.6624f, -250f), new Vector3(-321.1971f, -374.9857f, -203.4692f), new Vector3(-313.2763f, -406.1854f, -158.1453f), 
+                                              new Vector3(-299.129f, -429.1119f, -114.0591f), new Vector3(-279.6151f, -444.6158f, -71.24159f), new Vector3(-255.5943f, -453.5475f, -29.72377f), 
+                                              new Vector3(-227.9267f, -456.7573f, 10.4635f), new Vector3(-197.4721f, -455.0959f, 49.28928f), new Vector3(-165.0904f, -449.4137f, 86.7226f), 
+                                              new Vector3(-131.6414f, -440.5612f, 122.7325f), new Vector3(-97.98494f, -429.3887f, 157.2881f), new Vector3(-64.98097f, -416.7467f, 190.3586f), 
+                                              new Vector3(-33.48943f, -403.4859f, 221.9128f), new Vector3(-4.369995f, -390.4565f, 251.9199f), new Vector3(21.51727f, -378.509f, 280.3489f), 
+                                              new Vector3(43.31258f, -368.494f, 307.1689f), new Vector3(60.15605f, -361.2619f, 332.3491f), new Vector3(71.18779f, -357.6631f, 355.8584f), 
+                                              new Vector3(75.54793f, -358.5482f, 377.6658f), new Vector3(72.37659f, -364.7675f, 397.7406f), new Vector3(60.81392f, -377.1716f, 416.0518f), 
+                                              new Vector3(40f, -396.6109f, 432.5682f), new Vector3(9.075012f, -423.9359f, 447.2592f), new Vector3(-32.82098f, -459.997f, 460.0938f), 
+                                              new Vector3(-86.5478f, -505.6448f, 471.0408f), new Vector3(-283.5445f, -298.8886f, -250f), new Vector3(-302.4236f, -344.4475f, -203.4692f), 
+                                              new Vector3(-310.5597f, -380.3613f, -158.1453f), new Vector3(-309.0842f, -407.5276f, -114.0591f), new Vector3(-299.1291f, -426.8439f, -71.24158f), 
+                                              new Vector3(-281.8257f, -439.2078f, -29.72375f), new Vector3(-258.3058f, -445.5169f, 10.4635f), new Vector3(-229.7013f, -446.6689f, 49.28928f), 
+                                              new Vector3(-197.1437f, -443.5612f, 86.72263f), new Vector3(-161.7646f, -437.0914f, 122.7325f), new Vector3(-124.6958f, -428.1572f, 157.2881f), 
+                                              new Vector3(-87.06891f, -417.6562f, 190.3586f), new Vector3(-50.01566f, -406.4858f, 221.9128f), new Vector3(-14.66762f, -395.5438f, 251.9199f), 
+                                              new Vector3(17.84341f, -385.7275f, 280.3489f), new Vector3(46.38579f, -377.9348f, 307.1689f), new Vector3(69.82794f, -373.0631f, 332.3491f), 
+                                              new Vector3(87.03806f, -372.0101f, 355.8585f), new Vector3(96.88448f, -375.6732f, 377.6659f), new Vector3(98.23555f, -384.9502f, 397.7407f), 
+                                              new Vector3(89.95966f, -400.7386f, 416.0518f), new Vector3(70.925f, -423.9359f, 432.5682f), new Vector3(40f, -455.4398f, 447.2592f), 
+                                              new Vector3(-3.947067f, -496.1478f, 460.0938f), new Vector3(-62.04785f, -546.9575f, 471.0408f), new Vector3(-223.6745f, -250.7748f, -250f), 
+                                              new Vector3(-267.1924f, -301.9124f, -203.4692f), new Vector3(-295.6763f, -343.0533f, -158.1453f), new Vector3(-310.5597f, -375.1256f, -114.0591f), 
+                                              new Vector3(-313.2764f, -399.0579f, -71.24156f), new Vector3(-305.2599f, -415.7783f, -29.72374f), new Vector3(-287.944f, -426.2152f, 10.4635f), 
+                                              new Vector3(-262.7625f, -431.2969f, 49.28928f), new Vector3(-231.149f, -431.9517f, 86.72263f), new Vector3(-194.537f, -429.1079f, 122.7326f), 
+                                              new Vector3(-154.3603f, -423.6938f, 157.2881f), new Vector3(-112.0526f, -416.6378f, 190.3586f), new Vector3(-69.04765f, -408.868f, 221.9128f), 
+                                              new Vector3(-26.7789f, -401.313f, 251.9199f), new Vector3(13.31976f, -394.9008f, 280.3489f), new Vector3(49.81476f, -390.56f, 307.169f), 
+                                              new Vector3(81.27237f, -389.2188f, 332.3492f), new Vector3(106.2589f, -391.8054f, 355.8585f), new Vector3(123.3408f, -399.2482f, 377.6659f), 
+                                              new Vector3(131.0842f, -412.4756f, 397.7407f), new Vector3(128.0555f, -432.4157f, 416.0518f), new Vector3(112.821f, -459.997f, 432.5682f), 
+                                              new Vector3(83.94706f, -496.1478f, 447.2593f), new Vector3(40f, -541.7964f, 460.0938f), new Vector3(-20.45388f, -597.871f, 471.0409f), 
+                                              new Vector3(-140.2934f, -189.1214f, -250f), new Vector3(-213.7376f, -246.2165f, -203.4692f), new Vector3(-267.1924f, -293.149f, -158.1452f), 
+                                              new Vector3(-302.4236f, -330.8601f, -114.0591f), new Vector3(-321.1972f, -360.2907f, -71.24158f), new Vector3(-325.2788f, -382.3821f, -29.72374f), 
+                                              new Vector3(-316.4344f, -398.0754f, 10.4635f), new Vector3(-296.4301f, -408.3116f, 49.28925f), new Vector3(-267.0315f, -414.0318f, 86.7226f), 
+                                              new Vector3(-230.0046f, -416.1772f, 122.7325f), new Vector3(-187.1151f, -415.6888f, 157.2881f), new Vector3(-140.1292f, -413.5078f, 190.3586f), 
+                                              new Vector3(-90.81264f, -410.5752f, 221.9128f), new Vector3(-40.93115f, -407.8322f, 251.9199f), new Vector3(7.749237f, -406.2198f, 280.3489f), 
+                                              new Vector3(53.46262f, -406.6792f, 307.1689f), new Vector3(94.4433f, -410.1516f, 332.3492f), new Vector3(128.9252f, -417.5778f, 355.8585f), 
+                                              new Vector3(155.1424f, -429.8992f, 377.6659f), new Vector3(171.3292f, -448.0567f, 397.7407f), new Vector3(175.7196f, -472.9915f, 416.0518f), 
+                                              new Vector3(166.5478f, -505.6448f, 432.5682f), new Vector3(142.0479f, -546.9575f, 447.2593f), new Vector3(100.4539f, -597.871f, 460.0938f), 
+                                              new Vector3(40f, -659.326f, 471.0408f) };
+
+        static Vector2[] meshTextures = new Vector2[] { new Vector2(0f, 0f), new Vector2(0f, 0.04f), new Vector2(0f, 0.08f), new Vector2(0f, 0.12f), new Vector2(0f, 0.16f), new Vector2(0f, 0.2f), 
+                                             new Vector2(0f, 0.24f), new Vector2(0f, 0.28f), new Vector2(0f, 0.32f), new Vector2(0f, 0.36f), new Vector2(0f, 0.4f), new Vector2(0f, 0.44f), 
+                                             new Vector2(0f, 0.48f), new Vector2(0f, 0.52f), new Vector2(0f, 0.56f), new Vector2(0f, 0.6f), new Vector2(0f, 0.64f), new Vector2(0f, 0.68f), 
+                                             new Vector2(0f, 0.72f), new Vector2(0f, 0.76f), new Vector2(0f, 0.8f), new Vector2(0f, 0.84f), new Vector2(0f, 0.88f), new Vector2(0f, 0.92f), 
+                                             new Vector2(0f, 0.96f), new Vector2(0.04f, 0f), new Vector2(0.04f, 0.04f), new Vector2(0.04f, 0.08f), new Vector2(0.04f, 0.12f), new Vector2(0.04f, 0.16f), 
+                                             new Vector2(0.04f, 0.2f), new Vector2(0.04f, 0.24f), new Vector2(0.04f, 0.28f), new Vector2(0.04f, 0.32f), new Vector2(0.04f, 0.36f), new Vector2(0.04f, 0.4f), 
+                                             new Vector2(0.04f, 0.44f), new Vector2(0.04f, 0.48f), new Vector2(0.04f, 0.52f), new Vector2(0.04f, 0.56f), new Vector2(0.04f, 0.6f), new Vector2(0.04f, 0.64f), 
+                                             new Vector2(0.04f, 0.68f), new Vector2(0.04f, 0.72f), new Vector2(0.04f, 0.76f), new Vector2(0.04f, 0.8f), new Vector2(0.04f, 0.84f), new Vector2(0.04f, 0.88f), 
+                                             new Vector2(0.04f, 0.92f), new Vector2(0.04f, 0.96f), new Vector2(0.08f, 0f), new Vector2(0.08f, 0.04f), new Vector2(0.08f, 0.08f), new Vector2(0.08f, 0.12f), 
+                                             new Vector2(0.08f, 0.16f), new Vector2(0.08f, 0.2f), new Vector2(0.08f, 0.24f), new Vector2(0.08f, 0.28f), new Vector2(0.08f, 0.32f), new Vector2(0.08f, 0.36f), 
+                                             new Vector2(0.08f, 0.4f), new Vector2(0.08f, 0.44f), new Vector2(0.08f, 0.48f), new Vector2(0.08f, 0.52f), new Vector2(0.08f, 0.56f), new Vector2(0.08f, 0.6f), 
+                                             new Vector2(0.08f, 0.64f), new Vector2(0.08f, 0.68f), new Vector2(0.08f, 0.72f), new Vector2(0.08f, 0.76f), new Vector2(0.08f, 0.8f), new Vector2(0.08f, 0.84f), 
+                                             new Vector2(0.08f, 0.88f), new Vector2(0.08f, 0.92f), new Vector2(0.08f, 0.96f), new Vector2(0.12f, 0f), new Vector2(0.12f, 0.04f), new Vector2(0.12f, 0.08f), 
+                                             new Vector2(0.12f, 0.12f), new Vector2(0.12f, 0.16f), new Vector2(0.12f, 0.2f), new Vector2(0.12f, 0.24f), new Vector2(0.12f, 0.28f), new Vector2(0.12f, 0.32f), 
+                                             new Vector2(0.12f, 0.36f), new Vector2(0.12f, 0.4f), new Vector2(0.12f, 0.44f), new Vector2(0.12f, 0.48f), new Vector2(0.12f, 0.52f), new Vector2(0.12f, 0.56f), 
+                                             new Vector2(0.12f, 0.6f), new Vector2(0.12f, 0.64f), new Vector2(0.12f, 0.68f), new Vector2(0.12f, 0.72f), new Vector2(0.12f, 0.76f), new Vector2(0.12f, 0.8f), 
+                                             new Vector2(0.12f, 0.84f), new Vector2(0.12f, 0.88f), new Vector2(0.12f, 0.92f), new Vector2(0.12f, 0.96f), new Vector2(0.16f, 0f), new Vector2(0.16f, 0.04f), 
+                                             new Vector2(0.16f, 0.08f), new Vector2(0.16f, 0.12f), new Vector2(0.16f, 0.16f), new Vector2(0.16f, 0.2f), new Vector2(0.16f, 0.24f), new Vector2(0.16f, 0.28f), 
+                                             new Vector2(0.16f, 0.32f), new Vector2(0.16f, 0.36f), new Vector2(0.16f, 0.4f), new Vector2(0.16f, 0.44f), new Vector2(0.16f, 0.48f), new Vector2(0.16f, 0.52f), 
+                                             new Vector2(0.16f, 0.56f), new Vector2(0.16f, 0.6f), new Vector2(0.16f, 0.64f), new Vector2(0.16f, 0.68f), new Vector2(0.16f, 0.72f), new Vector2(0.16f, 0.76f), 
+                                             new Vector2(0.16f, 0.8f), new Vector2(0.16f, 0.84f), new Vector2(0.16f, 0.88f), new Vector2(0.16f, 0.92f), new Vector2(0.16f, 0.96f), new Vector2(0.2f, 0f), 
+                                             new Vector2(0.2f, 0.04f), new Vector2(0.2f, 0.08f), new Vector2(0.2f, 0.12f), new Vector2(0.2f, 0.16f), new Vector2(0.2f, 0.2f), new Vector2(0.2f, 0.24f), 
+                                             new Vector2(0.2f, 0.28f), new Vector2(0.2f, 0.32f), new Vector2(0.2f, 0.36f), new Vector2(0.2f, 0.4f), new Vector2(0.2f, 0.44f), new Vector2(0.2f, 0.48f), 
+                                             new Vector2(0.2f, 0.52f), new Vector2(0.2f, 0.56f), new Vector2(0.2f, 0.6f), new Vector2(0.2f, 0.64f), new Vector2(0.2f, 0.68f), new Vector2(0.2f, 0.72f), 
+                                             new Vector2(0.2f, 0.76f), new Vector2(0.2f, 0.8f), new Vector2(0.2f, 0.84f), new Vector2(0.2f, 0.88f), new Vector2(0.2f, 0.92f), new Vector2(0.2f, 0.96f), 
+                                             new Vector2(0.24f, 0f), new Vector2(0.24f, 0.04f), new Vector2(0.24f, 0.08f), new Vector2(0.24f, 0.12f), new Vector2(0.24f, 0.16f), new Vector2(0.24f, 0.2f), 
+                                             new Vector2(0.24f, 0.24f), new Vector2(0.24f, 0.28f), new Vector2(0.24f, 0.32f), new Vector2(0.24f, 0.36f), new Vector2(0.24f, 0.4f), new Vector2(0.24f, 0.44f), 
+                                             new Vector2(0.24f, 0.48f), new Vector2(0.24f, 0.52f), new Vector2(0.24f, 0.56f), new Vector2(0.24f, 0.6f), new Vector2(0.24f, 0.64f), new Vector2(0.24f, 0.68f), 
+                                             new Vector2(0.24f, 0.72f), new Vector2(0.24f, 0.76f), new Vector2(0.24f, 0.8f), new Vector2(0.24f, 0.84f), new Vector2(0.24f, 0.88f), new Vector2(0.24f, 0.92f), 
+                                             new Vector2(0.24f, 0.96f), new Vector2(0.28f, 0f), new Vector2(0.28f, 0.04f), new Vector2(0.28f, 0.08f), new Vector2(0.28f, 0.12f), new Vector2(0.28f, 0.16f), 
+                                             new Vector2(0.28f, 0.2f), new Vector2(0.28f, 0.24f), new Vector2(0.28f, 0.28f), new Vector2(0.28f, 0.32f), new Vector2(0.28f, 0.36f), new Vector2(0.28f, 0.4f), 
+                                             new Vector2(0.28f, 0.44f), new Vector2(0.28f, 0.48f), new Vector2(0.28f, 0.52f), new Vector2(0.28f, 0.56f), new Vector2(0.28f, 0.6f), new Vector2(0.28f, 0.64f), 
+                                             new Vector2(0.28f, 0.68f), new Vector2(0.28f, 0.72f), new Vector2(0.28f, 0.76f), new Vector2(0.28f, 0.8f), new Vector2(0.28f, 0.84f), new Vector2(0.28f, 0.88f), 
+                                             new Vector2(0.28f, 0.92f), new Vector2(0.28f, 0.96f), new Vector2(0.32f, 0f), new Vector2(0.32f, 0.04f), new Vector2(0.32f, 0.08f), new Vector2(0.32f, 0.12f), 
+                                             new Vector2(0.32f, 0.16f), new Vector2(0.32f, 0.2f), new Vector2(0.32f, 0.24f), new Vector2(0.32f, 0.28f), new Vector2(0.32f, 0.32f), new Vector2(0.32f, 0.36f), 
+                                             new Vector2(0.32f, 0.4f), new Vector2(0.32f, 0.44f), new Vector2(0.32f, 0.48f), new Vector2(0.32f, 0.52f), new Vector2(0.32f, 0.56f), new Vector2(0.32f, 0.6f), 
+                                             new Vector2(0.32f, 0.64f), new Vector2(0.32f, 0.68f), new Vector2(0.32f, 0.72f), new Vector2(0.32f, 0.76f), new Vector2(0.32f, 0.8f), new Vector2(0.32f, 0.84f), 
+                                             new Vector2(0.32f, 0.88f), new Vector2(0.32f, 0.92f), new Vector2(0.32f, 0.96f), new Vector2(0.36f, 0f), new Vector2(0.36f, 0.04f), new Vector2(0.36f, 0.08f), 
+                                             new Vector2(0.36f, 0.12f), new Vector2(0.36f, 0.16f), new Vector2(0.36f, 0.2f), new Vector2(0.36f, 0.24f), new Vector2(0.36f, 0.28f), new Vector2(0.36f, 0.32f), 
+                                             new Vector2(0.36f, 0.36f), new Vector2(0.36f, 0.4f), new Vector2(0.36f, 0.44f), new Vector2(0.36f, 0.48f), new Vector2(0.36f, 0.52f), new Vector2(0.36f, 0.56f), 
+                                             new Vector2(0.36f, 0.6f), new Vector2(0.36f, 0.64f), new Vector2(0.36f, 0.68f), new Vector2(0.36f, 0.72f), new Vector2(0.36f, 0.76f), new Vector2(0.36f, 0.8f), 
+                                             new Vector2(0.36f, 0.84f), new Vector2(0.36f, 0.88f), new Vector2(0.36f, 0.92f), new Vector2(0.36f, 0.96f), new Vector2(0.4f, 0f), new Vector2(0.4f, 0.04f), 
+                                             new Vector2(0.4f, 0.08f), new Vector2(0.4f, 0.12f), new Vector2(0.4f, 0.16f), new Vector2(0.4f, 0.2f), new Vector2(0.4f, 0.24f), new Vector2(0.4f, 0.28f), 
+                                             new Vector2(0.4f, 0.32f), new Vector2(0.4f, 0.36f), new Vector2(0.4f, 0.4f), new Vector2(0.4f, 0.44f), new Vector2(0.4f, 0.48f), new Vector2(0.4f, 0.52f), 
+                                             new Vector2(0.4f, 0.56f), new Vector2(0.4f, 0.6f), new Vector2(0.4f, 0.64f), new Vector2(0.4f, 0.68f), new Vector2(0.4f, 0.72f), new Vector2(0.4f, 0.76f), 
+                                             new Vector2(0.4f, 0.8f), new Vector2(0.4f, 0.84f), new Vector2(0.4f, 0.88f), new Vector2(0.4f, 0.92f), new Vector2(0.4f, 0.96f), new Vector2(0.44f, 0f), 
+                                             new Vector2(0.44f, 0.04f), new Vector2(0.44f, 0.08f), new Vector2(0.44f, 0.12f), new Vector2(0.44f, 0.16f), new Vector2(0.44f, 0.2f), new Vector2(0.44f, 0.24f), 
+                                             new Vector2(0.44f, 0.28f), new Vector2(0.44f, 0.32f), new Vector2(0.44f, 0.36f), new Vector2(0.44f, 0.4f), new Vector2(0.44f, 0.44f), new Vector2(0.44f, 0.48f), 
+                                             new Vector2(0.44f, 0.52f), new Vector2(0.44f, 0.56f), new Vector2(0.44f, 0.6f), new Vector2(0.44f, 0.64f), new Vector2(0.44f, 0.68f), new Vector2(0.44f, 0.72f), 
+                                             new Vector2(0.44f, 0.76f), new Vector2(0.44f, 0.8f), new Vector2(0.44f, 0.84f), new Vector2(0.44f, 0.88f), new Vector2(0.44f, 0.92f), new Vector2(0.44f, 0.96f), 
+                                             new Vector2(0.48f, 0f), new Vector2(0.48f, 0.04f), new Vector2(0.48f, 0.08f), new Vector2(0.48f, 0.12f), new Vector2(0.48f, 0.16f), new Vector2(0.48f, 0.2f), 
+                                             new Vector2(0.48f, 0.24f), new Vector2(0.48f, 0.28f), new Vector2(0.48f, 0.32f), new Vector2(0.48f, 0.36f), new Vector2(0.48f, 0.4f), new Vector2(0.48f, 0.44f), 
+                                             new Vector2(0.48f, 0.48f), new Vector2(0.48f, 0.52f), new Vector2(0.48f, 0.56f), new Vector2(0.48f, 0.6f), new Vector2(0.48f, 0.64f), new Vector2(0.48f, 0.68f), 
+                                             new Vector2(0.48f, 0.72f), new Vector2(0.48f, 0.76f), new Vector2(0.48f, 0.8f), new Vector2(0.48f, 0.84f), new Vector2(0.48f, 0.88f), new Vector2(0.48f, 0.92f), 
+                                             new Vector2(0.48f, 0.96f), new Vector2(0.52f, 0f), new Vector2(0.52f, 0.04f), new Vector2(0.52f, 0.08f), new Vector2(0.52f, 0.12f), new Vector2(0.52f, 0.16f), 
+                                             new Vector2(0.52f, 0.2f), new Vector2(0.52f, 0.24f), new Vector2(0.52f, 0.28f), new Vector2(0.52f, 0.32f), new Vector2(0.52f, 0.36f), new Vector2(0.52f, 0.4f), 
+                                             new Vector2(0.52f, 0.44f), new Vector2(0.52f, 0.48f), new Vector2(0.52f, 0.52f), new Vector2(0.52f, 0.56f), new Vector2(0.52f, 0.6f), new Vector2(0.52f, 0.64f), 
+                                             new Vector2(0.52f, 0.68f), new Vector2(0.52f, 0.72f), new Vector2(0.52f, 0.76f), new Vector2(0.52f, 0.8f), new Vector2(0.52f, 0.84f), new Vector2(0.52f, 0.88f), 
+                                             new Vector2(0.52f, 0.92f), new Vector2(0.52f, 0.96f), new Vector2(0.56f, 0f), new Vector2(0.56f, 0.04f), new Vector2(0.56f, 0.08f), new Vector2(0.56f, 0.12f), 
+                                             new Vector2(0.56f, 0.16f), new Vector2(0.56f, 0.2f), new Vector2(0.56f, 0.24f), new Vector2(0.56f, 0.28f), new Vector2(0.56f, 0.32f), new Vector2(0.56f, 0.36f), 
+                                             new Vector2(0.56f, 0.4f), new Vector2(0.56f, 0.44f), new Vector2(0.56f, 0.48f), new Vector2(0.56f, 0.52f), new Vector2(0.56f, 0.56f), new Vector2(0.56f, 0.6f), 
+                                             new Vector2(0.56f, 0.64f), new Vector2(0.56f, 0.68f), new Vector2(0.56f, 0.72f), new Vector2(0.56f, 0.76f), new Vector2(0.56f, 0.8f), new Vector2(0.56f, 0.84f), 
+                                             new Vector2(0.56f, 0.88f), new Vector2(0.56f, 0.92f), new Vector2(0.56f, 0.96f), new Vector2(0.6f, 0f), new Vector2(0.6f, 0.04f), new Vector2(0.6f, 0.08f), 
+                                             new Vector2(0.6f, 0.12f), new Vector2(0.6f, 0.16f), new Vector2(0.6f, 0.2f), new Vector2(0.6f, 0.24f), new Vector2(0.6f, 0.28f), new Vector2(0.6f, 0.32f), 
+                                             new Vector2(0.6f, 0.36f), new Vector2(0.6f, 0.4f), new Vector2(0.6f, 0.44f), new Vector2(0.6f, 0.48f), new Vector2(0.6f, 0.52f), new Vector2(0.6f, 0.56f), 
+                                             new Vector2(0.6f, 0.6f), new Vector2(0.6f, 0.64f), new Vector2(0.6f, 0.68f), new Vector2(0.6f, 0.72f), new Vector2(0.6f, 0.76f), new Vector2(0.6f, 0.8f), 
+                                             new Vector2(0.6f, 0.84f), new Vector2(0.6f, 0.88f), new Vector2(0.6f, 0.92f), new Vector2(0.6f, 0.96f), new Vector2(0.64f, 0f), new Vector2(0.64f, 0.04f), 
+                                             new Vector2(0.64f, 0.08f), new Vector2(0.64f, 0.12f), new Vector2(0.64f, 0.16f), new Vector2(0.64f, 0.2f), new Vector2(0.64f, 0.24f), new Vector2(0.64f, 0.28f), 
+                                             new Vector2(0.64f, 0.32f), new Vector2(0.64f, 0.36f), new Vector2(0.64f, 0.4f), new Vector2(0.64f, 0.44f), new Vector2(0.64f, 0.48f), new Vector2(0.64f, 0.52f), 
+                                             new Vector2(0.64f, 0.56f), new Vector2(0.64f, 0.6f), new Vector2(0.64f, 0.64f), new Vector2(0.64f, 0.68f), new Vector2(0.64f, 0.72f), new Vector2(0.64f, 0.76f), 
+                                             new Vector2(0.64f, 0.8f), new Vector2(0.64f, 0.84f), new Vector2(0.64f, 0.88f), new Vector2(0.64f, 0.92f), new Vector2(0.64f, 0.96f), new Vector2(0.68f, 0f), 
+                                             new Vector2(0.68f, 0.04f), new Vector2(0.68f, 0.08f), new Vector2(0.68f, 0.12f), new Vector2(0.68f, 0.16f), new Vector2(0.68f, 0.2f), new Vector2(0.68f, 0.24f), 
+                                             new Vector2(0.68f, 0.28f), new Vector2(0.68f, 0.32f), new Vector2(0.68f, 0.36f), new Vector2(0.68f, 0.4f), new Vector2(0.68f, 0.44f), new Vector2(0.68f, 0.48f), 
+                                             new Vector2(0.68f, 0.52f), new Vector2(0.68f, 0.56f), new Vector2(0.68f, 0.6f), new Vector2(0.68f, 0.64f), new Vector2(0.68f, 0.68f), new Vector2(0.68f, 0.72f), 
+                                             new Vector2(0.68f, 0.76f), new Vector2(0.68f, 0.8f), new Vector2(0.68f, 0.84f), new Vector2(0.68f, 0.88f), new Vector2(0.68f, 0.92f), new Vector2(0.68f, 0.96f), 
+                                             new Vector2(0.72f, 0f), new Vector2(0.72f, 0.04f), new Vector2(0.72f, 0.08f), new Vector2(0.72f, 0.12f), new Vector2(0.72f, 0.16f), new Vector2(0.72f, 0.2f), 
+                                             new Vector2(0.72f, 0.24f), new Vector2(0.72f, 0.28f), new Vector2(0.72f, 0.32f), new Vector2(0.72f, 0.36f), new Vector2(0.72f, 0.4f), new Vector2(0.72f, 0.44f), 
+                                             new Vector2(0.72f, 0.48f), new Vector2(0.72f, 0.52f), new Vector2(0.72f, 0.56f), new Vector2(0.72f, 0.6f), new Vector2(0.72f, 0.64f), new Vector2(0.72f, 0.68f), 
+                                             new Vector2(0.72f, 0.72f), new Vector2(0.72f, 0.76f), new Vector2(0.72f, 0.8f), new Vector2(0.72f, 0.84f), new Vector2(0.72f, 0.88f), new Vector2(0.72f, 0.92f), 
+                                             new Vector2(0.72f, 0.96f), new Vector2(0.76f, 0f), new Vector2(0.76f, 0.04f), new Vector2(0.76f, 0.08f), new Vector2(0.76f, 0.12f), new Vector2(0.76f, 0.16f), 
+                                             new Vector2(0.76f, 0.2f), new Vector2(0.76f, 0.24f), new Vector2(0.76f, 0.28f), new Vector2(0.76f, 0.32f), new Vector2(0.76f, 0.36f), new Vector2(0.76f, 0.4f), 
+                                             new Vector2(0.76f, 0.44f), new Vector2(0.76f, 0.48f), new Vector2(0.76f, 0.52f), new Vector2(0.76f, 0.56f), new Vector2(0.76f, 0.6f), new Vector2(0.76f, 0.64f), 
+                                             new Vector2(0.76f, 0.68f), new Vector2(0.76f, 0.72f), new Vector2(0.76f, 0.76f), new Vector2(0.76f, 0.8f), new Vector2(0.76f, 0.84f), new Vector2(0.76f, 0.88f), 
+                                             new Vector2(0.76f, 0.92f), new Vector2(0.76f, 0.96f), new Vector2(0.8f, 0f), new Vector2(0.8f, 0.04f), new Vector2(0.8f, 0.08f), new Vector2(0.8f, 0.12f), 
+                                             new Vector2(0.8f, 0.16f), new Vector2(0.8f, 0.2f), new Vector2(0.8f, 0.24f), new Vector2(0.8f, 0.28f), new Vector2(0.8f, 0.32f), new Vector2(0.8f, 0.36f), 
+                                             new Vector2(0.8f, 0.4f), new Vector2(0.8f, 0.44f), new Vector2(0.8f, 0.48f), new Vector2(0.8f, 0.52f), new Vector2(0.8f, 0.56f), new Vector2(0.8f, 0.6f), 
+                                             new Vector2(0.8f, 0.64f), new Vector2(0.8f, 0.68f), new Vector2(0.8f, 0.72f), new Vector2(0.8f, 0.76f), new Vector2(0.8f, 0.8f), new Vector2(0.8f, 0.84f), 
+                                             new Vector2(0.8f, 0.88f), new Vector2(0.8f, 0.92f), new Vector2(0.8f, 0.96f), new Vector2(0.84f, 0f), new Vector2(0.84f, 0.04f), new Vector2(0.84f, 0.08f), 
+                                             new Vector2(0.84f, 0.12f), new Vector2(0.84f, 0.16f), new Vector2(0.84f, 0.2f), new Vector2(0.84f, 0.24f), new Vector2(0.84f, 0.28f), new Vector2(0.84f, 0.32f), 
+                                             new Vector2(0.84f, 0.36f), new Vector2(0.84f, 0.4f), new Vector2(0.84f, 0.44f), new Vector2(0.84f, 0.48f), new Vector2(0.84f, 0.52f), new Vector2(0.84f, 0.56f), 
+                                             new Vector2(0.84f, 0.6f), new Vector2(0.84f, 0.64f), new Vector2(0.84f, 0.68f), new Vector2(0.84f, 0.72f), new Vector2(0.84f, 0.76f), new Vector2(0.84f, 0.8f), 
+                                             new Vector2(0.84f, 0.84f), new Vector2(0.84f, 0.88f), new Vector2(0.84f, 0.92f), new Vector2(0.84f, 0.96f), new Vector2(0.88f, 0f), new Vector2(0.88f, 0.04f), 
+                                             new Vector2(0.88f, 0.08f), new Vector2(0.88f, 0.12f), new Vector2(0.88f, 0.16f), new Vector2(0.88f, 0.2f), new Vector2(0.88f, 0.24f), new Vector2(0.88f, 0.28f), 
+                                             new Vector2(0.88f, 0.32f), new Vector2(0.88f, 0.36f), new Vector2(0.88f, 0.4f), new Vector2(0.88f, 0.44f), new Vector2(0.88f, 0.48f), new Vector2(0.88f, 0.52f), 
+                                             new Vector2(0.88f, 0.56f), new Vector2(0.88f, 0.6f), new Vector2(0.88f, 0.64f), new Vector2(0.88f, 0.68f), new Vector2(0.88f, 0.72f), new Vector2(0.88f, 0.76f), 
+                                             new Vector2(0.88f, 0.8f), new Vector2(0.88f, 0.84f), new Vector2(0.88f, 0.88f), new Vector2(0.88f, 0.92f), new Vector2(0.88f, 0.96f), new Vector2(0.92f, 0f), 
+                                             new Vector2(0.92f, 0.04f), new Vector2(0.92f, 0.08f), new Vector2(0.92f, 0.12f), new Vector2(0.92f, 0.16f), new Vector2(0.92f, 0.2f), new Vector2(0.92f, 0.24f), 
+                                             new Vector2(0.92f, 0.28f), new Vector2(0.92f, 0.32f), new Vector2(0.92f, 0.36f), new Vector2(0.92f, 0.4f), new Vector2(0.92f, 0.44f), new Vector2(0.92f, 0.48f), 
+                                             new Vector2(0.92f, 0.52f), new Vector2(0.92f, 0.56f), new Vector2(0.92f, 0.6f), new Vector2(0.92f, 0.64f), new Vector2(0.92f, 0.68f), new Vector2(0.92f, 0.72f), 
+                                             new Vector2(0.92f, 0.76f), new Vector2(0.92f, 0.8f), new Vector2(0.92f, 0.84f), new Vector2(0.92f, 0.88f), new Vector2(0.92f, 0.92f), new Vector2(0.92f, 0.96f), 
+                                             new Vector2(0.96f, 0f), new Vector2(0.96f, 0.04f), new Vector2(0.96f, 0.08f), new Vector2(0.96f, 0.12f), new Vector2(0.96f, 0.16f), new Vector2(0.96f, 0.2f), 
+                                             new Vector2(0.96f, 0.24f), new Vector2(0.96f, 0.28f), new Vector2(0.96f, 0.32f), new Vector2(0.96f, 0.36f), new Vector2(0.96f, 0.4f), new Vector2(0.96f, 0.44f), 
+                                             new Vector2(0.96f, 0.48f), new Vector2(0.96f, 0.52f), new Vector2(0.96f, 0.56f), new Vector2(0.96f, 0.6f), new Vector2(0.96f, 0.64f), new Vector2(0.96f, 0.68f), 
+                                             new Vector2(0.96f, 0.72f), new Vector2(0.96f, 0.76f), new Vector2(0.96f, 0.8f), new Vector2(0.96f, 0.84f), new Vector2(0.96f, 0.88f), new Vector2(0.96f, 0.92f), 
+                                             new Vector2(0.96f, 0.96f) };
+
+        public TriangleMesh2(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            TriangleMesh triangleMesh = scene.Factory.TriangleMeshManager.Create("TriangleMesh2");
+
+            TriangleMeshRegion r = triangleMesh.TriangleMeshRegionManager.Create(null);
+
+            for (int i = 0; i < meshPositions.Length; i++)
+            {
+                Vertex v = r.VertexManager.Create(null);
+
+                v.SetPosition(ref meshPositions[i]);
+                v.SetTexture(ref meshTextures[i]);
+            }
+
+            for (int i = 0; i < meshIndices.Length; i += 3)
+            {
+                Triangle t = r.TriangleManager.Create(null);
+
+                t.Index1 = meshIndices[i];
+                t.Index2 = meshIndices[i + 1];
+                t.Index3 = meshIndices[i + 2];
+            }
+
+            triangleMesh.Update(true, false);
+
+            if (!demo.Meshes.ContainsKey("TriangleMesh2"))
+                demo.Meshes.Add("TriangleMesh2", new DemoMesh(demo, triangleMesh, demo.Textures["Default"], Vector2.One, true, true, true, false, true, CullFaceMode.FrontAndBack, false, false));
+
+            int triangleCount = 0;
+            float[] frictions = null;
+            float[] restitutions = null;
+
+            triangleCount = triangleMesh.GetTriangleCount();
+            frictions = new float[triangleCount];
+            restitutions = new float[triangleCount];
+
+            for (int i = 0; i < triangleCount; i++)
+            {
+                frictions[i] = 1.0f;
+                restitutions[i] = 0.0f;
+            }
+
+            ShapePrimitive shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("TriangleMesh2");
+            shapePrimitive.CreateTriangleMesh(triangleMesh, false, 2, frictions, restitutions, 1.0f, 0.0f);
+
+            Shape shape = scene.Factory.ShapeManager.Create("TriangleMesh2");
+            shape.Set(shapePrimitive, Matrix4.Identity, 0.1f);
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, float density)
+        {
+            PhysicsObject objectBase = null;
+            Shape shape = scene.Factory.ShapeManager.Find("TriangleMesh2");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("TriangleMesh2" + instanceIndexName);
+            objectBase.Shape = shape;
+            objectBase.UserDataStr = "TriangleMesh2";
+            objectBase.InitLocalTransform.SetPosition(ref objectPosition);
+            objectBase.InitLocalTransform.SetScale(ref objectScale);
+            objectBase.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectBase.Integral.SetDensity(density);
+            objectBase.EnableLocalGravity = true;
+            objectBase.MaxSleepAngularVelocity = 0.05f;
+            objectBase.MaxSleepLinearVelocity = 0.05f;
+            objectBase.InternalControllers.CreateTriangleMeshController(true);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/UserShapes.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/UserShapes.cs
new file mode 100644
index 0000000..ea638b6
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/UserShapes.cs
@@ -0,0 +1,230 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class UserShapes
+    {
+        Demo demo;
+        PhysicsScene scene;
+
+        public UserShapes(Demo demo)
+        {
+            this.demo = demo;
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+            ShapePrimitive shapePrimitive = null;
+            Shape shape = null;
+            Shape userShape = null;
+
+            Shape sphere = scene.Factory.ShapeManager.Find("Sphere");
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape coneY = scene.Factory.ShapeManager.Find("ConeY");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 1");
+            shape.Add(box, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape1"))
+                demo.Meshes.Add("UserShape1", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 2");
+            shape.Add(coneY, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape2"))
+                demo.Meshes.Add("UserShape2", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 3");
+            shape.Add(cylinderY, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape3"))
+                demo.Meshes.Add("UserShape3", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 4");
+            shape.Add(coneY, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(cylinderY, Matrix4.CreateScale(4.0f, 0.5f, 4.0f), 0.0f, ShapeCompoundType.ConvexHull);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape4"))
+                demo.Meshes.Add("UserShape4", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            Vector3[] convexTab1 = new Vector3[6];
+            convexTab1[0] = new Vector3(0.0f, -2.0f, 0.0f);
+            convexTab1[1] = new Vector3(0.0f, 4.0f, 0.0f);
+            convexTab1[2] = new Vector3(2.0f, 0.0f, 0.0f);
+            convexTab1[3] = new Vector3(-4.0f, 0.0f, 0.0f);
+            convexTab1[4] = new Vector3(0.0f, 0.0f, 4.0f);
+            convexTab1[5] = new Vector3(0.0f, 0.0f, -2.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Convex 1");
+            shapePrimitive.CreateConvex(convexTab1);
+
+            userShape = scene.Factory.ShapeManager.Create("UserShape 5");
+            userShape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            userShape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape5"))
+                demo.Meshes.Add("UserShape5", new DemoMesh(demo, userShape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 6");
+            shape.Add(userShape, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape6"))
+                demo.Meshes.Add("UserShape6", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            Vector3[] convexTab2 = new Vector3[10];
+            convexTab2[0] = new Vector3(-2.0f, -0.5f, -1.0f);
+            convexTab2[1] = new Vector3(-1.5f, -0.5f, 0.5f);
+            convexTab2[2] = new Vector3(0.0f, -0.5f, 2.0f);
+            convexTab2[3] = new Vector3(1.5f, -0.5f, 0.5f);
+            convexTab2[4] = new Vector3(2.0f, -0.5f, -1.0f);
+            convexTab2[5] = new Vector3(-2.0f, 0.5f, -1.0f);
+            convexTab2[6] = new Vector3(-1.5f, 0.5f, 0.5f);
+            convexTab2[7] = new Vector3(0.0f, 0.5f, 2.0f);
+            convexTab2[8] = new Vector3(1.5f, 0.5f, 0.5f);
+            convexTab2[9] = new Vector3(2.0f, 0.5f, -1.0f);
+
+            shapePrimitive = scene.Factory.ShapePrimitiveManager.Create("Convex 2");
+            shapePrimitive.CreateConvex(convexTab2);
+            userShape = scene.Factory.ShapeManager.Create("UserShape 7");
+            userShape.Set(shapePrimitive, Matrix4.Identity, 0.0f);
+            userShape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape7"))
+                demo.Meshes.Add("UserShape7", new DemoMesh(demo, userShape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+
+            shape = scene.Factory.ShapeManager.Create("UserShape 8");
+            shape.Add(userShape, Matrix4.Identity, 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.Add(sphere, Matrix4.CreateScale(0.5f), 0.0f, ShapeCompoundType.MinkowskiSum);
+            shape.CreateMesh(0.0f);
+
+            if (!demo.Meshes.ContainsKey("UserShape8"))
+                demo.Meshes.Add("UserShape8", new DemoMesh(demo, shape, demo.Textures["Default"], Vector2.One, false, false, false, false, true, CullFaceMode.Back, false, false));
+        }
+
+        public void Create()
+        {
+            PhysicsObject objectBase = null;
+
+            Shape userShape1 = scene.Factory.ShapeManager.Find("UserShape 1");
+            Shape userShape2 = scene.Factory.ShapeManager.Find("UserShape 2");
+            Shape userShape3 = scene.Factory.ShapeManager.Find("UserShape 3");
+            Shape userShape4 = scene.Factory.ShapeManager.Find("UserShape 4");
+            Shape userShape5 = scene.Factory.ShapeManager.Find("UserShape 5");
+            Shape userShape6 = scene.Factory.ShapeManager.Find("UserShape 6");
+            Shape userShape7 = scene.Factory.ShapeManager.Find("UserShape 7");
+            Shape userShape8 = scene.Factory.ShapeManager.Find("UserShape 8");
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 1");
+            objectBase.Shape = userShape1;
+            objectBase.UserDataStr = "UserShape1";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 2");
+            objectBase.Shape = userShape2;
+            objectBase.UserDataStr = "UserShape2";
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.InitLocalTransform.SetPosition(20.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 3");
+            objectBase.Shape = userShape3;
+            objectBase.UserDataStr = "UserShape3";
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.InitLocalTransform.SetPosition(20.0f, 20.0f, 5.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 4");
+            objectBase.Shape = userShape4;
+            objectBase.UserDataStr = "UserShape4";
+            objectBase.Material.TransparencyFactor = 0.5f;
+            objectBase.CreateSound(true);
+            objectBase.Sound.MinNextImpactForce = 7000.0f;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 20.0f, 20.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 5");
+            objectBase.Shape = userShape5;
+            objectBase.UserDataStr = "UserShape5";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(-20.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 6");
+            objectBase.Shape = userShape6;
+            objectBase.UserDataStr = "UserShape6";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(20.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 7");
+            objectBase.Shape = userShape7;
+            objectBase.UserDataStr = "UserShape7";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(6.0f, 20.0f, 5.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("UserShape 8");
+            objectBase.Shape = userShape8;
+            objectBase.UserDataStr = "UserShape8";
+            objectBase.CreateSound(true);
+            objectBase.InitLocalTransform.SetPosition(0.0f, 20.0f, 40.0f);
+            objectBase.InitLocalTransform.SetScale(2.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            scene.UpdateFromInitLocalTransform(objectBase);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Vehicle1.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Vehicle1.cs
new file mode 100644
index 0000000..a9d478d
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Vehicle1.cs
@@ -0,0 +1,176 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Vehicle1
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Vehicle1(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation)
+        {
+            Shape box = scene.Factory.ShapeManager.Find("Box");
+            Shape cylinderY = scene.Factory.ShapeManager.Find("CylinderY");
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+            PhysicsObject objectA = null;
+            PhysicsObject objectB = null;
+
+            Vector3 position1 = Vector3.Zero;
+            Quaternion orientation1 = Quaternion.Identity;
+            Quaternion orientation2 = Quaternion.Identity;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Vehicle 1" + instanceIndexName);
+
+            objectA = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Body" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectA);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Body Up" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 1.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 0.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Body Down" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetScale(4.0f, 1.0f, 4.0f);
+            objectBase.Integral.SetDensity(1.0f);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Wing Right" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(4.0f, -1.0f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(10.0f)));
+            objectBase.InitLocalTransform.SetScale(4.0f, 0.1f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Wing Left" + instanceIndexName);
+            objectA.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = box;
+            objectBase.UserDataStr = "Box";
+            objectBase.Material.UserDataStr = "Plastic1";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-4.0f, -1.0f, 0.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(-10.0f)));
+            objectBase.InitLocalTransform.SetScale(4.0f, 0.1f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectB = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Turret" + instanceIndexName);
+            objectRoot.AddChildPhysicsObject(objectB);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Turret Body Up" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 4.0f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(3.0f, 0.5f, 3.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Turret Body Down" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Paint2";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(0.0f, 2.5f, 0.0f);
+            objectBase.InitLocalTransform.SetScale(4.0f, 1.0f, 4.0f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Turret Gun 1" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(-1.0f, 2.5f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 2.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectBase = scene.Factory.PhysicsObjectManager.Create("Vehicle 1 Turret Gun 2" + instanceIndexName);
+            objectB.AddChildPhysicsObject(objectBase);
+            objectBase.Shape = cylinderY;
+            objectBase.UserDataStr = "CylinderY";
+            objectBase.Material.UserDataStr = "Iron";
+            objectBase.Material.RigidGroup = true;
+            objectBase.InitLocalTransform.SetPosition(1.0f, 2.5f, 5.0f);
+            objectBase.InitLocalTransform.SetOrientation(Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-90.0f)));
+            objectBase.InitLocalTransform.SetScale(0.5f, 2.0f, 0.5f);
+            objectBase.Integral.SetDensity(1.0f);
+            objectBase.CreateSound(true);
+
+            objectRoot.UpdateFromInitLocalTransform();
+
+            Constraint constraint = null;
+            constraint = scene.Factory.ConstraintManager.Create("Vehicle 1 Turret Constraint" + instanceIndexName);
+            constraint.PhysicsObject1 = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Turret Body Down" + instanceIndexName);
+            constraint.PhysicsObject2 = scene.Factory.PhysicsObjectManager.Find("Vehicle 1 Body Up" + instanceIndexName);
+            constraint.PhysicsObject1.MainWorldTransform.GetPosition(ref position1);
+            constraint.PhysicsObject1.MainWorldTransform.GetOrientation(ref orientation1);
+            constraint.PhysicsObject2.MainWorldTransform.GetOrientation(ref orientation2);
+            constraint.SetAnchor1(position1 + new Vector3(0.0f, -1.0f, 0.0f));
+            constraint.SetAnchor2(position1 + new Vector3(0.0f, -1.0f, 0.0f));
+            constraint.SetInitWorldOrientation1(ref orientation1);
+            constraint.SetInitWorldOrientation2(ref orientation2);
+            constraint.EnableLimitAngleX = true;
+            constraint.EnableLimitAngleZ = true;
+            constraint.EnableControlAngleY = true;
+            constraint.EnableBreak = true;
+            constraint.MinBreakVelocity = 50.0f;
+            constraint.Update();
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Wall.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Wall.cs
new file mode 100644
index 0000000..25ccc90
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Objects/Wall.cs
@@ -0,0 +1,84 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public class Wall
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string instanceIndexName;
+
+        public Wall(Demo demo, int instanceIndex)
+        {
+            this.demo = demo;
+            instanceIndexName = " " + instanceIndex.ToString();
+        }
+
+        public void Initialize(PhysicsScene scene)
+        {
+            this.scene = scene;
+        }
+
+        public static void CreateShapes(Demo demo, PhysicsScene scene)
+        {
+        }
+
+        public void Create(Vector3 objectPosition, Vector3 objectScale, Quaternion objectOrientation, string shapeName, int wallSize, Vector3 shapeSize, float density, bool enableSleeping)
+        {
+            Shape shape = scene.Factory.ShapeManager.Find(shapeName);
+
+            PhysicsObject objectRoot = null;
+            PhysicsObject objectBase = null;
+
+            objectRoot = scene.Factory.PhysicsObjectManager.Create("Wall" + instanceIndexName);
+
+            int instanceIndexCount = 0;
+
+            for (int x = 0; x < wallSize; x++)
+                for (int y = 0; y < wallSize; y++)
+                    if (y % 2 == 0)
+                    {
+                        objectBase = scene.Factory.PhysicsObjectManager.Create("Wall " + instanceIndexCount.ToString() + instanceIndexName);
+                        objectRoot.AddChildPhysicsObject(objectBase);
+                        objectBase.Shape = shape;
+                        objectBase.UserDataStr = shapeName;
+                        objectBase.CreateSound(true);
+                        objectBase.InitLocalTransform.SetPosition(x * shapeSize.X + 0.5f * shapeSize.X - 0.5f * shapeSize.X * wallSize, y * shapeSize.Y + 0.5f * shapeSize.Y, 0.0f);
+                        objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z);
+                        objectBase.Integral.SetDensity(density);
+                        objectBase.EnableSleeping = enableSleeping;
+                        instanceIndexCount++;
+                    }
+                    else
+                    {
+                        objectBase = scene.Factory.PhysicsObjectManager.Create("Wall " + instanceIndexCount.ToString() + instanceIndexName);
+                        objectRoot.AddChildPhysicsObject(objectBase);
+                        objectBase.Shape = shape;
+                        objectBase.UserDataStr = shapeName;
+                        objectBase.CreateSound(true);
+                        objectBase.InitLocalTransform.SetPosition(x * shapeSize.X - 0.5f * shapeSize.X * wallSize, y * shapeSize.Y + 0.5f * shapeSize.Y, 0.0f);
+                        objectBase.InitLocalTransform.SetScale(0.5f * shapeSize.X, 0.5f * shapeSize.Y, 0.5f * shapeSize.Z);
+                        objectBase.Integral.SetDensity(density);
+                        objectBase.EnableSleeping = enableSleeping;
+                        instanceIndexCount++;
+                    }
+
+            objectRoot.InitLocalTransform.SetOrientation(ref objectOrientation);
+            objectRoot.InitLocalTransform.SetScale(ref objectScale);
+            objectRoot.InitLocalTransform.SetPosition(ref objectPosition);
+
+            scene.UpdateFromInitLocalTransform(objectRoot);
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Program.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Program.cs
new file mode 100644
index 0000000..b6eb452
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Program.cs
@@ -0,0 +1,21 @@
+﻿using System;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    static class Program
+    {
+        /// <summary>
+        /// The main entry point for the application.
+        /// </summary>
+        [STAThread]
+        static void Main()
+        {
+            using (Demo demo = new Demo())
+            {
+                demo.Title = "Matali Physics Demo " + PhysicsEngine.Version + " (OpenTK)";
+                demo.Run();
+            }
+        }
+    }
+}
new file mode 100644
index 0000000..b154092
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Matali Physics Demo")]
+[assembly: AssemblyDescription("Examples of use Matali Physics Basic")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Komires Sp. z o. o.")]
+[assembly: AssemblyProduct("Matali Physics Demo")]
+[assembly: AssemblyCopyright("Copyright © 2013. All rights reserved.")]
+[assembly: AssemblyTrademark("Komires Sp. z o. o.")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("a2f75dd4-943e-4f43-b687-e5a084044892")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
new file mode 100644
index 0000000..e487f9c
--- /dev/null
@@ -0,0 +1,70 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.1
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace MataliPhysicsDemo.Properties {
+    using System;
+    
+    
+    /// <summary>
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// </summary>
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources {
+        
+        private static global::System.Resources.ResourceManager resourceMan;
+        
+        private static global::System.Globalization.CultureInfo resourceCulture;
+        
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
+        internal Resources() {
+        }
+        
+        /// <summary>
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager {
+            get {
+                if (object.ReferenceEquals(resourceMan, null)) {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MataliPhysicsDemo.Properties.Resources", typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+        
+        /// <summary>
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture {
+            get {
+                return resourceCulture;
+            }
+            set {
+                resourceCulture = value;
+            }
+        }
+        
+        internal static System.Drawing.Icon MataliPhysicsDemo {
+            get {
+                object obj = ResourceManager.GetObject("MataliPhysicsDemo", resourceCulture);
+                return ((System.Drawing.Icon)(obj));
+            }
+        }
+    }
+}
new file mode 100644
index 0000000..2e98052
--- /dev/null
@@ -0,0 +1,30 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.1
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace MataliPhysicsDemo.Properties
+{
+
+
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
+    {
+
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+
+        public static Settings Default
+        {
+            get
+            {
+                return defaultInstance;
+            }
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AIScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AIScene.cs
new file mode 100644
index 0000000..028638c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AIScene.cs
@@ -0,0 +1,205 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class AIScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Plant1 plant1Instance1;
+        Vehicle1 vehicle1Instance1;
+        Amphibian1 amphibian1Instance1;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Vehicle1Animation1 vehicle1Animation1Instance1;
+        Amphibian1Animation1 amphibian1Animation1Instance1;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public AIScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            plant1Instance1 = new Plant1(demo, 1);
+            vehicle1Instance1 = new Vehicle1(demo, 1);
+            amphibian1Instance1 = new Amphibian1(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            vehicle1Animation1Instance1 = new Vehicle1Animation1(demo, 1);
+            amphibian1Animation1Instance1 = new Amphibian1Animation1(demo, 1);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            plant1Instance1.Initialize(scene);
+            vehicle1Instance1.Initialize(scene);
+            amphibian1Instance1.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            vehicle1Animation1Instance1.Initialize(scene);
+            amphibian1Animation1Instance1.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Plant1.CreateShapes(demo, scene);
+            Vehicle1.CreateShapes(demo, scene);
+            Amphibian1.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            plant1Instance1.Create(new Vector3(-30.0f, -9.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(10.0f)));
+            vehicle1Instance1.Create(new Vector3(-10.0f, 10.0f, 20.0f), Vector3.One, Quaternion.Identity);
+            amphibian1Instance1.Create(new Vector3(10.0f, -9.5f, 50.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(128.0f)));
+            camera2Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-20.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, -3.0f, 30.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(30.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-30.0f, -3.0f, 0.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(-25.0f, 7.0f, 20.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(30.0f, -3.0f, 0.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, 0.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, -3.0f, 15.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(45.0f, 0.0f, 15.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            vehicle1Animation1Instance1.SetControllers();
+            amphibian1Animation1Instance1.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AnimationScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AnimationScene.cs
new file mode 100644
index 0000000..c677279
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/AnimationScene.cs
@@ -0,0 +1,191 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class AnimationScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Crab1 crab1Instance1;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Crab1Animation1 crab1Animation1Instance1;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public AnimationScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            crab1Instance1 = new Crab1(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            crab1Animation1Instance1 = new Crab1Animation1(demo, 1);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 16;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            crab1Instance1.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            crab1Animation1Instance1.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Crab1.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            crab1Instance1.Create(new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.Identity);
+            camera2Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-20.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, -3.0f, 40.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(20.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-40.0f, -3.0f, 0.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(-10.0f, -3.0f, 0.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(20.0f, -3.0f, 0.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, 0.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, -3.0f, 15.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(45.0f, -3.0f, 15.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            crab1Animation1Instance1.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BridgesScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BridgesScene.cs
new file mode 100644
index 0000000..f085344
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BridgesScene.cs
@@ -0,0 +1,205 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class BridgesScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Car1 car1Instance1;
+        Bridge1 bridge1Instance1;
+        Bridge1 bridge1Instance2;
+        Ragdoll1 ragdoll1Instance1;
+        Camera1 camera1Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Car1Animation1 car1Animation1Instance1;
+        Camera1Animation1 camera1Animation1Instance1;
+        Camera1Draw1 camera1Draw1Instance1;
+
+        public BridgesScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            car1Instance1 = new Car1(demo, 1);
+            bridge1Instance1 = new Bridge1(demo, 1);
+            bridge1Instance2 = new Bridge1(demo, 2);
+            ragdoll1Instance1 = new Ragdoll1(demo, 1);
+            camera1Instance1 = new Camera1(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            car1Animation1Instance1 = new Car1Animation1(demo, 1);
+            camera1Animation1Instance1 = new Camera1Animation1(demo, 1);
+            camera1Draw1Instance1 = new Camera1Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            car1Instance1.Initialize(scene);
+            bridge1Instance1.Initialize(scene);
+            bridge1Instance2.Initialize(scene);
+            ragdoll1Instance1.Initialize(scene);
+            camera1Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            car1Animation1Instance1.Initialize(scene);
+            camera1Animation1Instance1.Initialize(scene);
+            camera1Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Car1.CreateShapes(demo, scene);
+            Bridge1.CreateShapes(demo, scene);
+            Ragdoll1.CreateShapes(demo, scene);
+            Camera1.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            car1Instance1.Create(new Vector3(20.0f, 60.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(90.0f)));
+            bridge1Instance1.Create(new Vector3(0.0f, 10.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-5.0f)), 50, new Vector3(5.0f, 0.4f, 15.0f));
+            bridge1Instance2.Create(new Vector3(0.0f, 10.0f, 100.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(5.0f)), 50, new Vector3(5.0f, 0.4f, 15.0f));
+            ragdoll1Instance1.Create(new Vector3(0.0f, 30.0f, 100.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(0.0f)), false, false, 1.0f);
+            camera1Instance1.Create(new Vector3(0.0f, 65.0f, -22.0f), Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(-30.0f)), Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-50.0f, 15.0f, 100.0f), new Vector3(0.2f, 1.0f, 1.0f), 40.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, 15.0f, 100.0f), new Vector3(1.0f, 0.5f, 0.1f), 40.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(50.0f, 15.0f, 105.0f), new Vector3(1.0f, 0.7f, 0.0f), 40.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-50.0f, 15.0f, 45.0f), new Vector3(1.0f, 0.7f, 0.5f), 40.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, 15.0f, 40.0f), new Vector3(1.0f, 1.0f, 0.5f), 40.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(50.0f, 15.0f, 35.0f), new Vector3(0.3f, 0.7f, 0.5f), 40.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-60.0f, 50.0f, 45.0f), new Vector3(0.1f, 0.7f, 1.0f), 40.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(10.0f, 50.0f, 105.0f), new Vector3(1.0f, 0.5f, 0.2f), 40.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(60.0f, 50.0f, 35.0f), new Vector3(0.5f, 1.0f, 0.2f), 40.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            car1Animation1Instance1.SetControllers(true);
+            camera1Animation1Instance1.SetControllers();
+            camera1Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera1Animation1Instance1.RefreshControllers();
+            camera1Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingScene.cs
new file mode 100644
index 0000000..2993449
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingScene.cs
@@ -0,0 +1,228 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class BuildingScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Plant2 plant2Instance1;
+        Building1 building1Instance1;
+        Car1 car1Instance1;
+        Ragdoll3 ragdoll3Instance1;
+        Box1 box1Instance1;
+        Lamp1 lamp1Instance1;
+        Lamp1 lamp1Instance2;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Car1Animation1 car1Animation1Instance1;
+        Lamp1Animation1 lamp1Animation1Instance1;
+        Lamp1Animation1 lamp1Animation1Instance2;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public BuildingScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            plant2Instance1 = new Plant2(demo, 1);
+            building1Instance1 = new Building1(demo, 1);
+            car1Instance1 = new Car1(demo, 1);
+            ragdoll3Instance1 = new Ragdoll3(demo, 1);
+            box1Instance1 = new Box1(demo, 1);
+            lamp1Instance1 = new Lamp1(demo, 1);
+            lamp1Instance2 = new Lamp1(demo, 2);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            car1Animation1Instance1 = new Car1Animation1(demo, 1);
+            lamp1Animation1Instance1 = new Lamp1Animation1(demo, 1);
+            lamp1Animation1Instance2 = new Lamp1Animation1(demo, 2);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            plant2Instance1.Initialize(scene);
+            building1Instance1.Initialize(scene);
+            car1Instance1.Initialize(scene);
+            ragdoll3Instance1.Initialize(scene);
+            box1Instance1.Initialize(scene);
+            lamp1Instance1.Initialize(scene);
+            lamp1Instance2.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            car1Animation1Instance1.Initialize(scene);
+            lamp1Animation1Instance1.Initialize(scene);
+            lamp1Animation1Instance2.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Plant2.CreateShapes(demo, scene);
+            Building1.CreateShapes(demo, scene);
+            Car1.CreateShapes(demo, scene);
+            Ragdoll3.CreateShapes(demo, scene);
+            Box1.CreateShapes(demo, scene);
+            Lamp1.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            plant2Instance1.Create(new Vector3(-30.0f, -9.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(10.0f)));
+            building1Instance1.Create(new Vector3(0.0f, 0.0f, 100.0f), Vector3.One, Quaternion.Identity);
+            car1Instance1.Create(new Vector3(10.0f, 0.0f, 40.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+            ragdoll3Instance1.Create(new Vector3(-10.0f, -10.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(0.0f)), false, false, 0.5f);
+            box1Instance1.Create(new Vector3(40.0f, 0.0f, 50.0f), Vector3.One, Quaternion.Identity, 4, new Vector3(1.0f, 4.0f, 0.1f), 0.02f);
+            lamp1Instance1.Create(new Vector3(-96.0f, 5.0f, 140.0f), Vector3.One, Quaternion.Identity, PhysicsScene.Factory.PhysicsObjectManager.Find("Building 1 Level 1 Wall 3 1"));
+            lamp1Instance2.Create(new Vector3(-96.0f, 5.0f, 220.0f), Vector3.One, Quaternion.Identity, PhysicsScene.Factory.PhysicsObjectManager.Find("Building 1 Level 1 Wall 3 1"));
+            camera2Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-30.0f, -3.0f, 90.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, -3.0f, 90.0f), new Vector3(0.3f, 0.7f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(30.0f, -3.0f, 90.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-20.0f, -3.0f, 20.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(20.0f, -3.0f, 10.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(30.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, -3.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, 8.0f, 20.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(45.0f, 0.0f, 45.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            car1Animation1Instance1.SetControllers(true);
+            lamp1Animation1Instance1.SetControllers();
+            lamp1Animation1Instance2.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingsScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingsScene.cs
new file mode 100644
index 0000000..ada8c13
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/BuildingsScene.cs
@@ -0,0 +1,227 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class BuildingsScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Building1 building1Instance1;
+        Building2 building2Instance1;
+        Bridge2 bridge2Instance1;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+        PointLightAnimation1 pointLightAnimation1Instance1;
+
+        Vector3 startPosition;
+        Vector3 endPosition;
+        Vector3 startScale;
+        Vector3 endScale;
+
+        public BuildingsScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            building1Instance1 = new Building1(demo, 1);
+            building2Instance1 = new Building2(demo, 1);
+            bridge2Instance1 = new Bridge2(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+            pointLightAnimation1Instance1 = new PointLightAnimation1(demo, 12);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            building1Instance1.Initialize(scene);
+            building2Instance1.Initialize(scene);
+            bridge2Instance1.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+            pointLightAnimation1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Building1.CreateShapes(demo, scene);
+            Building2.CreateShapes(demo, scene);
+            Bridge2.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            building1Instance1.Create(new Vector3(0.0f, 0.0f, 100.0f), Vector3.One, Quaternion.Identity);
+            building2Instance1.Create(new Vector3(0.0f, 0.0f, -100.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(180.0f)));
+
+            PhysicsObject startObject = PhysicsScene.Factory.PhysicsObjectManager.Find("Building 2 Level 2 Wall 42 1");
+            PhysicsObject endObject = PhysicsScene.Factory.PhysicsObjectManager.Find("Building 1 Level 3 Wall 43 1");
+
+            startObject.MainWorldTransform.GetPosition(ref startPosition);
+            startObject.MainWorldTransform.GetScale(ref startScale);
+
+            endObject.MainWorldTransform.GetPosition(ref endPosition);
+            endObject.MainWorldTransform.GetScale(ref endScale);
+
+            startPosition += new Vector3(0.0f, startScale.Z, startScale.Y);
+            endPosition += new Vector3(0.0f, endScale.Y, -endScale.Z);
+
+            bridge2Instance1.Create(startObject, endObject, startPosition, endPosition, 20, new Vector2(15.0f, 0.4f));
+
+            camera2Instance1.Create(new Vector3(0.0f, 120.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(60.0f, 115.0f, -200.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(40.0f, 102.0f, -180.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(40.0f, 102.0f, -220.0f), new Vector3(1.0f, 0.2f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-40.0f, 46.0f, -298.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(-15.0f, 28.0f, -298.0f), new Vector3(0.0f, 0.7f, 0.8f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(10.0f, 5.0f, -298.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(6, "Glass", new Vector3(-30.0f, -3.0f, -90.0f), new Vector3(1.0f, 0.9f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(7, "Glass", new Vector3(0.0f, -3.0f, -90.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(8, "Glass", new Vector3(30.0f, -3.0f, -90.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(9, "Glass", new Vector3(-30.0f, -3.0f, 90.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(10, "Glass", new Vector3(0.0f, -3.0f, 90.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(11, "Glass", new Vector3(30.0f, -3.0f, 90.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(12, "Field", new Vector3(0.0f, -3.0f, 0.0f), new Vector3(0.2f, 1.0f, 0.0f), 20.0f, 0.0001f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, 117.0f, 180.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, 117.0f, 150.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(30.0f, 117.0f, 180.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+            pointLightAnimation1Instance1.SetControllers(0.0f, 1.0f, 0.05f);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/ClothScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/ClothScene.cs
new file mode 100644
index 0000000..537337c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/ClothScene.cs
@@ -0,0 +1,202 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class ClothScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Column columnInstance1;
+        CargoJack cargoJackInstance1;
+        PointCloth pointClothInstance1;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        CargoJackAnimation1 cargoJackAnimation1Instance1;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public ClothScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            columnInstance1 = new Column(demo, 1);
+            cargoJackInstance1 = new CargoJack(demo, 1);
+            pointClothInstance1 = new PointCloth(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            cargoJackAnimation1Instance1 = new CargoJackAnimation1(demo, 1);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            columnInstance1.Initialize(scene);
+            cargoJackInstance1.Initialize(scene);
+            pointClothInstance1.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            cargoJackAnimation1Instance1.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Column.CreateShapes(demo, scene);
+            CargoJack.CreateShapes(demo, scene);
+            PointCloth.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            columnInstance1.Create(new Vector3(12.0f, -9.0f, 0.0f), Vector3.One, Quaternion.Identity, "Box", 4, new Vector3(4.0f, 4.0f, 4.0f), 0.001f, true, 1.0f, 1.0f);
+            cargoJackInstance1.Create(new Vector3(-14.0f, -9.0f, 0.0f), Vector3.One, Quaternion.Identity);
+            pointClothInstance1.Create(new Vector3(0.0f, -1.0f, 0.0f), Vector3.One, Quaternion.Identity, 16, 16, 1.0f, 1.0f, true, 1.0f, 0.1f);
+            pointClothInstance1.Join(1, "Cargo Jack Arm Handle Bottom", "Cargo Jack Arm Handle Bottom", "Cargo Jack Arm Handle Top", "Cargo Jack Arm Handle Top");
+            camera2Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-20.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, -3.0f, 40.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(20.0f, -3.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-40.0f, -3.0f, 0.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, -3.0f, 0.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(30.0f, -3.0f, 0.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, -3.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, -3.0f, 15.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(45.0f, -3.0f, 15.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            cargoJackAnimation1Instance1.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/DefaultShapesScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/DefaultShapesScene.cs
new file mode 100644
index 0000000..f7f3738
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/DefaultShapesScene.cs
@@ -0,0 +1,196 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class DefaultShapesScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        DefaultShapes defaultShapesInstance;
+        Column columnInstance1;
+        Column columnInstance2;
+        Camera1 camera1Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Camera1Animation1 camera1Animation1Instance1;
+        Camera1Draw1 camera1Draw1Instance1;
+
+        public DefaultShapesScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            defaultShapesInstance = new DefaultShapes(demo);
+            columnInstance1 = new Column(demo, 1);
+            columnInstance2 = new Column(demo, 2);
+            camera1Instance1 = new Camera1(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            camera1Animation1Instance1 = new Camera1Animation1(demo, 1);
+            camera1Draw1Instance1 = new Camera1Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            defaultShapesInstance.Initialize(scene);
+            columnInstance1.Initialize(scene);
+            columnInstance2.Initialize(scene);
+            camera1Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            camera1Animation1Instance1.Initialize(scene);
+            camera1Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            DefaultShapes.CreateShapes(demo, scene);
+            Column.CreateShapes(demo, scene);
+            Camera1.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            defaultShapesInstance.Create();
+            columnInstance1.Create(new Vector3(10.0f, 30.0f, 20.0f), Vector3.One, Quaternion.Identity, "Box", 4, new Vector3(4.0f, 2.0f, 8.0f), 1.0f, true, 0.1f, 0.05f);
+            columnInstance2.Create(new Vector3(20.0f, 30.0f, 20.0f), Vector3.One, Quaternion.Identity, "Box", 5, new Vector3(8.0f, 8.0f, 8.0f), 1.0f, true, 0.1f, 0.05f);
+            camera1Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-30.0f, 0.0f, 40.0f), new Vector3(0.2f, 1.0f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, 0.0f, 40.0f), new Vector3(1.0f, 0.5f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(12.0f, 20.0f, 12.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-30.0f, 7.0f, 15.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, 7.0f, 15.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(30.0f, 7.0f, 15.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-25.0f, 8.0f, 5.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, 8.0f, 5.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(25.0f, 8.0f, 5.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            camera1Animation1Instance1.SetControllers();
+            camera1Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera1Animation1Instance1.RefreshControllers();
+            camera1Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/HelicoptersScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/HelicoptersScene.cs
new file mode 100644
index 0000000..e82c563
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/HelicoptersScene.cs
@@ -0,0 +1,215 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class HelicoptersScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Helicopter1 helicopter1Instance1;
+        Helicopter1 helicopter1Instance2;
+        Helicopter1 helicopter1Instance3;
+        Helicopter1 helicopter1Instance4;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Helicopter1Animation1 helicopter1Animation1Instance1;
+        Helicopter1Animation1 helicopter1Animation1Instance2;
+        Helicopter1Animation1 helicopter1Animation1Instance3;
+        Helicopter1Animation1 helicopter1Animation1Instance4;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public HelicoptersScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            helicopter1Instance1 = new Helicopter1(demo, 1);
+            helicopter1Instance2 = new Helicopter1(demo, 2);
+            helicopter1Instance3 = new Helicopter1(demo, 3);
+            helicopter1Instance4 = new Helicopter1(demo, 4);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            helicopter1Animation1Instance1 = new Helicopter1Animation1(demo, 1);
+            helicopter1Animation1Instance2 = new Helicopter1Animation1(demo, 2);
+            helicopter1Animation1Instance3 = new Helicopter1Animation1(demo, 3);
+            helicopter1Animation1Instance4 = new Helicopter1Animation1(demo, 4);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            helicopter1Instance1.Initialize(scene);
+            helicopter1Instance2.Initialize(scene);
+            helicopter1Instance3.Initialize(scene);
+            helicopter1Instance4.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            helicopter1Animation1Instance1.Initialize(scene);
+            helicopter1Animation1Instance2.Initialize(scene);
+            helicopter1Animation1Instance3.Initialize(scene);
+            helicopter1Animation1Instance4.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Helicopter1.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            helicopter1Instance1.Create(new Vector3(0.0f, -11.8f, 20.0f), Vector3.One, Quaternion.Identity);
+            helicopter1Instance2.Create(new Vector3(0.0f, -11.8f, 60.0f), Vector3.One, Quaternion.Identity);
+            helicopter1Instance3.Create(new Vector3(0.0f, -11.8f, 100.0f), Vector3.One, Quaternion.Identity);
+            helicopter1Instance4.Create(new Vector3(0.0f, -11.8f, 140.0f), Vector3.One, Quaternion.Identity);
+            camera2Instance1.Create(new Vector3(60.0f, 5.0f, 20.0f), Quaternion.Identity, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(60.0f)), Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(20.0f, -3.0f, 20.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(20.0f, -3.0f, 60.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(20.0f, -3.0f, 100.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(20.0f, -3.0f, 140.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(-10.0f, -3.0f, 20.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(-10.0f, -3.0f, 60.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(5.0f, 17.0f, 4.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(5.0f, 17.0f, 44.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(5.0f, 17.0f, 84.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            helicopter1Animation1Instance1.SetControllers(new Vector3(0.0f, 20.0f, 50.0f), new Vector3(0.0f, 0.0f, 50.0f));
+            helicopter1Animation1Instance2.SetControllers(new Vector3(0.0f, 20.0f, 80.0f), new Vector3(0.0f, 0.0f, 80.0f));
+            helicopter1Animation1Instance3.SetControllers(new Vector3(0.0f, 20.0f, 110.0f), new Vector3(0.0f, 0.0f, 110.0f));
+            helicopter1Animation1Instance4.SetControllers(new Vector3(0.0f, 20.0f, 140.0f), new Vector3(0.0f, 0.0f, 140.0f));
+            camera2Animation1Instance1.SetControllers(false);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MenuScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MenuScene.cs
new file mode 100644
index 0000000..6b1c414
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MenuScene.cs
@@ -0,0 +1,160 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class MenuScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+        public MenuAnimation1 MenuAnimation1 { get { return menuAnimation1Instance1; } }
+
+        // Declare objects in the scene
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Menu menuInstance1;
+        Camera3 camera3Instance1;
+
+        // Declare controllers in the scene
+        CursorDraw1 cursorDraw1Instance;
+        MenuAnimation1 menuAnimation1Instance1;
+        MenuDraw1 menuDraw1Instance1;
+        Camera3Animation1 camera3Animation1Instance1;
+        Camera3Draw1 camera3Draw1Instance1;
+
+        public MenuScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            menuInstance1 = new Menu(demo, 1);
+            camera3Instance1 = new Camera3(demo, 1);
+
+            // Create a new controllers in the scene
+            cursorDraw1Instance = new CursorDraw1(demo);
+            menuAnimation1Instance1 = new MenuAnimation1(demo, 1);
+            menuDraw1Instance1 = new MenuDraw1(demo, 1);
+            camera3Animation1Instance1 = new Camera3Animation1(demo, 1);
+            camera3Draw1Instance1 = new Camera3Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            menuInstance1.Initialize(scene);
+            camera3Instance1.Initialize(scene);
+
+            // Initialize controllers in the scene
+            cursorDraw1Instance.Initialize(scene);
+            menuAnimation1Instance1.Initialize(scene);
+            menuDraw1Instance1.Initialize(scene);
+            camera3Animation1Instance1.Initialize(scene);
+            camera3Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Menu.CreateShapes(demo, scene);
+            Camera3.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            cursorInstance.Create();
+            shotInstance.Create();
+            menuInstance1.Create();
+            camera3Instance1.Create(new Vector3(0.0f, 5.0f, -122.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(0.0f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            cursorDraw1Instance.SetControllers();
+            menuAnimation1Instance1.SetControllers();
+            menuDraw1Instance1.SetControllers();
+            camera3Animation1Instance1.SetControllers(new Vector3(0.0f, 0.0f, 20.0f), 5);
+            camera3Draw1Instance1.SetControllers(false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            menuAnimation1Instance1.RefreshControllers();
+            camera3Animation1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+
+            if (demo.EnableMenu)
+                scene.Draw(time);
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MeshesScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MeshesScene.cs
new file mode 100644
index 0000000..ad2c55c
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/MeshesScene.cs
@@ -0,0 +1,197 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class MeshesScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Column columnInstance1;
+        TriangleMesh1 triangleMesh1;
+        TriangleMesh2 triangleMesh2;
+        TorusMesh torusMesh;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public MeshesScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            columnInstance1 = new Column(demo, 1);
+            triangleMesh1 = new TriangleMesh1(demo, 1);
+            triangleMesh2 = new TriangleMesh2(demo, 1);
+            torusMesh = new TorusMesh(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            columnInstance1.Initialize(scene);
+            triangleMesh1.Initialize(scene);
+            triangleMesh2.Initialize(scene);
+            torusMesh.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Column.CreateShapes(demo, scene);
+            TriangleMesh1.CreateShapes(demo, scene);
+            TriangleMesh2.CreateShapes(demo, scene);
+            TorusMesh.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            cursorInstance.Create();
+            shotInstance.Create();
+            columnInstance1.Create(new Vector3(-500.0f, -20.0f, 1000.0f), Vector3.One, Quaternion.Identity, "Box", 4, new Vector3(8.0f, 8.0f, 8.0f), 1.0f, true, 0.1f, 0.05f);
+            triangleMesh1.Create(new Vector3(0.0f, 60.0f, 0.0f), Vector3.One, Quaternion.Identity, 0.0f);
+            triangleMesh2.Create(new Vector3(0.0f, 60.0f, 0.0f), Vector3.One, Quaternion.Identity, 0.0f);
+            torusMesh.Create(new Vector3(-550.0f, -20.0f, 1000.0f), Vector3.One, Quaternion.Identity, 100000.0f);
+            camera2Instance1.Create(new Vector3(-550.0f, -90.0f, 1020.0f), Quaternion.Identity, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-95.0f)), Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-530.0f, -106.0f, 1020.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(-500.0f, -116.0f, 1040.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(-470.0f, -124.0f, 1040.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(45.0f, -275.0f, 380.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, -100.0f, 0.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(-470.0f, -124.0f, 1020.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-530.0f, -104.0f, 1000.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(-500.0f, -114.0f, 1020.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(-470.0f, -124.0f, 1000.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/RagdollsScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/RagdollsScene.cs
new file mode 100644
index 0000000..53b78a2
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/RagdollsScene.cs
@@ -0,0 +1,272 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class RagdollsScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Ragdoll1 ragdoll1Instance1;
+        Ragdoll2 ragdoll2Instance1;
+        Ragdoll3 ragdoll3Instance1;
+        Ragdoll1 ragdoll1Instance2;
+        Ragdoll2 ragdoll2Instance2;
+        Ragdoll3 ragdoll3Instance2;
+        Ragdoll1 ragdoll1Instance3;
+        Ragdoll2 ragdoll2Instance3;
+        Ragdoll3 ragdoll3Instance3;
+        Camera1 camera1Instance1;
+        Camera1 camera1Instance2;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Camera1Animation1 camera1Animation1Instance1;
+        Camera1Animation1 camera1Animation1Instance2;
+        Camera1Draw1 camera1Draw1Instance1;
+        Camera1Draw1 camera1Draw1Instance2;
+
+        DemoKeyboardState oldKeyboardState;
+
+        public RagdollsScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            ragdoll1Instance1 = new Ragdoll1(demo, 1);
+            ragdoll2Instance1 = new Ragdoll2(demo, 1);
+            ragdoll3Instance1 = new Ragdoll3(demo, 1);
+            ragdoll1Instance2 = new Ragdoll1(demo, 2);
+            ragdoll2Instance2 = new Ragdoll2(demo, 2);
+            ragdoll3Instance2 = new Ragdoll3(demo, 2);
+            ragdoll1Instance3 = new Ragdoll1(demo, 3);
+            ragdoll2Instance3 = new Ragdoll2(demo, 3);
+            ragdoll3Instance3 = new Ragdoll3(demo, 3);
+            camera1Instance1 = new Camera1(demo, 1);
+            camera1Instance2 = new Camera1(demo, 2);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            camera1Animation1Instance1 = new Camera1Animation1(demo, 1);
+            camera1Animation1Instance2 = new Camera1Animation1(demo, 2);
+            camera1Draw1Instance1 = new Camera1Draw1(demo, 1);
+            camera1Draw1Instance2 = new Camera1Draw1(demo, 2);
+
+            oldKeyboardState = demo.GetKeyboardState();
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            ragdoll1Instance1.Initialize(scene);
+            ragdoll2Instance1.Initialize(scene);
+            ragdoll3Instance1.Initialize(scene);
+            ragdoll1Instance2.Initialize(scene);
+            ragdoll2Instance2.Initialize(scene);
+            ragdoll3Instance2.Initialize(scene);
+            ragdoll1Instance3.Initialize(scene);
+            ragdoll2Instance3.Initialize(scene);
+            ragdoll3Instance3.Initialize(scene);
+            camera1Instance1.Initialize(scene);
+            camera1Instance2.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            camera1Animation1Instance1.Initialize(scene);
+            camera1Animation1Instance2.Initialize(scene);
+            camera1Draw1Instance1.Initialize(scene);
+            camera1Draw1Instance2.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Ragdoll1.CreateShapes(demo, scene);
+            Ragdoll2.CreateShapes(demo, scene);
+            Ragdoll3.CreateShapes(demo, scene);
+            Camera1.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            ragdoll1Instance1.Create(new Vector3(-30.0f, 0.0f, 0.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(0.0f)), false, false, 1.0f);
+            ragdoll2Instance1.Create(new Vector3(0.0f, 0.0f, 0.0f), Vector3.One, Quaternion.Identity, false, true, 1.0f);
+            ragdoll3Instance1.Create(new Vector3(30.0f, 0.0f, 0.0f), Vector3.One, Quaternion.Identity, true, false, 0.5f);
+            ragdoll1Instance2.Create(new Vector3(-30.0f, 15.0f, 0.0f), Vector3.One, Quaternion.Identity, false, false, 1.0f);
+            ragdoll2Instance2.Create(new Vector3(0.0f, 15.0f, 0.0f), Vector3.One, Quaternion.Identity, false, false, 1.0f);
+            ragdoll3Instance2.Create(new Vector3(30.0f, 15.0f, 0.0f), Vector3.One, Quaternion.Identity, false, true, 0.5f);
+            ragdoll1Instance3.Create(new Vector3(-30.0f, 30.0f, 0.0f), Vector3.One, Quaternion.Identity, false, false, 1.0f);
+            ragdoll2Instance3.Create(new Vector3(0.0f, 30.0f, 0.0f), Vector3.One, Quaternion.Identity, false, false, 1.0f);
+            ragdoll3Instance3.Create(new Vector3(30.0f, 30.0f, 0.0f), Vector3.One, Quaternion.Identity, false, true, 0.5f);
+            camera1Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+            camera1Instance2.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, false);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-30.0f, -5.0f, 45.0f), new Vector3(0.2f, 1.0f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, -5.0f, 45.0f), new Vector3(1.0f, 0.5f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(30.0f, -5.0f, 45.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-20.0f, -5.0f, -5.0f), new Vector3(1.0f, 0.4f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, -5.0f, -5.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(20.0f, -5.0f, -5.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, 18.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, 18.0f, 15.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(30.0f, 18.0f, 15.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+            scene.UserControllers.PostDrawMethods += ChangeCamera;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            camera1Animation1Instance1.SetControllers();
+            camera1Animation1Instance2.SetControllers();
+            camera1Draw1Instance1.SetControllers(false, false, false, false, false, false);
+            camera1Draw1Instance2.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera1Animation1Instance1.RefreshControllers();
+            camera1Animation1Instance2.RefreshControllers();
+            camera1Draw1Instance1.RefreshControllers();
+            camera1Draw1Instance2.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+
+        void ChangeCamera(DrawMethodArgs args)
+        {
+            PhysicsScene scene = demo.Engine.Factory.PhysicsSceneManager.Get(args.OwnerSceneIndex);
+
+            DemoKeyboardState keyboardState = demo.GetKeyboardState();
+
+            if (keyboardState[Key.Tab] && !oldKeyboardState[Key.Tab])
+            {
+                PhysicsObject activeCameraObject = null;
+                int activeCameraInstanceIndex = 0;
+
+                for (int i = 0; i < scene.PhysicsObjectWithCameraCount; i++)
+                {
+                    PhysicsObject cameraObject = scene.GetPhysicsObjectWithCamera(i);
+
+                    if (cameraObject.Camera.Active)
+                    {
+                        activeCameraObject = cameraObject;
+                        activeCameraInstanceIndex = i;
+                        cameraObject.Camera.Active = false;
+                    }
+                }
+
+                int nextActiveCameraInstanceIndex = (activeCameraInstanceIndex + 1) % scene.PhysicsObjectWithCameraCount;
+                PhysicsObject nextCameraObject = scene.GetPhysicsObjectWithCamera(nextActiveCameraInstanceIndex);
+                nextCameraObject.Camera.Active = true;
+            }
+
+            oldKeyboardState = keyboardState;
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/SimpleScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/SimpleScene.cs
new file mode 100644
index 0000000..2055395
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/SimpleScene.cs
@@ -0,0 +1,158 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class SimpleScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Shot shotInstance;
+        SimpleCamera simpleCameraInstance1;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        SimpleCameraAnimation1 simpleCameraAnimation1Instance1;
+        SimpleCameraDraw1 simpleCameraDraw1Instance1;
+
+        public SimpleScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            shotInstance = new Shot(demo);
+            simpleCameraInstance1 = new SimpleCamera(demo, 1);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            simpleCameraAnimation1Instance1 = new SimpleCameraAnimation1(demo, 1);
+            simpleCameraDraw1Instance1 = new SimpleCameraDraw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            shotInstance.Initialize(scene);
+            simpleCameraInstance1.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            simpleCameraAnimation1Instance1.Initialize(scene);
+            simpleCameraDraw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            SimpleCamera.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            shotInstance.Create();
+            simpleCameraInstance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            simpleCameraAnimation1Instance1.SetControllers();
+            simpleCameraDraw1Instance1.SetControllers();
+        }
+
+        public void Refresh(double time)
+        {
+            simpleCameraAnimation1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/StacksScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/StacksScene.cs
new file mode 100644
index 0000000..2140a6a
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/StacksScene.cs
@@ -0,0 +1,197 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class StacksScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Jenga jengaInstance1;
+        Pyramid pyramidInstance1;
+        Wall wallInstance1;
+        Camera1 camera1Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Camera1Animation1 camera1Animation1Instance1;
+        Camera1Draw1 camera1Draw1Instance1;
+
+        public StacksScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            jengaInstance1 = new Jenga(demo, 1);
+            pyramidInstance1 = new Pyramid(demo, 1);
+            wallInstance1 = new Wall(demo, 1);
+            camera1Instance1 = new Camera1(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            camera1Animation1Instance1 = new Camera1Animation1(demo, 1);
+            camera1Draw1Instance1 = new Camera1Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 15;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            jengaInstance1.Initialize(scene);
+            pyramidInstance1.Initialize(scene);
+            wallInstance1.Initialize(scene);
+            camera1Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            camera1Animation1Instance1.Initialize(scene);
+            camera1Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            Jenga.CreateShapes(demo, scene);
+            Pyramid.CreateShapes(demo, scene);
+            Wall.CreateShapes(demo, scene);
+            Camera1.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            jengaInstance1.Create(new Vector3(-30.0f, -9.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(60.0f)), "Box", 16, 3, new Vector3(2.0f, 2.0f, 2.0f), 1.0f, true);
+            pyramidInstance1.Create(new Vector3(0.0f, -9.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-45.0f)), "Box", 14, new Vector3(2.0f, 2.0f, 2.0f), 1.0f, true);
+            wallInstance1.Create(new Vector3(30.0f, -9.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-100.0f)), "Box", 12, new Vector3(2.0f, 2.0f, 2.0f), 1.0f, true);
+            camera1Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-30.0f, 0.0f, 40.0f), new Vector3(0.2f, 1.0f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, 0.0f, 40.0f), new Vector3(1.0f, 0.5f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(20.0f, 0.0f, 40.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-30.0f, 7.0f, 15.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(0.0f, 7.0f, 15.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(20.0f, 7.0f, 15.0f), new Vector3(0.7f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-20.0f, 8.0f, 15.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(0.0f, 8.0f, 5.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(20.0f, 8.0f, 10.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            camera1Animation1Instance1.SetControllers();
+            camera1Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera1Animation1Instance1.RefreshControllers();
+            camera1Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/TerrainWithWaterScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/TerrainWithWaterScene.cs
new file mode 100644
index 0000000..2cf1cb3
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/TerrainWithWaterScene.cs
@@ -0,0 +1,268 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class TerrainWithWaterScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        Terrain terrainInstance1;
+        Lake lakeInstance1;
+        DefaultShapes defaultShapesInstance;
+        Column columnInstance1;
+        Column columnInstance2;
+        Pier pierInstance1;
+        Ragdoll2 ragdoll2Instance1;
+        Boat1 boat1Instance1;
+        Car1 car1Instance1;
+        Box2 box2Instance1;
+        Crab1 crab1Instance1;
+        TorusMesh torusMesh;
+        Camera2 camera2Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        Boat1Animation1 boat1Animation1Instance1;
+        Car1Animation1 car1Animation1Instance1;
+        TerrainDraw1 terrainDraw1Instance1;
+        LakeDraw1 lakeDraw1Instance1;
+        Camera2Animation1 camera2Animation1Instance1;
+        Camera2Draw1 camera2Draw1Instance1;
+
+        public TerrainWithWaterScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            terrainInstance1 = new Terrain(demo, 1);
+            lakeInstance1 = new Lake(demo, 1, 8, 8);
+            defaultShapesInstance = new DefaultShapes(demo);
+            columnInstance1 = new Column(demo, 1);
+            columnInstance2 = new Column(demo, 2);
+            pierInstance1 = new Pier(demo, 1);
+            ragdoll2Instance1 = new Ragdoll2(demo, 1);
+            boat1Instance1 = new Boat1(demo, 1);
+            car1Instance1 = new Car1(demo, 1);
+            box2Instance1 = new Box2(demo, 1);
+            crab1Instance1 = new Crab1(demo, 1);
+            torusMesh = new TorusMesh(demo, 1);
+            camera2Instance1 = new Camera2(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            boat1Animation1Instance1 = new Boat1Animation1(demo, 1);
+            car1Animation1Instance1 = new Car1Animation1(demo, 1);
+            terrainDraw1Instance1 = new TerrainDraw1(demo, 1);
+            lakeDraw1Instance1 = new LakeDraw1(demo, 1, 8, 8);
+            camera2Animation1Instance1 = new Camera2Animation1(demo, 1);
+            camera2Draw1Instance1 = new Camera2Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            terrainInstance1.Initialize(scene);
+            lakeInstance1.Initialize(scene);
+            defaultShapesInstance.Initialize(scene);
+            columnInstance1.Initialize(scene);
+            columnInstance2.Initialize(scene);
+            pierInstance1.Initialize(scene);
+            ragdoll2Instance1.Initialize(scene);
+            boat1Instance1.Initialize(scene);
+            car1Instance1.Initialize(scene);
+            box2Instance1.Initialize(scene);
+            crab1Instance1.Initialize(scene);
+            torusMesh.Initialize(scene);
+            camera2Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            boat1Animation1Instance1.Initialize(scene);
+            car1Animation1Instance1.Initialize(scene);
+            terrainDraw1Instance1.Initialize(scene);
+            lakeDraw1Instance1.Initialize(scene);
+            camera2Animation1Instance1.Initialize(scene);
+            camera2Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            //terrainInstance1.CreateShapes(demo, scene, 0.0f, false);
+            //lakeInstance1.CreateShapes(demo, scene, 2, 2, 50.0f, 0.95f, 0.04f, 0.04f, 0.5f, 1.0f, 1.0f, 0.2f, 1.0f, 0.0f, false);
+            terrainInstance1.CreateShapes(demo, scene, 0.0f, true);
+            lakeInstance1.CreateShapes(demo, scene, 150, 150, 50.0f, 0.95f, 0.04f, 0.04f, 0.5f, 1.0f, 1.0f, 0.2f, 1.0f, 0.0f, true);
+            DefaultShapes.CreateShapes(demo, scene);
+            Column.CreateShapes(demo, scene);
+            Pier.CreateShapes(demo, scene);
+            Ragdoll2.CreateShapes(demo, scene);
+            Boat1.CreateShapes(demo, scene);
+            Car1.CreateShapes(demo, scene);
+            Box2.CreateShapes(demo, scene);
+            Crab1.CreateShapes(demo, scene);
+            TorusMesh.CreateShapes(demo, scene);
+            Camera2.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            cursorInstance.Create();
+            shotInstance.Create();
+            terrainInstance1.Create(new Vector3(-316.0f, -128.0f, -2072.0f), new Vector3(32.0f, 256.0f, 32.0f), Quaternion.Identity, 0.0f);
+            //lakeInstance1.Create(new Vector3(-316.0f, -100.0f, -2072.0f), new Vector3(2400.0f, 1.0f, 2400.0f), Quaternion.Identity, 0.0f);
+            lakeInstance1.Create(new Vector3(-316.0f, -100.0f, -2072.0f), new Vector3(4.0f, 1.0f, 4.0f), Quaternion.Identity, 0.0f);
+            defaultShapesInstance.Create();
+            columnInstance1.Create(new Vector3(10.0f, 30.0f, 20.0f), Vector3.One, Quaternion.Identity, "Box", 4, new Vector3(4.0f, 2.0f, 8.0f), 1.0f, true, 0.1f, 0.05f);
+            columnInstance2.Create(new Vector3(20.0f, 30.0f, 20.0f), Vector3.One, Quaternion.Identity, "Box", 5, new Vector3(8.0f, 8.0f, 8.0f), 1.0f, true, 0.1f, 0.05f);
+            pierInstance1.Create(new Vector3(0.0f, 0.0f, 100.0f), Vector3.One, Quaternion.Identity);
+            ragdoll2Instance1.Create(new Vector3(-10.0f, -50.0f, 70.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(45.0f)), false, false, 1.0f);
+            boat1Instance1.Create(new Vector3(0.0f, -5.0f, 0.0f), Vector3.One, Quaternion.Identity);
+            car1Instance1.Create(new Vector3(-80.0f, -70.0f, 20.0f), Vector3.One, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-115.0f)));
+            box2Instance1.Create(new Vector3(-20.0f, 0.0f, 40.0f), Vector3.One, Quaternion.Identity, 4, new Vector3(1.0f, 4.0f, 0.1f), 0.02f);
+            crab1Instance1.Create(new Vector3(-90.0f, -75.0f, -40.0f), new Vector3(0.5f, 0.5f, 0.5f), Quaternion.FromAxisAngle(Vector3.UnitX, MathHelper.DegreesToRadians(180.0f)));
+            torusMesh.Create(new Vector3(10.0f, 20.0f, 50.0f), Vector3.One, Quaternion.Identity, 100000.0f);
+            camera2Instance1.Create(new Vector3(50.0f, 5.0f, 40.0f), Quaternion.Identity, Quaternion.FromAxisAngle(Vector3.UnitY, MathHelper.DegreesToRadians(-220.0f)), Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-120.0f, -97.0f, -140.0f), new Vector3(0.1f, 0.9f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(-70.0f, -97.0f, -200.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(-90.0f, -97.0f, -100.0f), new Vector3(0.0f, 0.7f, 0.8f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(70.0f, -97.0f, -180.0f), new Vector3(1.0f, 0.4f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(10.0f, -97.0f, -160.0f), new Vector3(0.2f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(40.0f, -97.0f, -140.0f), new Vector3(0.4f, 0.6f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(6, "Glass", new Vector3(-40.0f, -95.0f, -190.0f), new Vector3(1.0f, 0.9f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(7, "Glass", new Vector3(-40.0f, -95.0f, -140.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(8, "Glass", new Vector3(-40.0f, -85.0f, -90.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(9, "Glass", new Vector3(-10.0f, -95.0f, -190.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(10, "Glass", new Vector3(-10.0f, -95.0f, -140.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(11, "Glass", new Vector3(-10.0f, -85.0f, -90.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(12, "Glass", new Vector3(-40.0f, -85.0f, -290.0f), new Vector3(0.5f, 0.7f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(13, "Glass", new Vector3(-40.0f, -95.0f, -240.0f), new Vector3(1.0f, 1.0f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(14, "Glass", new Vector3(-10.0f, -85.0f, -290.0f), new Vector3(1.0f, 0.9f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(15, "Glass", new Vector3(-10.0f, -95.0f, -240.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(16, "Glass", new Vector3(-60.0f, -69.0f, 20.0f), new Vector3(0.6f, 0.8f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(17, "Glass", new Vector3(-20.0f, -55.0f, 45.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(18, "Glass", new Vector3(10.0f, -72.0f, -20.0f), new Vector3(0.8f, 0.7f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(19, "Glass", new Vector3(25.0f, -55.0f, 25.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(0.0f, -65.0f, 0.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(-5.0f, -55.0f, 40.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, -0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            boat1Animation1Instance1.SetControllers(true);
+            car1Animation1Instance1.SetControllers(false);
+            terrainDraw1Instance1.SetControllers();
+            lakeDraw1Instance1.SetControllers();
+            camera2Animation1Instance1.SetControllers(true);
+            camera2Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera2Animation1Instance1.RefreshControllers();
+            camera2Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}
diff --git a/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/UserShapesScene.cs b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/UserShapesScene.cs
new file mode 100644
index 0000000..d0343c5
--- /dev/null
+++ b/Dependencies/MataliPhysicsBasic/MataliPhysicsOpenTK/Mono/MataliPhysicsDemo/MataliPhysicsDemo/Scenes/UserShapesScene.cs
@@ -0,0 +1,240 @@
+/*
+    Matali Physics Demo
+    Copyright (c) 2013 KOMIRES Sp. z o. o.
+ */
+using System;
+using System.Collections.Generic;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using Komires.MataliPhysics;
+
+namespace MataliPhysicsDemo
+{
+    /// <summary>
+    /// This is the main type for your game
+    /// </summary>
+    public sealed class UserShapesScene : IDemoScene
+    {
+        Demo demo;
+        PhysicsScene scene;
+        string name;
+        string instanceIndexName;
+        string info;
+
+        public PhysicsScene PhysicsScene { get { return scene; } }
+        public string SceneName { get { return name; } }
+        public string SceneInfo { get { return info; } }
+
+        // Declare objects in the scene
+        Sky skyInstance1;
+        Quad quadInstance1;
+        Cursor cursorInstance;
+        Shot shotInstance;
+        UserShapes userShapesInstance;
+        TorusMesh torusMesh1;
+        TorusMesh torusMesh2;
+        TorusMesh torusMesh3;
+        TorusMesh torusMesh4;
+        ForceField1 forceField1Instance;
+        ForceField2 forceField2Instance;
+        Switch1 switch1Instance;
+        Switch2 switch2Instance;
+        Camera1 camera1Instance1;
+        Lights lightInstance;
+
+        // Declare controllers in the scene
+        SkyDraw1 skyDraw1Instance1;
+        CursorDraw1 cursorDraw1Instance;
+        ForceField1Animation1 forceField1Animation1Instance;
+        ForceField2Animation1 forceField2Animation1Instance;
+        Switch1Animation1 switch1Animation1Instance;
+        Switch2Animation1 switch2Animation1Instance;
+        Camera1Animation1 camera1Animation1Instance1;
+        Camera1Draw1 camera1Draw1Instance1;
+
+        public UserShapesScene(Demo demo, string name, int instanceIndex, string info)
+        {
+            this.demo = demo;
+            this.name = name;
+            this.instanceIndexName = " " + instanceIndex.ToString();
+            this.info = info;
+
+            // Create a new objects in the scene
+            skyInstance1 = new Sky(demo, 1);
+            quadInstance1 = new Quad(demo, 1);
+            cursorInstance = new Cursor(demo);
+            shotInstance = new Shot(demo);
+            userShapesInstance = new UserShapes(demo);
+            torusMesh1 = new TorusMesh(demo, 1);
+            torusMesh2 = new TorusMesh(demo, 2);
+            torusMesh3 = new TorusMesh(demo, 3);
+            torusMesh4 = new TorusMesh(demo, 4);
+            forceField1Instance = new ForceField1(demo);
+            forceField2Instance = new ForceField2(demo);
+            switch1Instance = new Switch1(demo);
+            switch2Instance = new Switch2(demo);
+            camera1Instance1 = new Camera1(demo, 1);
+            lightInstance = new Lights(demo);
+
+            // Create a new controllers in the scene
+            skyDraw1Instance1 = new SkyDraw1(demo, 1);
+            cursorDraw1Instance = new CursorDraw1(demo);
+            forceField1Animation1Instance = new ForceField1Animation1(demo, forceField1Instance);
+            forceField2Animation1Instance = new ForceField2Animation1(demo, forceField2Instance);
+            switch1Animation1Instance = new Switch1Animation1(demo, switch1Instance);
+            switch2Animation1Instance = new Switch2Animation1(demo, switch2Instance);
+            camera1Animation1Instance1 = new Camera1Animation1(demo, 1);
+            camera1Draw1Instance1 = new Camera1Draw1(demo, 1);
+        }
+
+        public void Create()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null) return;
+
+            scene = demo.Engine.Factory.PhysicsSceneManager.Create(sceneInstanceIndexName);
+
+            // Initialize maximum number of solver iterations for the scene
+            scene.MaxIterationCount = 10;
+
+            // Initialize time of simulation for the scene
+            scene.TimeOfSimulation = 1.0f / 15.0f;
+
+            Initialize();
+
+            // Initialize objects in the scene
+            skyInstance1.Initialize(scene);
+            quadInstance1.Initialize(scene);
+            cursorInstance.Initialize(scene);
+            shotInstance.Initialize(scene);
+            userShapesInstance.Initialize(scene);
+            torusMesh1.Initialize(scene);
+            torusMesh2.Initialize(scene);
+            torusMesh3.Initialize(scene);
+            torusMesh4.Initialize(scene);
+            forceField1Instance.Initialize(scene);
+            forceField2Instance.Initialize(scene);
+            switch1Instance.Initialize(scene);
+            switch2Instance.Initialize(scene);
+            camera1Instance1.Initialize(scene);
+            lightInstance.Initialize(scene);
+
+            // Initialize controllers in the scene
+            skyDraw1Instance1.Initialize(scene);
+            cursorDraw1Instance.Initialize(scene);
+            forceField1Animation1Instance.Initialize(scene);
+            forceField2Animation1Instance.Initialize(scene);
+            switch1Animation1Instance.Initialize(scene);
+            switch2Animation1Instance.Initialize(scene);
+            camera1Animation1Instance1.Initialize(scene);
+            camera1Draw1Instance1.Initialize(scene);
+
+            // Create shapes shared for all physics objects in the scene
+            // These shapes are used by all objects in the scene
+            Demo.CreateSharedShapes(demo, scene);
+
+            // Create shapes for objects in the scene
+            Sky.CreateShapes(demo, scene);
+            Quad.CreateShapes(demo, scene);
+            Cursor.CreateShapes(demo, scene);
+            Shot.CreateShapes(demo, scene);
+            UserShapes.CreateShapes(demo, scene);
+            TorusMesh.CreateShapes(demo, scene);
+            ForceField1.CreateShapes(demo, scene);
+            ForceField2.CreateShapes(demo, scene);
+            Switch1.CreateShapes(demo, scene);
+            Switch2.CreateShapes(demo, scene);
+            Camera1.CreateShapes(demo, scene);
+            Lights.CreateShapes(demo, scene);
+
+            // Create physics objects for objects in the scene
+            skyInstance1.Create(new Vector3(0.0f, 0.0f, 0.0f));
+            quadInstance1.Create(new Vector3(0.0f, -40.0f, 20.0f), new Vector3(1000.0f, 31.0f, 1000.0f), Quaternion.Identity);
+            cursorInstance.Create();
+            shotInstance.Create();
+            userShapesInstance.Create();
+            torusMesh1.Create(new Vector3(-5.0f, -5.0f, 5.0f), Vector3.One, Quaternion.Identity, 0.0f);
+            torusMesh2.Create(new Vector3(-20.0f, -5.0f, 5.0f), new Vector3(2.0f, 1.0f, 1.0f), Quaternion.FromAxisAngle(Vector3.UnitZ, MathHelper.DegreesToRadians(45.0f)), 0.0f);
+            torusMesh3.Create(new Vector3(-5.0f, 10.0f, 5.0f), Vector3.One, Quaternion.Identity, 100000.0f);
+            torusMesh4.Create(new Vector3(-5.0f, 20.0f, 5.0f), Vector3.One, Quaternion.Identity, 100000.0f);
+            forceField1Instance.Create();
+            forceField2Instance.Create();
+            switch1Instance.Create();
+            switch2Instance.Create();
+            camera1Instance1.Create(new Vector3(0.0f, 5.0f, -22.0f), Quaternion.Identity, Quaternion.Identity, Quaternion.Identity, true);
+
+            lightInstance.CreateLightPoint(0, "Glass", new Vector3(-30.0f, 0.0f, 60.0f), new Vector3(0.2f, 1.0f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(1, "Glass", new Vector3(0.0f, 7.0f, 60.0f), new Vector3(1.0f, 0.5f, 0.1f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(2, "Glass", new Vector3(30.0f, 0.0f, 60.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(3, "Glass", new Vector3(-30.0f, 0.0f, 15.0f), new Vector3(1.0f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(4, "Glass", new Vector3(10.0f, 7.0f, 10.0f), new Vector3(1.0f, 0.7f, 0.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightPoint(5, "Glass", new Vector3(40.0f, 0.0f, 15.0f), new Vector3(0.3f, 0.7f, 0.5f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(0, "Glass", new Vector3(-30.0f, 8.0f, 0.0f), new Vector3(0.1f, 0.7f, 1.0f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(1, "Glass", new Vector3(5.0f, 8.0f, -5.0f), new Vector3(1.0f, 0.5f, 0.2f), 20.0f, 1.0f);
+            lightInstance.CreateLightSpot(2, "Glass", new Vector3(30.0f, 8.0f, 0.0f), new Vector3(0.5f, 1.0f, 0.2f), 20.0f, 1.0f);
+
+            // Set controllers for objects in the scene
+            SetControllers();
+        }
+
+        public void Initialize()
+        {
+            scene.UserControllers.PostDrawMethods += demo.DrawInfo;
+
+            if (scene.Light == null)
+            {
+                scene.CreateLight(true);
+                scene.Light.Type = PhysicsLightType.Directional;
+                scene.Light.SetDirection(-0.4f, -0.8f, 0.4f, 0.0f);
+            }
+        }
+
+        public void SetControllers()
+        {
+            skyDraw1Instance1.SetControllers();
+            cursorDraw1Instance.SetControllers();
+            forceField1Animation1Instance.SetControllers();
+            forceField2Animation1Instance.SetControllers();
+            switch1Animation1Instance.SetControllers();
+            switch2Animation1Instance.SetControllers();
+            camera1Animation1Instance1.SetControllers();
+            camera1Draw1Instance1.SetControllers(false, false, false, false, false, false);
+        }
+
+        public void Refresh(double time)
+        {
+            camera1Animation1Instance1.RefreshControllers();
+            camera1Draw1Instance1.RefreshControllers();
+
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            scene.Simulate(time);
+            scene.Draw(time);
+
+            if (demo.EnableMenu)
+            {
+                GL.Clear(ClearBufferMask.DepthBufferBit);
+                demo.MenuScene.PhysicsScene.Draw(time);
+            }
+
+            demo.SwapBuffers();
+        }
+
+        public void Remove()
+        {
+            string sceneInstanceIndexName = name + instanceIndexName;
+
+            if (demo.Engine.Factory.PhysicsSceneManager.Find(sceneInstanceIndexName) != null)
+                demo.Engine.Factory.PhysicsSceneManager.Remove(sceneInstanceIndexName);
+        }
+
+        public void CreateResources()
+        {
+        }
+
+        public void DisposeResources()
+        {
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/26c56564c93027ebbdb430e0c8b7409eec93d444">Unity tutorial</a>  -  26c5656</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 68 insertions(+)

diff --git a/Unity/Assets/_Scripts/CameraController.cs b/Unity/Assets/_Scripts/CameraController.cs
new file mode 100644
index 0000000..47644d3
--- /dev/null
+++ b/Unity/Assets/_Scripts/CameraController.cs
@@ -0,0 +1,18 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class CameraController : MonoBehaviour {
+
+    public GameObject player;
+    private Vector3 offset;
+
+	// Use this for initialization
+	void Start () {
+        offset = transform.position;
+	}
+	
+	// Update is called once per frame
+	void LateUpdate () {
+        transform.position = player.transform.position + offset;
+	}
+}
diff --git a/Unity/Assets/_Scripts/PickupAnim.cs b/Unity/Assets/_Scripts/PickupAnim.cs
new file mode 100644
index 0000000..022464c
--- /dev/null
+++ b/Unity/Assets/_Scripts/PickupAnim.cs
@@ -0,0 +1,10 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class PickupAnim : MonoBehaviour {
+
+	// Update is called once per frame
+	void Update () {
+		transform.Rotate (new Vector3 (15, 30, 45) * Time.deltaTime);
+	}
+}
diff --git a/Unity/Assets/_Scripts/PlayerScript.cs b/Unity/Assets/_Scripts/PlayerScript.cs
new file mode 100644
index 0000000..28d4cb9
--- /dev/null
+++ b/Unity/Assets/_Scripts/PlayerScript.cs
@@ -0,0 +1,40 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class PlayerScript : MonoBehaviour {
+
+	public float speed;
+	private int score;
+	public GUIText scoreText, winText;
+
+	void Start()
+	{
+		score = 0;
+		scoreText.text = "Score: " + score.ToString();
+		winText.text = "";
+	}
+    
+	void FixedUpdate ()
+    {
+        float moveHorizontal = Input.GetAxis("Horizontal");
+        float moveVertical = Input.GetAxis("Vertical");
+
+        Vector3 movementForce = new Vector3(moveHorizontal, 0.0f, moveVertical);
+
+        rigidbody.AddForce(movementForce * speed * Time.deltaTime);
+
+		if (score == 12)
+		{
+			winText.text = "You Win";
+		}
+    }
+
+	void OnTriggerEnter(Collider other) {
+		if (other.gameObject.tag == "Pickup"){
+
+			other.gameObject.SetActive(false);
+			score++;
+			scoreText.text = "Score :" + score.ToString();
+		}
+	}
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/10dc34623fe87db8fa22e480a67b9c0b65a84914">More research etc from Unity and Blender.</a>  -  10dc346</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 12 files changed, 317 insertions(+), 3 deletions(-)

diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index ecdade2..e3953d8 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -28,3 +28,3 @@ namespace KAOS
             : base(height, width, new GraphicsMode(32, 16, 0, 4), KAOSEngine.AppName, GameWindowFlags.Default, 
-            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default)
+            DisplayDevice.Default, major, minor, GraphicsContextFlags.Default | GraphicsContextFlags.ForwardCompatible)
         { }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index ade7e96..9567103 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -21,3 +21,3 @@ namespace KAOS.States
             defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
             defaultSkyboxPath + "pos_y.bmp",
@@ -25,3 +25,3 @@ namespace KAOS.States
             defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
         };
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_BGScroller.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_BGScroller.cs
new file mode 100644
index 0000000..948200d
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_BGScroller.cs
@@ -0,0 +1,21 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_BGScroller : MonoBehaviour
+{
+	public float scrollSpeed;
+	public float tileSizeZ;
+
+	private Vector3 startPosition;
+
+	void Start ()
+	{
+		startPosition = transform.position;
+	}
+
+	void Update ()
+	{
+		float newPosition = Mathf.Repeat(Time.time * scrollSpeed, tileSizeZ);
+		transform.position = startPosition + Vector3.forward * newPosition;
+	}
+}
\ No newline at end of file
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByBoundary.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByBoundary.cs
new file mode 100644
index 0000000..ee36fb2
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByBoundary.cs
@@ -0,0 +1,10 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_DestroyByBoundary : MonoBehaviour
+{
+	void OnTriggerExit (Collider other) 
+	{
+		Destroy(other.gameObject);
+	}
+}
\ No newline at end of file
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByContact.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByContact.cs
new file mode 100644
index 0000000..e1a5890
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByContact.cs
@@ -0,0 +1,46 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_DestroyByContact : MonoBehaviour
+{
+	public GameObject explosion;
+	public GameObject playerExplosion;
+	public int scoreValue;
+	private Done_GameController gameController;
+
+	void Start ()
+	{
+		GameObject gameControllerObject = GameObject.FindGameObjectWithTag ("GameController");
+		if (gameControllerObject != null)
+		{
+			gameController = gameControllerObject.GetComponent <Done_GameController>();
+		}
+		if (gameController == null)
+		{
+			Debug.Log ("Cannot find 'GameController' script");
+		}
+	}
+
+	void OnTriggerEnter (Collider other)
+	{
+		if (other.tag == "Boundary" || other.tag == "Enemy")
+		{
+			return;
+		}
+
+		if (explosion != null)
+		{
+			Instantiate(explosion, transform.position, transform.rotation);
+		}
+
+		if (other.tag == "Player")
+		{
+			Instantiate(playerExplosion, other.transform.position, other.transform.rotation);
+			gameController.GameOver();
+		}
+		
+		gameController.AddScore(scoreValue);
+		Destroy (other.gameObject);
+		Destroy (gameObject);
+	}
+}
\ No newline at end of file
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByTime.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByTime.cs
new file mode 100644
index 0000000..20db062
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_DestroyByTime.cs
@@ -0,0 +1,12 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_DestroyByTime : MonoBehaviour
+{
+	public float lifetime;
+
+	void Start ()
+	{
+		Destroy (gameObject, lifetime);
+	}
+}
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_EvasiveManeuver.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_EvasiveManeuver.cs
new file mode 100644
index 0000000..68a0ae1
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_EvasiveManeuver.cs
@@ -0,0 +1,48 @@
+using UnityEngine;
+using System.Collections;
+
+public class Done_EvasiveManeuver : MonoBehaviour
+{
+	public Done_Boundary boundary;
+	public float tilt;
+	public float dodge;
+	public float smoothing;
+	public Vector2 startWait;
+	public Vector2 maneuverTime;
+	public Vector2 maneuverWait;
+
+	private float currentSpeed;
+	private float targetManeuver;
+
+	void Start ()
+	{
+		currentSpeed = rigidbody.velocity.z;
+		StartCoroutine(Evade());
+	}
+	
+	IEnumerator Evade ()
+	{
+		yield return new WaitForSeconds (Random.Range (startWait.x, startWait.y));
+		while (true)
+		{
+			targetManeuver = Random.Range (1, dodge) * -Mathf.Sign (transform.position.x);
+			yield return new WaitForSeconds (Random.Range (maneuverTime.x, maneuverTime.y));
+			targetManeuver = 0;
+			yield return new WaitForSeconds (Random.Range (maneuverWait.x, maneuverWait.y));
+		}
+	}
+	
+	void FixedUpdate ()
+	{
+		float newManeuver = Mathf.MoveTowards (rigidbody.velocity.x, targetManeuver, smoothing * Time.deltaTime);
+		rigidbody.velocity = new Vector3 (newManeuver, 0.0f, currentSpeed);
+		rigidbody.position = new Vector3
+		(
+			Mathf.Clamp(rigidbody.position.x, boundary.xMin, boundary.xMax), 
+			0.0f, 
+			Mathf.Clamp(rigidbody.position.z, boundary.zMin, boundary.zMax)
+		);
+		
+		rigidbody.rotation = Quaternion.Euler (0, 0, rigidbody.velocity.x * -tilt);
+	}
+}
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_GameController.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_GameController.cs
new file mode 100644
index 0000000..4b65419
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_GameController.cs
@@ -0,0 +1,83 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_GameController : MonoBehaviour
+{
+	public GameObject[] hazards;
+	public Vector3 spawnValues;
+	public int hazardCount;
+	public float spawnWait;
+	public float startWait;
+	public float waveWait;
+	
+	public GUIText scoreText;
+	public GUIText restartText;
+	public GUIText gameOverText;
+	
+	private bool gameOver;
+	private bool restart;
+	private int score;
+	
+	void Start ()
+	{
+		gameOver = false;
+		restart = false;
+		restartText.text = "";
+		gameOverText.text = "";
+		score = 0;
+		UpdateScore ();
+		StartCoroutine (SpawnWaves ());
+	}
+	
+	void Update ()
+	{
+		if (restart)
+		{
+			if (Input.GetKeyDown (KeyCode.R))
+			{
+				Application.LoadLevel (Application.loadedLevel);
+			}
+		}
+	}
+	
+	IEnumerator SpawnWaves ()
+	{
+		yield return new WaitForSeconds (startWait);
+		while (true)
+		{
+			for (int i = 0; i < hazardCount; i++)
+			{
+				GameObject hazard = hazards [Random.Range (0, hazards.Length)];
+				Vector3 spawnPosition = new Vector3 (Random.Range (-spawnValues.x, spawnValues.x), spawnValues.y, spawnValues.z);
+				Quaternion spawnRotation = Quaternion.identity;
+				Instantiate (hazard, spawnPosition, spawnRotation);
+				yield return new WaitForSeconds (spawnWait);
+			}
+			yield return new WaitForSeconds (waveWait);
+			
+			if (gameOver)
+			{
+				restartText.text = "Press 'R' for Restart";
+				restart = true;
+				break;
+			}
+		}
+	}
+	
+	public void AddScore (int newScoreValue)
+	{
+		score += newScoreValue;
+		UpdateScore ();
+	}
+	
+	void UpdateScore ()
+	{
+		scoreText.text = "Score: " + score;
+	}
+	
+	public void GameOver ()
+	{
+		gameOverText.text = "Game Over!";
+		gameOver = true;
+	}
+}
\ No newline at end of file
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_Mover.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_Mover.cs
new file mode 100644
index 0000000..d40a798
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_Mover.cs
@@ -0,0 +1,12 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_Mover : MonoBehaviour
+{
+	public float speed;
+
+	void Start ()
+	{
+		rigidbody.velocity = transform.forward * speed;
+	}
+}
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_PlayerController.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_PlayerController.cs
new file mode 100644
index 0000000..9892460
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_PlayerController.cs
@@ -0,0 +1,49 @@
+﻿using UnityEngine;
+using System.Collections;
+
+[System.Serializable]
+public class Done_Boundary 
+{
+	public float xMin, xMax, zMin, zMax;
+}
+
+public class Done_PlayerController : MonoBehaviour
+{
+	public float speed;
+	public float tilt;
+	public Done_Boundary boundary;
+
+	public GameObject shot;
+	public Transform shotSpawn;
+	public float fireRate;
+	 
+	private float nextFire;
+	
+	void Update ()
+	{
+		if (Input.GetButton("Fire1") && Time.time > nextFire) 
+		{
+			nextFire = Time.time + fireRate;
+			Instantiate(shot, shotSpawn.position, shotSpawn.rotation);
+			audio.Play ();
+		}
+	}
+
+	void FixedUpdate ()
+	{
+		float moveHorizontal = Input.GetAxis ("Horizontal");
+		float moveVertical = Input.GetAxis ("Vertical");
+
+		Vector3 movement = new Vector3 (moveHorizontal, 0.0f, moveVertical);
+		rigidbody.velocity = movement * speed;
+		
+		rigidbody.position = new Vector3
+		(
+			Mathf.Clamp (rigidbody.position.x, boundary.xMin, boundary.xMax), 
+			0.0f, 
+			Mathf.Clamp (rigidbody.position.z, boundary.zMin, boundary.zMax)
+		);
+		
+		rigidbody.rotation = Quaternion.Euler (0.0f, 0.0f, rigidbody.velocity.x * -tilt);
+	}
+}
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_RandomRotator.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_RandomRotator.cs
new file mode 100644
index 0000000..e28e8af
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_RandomRotator.cs
@@ -0,0 +1,12 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_RandomRotator : MonoBehaviour 
+{
+	public float tumble;
+	
+	void Start ()
+	{
+		rigidbody.angularVelocity = Random.insideUnitSphere * tumble;
+	}
+}
\ No newline at end of file
diff --git a/Unity-Shooter/Assets/Done/Done_Scripts/Done_WeaponController.cs b/Unity-Shooter/Assets/Done/Done_Scripts/Done_WeaponController.cs
new file mode 100644
index 0000000..18adf9d
--- /dev/null
+++ b/Unity-Shooter/Assets/Done/Done_Scripts/Done_WeaponController.cs
@@ -0,0 +1,21 @@
+﻿using UnityEngine;
+using System.Collections;
+
+public class Done_WeaponController : MonoBehaviour
+{
+	public GameObject shot;
+	public Transform shotSpawn;
+	public float fireRate;
+	public float delay;
+
+	void Start ()
+	{
+		InvokeRepeating ("Fire", delay, fireRate);
+	}
+
+	void Fire ()
+	{
+		Instantiate(shot, shotSpawn.position, shotSpawn.rotation);
+		audio.Play();
+	}
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/8a7d8ef2a333b7ac7bfeacadd18c0e0b9f0cd5ae">Fixing skybox.</a>  -  8a7d8ef</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 9567103..ade7e96 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -21,3 +21,3 @@ namespace KAOS.States
             defaultSkyboxPath + "pos_x.bmp",
-            defaultSkyboxPath + "neg_z.bmp",
+            defaultSkyboxPath + "neg_x.bmp",
             defaultSkyboxPath + "pos_y.bmp",
@@ -25,3 +25,3 @@ namespace KAOS.States
             defaultSkyboxPath + "pos_z.bmp",
-            defaultSkyboxPath + "neg_x.bmp",
+            defaultSkyboxPath + "neg_z.bmp",
         };

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7939aa806c1714cac72bab7b6742c528aa21eb89">Adding empty game states to game project.</a>  -  7939aa8</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 71 insertions(+), 3 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 9e46ee4..348e31a 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -1,2 +1,3 @@
-﻿using KAOS;
+﻿using Game.States;
+using KAOS;
 using KAOS.Managers;
@@ -20,3 +21,3 @@ namespace Game
             SetupStates();
-            stateManager.ChangeState("skybox");
+            stateManager.ChangeState("SplashScreen");
         }
@@ -25,3 +26,4 @@ namespace Game
         {
-            stateManager.AddState("skybox", new Skyboxstate(stateManager));
+            stateManager.AddState("SplashScreen", new SplashScreen(stateManager));
+            stateManager.AddState("TestScene", new TestScene(stateManager));
         }
diff --git a/Game/States/SplashScreen.cs b/Game/States/SplashScreen.cs
new file mode 100644
index 0000000..86d194c
--- /dev/null
+++ b/Game/States/SplashScreen.cs
@@ -0,0 +1,37 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using KAOS.Interfaces;
+using KAOS.Managers;
+
+namespace Game.States
+{
+    class SplashScreen : IGameObject
+    {
+        double currentRotation = 0;
+        double delay = 300;
+
+        StateManager m_stateManager;
+        public SplashScreen(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            delay--;
+            if (delay <= 0){
+                delay = 3;
+                m_stateManager.ChangeState("TestScene");
+            }
+            currentRotation = 10 * elapsedTime;
+        }
+
+        public void Render()
+        {
+
+        }
+    }
+}
diff --git a/Game/States/TestScene.cs b/Game/States/TestScene.cs
new file mode 100644
index 0000000..eb12f86
--- /dev/null
+++ b/Game/States/TestScene.cs
@@ -0,0 +1,29 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using KAOS.Interfaces;
+using KAOS.Managers;
+
+namespace Game.States
+{
+    class TestScene : IGameObject
+    {
+        StateManager m_stateManager;
+        public TestScene(StateManager stateManager)
+        {
+            m_stateManager = stateManager;
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/080442338074ee40952bc9cb783e9525ce1c9397">~ Tested refactoring of buffer Managers/VertexBufferManager.cs</a>  -  0804423</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 6 files changed, 199 insertions(+), 9 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 348e31a..9647f3e 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -27,3 +27,3 @@ namespace Game
             stateManager.AddState("SplashScreen", new SplashScreen(stateManager));
-            stateManager.AddState("TestScene", new TestScene(stateManager));
+            stateManager.AddState("TestScene", new Skyboxstate(stateManager));
         }
diff --git a/KAOS/Managers/VertexBufferManager.cs b/KAOS/Managers/VertexBufferManager.cs
new file mode 100644
index 0000000..1caea30
--- /dev/null
+++ b/KAOS/Managers/VertexBufferManager.cs
@@ -0,0 +1,145 @@
+﻿using KAOS.Interfaces;
+using KAOS.Shapes;
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+
+namespace KAOS.Managers
+{
+    /// <summary>
+    /// Responsible for uploading vertex data to the gpu and setting up vertex arrays.
+    /// </summary>
+    public class VertexBufferManager
+    {
+        Dictionary<string, VertexBuffer> m_bufferStore = new Dictionary<string, VertexBuffer>();
+        int gpuHandle, sizeOfPositionData, sizeOfNormalsData;
+        IntPtr vertexBufferSize, noOffset;
+        VertexBuffer vertexBuffer = new VertexBuffer();
+        VertexT2fN3fV3f[] vertexData;
+        uint[] indices;
+        PrimitiveType type;
+
+        public void GenerateVertexBuffer(string name, IDrawableShape shape, int program)
+        {
+
+            LoadBufferData(shape);
+
+            CalculateBufferSize();
+
+            // Generate Vertex Buffer Object and bind it so it is current.
+            GenerateVertexBuffer();
+            
+            SendVertexBufferData();
+
+            // Generate Vertex Array Object and bind it so it is current.
+            GenerateVertexArray();
+
+            GetVertexArrayPointers(program);
+
+            // IMPORTANT: vertex array needs unbinding here to avoid rendering incorrectly
+            UnbindVertexArrayBuffer();
+
+            m_bufferStore.Add(name, vertexBuffer);
+        }
+
+        public VertexBuffer GetBuffer(string name)
+        {
+            return m_bufferStore[name];
+        }
+
+        #region Private Methods
+
+        private void CalculateBufferSize()
+        {
+            sizeOfPositionData = Vector3.SizeInBytes * vertexBuffer.PositionData.Length;
+            sizeOfNormalsData = Vector3.SizeInBytes * vertexBuffer.NormalsData.Length;
+            //sizeOfColorData = Marshal.SizeOf(new Color4()) * bufferObject.ColorData.Length;
+            vertexBufferSize = new IntPtr(sizeOfPositionData + sizeOfNormalsData);
+            noOffset = new IntPtr(0);
+        }
+
+        private void LoadBufferData(IDrawableShape shape)
+        {
+            //bufferObject.PositionData = new Vector3d[1];
+            //bufferObject.NormalsData = new Vector3d[1];
+
+            shape.GetArraysforVBO(out type, out vertexData, out indices);
+
+            vertexBuffer.PositionData = shape.Vertices;
+            vertexBuffer.NormalsData = shape.Normals;
+            vertexBuffer.IndicesData = shape.Indices;
+            vertexBuffer.PrimitiveType = type;
+        }
+
+        private void GenerateVertexBuffer()
+        {
+            GL.GenBuffers(1, out gpuHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, gpuHandle);
+
+            // Save pointers generated by OpenGL here so i dont forget.
+            vertexBuffer.VboID = gpuHandle;
+        } 
+
+        private void SendVertexBufferData()
+        {
+            // Initialise storage space for the Vertex Buffer.
+            GL.BufferData(BufferTarget.ArrayBuffer, vertexBufferSize, IntPtr.Zero, BufferUsageHint.StaticDraw);
+            // Send Position data.
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, noOffset, new IntPtr(sizeOfPositionData), vertexBuffer.PositionData);
+            // Send Normals data, offset by size of Position data.
+            GL.BufferSubData<Vector3>(
+                BufferTarget.ArrayBuffer, new IntPtr(sizeOfPositionData), new IntPtr(sizeOfNormalsData), vertexBuffer.NormalsData);
+
+            GL.GenBuffers(1, out gpuHandle);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, gpuHandle);
+            GL.BufferData(
+                BufferTarget.ElementArrayBuffer, new IntPtr(sizeof(uint) * vertexBuffer.IndicesData.Length), vertexBuffer.IndicesData, BufferUsageHint.StaticDraw);
+
+            vertexBuffer.IboID = gpuHandle;
+
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vertexBuffer.IboID);
+        }
+
+        private void GenerateVertexArray()
+        {
+
+            // GL3 allows us to store the vertex layout in a "vertex array object" (VAO).
+            // This means we do not have to re-issue VertexAttribPointer calls
+            // every time we try to use a different vertex layout - these calls are
+            // stored in the VAO so we simply need to bind the correct VAO.
+            GL.GenVertexArrays(1, out gpuHandle);
+            GL.BindVertexArray(gpuHandle);
+
+            vertexBuffer.VaoID = gpuHandle;
+        }
+    
+        private void GetVertexArrayPointers(int program)
+        {
+            gpuHandle = GL.GetAttribLocation(program, "in_position");
+            GL.EnableVertexAttribArray(gpuHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
+            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, 0);
+            GL.BindAttribLocation(program, gpuHandle, "in_position");
+
+            gpuHandle = GL.GetAttribLocation(program, "in_normal");
+            GL.EnableVertexAttribArray(gpuHandle);
+            GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer.VboID);
+            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, true, Vector3.SizeInBytes, sizeOfPositionData);
+            GL.BindAttribLocation(program, gpuHandle, "in_normal");
+
+            GL.BindBuffer(BufferTarget.ElementArrayBuffer, vertexBuffer.IboID);
+        }
+
+        private static void UnbindVertexArrayBuffer()
+        {
+            GL.BindVertexArray(0);
+        }
+
+        #endregion
+
+    }
+}
diff --git a/KAOS/Nodes/AWNode.cs b/KAOS/Nodes/AWNode.cs
index d0dddca..7b1a34d 100644
--- a/KAOS/Nodes/AWNode.cs
+++ b/KAOS/Nodes/AWNode.cs
@@ -11,3 +11,3 @@ namespace KAOS.Nodes
     {
-        protected BufferObjectManager m_BufferManager;
+        protected VertexBufferManager m_BufferManager;
 
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index ade7e96..7eaea93 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -13,3 +13,3 @@ namespace KAOS.States
     {
-        private BufferObjectManager m_bufferManager;
+        private VertexBufferManager m_bufferManager;
         private StateManager m_stateManager;
@@ -32,3 +32,3 @@ namespace KAOS.States
         {
-            m_bufferManager = new BufferObjectManager();
+            m_bufferManager = new VertexBufferManager();
             m_stateManager = stateManager;
@@ -66,5 +66,5 @@ namespace KAOS.States
         {
-            m_bufferManager.AddBufferObject("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
-            m_bufferManager.AddBufferObject("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
-            m_bufferManager.AddBufferObject("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
+            m_bufferManager.GenerateVertexBuffer("SkyCube", new Cube(0, 0, 0), ShaderManager.Skybox.ID);
+            m_bufferManager.GenerateVertexBuffer("MengerSponge", new MengerSponge(1.0, Shapes.MengerSponge.eSubdivisions.Two, true ), ShaderManager.Render.ID);
+            m_bufferManager.GenerateVertexBuffer("Sphere", new SlicedSphere(2.0f, Vector3d.Zero, SlicedSphere.eSubdivisions.Eight, new SlicedSphere.eDir[] { SlicedSphere.eDir.All }, false), ShaderManager.Render.ID); 
         }
diff --git a/KAOS/Utilities/Renderer.cs b/KAOS/Utilities/Renderer.cs
index 1e6c0eb..ba71c48 100644
--- a/KAOS/Utilities/Renderer.cs
+++ b/KAOS/Utilities/Renderer.cs
@@ -33,3 +33,3 @@ namespace KAOS.Utilities
 
-        public static void DrawSkyBox(TextureManager textureManager, BufferObject bufferObject)
+        public static void DrawSkyBox(TextureManager textureManager, VertexBuffer bufferObject)
         {
@@ -49,3 +49,3 @@ namespace KAOS.Utilities
 
-        public static void DrawObject(TextureManager textureManager, BufferObject bufferObject)
+        public static void DrawObject(TextureManager textureManager, VertexBuffer bufferObject)
         {
diff --git a/KAOS/Utilities/VertexBuffer.cs b/KAOS/Utilities/VertexBuffer.cs
new file mode 100644
index 0000000..10a3be9
--- /dev/null
+++ b/KAOS/Utilities/VertexBuffer.cs
@@ -0,0 +1,45 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace KAOS.Utilities
+{
+    public struct VertexBuffer
+    {
+        public int VaoID { get; set; }
+
+        public int VboID { get; set; }
+
+        public int IboID { get; set; }
+
+        public PrimitiveType PrimitiveType { get; set; }
+
+        public Vector3[] PositionData { get; set; }
+
+        public Vector3[] NormalsData { get; set; }
+
+        public Color4[] ColorData { get; set; }
+
+        public uint[] IndicesData { get; set; }
+
+        public VertexBuffer(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 
+            Vector3[] vPositionData, Vector3[] vNormalsData, Color4[] vColorData, PrimitiveType primitiveType, uint[] indicesData) :this()
+        {
+            #region Buffer Pointer IDs
+            VaoID = vaoId;
+            VboID = vboId;
+            IboID = iboId;
+            #endregion
+            
+            PositionData = vPositionData;
+            NormalsData = vNormalsData;
+            ColorData = vColorData;
+            IndicesData = indicesData;
+        }
+
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/4847f29dfa50508cf99deb0e60210699f96c91d1">~ missed from last commit.</a>  -  4847f29</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 4 insertions(+)

diff --git a/KAOS/Utilities/VertexBuffer.cs b/KAOS/Utilities/VertexBuffer.cs
index 10a3be9..237e0e4 100644
--- a/KAOS/Utilities/VertexBuffer.cs
+++ b/KAOS/Utilities/VertexBuffer.cs
@@ -12,2 +12,4 @@ namespace KAOS.Utilities
     {
+        #region Public Buffer Pointer IDs
+
         public int VaoID { get; set; }
@@ -28,2 +30,4 @@ namespace KAOS.Utilities
 
+        #endregion
+
         public VertexBuffer(int vaoId, int vboId, int iboId, int vPosition, int vNormals, int vColor, 

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d6924d22549dc584d7e068102ade82bc92e84412">Initial Commit</a>  -  d6924d2</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 6 files changed, 239 insertions(+)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
new file mode 100644
index 0000000..49cb2f4
--- /dev/null
+++ b/Editor/FrmEditor.Designer.cs
@@ -0,0 +1,60 @@
+﻿namespace Editor
+{
+    partial class Editor
+    {
+        /// <summary>
+        /// Required designer variable.
+        /// </summary>
+        private System.ComponentModel.IContainer components = null;
+
+        /// <summary>
+        /// Clean up any resources being used.
+        /// </summary>
+        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
+        protected override void Dispose(bool disposing)
+        {
+            if (disposing && (components != null))
+            {
+                components.Dispose();
+            }
+            base.Dispose(disposing);
+        }
+
+        #region Windows Form Designer generated code
+
+        /// <summary>
+        /// Required method for Designer support - do not modify
+        /// the contents of this method with the code editor.
+        /// </summary>
+        private void InitializeComponent()
+        {
+            this.glControl1 = new OpenTK.GLControl();
+            this.SuspendLayout();
+            // 
+            // glControl1
+            // 
+            this.glControl1.BackColor = System.Drawing.Color.Black;
+            this.glControl1.Location = new System.Drawing.Point(319, 5);
+            this.glControl1.Name = "glControl1";
+            this.glControl1.Size = new System.Drawing.Size(768, 576);
+            this.glControl1.TabIndex = 0;
+            this.glControl1.VSync = false;
+            // 
+            // Editor
+            // 
+            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+            this.ClientSize = new System.Drawing.Size(1099, 593);
+            this.Controls.Add(this.glControl1);
+            this.Name = "Editor";
+            this.Text = "Editor";
+            this.ResumeLayout(false);
+
+        }
+
+        #endregion
+
+        private OpenTK.GLControl glControl1;
+    }
+}
+
diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
new file mode 100644
index 0000000..691ac3a
--- /dev/null
+++ b/Editor/FrmEditor.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Data;
+using System.Drawing;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace Editor
+{
+    public partial class Editor : Form
+    {
+        public Editor()
+        {
+            InitializeComponent();
+        }
+    }
+}
diff --git a/Editor/Program.cs b/Editor/Program.cs
new file mode 100644
index 0000000..43626e5
--- /dev/null
+++ b/Editor/Program.cs
@@ -0,0 +1,22 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using System.Windows.Forms;
+
+namespace Editor
+{
+    static class Program
+    {
+        /// <summary>
+        /// The main entry point for the application.
+        /// </summary>
+        [STAThread]
+        static void Main()
+        {
+            Application.EnableVisualStyles();
+            Application.SetCompatibleTextRenderingDefault(false);
+            Application.Run(new Editor());
+        }
+    }
+}
new file mode 100644
index 0000000..f9cb0b3
--- /dev/null
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Editor")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("Editor")]
+[assembly: AssemblyCopyright("Copyright ©  2014")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("0d725645-ebc5-4fca-a2c0-9f88d8d2668f")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
new file mode 100644
index 0000000..f75069e
--- /dev/null
@@ -0,0 +1,71 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18449
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace Editor.Properties
+{
+
+
+    /// <summary>
+    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    /// </summary>
+    // This class was auto-generated by the StronglyTypedResourceBuilder
+    // class via a tool like ResGen or Visual Studio.
+    // To add or remove a member, edit your .ResX file then rerun ResGen
+    // with the /str option, or rebuild your VS project.
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    internal class Resources
+    {
+
+        private static global::System.Resources.ResourceManager resourceMan;
+
+        private static global::System.Globalization.CultureInfo resourceCulture;
+
+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
+        internal Resources()
+        {
+        }
+
+        /// <summary>
+        ///   Returns the cached ResourceManager instance used by this class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Resources.ResourceManager ResourceManager
+        {
+            get
+            {
+                if ((resourceMan == null))
+                {
+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Editor.Properties.Resources", typeof(Resources).Assembly);
+                    resourceMan = temp;
+                }
+                return resourceMan;
+            }
+        }
+
+        /// <summary>
+        ///   Overrides the current thread's CurrentUICulture property for all
+        ///   resource lookups using this strongly typed resource class.
+        /// </summary>
+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
+        internal static global::System.Globalization.CultureInfo Culture
+        {
+            get
+            {
+                return resourceCulture;
+            }
+            set
+            {
+                resourceCulture = value;
+            }
+        }
+    }
+}
new file mode 100644
index 0000000..9cb6606
--- /dev/null
@@ -0,0 +1,30 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//     Runtime Version:4.0.30319.18449
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace Editor.Properties
+{
+
+
+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
+    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
+    {
+
+        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
+
+        public static Settings Default
+        {
+            get
+            {
+                return defaultInstance;
+            }
+        }
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0a101c8b60c8b3bccbb0f6606c9514ab78a338ba">Setting up basic environment.</a>  -  0a101c8</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 98 insertions(+)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
index 49cb2f4..b6a5e2e 100644
--- a/Editor/FrmEditor.Designer.cs
+++ b/Editor/FrmEditor.Designer.cs
@@ -31,2 +31,3 @@
             this.glControl1 = new OpenTK.GLControl();
+            this.button1 = new System.Windows.Forms.Button();
             this.SuspendLayout();
@@ -41,2 +42,15 @@
             this.glControl1.VSync = false;
+            this.glControl1.Load += new System.EventHandler(this.glControl1_Load);
+            this.glControl1.Paint += new System.Windows.Forms.PaintEventHandler(this.glControl1_Paint);
+            this.glControl1.KeyDown += new System.Windows.Forms.KeyEventHandler(this.glControl1_KeyDown);
+            this.glControl1.Resize += new System.EventHandler(this.glControl1_Resize);
+            // 
+            // button1
+            // 
+            this.button1.Location = new System.Drawing.Point(22, 23);
+            this.button1.Name = "button1";
+            this.button1.Size = new System.Drawing.Size(75, 23);
+            this.button1.TabIndex = 1;
+            this.button1.Text = "button1";
+            this.button1.UseVisualStyleBackColor = true;
             // 
@@ -47,2 +61,3 @@
             this.ClientSize = new System.Drawing.Size(1099, 593);
+            this.Controls.Add(this.button1);
             this.Controls.Add(this.glControl1);
@@ -57,2 +72,3 @@
         private OpenTK.GLControl glControl1;
+        private System.Windows.Forms.Button button1;
     }
diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 691ac3a..80439ba 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -9,2 +9,3 @@ using System.Threading.Tasks;
 using System.Windows.Forms;
+using OpenTK.Graphics.OpenGL;
 
@@ -14,2 +15,5 @@ namespace Editor
     {
+        bool glControlLoaded = false;
+        int x = 0;
+
         public Editor()
@@ -18,2 +22,80 @@ namespace Editor
         }
+
+        private void glControl1_Load(object sender, EventArgs e)
+        {
+            glControlLoaded = true;
+            Renderer.Load();
+            Renderer.SetupViewport(ref glControl1);
+        }
+
+        private void glControl1_Paint(object sender, PaintEventArgs e)
+        {
+            if (!glControlLoaded) // Play nice
+                return;
+
+            Renderer.DefaultRender(ref glControl1, x);
+        }
+
+        private void glControl1_KeyDown(object sender, KeyEventArgs e)
+        {
+            if (e.KeyCode == Keys.Space)
+            {
+                x++;
+                glControl1.Invalidate();
+            }
+        }
+
+        private void glControl1_Resize(object sender, EventArgs e)
+        {
+            Renderer.Resize(ref glControl1);
+        }
+
+    }
+
+    static class Renderer
+    {
+
+        internal static void Resize(ref OpenTK.GLControl glControl1)
+        {
+            SetupViewport(ref glControl1);
+            glControl1.Invalidate();
+        }
+
+        internal static void SetupViewport(ref OpenTK.GLControl glControl1)
+        {
+            int w = glControl1.Width;
+            int h = glControl1.Height;
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadIdentity();
+            GL.Ortho(0, w, 0, h, -1, 1); // Bottom-left corner pixel has coordinate (0, 0)
+            GL.Viewport(0, 0, w, h); // Use all of the glControl painting area
+        }
+
+        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x)
+        {
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+
+            GL.Translate(x, 0, 0); // position triangle according to our x variable
+
+            if (glControl1.Focused) // Simple enough :)
+                GL.Color3(Color.Yellow);
+            else
+                GL.Color3(Color.Blue);
+
+            GL.Begin(PrimitiveType.Triangles);
+            GL.Vertex2(10, 20);
+            GL.Vertex2(100, 20);
+            GL.Vertex2(100, 50);
+            GL.End();
+
+            glControl1.SwapBuffers();
+        }
+
+        internal static void Load()
+        {
+            GL.ClearColor(Color.SkyBlue);
+        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/7aea01ea6c558ab136b8867df7322969c35734a0">More example setup code for glControl</a>  -  7aea01e</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 47 insertions(+), 2 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 80439ba..a044afc 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -10,2 +10,4 @@ using System.Windows.Forms;
 using OpenTK.Graphics.OpenGL;
+using OpenTK;
+using System.Diagnostics;
 
@@ -23,2 +25,3 @@ namespace Editor
 
+        Stopwatch sw = new Stopwatch();
         private void glControl1_Load(object sender, EventArgs e)
@@ -28,2 +31,42 @@ namespace Editor
             Renderer.SetupViewport(ref glControl1);
+            Application.Idle += Application_Idle; // press TAB twice after +=
+            sw.Start();
+        }
+
+        void Application_Idle(object sender, EventArgs e)
+        {
+            double milliseconds = ComputeTimeSlice();
+            Accumulate(milliseconds);
+            Animate(milliseconds);
+        }
+
+        private double ComputeTimeSlice()
+        {
+            sw.Stop();
+            double timeslice = sw.Elapsed.TotalMilliseconds;
+            sw.Reset();
+            sw.Start();
+            return timeslice;
+        }
+
+        float rotation = 0;
+        private void Animate(double milliseconds)
+        {
+            float deltaRotation = (float)milliseconds / 20.0f;
+            rotation += deltaRotation;
+            glControl1.Invalidate();
+        }
+
+        double accumulator = 0;
+        int idleCounter = 0;
+        private void Accumulate(double milliseconds)
+        {
+            idleCounter++;
+            accumulator += milliseconds;
+            if (accumulator > 1000)
+            {
+                Text = idleCounter.ToString();
+                accumulator -= 1000;
+                idleCounter = 0; // don't forget to reset the counter!
+            }
         }
@@ -35,3 +78,3 @@ namespace Editor
 
-            Renderer.DefaultRender(ref glControl1, x);
+            Renderer.DefaultRender(ref glControl1, x, rotation);
         }
@@ -73,3 +116,3 @@ namespace Editor
 
-        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x)
+        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x, float rotation)
         {
@@ -87,2 +130,4 @@ namespace Editor
 
+            GL.Rotate(rotation, Vector3.UnitZ); // OpenTK has this nice Vector3 class!
+
             GL.Begin(PrimitiveType.Triangles);

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3dc7eb3246bb9d31c62a05d0fd852f6e352fb690">More progress integrating glControl</a>  -  3dc7eb3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 70 insertions(+), 16 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index a044afc..8e3deb4 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -29,4 +29,7 @@ namespace Editor
             glControlLoaded = true;
+
+            Text = Renderer.GetVersionInfo();
             Renderer.Load();
             Renderer.SetupViewport(ref glControl1);
+
             Application.Idle += Application_Idle; // press TAB twice after +=
@@ -67,3 +70,3 @@ namespace Editor
             {
-                Text = idleCounter.ToString();
+                Text = Renderer.GetVersionInfo() + ": " + idleCounter.ToString() + "fps";
                 accumulator -= 1000;
@@ -110,6 +113,9 @@ namespace Editor
             int h = glControl1.Height;
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadIdentity();
-            GL.Ortho(0, w, 0, h, -1, 1); // Bottom-left corner pixel has coordinate (0, 0)
+            
             GL.Viewport(0, 0, w, h); // Use all of the glControl painting area
+
+            float aspect_ratio = w / (float)h;
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
         }
@@ -118,8 +124,5 @@ namespace Editor
         {
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
             GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-
-            GL.Translate(x, 0, 0); // position triangle according to our x variable
+            GL.LoadMatrix(ref lookat);
 
@@ -130,9 +133,7 @@ namespace Editor
 
-            GL.Rotate(rotation, Vector3.UnitZ); // OpenTK has this nice Vector3 class!
+            GL.Rotate(rotation, Vector3.UnitY); // OpenTK has this nice Vector3 class!
 
-            GL.Begin(PrimitiveType.Triangles);
-            GL.Vertex2(10, 20);
-            GL.Vertex2(100, 20);
-            GL.Vertex2(100, 50);
-            GL.End();
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            DrawCube();
 
@@ -140,2 +141,47 @@ namespace Editor
         }
+        
+        private static void DrawCube()
+        {
+            GL.Begin(PrimitiveType.Quads);
+
+            GL.Color3(Color.Silver);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+
+            GL.Color3(Color.Honeydew);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+
+            GL.Color3(Color.Moccasin);
+
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.IndianRed);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+
+            GL.Color3(Color.PaleVioletRed);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.ForestGreen);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+
+            GL.End();
+        }
+
 
@@ -143,3 +189,11 @@ namespace Editor
         {
-            GL.ClearColor(Color.SkyBlue);
+            GL.ClearColor(Color.MidnightBlue);
+            GL.Enable(EnableCap.DepthTest);
+        }
+
+        internal static string GetVersionInfo()
+        {
+            return GL.GetString(StringName.Vendor) + " " +
+                GL.GetString(StringName.Renderer) + " " +
+                GL.GetString(StringName.Version);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/2e29a8926101796d3fec6df1f7638b63db39e418">Anchored glControl so that it resizes correctly when the form does.</a>  -  2e29a89</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 32 insertions(+)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
index b6a5e2e..03b689b 100644
--- a/Editor/FrmEditor.Designer.cs
+++ b/Editor/FrmEditor.Designer.cs
@@ -36,2 +36,5 @@
             // 
+            this.glControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
+            | System.Windows.Forms.AnchorStyles.Left) 
+            | System.Windows.Forms.AnchorStyles.Right)));
             this.glControl1.BackColor = System.Drawing.Color.Black;
diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 8e3deb4..19871bc 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -19,2 +19,3 @@ namespace Editor
         int x = 0;
+        Bitmap TextBitmap;
 
@@ -34,2 +35,4 @@ namespace Editor
 
+            SetupTextDisplayBitmap();
+
             Application.Idle += Application_Idle; // press TAB twice after +=
@@ -38,2 +41,26 @@ namespace Editor
 
+        private void SetupTextDisplayBitmap()
+        {
+            if (TextBitmap != null)
+            {
+                TextBitmap.Dispose();
+                TextBitmap = null;
+            }
+
+            TextBitmap = new Bitmap(glControl1.Width, glControl1.Height);
+        }
+
+        #region OnClosing
+
+        protected override void OnClosing(CancelEventArgs e)
+        {
+            Application.Idle -= Application_Idle;
+
+            base.OnClosing(e);
+        }
+
+        #endregion
+
+        #region Application_Idle event
+
         void Application_Idle(object sender, EventArgs e)
@@ -76,2 +103,4 @@ namespace Editor
 
+        #endregion
+
         private void glControl1_Paint(object sender, PaintEventArgs e)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/15ecfb3ee7c1fba58bba99974306688ed52751f5">Tidying up the code by separating it into regions.</a>  -  15ecfb3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 19871bc..f291977 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -19,3 +19,2 @@ namespace Editor
         int x = 0;
-        Bitmap TextBitmap;
 
@@ -26,2 +25,4 @@ namespace Editor
 
+        #region OnLoad
+
         Stopwatch sw = new Stopwatch();
@@ -41,2 +42,3 @@ namespace Editor
 
+        Bitmap TextBitmap;
         private void SetupTextDisplayBitmap()
@@ -52,2 +54,4 @@ namespace Editor
 
+        #endregion
+
         #region OnClosing
@@ -105,2 +109,4 @@ namespace Editor
 
+        #region glControl1_Events
+
         private void glControl1_Paint(object sender, PaintEventArgs e)
@@ -127,2 +133,3 @@ namespace Editor
 
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/477a4c265c25895b84b533f65f9251000434c246">Got debug text rendering.</a>  -  477a4c2</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 389 insertions(+), 35 deletions(-)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
index 03b689b..f1f8026 100644
--- a/Editor/FrmEditor.Designer.cs
+++ b/Editor/FrmEditor.Designer.cs
@@ -48,2 +48,4 @@
             this.glControl1.KeyDown += new System.Windows.Forms.KeyEventHandler(this.glControl1_KeyDown);
+            this.glControl1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseDown);
+            this.glControl1.MouseMove += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseMove);
             this.glControl1.Resize += new System.EventHandler(this.glControl1_Resize);
diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index f291977..8f7ff33 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -12,2 +12,4 @@ using OpenTK;
 using System.Diagnostics;
+using OpenTK.Input;
+using OpenTK.Graphics;
 
@@ -20,2 +22,22 @@ namespace Editor
 
+        static readonly Font TextFont = new Font(FontFamily.GenericSansSerif, 11);
+        Bitmap TextBitmap;
+        StringBuilder TypedText = new StringBuilder();
+        int texture;
+        bool mouse_in_glControl = false;
+        bool viewport_changed = true;
+
+        // time drift
+        Stopwatch watch = new Stopwatch();
+        double update_time, render_time;
+
+        // timing information
+        double timestamp;
+        int update_count;
+        int update_fps;
+        int render_count;
+        int render_fps;
+
+        #region --- Constructor ---
+
         public Editor()
@@ -25,5 +47,6 @@ namespace Editor
 
+        #endregion
+
         #region OnLoad
 
-        Stopwatch sw = new Stopwatch();
         private void glControl1_Load(object sender, EventArgs e)
@@ -34,3 +57,6 @@ namespace Editor
             Renderer.Load();
-            Renderer.SetupViewport(ref glControl1);
+            //Renderer.SetupViewport(ref glControl1);
+
+            glControl1.MouseEnter += delegate { mouse_in_glControl = true; };
+            glControl1.MouseLeave += delegate { mouse_in_glControl = false; };
 
@@ -38,15 +64,19 @@ namespace Editor
 
+            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcColor);
+
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, TextBitmap.Width, TextBitmap.Height,
+                0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Nearest);
+
             Application.Idle += Application_Idle; // press TAB twice after +=
-            sw.Start();
+            watch.Start();
         }
 
-        Bitmap TextBitmap;
         private void SetupTextDisplayBitmap()
         {
-            if (TextBitmap != null)
-            {
-                TextBitmap.Dispose();
-                TextBitmap = null;
-            }
-
             TextBitmap = new Bitmap(glControl1.Width, glControl1.Height);
@@ -78,6 +108,6 @@ namespace Editor
         {
-            sw.Stop();
-            double timeslice = sw.Elapsed.TotalMilliseconds;
-            sw.Reset();
-            sw.Start();
+            watch.Stop();
+            double timeslice = watch.Elapsed.TotalMilliseconds;
+            watch.Reset();
+            watch.Start();
             return timeslice;
@@ -90,2 +120,5 @@ namespace Editor
             rotation += deltaRotation;
+
+            UpdateTextDisplay();
+
             glControl1.Invalidate();
@@ -109,2 +142,227 @@ namespace Editor
 
+        #region Debug Text Rendering Methods
+
+        private void UpdateTextDisplay()
+        {
+            double clock_time = watch.Elapsed.TotalSeconds;
+            //update_time += e.Time;
+            //timestamp += e.Time;
+            update_count++;
+
+            using (Graphics gfx = Graphics.FromImage(TextBitmap))
+            {
+                int line = 0;
+
+                gfx.Clear(Color.Black);
+                gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
+
+                // OpenGL information
+                DrawString(gfx, GL.GetString(StringName.Renderer), line++);
+                DrawString(gfx, GL.GetString(StringName.Version), line++);
+                DrawString(gfx, glControl1.GraphicsMode.ToString(), line++);
+
+                // GameWindow information
+                line++;
+                DrawString(gfx, "GLControl:", line++);
+
+                DrawString(gfx, String.Format("[V]: VSync.{0}.", glControl1.VSync), line++);
+                DrawString(gfx, String.Format("Bounds: {0}", glControl1.Bounds), line++);
+                DrawString(gfx, String.Format("ClientRectangle: {0}", glControl1.ClientRectangle), line++);
+                DrawString(gfx, String.Format("Mouse {0}: {1}.",
+                    mouse_in_glControl ? "inside" : "outside",
+                    glControl1.Focused ? "Focused" : "Not focused"), line++);
+                DrawString(gfx, String.Format("Mouse coordinates: {0}", new Vector3(
+                    OpenTK.Input.Mouse.GetState().X, 
+                    OpenTK.Input.Mouse.GetState().Y, 
+                    OpenTK.Input.Mouse.GetState().WheelPrecise)), 
+                    line++
+                    );
+
+                #region Timing Information
+                /*
+                line++;
+                DrawString(gfx, "Timing:", line++);
+                DrawString(gfx,
+                    String.Format("Frequency: update {4} ({0:f2}/{1:f2}); render {5} ({2:f2}/{3:f2})",
+                        UpdateFrequency, TargetUpdateFrequency,
+                        RenderFrequency, TargetRenderFrequency,
+                        update_fps, render_fps),
+                    line++);
+                DrawString(gfx,
+                    String.Format("Period: update {4:N4} ({0:f4}/{1:f4}); render {5:N4} ({2:f4}/{3:f4})",
+                        UpdatePeriod, TargetUpdatePeriod,
+                        RenderPeriod, TargetRenderPeriod,
+                        1.0 / update_fps, 1.0 / render_fps),
+                    line++);
+                DrawString(gfx, String.Format("Time: update {0:f4}; render {1:f4}",
+                    UpdateTime, RenderTime), line++);
+                DrawString(gfx, String.Format("Drift: clock {0:f4}; update {1:f4}; render {2:f4}",
+                    clock_time, clock_time - update_time, clock_time - render_time), line++);
+                DrawString(gfx, String.Format("Text: {0}", TypedText.ToString()), line++);
+
+                if (timestamp >= 1)
+                {
+                    timestamp -= 1;
+                    update_fps = update_count;
+                    render_fps = render_count;
+                    update_count = 0;
+                    render_count = 0;
+
+                }
+                 * 
+                 * */
+                #endregion
+
+                // Input information
+                line = DrawKeyboards(gfx, line);
+                line = DrawMice(gfx, line);
+                // line = DrawJoysticks(gfx, line);
+                // line = DrawLegacyJoysticks(gfx, Joysticks, line);
+            }
+
+            /*
+            fixed_update_timestep_pos += TargetUpdatePeriod;
+            variable_update_timestep_pos += e.Time;
+            if (fixed_update_timestep_pos >= 1)
+                fixed_update_timestep_pos -= 2;
+            if (variable_update_timestep_pos >= 1)
+                variable_update_timestep_pos -= 2;
+             * */
+        }
+
+        private float DrawString(Graphics gfx, string str, int line)
+        {
+            return DrawString(gfx, str, line, 0);
+        }
+
+        private float DrawString(Graphics gfx, string str, int line, float offset)
+        {
+            gfx.DrawString(str, TextFont, Brushes.White, new PointF(offset, line * TextFont.Height));
+            return offset + gfx.MeasureString(str, TextFont).Width;
+        }
+
+        private int DrawKeyboards(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "Keyboard:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                var state = OpenTK.Input.Keyboard.GetState(i);
+                if (state.IsConnected)
+                {
+                    StringBuilder sb = new StringBuilder();
+                    sb.Append(i);
+                    sb.Append(": ");
+                    for (int key_index = 0; key_index < (int)Key.LastKey; key_index++)
+                    {
+                        Key k = (Key)key_index;
+                        if (state[k])
+                        {
+                            sb.Append(k);
+                            sb.Append(" ");
+                        }
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+            return line;
+        }
+
+        private int DrawMice(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "Mouse:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                var state = OpenTK.Input.Mouse.GetState(i);
+                if (state.IsConnected)
+                {
+                    StringBuilder sb = new StringBuilder();
+                    Vector3 pos = new Vector3(state.X, state.Y, state.WheelPrecise);
+                    sb.Append(i);
+                    sb.Append(": ");
+                    sb.Append(pos);
+                    for (int button_index = 0; button_index < (int)MouseButton.LastButton; button_index++)
+                    {
+                        MouseButton b = (MouseButton)button_index;
+                        if (state[b])
+                        {
+                            sb.Append(b);
+                            sb.Append(" ");
+                        }
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+            return line;
+        }
+
+        int DrawJoysticks(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "GamePad:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                GamePadCapabilities caps = GamePad.GetCapabilities(i);
+                GamePadState state = GamePad.GetState(i);
+                if (state.IsConnected)
+                {
+                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
+                    DrawString(gfx, state.ToString(), line++);
+                }
+            }
+
+            line++;
+            DrawString(gfx, "Joystick:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                JoystickCapabilities caps = Joystick.GetCapabilities(i);
+                JoystickState state = Joystick.GetState(i);
+                if (state.IsConnected)
+                {
+                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
+                    DrawString(gfx, state.ToString(), line++);
+                }
+            }
+
+            return line;
+        }
+
+        private int DrawLegacyJoysticks(Graphics gfx, IList<JoystickDevice> joysticks, int line)
+        {
+            line++;
+            DrawString(gfx, "Legacy Joystick:", line++);
+
+            int joy_index = -1;
+            foreach (var joy in joysticks)
+            {
+                joy_index++;
+                if (!String.IsNullOrEmpty(joy.Description))
+                {
+                    StringBuilder sb = new StringBuilder();
+                    sb.Append(joy_index);
+                    sb.Append(": '");
+                    sb.Append(joy.Description);
+                    sb.Append("' ");
+
+                    for (int i = 0; i < joy.Axis.Count; i++)
+                    {
+                        sb.Append(joy.Axis[i]);
+                        sb.Append(" ");
+                    }
+
+                    for (int i = 0; i < joy.Button.Count; i++)
+                    {
+                        sb.Append(joy.Button[i]);
+                        sb.Append(" ");
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+
+            return line;
+        }
+
+        #endregion
+
         #region glControl1_Events
@@ -115,4 +373,9 @@ namespace Editor
                 return;
+            if (viewport_changed)
+            {
+                viewport_changed = false;
+                GL.Viewport(0, 0, glControl1.Width, glControl1.Height);
+            }
 
-            Renderer.DefaultRender(ref glControl1, x, rotation);
+            Renderer.DefaultRender(ref glControl1, x, rotation, TextBitmap, ref viewport_changed);
         }
@@ -130,3 +393,16 @@ namespace Editor
         {
-            Renderer.Resize(ref glControl1);
+            OpenTK.GLControl c = sender as OpenTK.GLControl;
+
+            viewport_changed = true;
+            //Renderer.Resize(ref glControl1);
+        }
+
+        private void glControl1_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
+        {
+
+        }
+
+        private void glControl1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
+        {
+
         }
@@ -141,3 +417,3 @@ namespace Editor
         {
-            SetupViewport(ref glControl1);
+            //SetupViewport(ref glControl1);
             glControl1.Invalidate();
@@ -152,24 +428,30 @@ namespace Editor
 
-            float aspect_ratio = w / (float)h;
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
+            //float aspect_ratio = w / (float)h;
+            //Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perpective);
         }
 
-        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x, float rotation)
+        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x, float rotation, Bitmap TextBitmap, ref bool viewport_changed)
         {
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
+            TextBitmap.Save("RendererTextBitmap.bmp");
+            //if (glControl1.Focused) // Simple enough :)
+                //GL.Color3(Color.Yellow);
+            //else
+                //GL.Color3(Color.Blue);
 
-            if (glControl1.Focused) // Simple enough :)
-                GL.Color3(Color.Yellow);
-            else
-                GL.Color3(Color.Blue);
+            // GL.Rotate(rotation, Vector3.UnitY); // OpenTK has this nice Vector3 class!
 
-            GL.Rotate(rotation, Vector3.UnitY); // OpenTK has this nice Vector3 class!
+            GL.Clear(ClearBufferMask.ColorBufferBit);
 
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+            if (viewport_changed)
+            {
+                viewport_changed = false;
+                GL.Viewport(0, 0, glControl1.Width, glControl1.Height);
+            }
+
+            DrawText(ref glControl1, TextBitmap);
 
-            DrawCube();
+            DrawMovingObjects();
+            //DrawCube(glControl1.Width / (float) glControl1.Height);
 
@@ -177,5 +459,76 @@ namespace Editor
         }
+
+        // Uploads our text Bitmap to an OpenGL texture
+        // and displays is to screen.
+        private static void DrawText(ref OpenTK.GLControl glControl1, Bitmap TextBitmap)
+        {
+            System.Drawing.Imaging.BitmapData data = TextBitmap.LockBits(
+                new System.Drawing.Rectangle(0, 0, TextBitmap.Width, TextBitmap.Height),
+                System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, TextBitmap.Width, TextBitmap.Height, PixelFormat.Bgra,
+                PixelType.UnsignedByte, data.Scan0);
+            TextBitmap.UnlockBits(data);
+
+            Matrix4 text_projection = Matrix4.CreateOrthographicOffCenter(0, glControl1.Width, glControl1.Height, 0, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref text_projection);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+
+            GL.Color4(Color4.White);
+            GL.Enable(EnableCap.Texture2D);
+            GL.Begin(PrimitiveType.Quads);
+            GL.TexCoord2(0, 0); GL.Vertex2(0, 0);
+            GL.TexCoord2(1, 0); GL.Vertex2(TextBitmap.Width, 0);
+            GL.TexCoord2(1, 1); GL.Vertex2(TextBitmap.Width, TextBitmap.Height);
+            GL.TexCoord2(0, 1); GL.Vertex2(0, TextBitmap.Height);
+            GL.End();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        private static void DrawMovingObjects()
+        {
+            Matrix4 thing_projection = Matrix4.CreateOrthographic(2, 2, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref thing_projection);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.2, 0);
+            GL.Color4(Color4.Red);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.4, 0);
+            GL.Color4(Color4.DarkGoldenrod);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.8, 0);
+            GL.Color4(Color4.DarkGreen);
+            DrawRectangle();
+        }
+
+        private static void DrawRectangle()
+        {
+            GL.Begin(PrimitiveType.Quads);
+            GL.Vertex2(-0.05, -0.05);
+            GL.Vertex2(+0.05, -0.05);
+            GL.Vertex2(+0.05, +0.05);
+            GL.Vertex2(-0.05, +0.05);
+            GL.End();
+        }
         
-        private static void DrawCube()
+        private static void DrawCube(float aspect_ratio)
         {
+            //Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            //GL.MatrixMode(MatrixMode.Projection);
+            //GL.LoadMatrix(ref perpective);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
             GL.Begin(PrimitiveType.Quads);
@@ -222,3 +575,2 @@ namespace Editor
 
-
         internal static void Load()
@@ -226,3 +578,3 @@ namespace Editor
             GL.ClearColor(Color.MidnightBlue);
-            GL.Enable(EnableCap.DepthTest);
+            //GL.Enable(EnableCap.DepthTest);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a613397fd6d220b39f2c5b2c60f7d957a100abd4">More more on the editor.</a>  -  a613397</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 16 insertions(+), 24 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 8f7ff33..0c391ce 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -393,6 +393,3 @@ namespace Editor
         {
-            OpenTK.GLControl c = sender as OpenTK.GLControl;
-
-            viewport_changed = true;
-            //Renderer.Resize(ref glControl1);
+            Renderer.Resize(ref glControl1, ref viewport_changed);
         }
@@ -410,2 +407,3 @@ namespace Editor
         #endregion
+
     }
@@ -415,5 +413,5 @@ namespace Editor
 
-        internal static void Resize(ref OpenTK.GLControl glControl1)
+        internal static void Resize(ref OpenTK.GLControl glControl1, ref bool viewport_changed)
         {
-            //SetupViewport(ref glControl1);
+            viewport_changed = true;
             glControl1.Invalidate();
@@ -427,7 +425,2 @@ namespace Editor
             GL.Viewport(0, 0, w, h); // Use all of the glControl painting area
-
-            //float aspect_ratio = w / (float)h;
-            //Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perpective);
         }
@@ -436,9 +429,2 @@ namespace Editor
         {
-            TextBitmap.Save("RendererTextBitmap.bmp");
-            //if (glControl1.Focused) // Simple enough :)
-                //GL.Color3(Color.Yellow);
-            //else
-                //GL.Color3(Color.Blue);
-
-            // GL.Rotate(rotation, Vector3.UnitY); // OpenTK has this nice Vector3 class!
 
@@ -449,3 +435,3 @@ namespace Editor
                 viewport_changed = false;
-                GL.Viewport(0, 0, glControl1.Width, glControl1.Height);
+                SetupViewport(ref glControl1);
             }
@@ -454,4 +440,6 @@ namespace Editor
 
-            DrawMovingObjects();
-            //DrawCube(glControl1.Width / (float) glControl1.Height);
+            GL.Clear(ClearBufferMask.DepthBufferBit);
+
+            //DrawMovingObjects();
+            DrawCube(glControl1.Width / (float) glControl1.Height);
 
@@ -525,5 +513,7 @@ namespace Editor
         {
-            //Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            //GL.MatrixMode(MatrixMode.Projection);
-            //GL.LoadMatrix(ref perpective);
+            GL.Enable(EnableCap.DepthTest);
+
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
 
@@ -573,2 +563,4 @@ namespace Editor
             GL.End();
+
+            GL.Disable(EnableCap.DepthTest);
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b1945f3a2612090ca253b830e3ab4979d913de17">~</a>  -  b1945f3</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 258 insertions(+), 245 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 0c391ce..4076008 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -22,11 +22,4 @@ namespace Editor
 
-        static readonly Font TextFont = new Font(FontFamily.GenericSansSerif, 11);
-        Bitmap TextBitmap;
-        StringBuilder TypedText = new StringBuilder();
-        int texture;
-        bool mouse_in_glControl = false;
-        bool viewport_changed = true;
-
         // time drift
-        Stopwatch watch = new Stopwatch();
+        public static Stopwatch watch = new Stopwatch();
         double update_time, render_time;
@@ -56,2 +49,3 @@ namespace Editor
             Text = Renderer.GetVersionInfo();
+            
             Renderer.Load();
@@ -59,17 +53,4 @@ namespace Editor
 
-            glControl1.MouseEnter += delegate { mouse_in_glControl = true; };
-            glControl1.MouseLeave += delegate { mouse_in_glControl = false; };
-
-            SetupTextDisplayBitmap();
-
-            GL.Enable(EnableCap.Texture2D);
-            GL.Enable(EnableCap.Blend);
-            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcColor);
-
-            texture = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, TextBitmap.Width, TextBitmap.Height,
-                0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Nearest);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Nearest);
+            glControl1.MouseEnter += delegate { Renderer.mouse_in_glControl = true; };
+            glControl1.MouseLeave += delegate { Renderer.mouse_in_glControl = false; };
 
@@ -79,7 +60,2 @@ namespace Editor
 
-        private void SetupTextDisplayBitmap()
-        {
-            TextBitmap = new Bitmap(glControl1.Width, glControl1.Height);
-        }
-
         #endregion
@@ -121,3 +97,3 @@ namespace Editor
 
-            UpdateTextDisplay();
+            Renderer.UpdateTextDisplay(ref watch);
 
@@ -142,5 +118,231 @@ namespace Editor
 
+        #region glControl1_Events
+
+        private void glControl1_Paint(object sender, PaintEventArgs e)
+        {
+            if (!glControlLoaded) // Play nice
+                return;
+
+            Renderer.DefaultRender(x, rotation);
+        }
+
+        private void glControl1_KeyDown(object sender, KeyEventArgs e)
+        {
+            if (e.KeyCode == Keys.Space)
+            {
+                x++;
+                glControl1.Invalidate();
+            }
+        }
+
+        private void glControl1_Resize(object sender, EventArgs e)
+        {
+            Renderer.Resize(ref glControl1);
+        }
+
+        private void glControl1_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
+        {
+
+        }
+
+        private void glControl1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
+        {
+
+        }
+
+        #endregion
+
+    }
+
+    static class Renderer
+    {
+        internal static int texture;
+        internal static readonly Font TextFont = new Font(FontFamily.GenericSansSerif, 11);
+        internal static Bitmap TextBitmap;
+        internal static StringBuilder TypedText = new StringBuilder();
+        internal static int viewportWidth = 0;
+        internal static int viewportHeight = 0;
+        internal static OpenTK.GLControl renderView;
+        internal static bool mouse_in_glControl = false;
+        internal static bool viewport_changed = true;
+
+        internal static void Resize(ref OpenTK.GLControl glControl1)
+        {
+            viewport_changed = true;
+
+            renderView = glControl1;
+            viewportWidth = renderView.Width;
+            viewportHeight = renderView.Height;
+
+            renderView.Invalidate();
+        }
+
+        internal static void SetupViewport()
+        {
+            GL.Viewport(0, 0, viewportWidth, viewportHeight); // Use all of the glControl painting area
+        }
+
+        internal static void DefaultRender(int x, float rotation)
+        {
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            if (viewport_changed)
+            {
+                viewport_changed = false;
+                SetupViewport();
+            }
+
+            DrawText();
+
+            DrawCube(viewportWidth / (float)viewportHeight, rotation);
+
+            renderView.SwapBuffers();
+        }
+
+        // Uploads our text Bitmap to an OpenGL texture
+        // and displays is to screen.
+        private static void DrawText()
+        {
+            System.Drawing.Imaging.BitmapData data = TextBitmap.LockBits(
+                new System.Drawing.Rectangle(0, 0, TextBitmap.Width, TextBitmap.Height),
+                System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, TextBitmap.Width, TextBitmap.Height, PixelFormat.Bgra,
+                PixelType.UnsignedByte, data.Scan0);
+            TextBitmap.UnlockBits(data);
+
+            Matrix4 text_projection = Matrix4.CreateOrthographicOffCenter(0, viewportWidth, viewportHeight, 0, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref text_projection);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+
+            GL.Color4(Color4.White);
+            GL.Enable(EnableCap.Texture2D);
+            GL.Begin(PrimitiveType.Quads);
+            GL.TexCoord2(0, 0); GL.Vertex2(0, 0);
+            GL.TexCoord2(1, 0); GL.Vertex2(TextBitmap.Width, 0);
+            GL.TexCoord2(1, 1); GL.Vertex2(TextBitmap.Width, TextBitmap.Height);
+            GL.TexCoord2(0, 1); GL.Vertex2(0, TextBitmap.Height);
+            GL.End();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        private static void DrawMovingObjects()
+        {
+            Matrix4 thing_projection = Matrix4.CreateOrthographic(2, 2, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref thing_projection);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.2, 0);
+            GL.Color4(Color4.Red);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.4, 0);
+            GL.Color4(Color4.DarkGoldenrod);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.8, 0);
+            GL.Color4(Color4.DarkGreen);
+            DrawRectangle();
+        }
+
+        private static void DrawRectangle()
+        {
+            GL.Begin(PrimitiveType.Quads);
+            GL.Vertex2(-0.05, -0.05);
+            GL.Vertex2(+0.05, -0.05);
+            GL.Vertex2(+0.05, +0.05);
+            GL.Vertex2(-0.05, +0.05);
+            GL.End();
+        }
+        
+        private static void DrawCube(float aspect_ratio, float rotation)
+        {
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(rotation, Vector3.UnitY);
+
+            GL.Begin(PrimitiveType.Quads);
+
+            GL.Color3(Color.Silver);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+
+            GL.Color3(Color.Honeydew);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+
+            GL.Color3(Color.Moccasin);
+
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.IndianRed);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+
+            GL.Color3(Color.PaleVioletRed);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.ForestGreen);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+
+            GL.End();
+            
+            GL.Disable(EnableCap.DepthTest);
+        }
+
+        internal static void Load()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+            LoadDebugDisplay();    
+        }
+
+        private static void LoadDebugDisplay()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcColor);
+
+            TextBitmap = new Bitmap(viewportWidth, viewportHeight);
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, TextBitmap.Width, TextBitmap.Height,
+                0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Nearest);
+        }
+
         #region Debug Text Rendering Methods
 
-        private void UpdateTextDisplay()
+        internal static void UpdateTextDisplay(ref Stopwatch watch)
         {
@@ -149,3 +351,3 @@ namespace Editor
             //timestamp += e.Time;
-            update_count++;
+            //update_count++;
 
@@ -159,5 +361,5 @@ namespace Editor
                 // OpenGL information
-                DrawString(gfx, GL.GetString(StringName.Renderer), line++);
-                DrawString(gfx, GL.GetString(StringName.Version), line++);
-                DrawString(gfx, glControl1.GraphicsMode.ToString(), line++);
+                DrawString(gfx, Renderer.GetVendor(), line++);
+                DrawString(gfx, Renderer.GetVerion(), line++);
+                DrawString(gfx, renderView.GraphicsMode.ToString(), line++);
 
@@ -167,12 +369,12 @@ namespace Editor
 
-                DrawString(gfx, String.Format("[V]: VSync.{0}.", glControl1.VSync), line++);
-                DrawString(gfx, String.Format("Bounds: {0}", glControl1.Bounds), line++);
-                DrawString(gfx, String.Format("ClientRectangle: {0}", glControl1.ClientRectangle), line++);
+                DrawString(gfx, String.Format("[V]: VSync.{0}.", renderView.VSync), line++);
+                DrawString(gfx, String.Format("Bounds: {0}", renderView.Bounds), line++);
+                DrawString(gfx, String.Format("ClientRectangle: {0}", renderView.ClientRectangle), line++);
                 DrawString(gfx, String.Format("Mouse {0}: {1}.",
                     mouse_in_glControl ? "inside" : "outside",
-                    glControl1.Focused ? "Focused" : "Not focused"), line++);
+                    renderView.Focused ? "Focused" : "Not focused"), line++);
                 DrawString(gfx, String.Format("Mouse coordinates: {0}", new Vector3(
-                    OpenTK.Input.Mouse.GetState().X, 
-                    OpenTK.Input.Mouse.GetState().Y, 
-                    OpenTK.Input.Mouse.GetState().WheelPrecise)), 
+                    OpenTK.Input.Mouse.GetState().X,
+                    OpenTK.Input.Mouse.GetState().Y,
+                    OpenTK.Input.Mouse.GetState().WheelPrecise)),
                     line++
@@ -232,3 +434,3 @@ namespace Editor
 
-        private float DrawString(Graphics gfx, string str, int line)
+        private static float DrawString(Graphics gfx, string str, int line)
         {
@@ -237,3 +439,3 @@ namespace Editor
 
-        private float DrawString(Graphics gfx, string str, int line, float offset)
+        private static float DrawString(Graphics gfx, string str, int line, float offset)
         {
@@ -243,3 +445,3 @@ namespace Editor
 
-        private int DrawKeyboards(Graphics gfx, int line)
+        private static int DrawKeyboards(Graphics gfx, int line)
         {
@@ -270,3 +472,3 @@ namespace Editor
 
-        private int DrawMice(Graphics gfx, int line)
+        private static int DrawMice(Graphics gfx, int line)
         {
@@ -299,3 +501,3 @@ namespace Editor
 
-        int DrawJoysticks(Graphics gfx, int line)
+        private static int DrawJoysticks(Graphics gfx, int line)
         {
@@ -330,3 +532,3 @@ namespace Editor
 
-        private int DrawLegacyJoysticks(Graphics gfx, IList<JoystickDevice> joysticks, int line)
+        private static int DrawLegacyJoysticks(Graphics gfx, IList<JoystickDevice> joysticks, int line)
         {
@@ -367,39 +569,22 @@ namespace Editor
 
-        #region glControl1_Events
+        #region Version Info
 
-        private void glControl1_Paint(object sender, PaintEventArgs e)
-        {
-            if (!glControlLoaded) // Play nice
-                return;
-            if (viewport_changed)
-            {
-                viewport_changed = false;
-                GL.Viewport(0, 0, glControl1.Width, glControl1.Height);
-            }
-
-            Renderer.DefaultRender(ref glControl1, x, rotation, TextBitmap, ref viewport_changed);
-        }
-
-        private void glControl1_KeyDown(object sender, KeyEventArgs e)
+        internal static string GetVersionInfo()
         {
-            if (e.KeyCode == Keys.Space)
-            {
-                x++;
-                glControl1.Invalidate();
-            }
+            return GetVendor() + " " + GetRenderer() + " " + GetVerion();
         }
 
-        private void glControl1_Resize(object sender, EventArgs e)
+        internal static string GetVendor()
         {
-            Renderer.Resize(ref glControl1, ref viewport_changed);
+            return GL.GetString(StringName.Vendor);
         }
 
-        private void glControl1_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
+        internal static string GetRenderer()
         {
-
+            return GL.GetString(StringName.Renderer);
         }
 
-        private void glControl1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
+        internal static string GetVerion()
         {
-
+            return GL.GetString(StringName.Version);
         }
@@ -407,174 +592,2 @@ namespace Editor
         #endregion
-
-    }
-
-    static class Renderer
-    {
-
-        internal static void Resize(ref OpenTK.GLControl glControl1, ref bool viewport_changed)
-        {
-            viewport_changed = true;
-            glControl1.Invalidate();
-        }
-
-        internal static void SetupViewport(ref OpenTK.GLControl glControl1)
-        {
-            int w = glControl1.Width;
-            int h = glControl1.Height;
-            
-            GL.Viewport(0, 0, w, h); // Use all of the glControl painting area
-        }
-
-        internal static void DefaultRender(ref OpenTK.GLControl glControl1, int x, float rotation, Bitmap TextBitmap, ref bool viewport_changed)
-        {
-
-            GL.Clear(ClearBufferMask.ColorBufferBit);
-
-            if (viewport_changed)
-            {
-                viewport_changed = false;
-                SetupViewport(ref glControl1);
-            }
-
-            DrawText(ref glControl1, TextBitmap);
-
-            GL.Clear(ClearBufferMask.DepthBufferBit);
-
-            //DrawMovingObjects();
-            DrawCube(glControl1.Width / (float) glControl1.Height);
-
-            glControl1.SwapBuffers();
-        }
-
-        // Uploads our text Bitmap to an OpenGL texture
-        // and displays is to screen.
-        private static void DrawText(ref OpenTK.GLControl glControl1, Bitmap TextBitmap)
-        {
-            System.Drawing.Imaging.BitmapData data = TextBitmap.LockBits(
-                new System.Drawing.Rectangle(0, 0, TextBitmap.Width, TextBitmap.Height),
-                System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, TextBitmap.Width, TextBitmap.Height, PixelFormat.Bgra,
-                PixelType.UnsignedByte, data.Scan0);
-            TextBitmap.UnlockBits(data);
-
-            Matrix4 text_projection = Matrix4.CreateOrthographicOffCenter(0, glControl1.Width, glControl1.Height, 0, -1, 1);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref text_projection);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-
-            GL.Color4(Color4.White);
-            GL.Enable(EnableCap.Texture2D);
-            GL.Begin(PrimitiveType.Quads);
-            GL.TexCoord2(0, 0); GL.Vertex2(0, 0);
-            GL.TexCoord2(1, 0); GL.Vertex2(TextBitmap.Width, 0);
-            GL.TexCoord2(1, 1); GL.Vertex2(TextBitmap.Width, TextBitmap.Height);
-            GL.TexCoord2(0, 1); GL.Vertex2(0, TextBitmap.Height);
-            GL.End();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        private static void DrawMovingObjects()
-        {
-            Matrix4 thing_projection = Matrix4.CreateOrthographic(2, 2, -1, 1);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref thing_projection);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.2, 0);
-            GL.Color4(Color4.Red);
-            DrawRectangle();
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.4, 0);
-            GL.Color4(Color4.DarkGoldenrod);
-            DrawRectangle();
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.8, 0);
-            GL.Color4(Color4.DarkGreen);
-            DrawRectangle();
-        }
-
-        private static void DrawRectangle()
-        {
-            GL.Begin(PrimitiveType.Quads);
-            GL.Vertex2(-0.05, -0.05);
-            GL.Vertex2(+0.05, -0.05);
-            GL.Vertex2(+0.05, +0.05);
-            GL.Vertex2(-0.05, +0.05);
-            GL.End();
-        }
-        
-        private static void DrawCube(float aspect_ratio)
-        {
-            GL.Enable(EnableCap.DepthTest);
-
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            GL.Begin(PrimitiveType.Quads);
-
-            GL.Color3(Color.Silver);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-
-            GL.Color3(Color.Honeydew);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-
-            GL.Color3(Color.Moccasin);
-
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.IndianRed);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-
-            GL.Color3(Color.PaleVioletRed);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.ForestGreen);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-
-            GL.End();
-
-            GL.Disable(EnableCap.DepthTest);
-        }
-
-        internal static void Load()
-        {
-            GL.ClearColor(Color.MidnightBlue);
-            //GL.Enable(EnableCap.DepthTest);
-        }
-
-        internal static string GetVersionInfo()
-        {
-            return GL.GetString(StringName.Vendor) + " " +
-                GL.GetString(StringName.Renderer) + " " +
-                GL.GetString(StringName.Version);
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cafa614b88ef008a76d3d7de3c4407c697250ec3">Separated Renderer.cs.</a>  -  cafa614</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 451 insertions(+), 449 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 4076008..18ae546 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -1,15 +1,5 @@
 ﻿using System;
-using System.Collections.Generic;
 using System.ComponentModel;
-using System.Data;
-using System.Drawing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Windows.Forms;
-using OpenTK.Graphics.OpenGL;
-using OpenTK;
 using System.Diagnostics;
-using OpenTK.Input;
-using OpenTK.Graphics;
+using System.Windows.Forms;
 
@@ -155,440 +145,2 @@ namespace Editor
     }
-
-    static class Renderer
-    {
-        internal static int texture;
-        internal static readonly Font TextFont = new Font(FontFamily.GenericSansSerif, 11);
-        internal static Bitmap TextBitmap;
-        internal static StringBuilder TypedText = new StringBuilder();
-        internal static int viewportWidth = 0;
-        internal static int viewportHeight = 0;
-        internal static OpenTK.GLControl renderView;
-        internal static bool mouse_in_glControl = false;
-        internal static bool viewport_changed = true;
-
-        internal static void Resize(ref OpenTK.GLControl glControl1)
-        {
-            viewport_changed = true;
-
-            renderView = glControl1;
-            viewportWidth = renderView.Width;
-            viewportHeight = renderView.Height;
-
-            renderView.Invalidate();
-        }
-
-        internal static void SetupViewport()
-        {
-            GL.Viewport(0, 0, viewportWidth, viewportHeight); // Use all of the glControl painting area
-        }
-
-        internal static void DefaultRender(int x, float rotation)
-        {
-
-            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
-
-            if (viewport_changed)
-            {
-                viewport_changed = false;
-                SetupViewport();
-            }
-
-            DrawText();
-
-            DrawCube(viewportWidth / (float)viewportHeight, rotation);
-
-            renderView.SwapBuffers();
-        }
-
-        // Uploads our text Bitmap to an OpenGL texture
-        // and displays is to screen.
-        private static void DrawText()
-        {
-            System.Drawing.Imaging.BitmapData data = TextBitmap.LockBits(
-                new System.Drawing.Rectangle(0, 0, TextBitmap.Width, TextBitmap.Height),
-                System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
-            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, TextBitmap.Width, TextBitmap.Height, PixelFormat.Bgra,
-                PixelType.UnsignedByte, data.Scan0);
-            TextBitmap.UnlockBits(data);
-
-            Matrix4 text_projection = Matrix4.CreateOrthographicOffCenter(0, viewportWidth, viewportHeight, 0, -1, 1);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref text_projection);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-
-            GL.Color4(Color4.White);
-            GL.Enable(EnableCap.Texture2D);
-            GL.Begin(PrimitiveType.Quads);
-            GL.TexCoord2(0, 0); GL.Vertex2(0, 0);
-            GL.TexCoord2(1, 0); GL.Vertex2(TextBitmap.Width, 0);
-            GL.TexCoord2(1, 1); GL.Vertex2(TextBitmap.Width, TextBitmap.Height);
-            GL.TexCoord2(0, 1); GL.Vertex2(0, TextBitmap.Height);
-            GL.End();
-            GL.Disable(EnableCap.Texture2D);
-        }
-
-        private static void DrawMovingObjects()
-        {
-            Matrix4 thing_projection = Matrix4.CreateOrthographic(2, 2, -1, 1);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref thing_projection);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.2, 0);
-            GL.Color4(Color4.Red);
-            DrawRectangle();
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.4, 0);
-            GL.Color4(Color4.DarkGoldenrod);
-            DrawRectangle();
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadIdentity();
-            GL.Translate(0, -0.8, 0);
-            GL.Color4(Color4.DarkGreen);
-            DrawRectangle();
-        }
-
-        private static void DrawRectangle()
-        {
-            GL.Begin(PrimitiveType.Quads);
-            GL.Vertex2(-0.05, -0.05);
-            GL.Vertex2(+0.05, -0.05);
-            GL.Vertex2(+0.05, +0.05);
-            GL.Vertex2(-0.05, +0.05);
-            GL.End();
-        }
-        
-        private static void DrawCube(float aspect_ratio, float rotation)
-        {
-            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
-            GL.MatrixMode(MatrixMode.Projection);
-            GL.LoadMatrix(ref perpective);
-
-            GL.Enable(EnableCap.DepthTest);
-
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.MatrixMode(MatrixMode.Modelview);
-            GL.LoadMatrix(ref lookat);
-
-            GL.Rotate(rotation, Vector3.UnitY);
-
-            GL.Begin(PrimitiveType.Quads);
-
-            GL.Color3(Color.Silver);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-
-            GL.Color3(Color.Honeydew);
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-
-            GL.Color3(Color.Moccasin);
-
-            GL.Vertex3(-1.0f, -1.0f, -1.0f);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.IndianRed);
-            GL.Vertex3(-1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-
-            GL.Color3(Color.PaleVioletRed);
-            GL.Vertex3(-1.0f, 1.0f, -1.0f);
-            GL.Vertex3(-1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-
-            GL.Color3(Color.ForestGreen);
-            GL.Vertex3(1.0f, -1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, -1.0f);
-            GL.Vertex3(1.0f, 1.0f, 1.0f);
-            GL.Vertex3(1.0f, -1.0f, 1.0f);
-
-            GL.End();
-            
-            GL.Disable(EnableCap.DepthTest);
-        }
-
-        internal static void Load()
-        {
-            GL.ClearColor(Color.MidnightBlue);
-            LoadDebugDisplay();    
-        }
-
-        private static void LoadDebugDisplay()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            GL.Enable(EnableCap.Blend);
-            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcColor);
-
-            TextBitmap = new Bitmap(viewportWidth, viewportHeight);
-            texture = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, texture);
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, TextBitmap.Width, TextBitmap.Height,
-                0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Nearest);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Nearest);
-        }
-
-        #region Debug Text Rendering Methods
-
-        internal static void UpdateTextDisplay(ref Stopwatch watch)
-        {
-            double clock_time = watch.Elapsed.TotalSeconds;
-            //update_time += e.Time;
-            //timestamp += e.Time;
-            //update_count++;
-
-            using (Graphics gfx = Graphics.FromImage(TextBitmap))
-            {
-                int line = 0;
-
-                gfx.Clear(Color.Black);
-                gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
-
-                // OpenGL information
-                DrawString(gfx, Renderer.GetVendor(), line++);
-                DrawString(gfx, Renderer.GetVerion(), line++);
-                DrawString(gfx, renderView.GraphicsMode.ToString(), line++);
-
-                // GameWindow information
-                line++;
-                DrawString(gfx, "GLControl:", line++);
-
-                DrawString(gfx, String.Format("[V]: VSync.{0}.", renderView.VSync), line++);
-                DrawString(gfx, String.Format("Bounds: {0}", renderView.Bounds), line++);
-                DrawString(gfx, String.Format("ClientRectangle: {0}", renderView.ClientRectangle), line++);
-                DrawString(gfx, String.Format("Mouse {0}: {1}.",
-                    mouse_in_glControl ? "inside" : "outside",
-                    renderView.Focused ? "Focused" : "Not focused"), line++);
-                DrawString(gfx, String.Format("Mouse coordinates: {0}", new Vector3(
-                    OpenTK.Input.Mouse.GetState().X,
-                    OpenTK.Input.Mouse.GetState().Y,
-                    OpenTK.Input.Mouse.GetState().WheelPrecise)),
-                    line++
-                    );
-
-                #region Timing Information
-                /*
-                line++;
-                DrawString(gfx, "Timing:", line++);
-                DrawString(gfx,
-                    String.Format("Frequency: update {4} ({0:f2}/{1:f2}); render {5} ({2:f2}/{3:f2})",
-                        UpdateFrequency, TargetUpdateFrequency,
-                        RenderFrequency, TargetRenderFrequency,
-                        update_fps, render_fps),
-                    line++);
-                DrawString(gfx,
-                    String.Format("Period: update {4:N4} ({0:f4}/{1:f4}); render {5:N4} ({2:f4}/{3:f4})",
-                        UpdatePeriod, TargetUpdatePeriod,
-                        RenderPeriod, TargetRenderPeriod,
-                        1.0 / update_fps, 1.0 / render_fps),
-                    line++);
-                DrawString(gfx, String.Format("Time: update {0:f4}; render {1:f4}",
-                    UpdateTime, RenderTime), line++);
-                DrawString(gfx, String.Format("Drift: clock {0:f4}; update {1:f4}; render {2:f4}",
-                    clock_time, clock_time - update_time, clock_time - render_time), line++);
-                DrawString(gfx, String.Format("Text: {0}", TypedText.ToString()), line++);
-
-                if (timestamp >= 1)
-                {
-                    timestamp -= 1;
-                    update_fps = update_count;
-                    render_fps = render_count;
-                    update_count = 0;
-                    render_count = 0;
-
-                }
-                 * 
-                 * */
-                #endregion
-
-                // Input information
-                line = DrawKeyboards(gfx, line);
-                line = DrawMice(gfx, line);
-                // line = DrawJoysticks(gfx, line);
-                // line = DrawLegacyJoysticks(gfx, Joysticks, line);
-            }
-
-            /*
-            fixed_update_timestep_pos += TargetUpdatePeriod;
-            variable_update_timestep_pos += e.Time;
-            if (fixed_update_timestep_pos >= 1)
-                fixed_update_timestep_pos -= 2;
-            if (variable_update_timestep_pos >= 1)
-                variable_update_timestep_pos -= 2;
-             * */
-        }
-
-        private static float DrawString(Graphics gfx, string str, int line)
-        {
-            return DrawString(gfx, str, line, 0);
-        }
-
-        private static float DrawString(Graphics gfx, string str, int line, float offset)
-        {
-            gfx.DrawString(str, TextFont, Brushes.White, new PointF(offset, line * TextFont.Height));
-            return offset + gfx.MeasureString(str, TextFont).Width;
-        }
-
-        private static int DrawKeyboards(Graphics gfx, int line)
-        {
-            line++;
-            DrawString(gfx, "Keyboard:", line++);
-            for (int i = 0; i < 4; i++)
-            {
-                var state = OpenTK.Input.Keyboard.GetState(i);
-                if (state.IsConnected)
-                {
-                    StringBuilder sb = new StringBuilder();
-                    sb.Append(i);
-                    sb.Append(": ");
-                    for (int key_index = 0; key_index < (int)Key.LastKey; key_index++)
-                    {
-                        Key k = (Key)key_index;
-                        if (state[k])
-                        {
-                            sb.Append(k);
-                            sb.Append(" ");
-                        }
-                    }
-                    DrawString(gfx, sb.ToString(), line++);
-                }
-            }
-            return line;
-        }
-
-        private static int DrawMice(Graphics gfx, int line)
-        {
-            line++;
-            DrawString(gfx, "Mouse:", line++);
-            for (int i = 0; i < 4; i++)
-            {
-                var state = OpenTK.Input.Mouse.GetState(i);
-                if (state.IsConnected)
-                {
-                    StringBuilder sb = new StringBuilder();
-                    Vector3 pos = new Vector3(state.X, state.Y, state.WheelPrecise);
-                    sb.Append(i);
-                    sb.Append(": ");
-                    sb.Append(pos);
-                    for (int button_index = 0; button_index < (int)MouseButton.LastButton; button_index++)
-                    {
-                        MouseButton b = (MouseButton)button_index;
-                        if (state[b])
-                        {
-                            sb.Append(b);
-                            sb.Append(" ");
-                        }
-                    }
-                    DrawString(gfx, sb.ToString(), line++);
-                }
-            }
-            return line;
-        }
-
-        private static int DrawJoysticks(Graphics gfx, int line)
-        {
-            line++;
-            DrawString(gfx, "GamePad:", line++);
-            for (int i = 0; i < 4; i++)
-            {
-                GamePadCapabilities caps = GamePad.GetCapabilities(i);
-                GamePadState state = GamePad.GetState(i);
-                if (state.IsConnected)
-                {
-                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
-                    DrawString(gfx, state.ToString(), line++);
-                }
-            }
-
-            line++;
-            DrawString(gfx, "Joystick:", line++);
-            for (int i = 0; i < 4; i++)
-            {
-                JoystickCapabilities caps = Joystick.GetCapabilities(i);
-                JoystickState state = Joystick.GetState(i);
-                if (state.IsConnected)
-                {
-                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
-                    DrawString(gfx, state.ToString(), line++);
-                }
-            }
-
-            return line;
-        }
-
-        private static int DrawLegacyJoysticks(Graphics gfx, IList<JoystickDevice> joysticks, int line)
-        {
-            line++;
-            DrawString(gfx, "Legacy Joystick:", line++);
-
-            int joy_index = -1;
-            foreach (var joy in joysticks)
-            {
-                joy_index++;
-                if (!String.IsNullOrEmpty(joy.Description))
-                {
-                    StringBuilder sb = new StringBuilder();
-                    sb.Append(joy_index);
-                    sb.Append(": '");
-                    sb.Append(joy.Description);
-                    sb.Append("' ");
-
-                    for (int i = 0; i < joy.Axis.Count; i++)
-                    {
-                        sb.Append(joy.Axis[i]);
-                        sb.Append(" ");
-                    }
-
-                    for (int i = 0; i < joy.Button.Count; i++)
-                    {
-                        sb.Append(joy.Button[i]);
-                        sb.Append(" ");
-                    }
-                    DrawString(gfx, sb.ToString(), line++);
-                }
-            }
-
-            return line;
-        }
-
-        #endregion
-
-        #region Version Info
-
-        internal static string GetVersionInfo()
-        {
-            return GetVendor() + " " + GetRenderer() + " " + GetVerion();
-        }
-
-        internal static string GetVendor()
-        {
-            return GL.GetString(StringName.Vendor);
-        }
-
-        internal static string GetRenderer()
-        {
-            return GL.GetString(StringName.Renderer);
-        }
-
-        internal static string GetVerion()
-        {
-            return GL.GetString(StringName.Version);
-        }
-
-        #endregion
-    }
 }
diff --git a/Editor/Renderer.cs b/Editor/Renderer.cs
new file mode 100644
index 0000000..8f090c0
--- /dev/null
+++ b/Editor/Renderer.cs
@@ -0,0 +1,450 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Drawing;
+using System.Text;
+
+namespace Editor
+{
+    static class Renderer
+    {
+        internal static int texture;
+        internal static readonly Font TextFont = new Font(FontFamily.GenericSansSerif, 11);
+        internal static Bitmap TextBitmap;
+        internal static StringBuilder TypedText = new StringBuilder();
+        internal static int viewportWidth = 0;
+        internal static int viewportHeight = 0;
+        internal static OpenTK.GLControl renderView;
+        internal static bool mouse_in_glControl = false;
+        internal static bool viewport_changed = true;
+
+        internal static void Resize(ref OpenTK.GLControl glControl1)
+        {
+            viewport_changed = true;
+
+            renderView = glControl1;
+            viewportWidth = renderView.Width;
+            viewportHeight = renderView.Height;
+
+            renderView.Invalidate();
+        }
+
+        internal static void SetupViewport()
+        {
+            GL.Viewport(0, 0, viewportWidth, viewportHeight); // Use all of the glControl painting area
+        }
+
+        internal static void DefaultRender(int x, float rotation)
+        {
+
+            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
+
+            if (viewport_changed)
+            {
+                viewport_changed = false;
+                SetupViewport();
+            }
+
+            DrawText();
+
+            DrawCube(viewportWidth / (float)viewportHeight, rotation);
+
+            renderView.SwapBuffers();
+        }
+
+        // Uploads our text Bitmap to an OpenGL texture
+        // and displays is to screen.
+        private static void DrawText()
+        {
+            System.Drawing.Imaging.BitmapData data = TextBitmap.LockBits(
+                new System.Drawing.Rectangle(0, 0, TextBitmap.Width, TextBitmap.Height),
+                System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
+            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, TextBitmap.Width, TextBitmap.Height, PixelFormat.Bgra,
+                PixelType.UnsignedByte, data.Scan0);
+            TextBitmap.UnlockBits(data);
+
+            Matrix4 text_projection = Matrix4.CreateOrthographicOffCenter(0, viewportWidth, viewportHeight, 0, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref text_projection);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+
+            GL.Color4(Color4.White);
+            GL.Enable(EnableCap.Texture2D);
+            GL.Begin(PrimitiveType.Quads);
+            GL.TexCoord2(0, 0); GL.Vertex2(0, 0);
+            GL.TexCoord2(1, 0); GL.Vertex2(TextBitmap.Width, 0);
+            GL.TexCoord2(1, 1); GL.Vertex2(TextBitmap.Width, TextBitmap.Height);
+            GL.TexCoord2(0, 1); GL.Vertex2(0, TextBitmap.Height);
+            GL.End();
+            GL.Disable(EnableCap.Texture2D);
+        }
+
+        private static void DrawMovingObjects()
+        {
+            Matrix4 thing_projection = Matrix4.CreateOrthographic(2, 2, -1, 1);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref thing_projection);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.2, 0);
+            GL.Color4(Color4.Red);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.4, 0);
+            GL.Color4(Color4.DarkGoldenrod);
+            DrawRectangle();
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadIdentity();
+            GL.Translate(0, -0.8, 0);
+            GL.Color4(Color4.DarkGreen);
+            DrawRectangle();
+        }
+
+        private static void DrawRectangle()
+        {
+            GL.Begin(PrimitiveType.Quads);
+            GL.Vertex2(-0.05, -0.05);
+            GL.Vertex2(+0.05, -0.05);
+            GL.Vertex2(+0.05, +0.05);
+            GL.Vertex2(-0.05, +0.05);
+            GL.End();
+        }
+
+        private static void DrawCube(float aspect_ratio, float rotation)
+        {
+            Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perpective);
+
+            GL.Enable(EnableCap.DepthTest);
+
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.MatrixMode(MatrixMode.Modelview);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(rotation, Vector3.UnitY);
+
+            GL.Begin(PrimitiveType.Quads);
+
+            GL.Color3(Color.Silver);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+
+            GL.Color3(Color.Honeydew);
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+
+            GL.Color3(Color.Moccasin);
+
+            GL.Vertex3(-1.0f, -1.0f, -1.0f);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.IndianRed);
+            GL.Vertex3(-1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+
+            GL.Color3(Color.PaleVioletRed);
+            GL.Vertex3(-1.0f, 1.0f, -1.0f);
+            GL.Vertex3(-1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+
+            GL.Color3(Color.ForestGreen);
+            GL.Vertex3(1.0f, -1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, -1.0f);
+            GL.Vertex3(1.0f, 1.0f, 1.0f);
+            GL.Vertex3(1.0f, -1.0f, 1.0f);
+
+            GL.End();
+
+            GL.Disable(EnableCap.DepthTest);
+        }
+
+        internal static void Load()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+            LoadDebugDisplay();
+        }
+
+        private static void LoadDebugDisplay()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Enable(EnableCap.Blend);
+            GL.BlendFunc(BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcColor);
+
+            TextBitmap = new Bitmap(viewportWidth, viewportHeight);
+            texture = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, texture);
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, TextBitmap.Width, TextBitmap.Height,
+                0, PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Nearest);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Nearest);
+        }
+
+        #region Debug Text Rendering Methods
+
+        internal static void UpdateTextDisplay(ref Stopwatch watch)
+        {
+            double clock_time = watch.Elapsed.TotalSeconds;
+            //update_time += e.Time;
+            //timestamp += e.Time;
+            //update_count++;
+
+            using (Graphics gfx = Graphics.FromImage(TextBitmap))
+            {
+                int line = 0;
+
+                gfx.Clear(Color.Black);
+                gfx.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;
+
+                // OpenGL information
+                DrawString(gfx, Renderer.GetVendor(), line++);
+                DrawString(gfx, Renderer.GetVerion(), line++);
+                DrawString(gfx, renderView.GraphicsMode.ToString(), line++);
+
+                // GameWindow information
+                line++;
+                DrawString(gfx, "GLControl:", line++);
+
+                DrawString(gfx, String.Format("[V]: VSync.{0}.", renderView.VSync), line++);
+                DrawString(gfx, String.Format("Bounds: {0}", renderView.Bounds), line++);
+                DrawString(gfx, String.Format("ClientRectangle: {0}", renderView.ClientRectangle), line++);
+                DrawString(gfx, String.Format("Mouse {0}: {1}.",
+                    mouse_in_glControl ? "inside" : "outside",
+                    renderView.Focused ? "Focused" : "Not focused"), line++);
+                DrawString(gfx, String.Format("Mouse coordinates: {0}", new Vector3(
+                    OpenTK.Input.Mouse.GetState().X,
+                    OpenTK.Input.Mouse.GetState().Y,
+                    OpenTK.Input.Mouse.GetState().WheelPrecise)),
+                    line++
+                    );
+
+                #region Timing Information
+                /*
+                line++;
+                DrawString(gfx, "Timing:", line++);
+                DrawString(gfx,
+                    String.Format("Frequency: update {4} ({0:f2}/{1:f2}); render {5} ({2:f2}/{3:f2})",
+                        UpdateFrequency, TargetUpdateFrequency,
+                        RenderFrequency, TargetRenderFrequency,
+                        update_fps, render_fps),
+                    line++);
+                DrawString(gfx,
+                    String.Format("Period: update {4:N4} ({0:f4}/{1:f4}); render {5:N4} ({2:f4}/{3:f4})",
+                        UpdatePeriod, TargetUpdatePeriod,
+                        RenderPeriod, TargetRenderPeriod,
+                        1.0 / update_fps, 1.0 / render_fps),
+                    line++);
+                DrawString(gfx, String.Format("Time: update {0:f4}; render {1:f4}",
+                    UpdateTime, RenderTime), line++);
+                DrawString(gfx, String.Format("Drift: clock {0:f4}; update {1:f4}; render {2:f4}",
+                    clock_time, clock_time - update_time, clock_time - render_time), line++);
+                DrawString(gfx, String.Format("Text: {0}", TypedText.ToString()), line++);
+
+                if (timestamp >= 1)
+                {
+                    timestamp -= 1;
+                    update_fps = update_count;
+                    render_fps = render_count;
+                    update_count = 0;
+                    render_count = 0;
+
+                }
+                 * 
+                 * */
+                #endregion
+
+                // Input information
+                line = DrawKeyboards(gfx, line);
+                line = DrawMice(gfx, line);
+                // line = DrawJoysticks(gfx, line);
+                // line = DrawLegacyJoysticks(gfx, Joysticks, line);
+            }
+
+            /*
+            fixed_update_timestep_pos += TargetUpdatePeriod;
+            variable_update_timestep_pos += e.Time;
+            if (fixed_update_timestep_pos >= 1)
+                fixed_update_timestep_pos -= 2;
+            if (variable_update_timestep_pos >= 1)
+                variable_update_timestep_pos -= 2;
+             * */
+        }
+
+        private static float DrawString(Graphics gfx, string str, int line)
+        {
+            return DrawString(gfx, str, line, 0);
+        }
+
+        private static float DrawString(Graphics gfx, string str, int line, float offset)
+        {
+            gfx.DrawString(str, TextFont, Brushes.White, new PointF(offset, line * TextFont.Height));
+            return offset + gfx.MeasureString(str, TextFont).Width;
+        }
+
+        private static int DrawKeyboards(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "Keyboard:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                var state = OpenTK.Input.Keyboard.GetState(i);
+                if (state.IsConnected)
+                {
+                    StringBuilder sb = new StringBuilder();
+                    sb.Append(i);
+                    sb.Append(": ");
+                    for (int key_index = 0; key_index < (int)Key.LastKey; key_index++)
+                    {
+                        Key k = (Key)key_index;
+                        if (state[k])
+                        {
+                            sb.Append(k);
+                            sb.Append(" ");
+                        }
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+            return line;
+        }
+
+        private static int DrawMice(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "Mouse:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                var state = OpenTK.Input.Mouse.GetState(i);
+                if (state.IsConnected)
+                {
+                    StringBuilder sb = new StringBuilder();
+                    Vector3 pos = new Vector3(state.X, state.Y, state.WheelPrecise);
+                    sb.Append(i);
+                    sb.Append(": ");
+                    sb.Append(pos);
+                    for (int button_index = 0; button_index < (int)MouseButton.LastButton; button_index++)
+                    {
+                        MouseButton b = (MouseButton)button_index;
+                        if (state[b])
+                        {
+                            sb.Append(b);
+                            sb.Append(" ");
+                        }
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+            return line;
+        }
+
+        private static int DrawJoysticks(Graphics gfx, int line)
+        {
+            line++;
+            DrawString(gfx, "GamePad:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                GamePadCapabilities caps = GamePad.GetCapabilities(i);
+                GamePadState state = GamePad.GetState(i);
+                if (state.IsConnected)
+                {
+                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
+                    DrawString(gfx, state.ToString(), line++);
+                }
+            }
+
+            line++;
+            DrawString(gfx, "Joystick:", line++);
+            for (int i = 0; i < 4; i++)
+            {
+                JoystickCapabilities caps = Joystick.GetCapabilities(i);
+                JoystickState state = Joystick.GetState(i);
+                if (state.IsConnected)
+                {
+                    DrawString(gfx, String.Format("{0}: {1}", i, caps), line++);
+                    DrawString(gfx, state.ToString(), line++);
+                }
+            }
+
+            return line;
+        }
+
+        private static int DrawLegacyJoysticks(Graphics gfx, IList<JoystickDevice> joysticks, int line)
+        {
+            line++;
+            DrawString(gfx, "Legacy Joystick:", line++);
+
+            int joy_index = -1;
+            foreach (var joy in joysticks)
+            {
+                joy_index++;
+                if (!String.IsNullOrEmpty(joy.Description))
+                {
+                    StringBuilder sb = new StringBuilder();
+                    sb.Append(joy_index);
+                    sb.Append(": '");
+                    sb.Append(joy.Description);
+                    sb.Append("' ");
+
+                    for (int i = 0; i < joy.Axis.Count; i++)
+                    {
+                        sb.Append(joy.Axis[i]);
+                        sb.Append(" ");
+                    }
+
+                    for (int i = 0; i < joy.Button.Count; i++)
+                    {
+                        sb.Append(joy.Button[i]);
+                        sb.Append(" ");
+                    }
+                    DrawString(gfx, sb.ToString(), line++);
+                }
+            }
+
+            return line;
+        }
+
+        #endregion
+
+        #region Version Info
+
+        internal static string GetVersionInfo()
+        {
+            return GetVendor() + " " + GetRenderer() + " " + GetVerion();
+        }
+
+        internal static string GetVendor()
+        {
+            return GL.GetString(StringName.Vendor);
+        }
+
+        internal static string GetRenderer()
+        {
+            return GL.GetString(StringName.Renderer);
+        }
+
+        internal static string GetVerion()
+        {
+            return GL.GetString(StringName.Version);
+        }
+
+        #endregion
+    }
+}

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/f1df4ff43f9786454944b4b7ed774c9124c6cf24">Finished separating Renderer.cs</a>  -  f1df4ff</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 2 files changed, 8 insertions(+), 12 deletions(-)

diff --git a/Editor/FrmEditor.cs b/Editor/FrmEditor.cs
index 18ae546..7e242f8 100644
--- a/Editor/FrmEditor.cs
+++ b/Editor/FrmEditor.cs
@@ -10,3 +10,2 @@ namespace Editor
         bool glControlLoaded = false;
-        int x = 0;
 
@@ -14,10 +13,2 @@ namespace Editor
         public static Stopwatch watch = new Stopwatch();
-        double update_time, render_time;
-
-        // timing information
-        double timestamp;
-        int update_count;
-        int update_fps;
-        int render_count;
-        int render_fps;
 
@@ -115,3 +106,3 @@ namespace Editor
 
-            Renderer.DefaultRender(x, rotation);
+            Renderer.DefaultRender(rotation);
         }
@@ -122,3 +113,2 @@ namespace Editor
             {
-                x++;
                 glControl1.Invalidate();
diff --git a/Editor/Renderer.cs b/Editor/Renderer.cs
index 8f090c0..2098844 100644
--- a/Editor/Renderer.cs
+++ b/Editor/Renderer.cs
@@ -24,2 +24,8 @@ namespace Editor
 
+        #region Text Debug Example       
+        // timing information
+        static double update_time, render_time, timestamp;
+        static int update_count, update_fps, render_count, render_fps;
+        #endregion
+
         internal static void Resize(ref OpenTK.GLControl glControl1)
@@ -40,3 +46,3 @@ namespace Editor
 
-        internal static void DefaultRender(int x, float rotation)
+        internal static void DefaultRender(float rotation)
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9feda606fa3b50aa140365ff55406cad15f29780">~tidying</a>  -  9feda60</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 1 file changed, 9 insertions(+), 7 deletions(-)

diff --git a/Editor/Renderer.cs b/Editor/Renderer.cs
index 2098844..55feb5a 100644
--- a/Editor/Renderer.cs
+++ b/Editor/Renderer.cs
@@ -30,2 +30,8 @@ namespace Editor
 
+        internal static void Load()
+        {
+            GL.ClearColor(Color.MidnightBlue);
+            LoadDebugDisplay();
+        }
+
         internal static void Resize(ref OpenTK.GLControl glControl1)
@@ -46,2 +52,3 @@ namespace Editor
 
+        #region Immediate Mode
         internal static void DefaultRender(float rotation)
@@ -184,8 +191,5 @@ namespace Editor
         }
+        #endregion
 
-        internal static void Load()
-        {
-            GL.ClearColor(Color.MidnightBlue);
-            LoadDebugDisplay();
-        }
+        #region Debug Text Rendering Methods
 
@@ -206,4 +210,2 @@ namespace Editor
 
-        #region Debug Text Rendering Methods
-
         internal static void UpdateTextDisplay(ref Stopwatch watch)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/e1c6b98a5cfdd7caa3c7f20633be262f1480a09e">Derived from GLControl.</a>  -  e1c6b98</p><p>authored by Anthony Woodward, 5 weeks ago</p></div><pre>
 3 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
index f1f8026..e1d86d8 100644
--- a/Editor/FrmEditor.Designer.cs
+++ b/Editor/FrmEditor.Designer.cs
@@ -30,3 +30,3 @@
         {
-            this.glControl1 = new OpenTK.GLControl();
+            this.glControl1 = new ModernGLControl();
             this.button1 = new System.Windows.Forms.Button();
@@ -76,3 +76,3 @@
 
-        private OpenTK.GLControl glControl1;
+        private ModernGLControl glControl1;
         private System.Windows.Forms.Button button1;
diff --git a/Editor/ModernGLControl.cs b/Editor/ModernGLControl.cs
new file mode 100644
index 0000000..9159fb9
--- /dev/null
+++ b/Editor/ModernGLControl.cs
@@ -0,0 +1,19 @@
+﻿using OpenTK;
+using OpenTK.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Editor
+{
+    class ModernGLControl : GLControl
+    {
+        // 32bpp color, 24bpp z-depth, 8bpp stencil and 4x antialiasing
+        // OpenGL version is major=3, minor=3
+        public ModernGLControl()
+            : base(new GraphicsMode(32, 24, 8, 4), 3, 3, GraphicsContextFlags.Default)
+        { }
+    }
+}
diff --git a/Editor/Renderer.cs b/Editor/Renderer.cs
index 55feb5a..b2b1fe3 100644
--- a/Editor/Renderer.cs
+++ b/Editor/Renderer.cs
@@ -36,3 +36,3 @@ namespace Editor
 
-        internal static void Resize(ref OpenTK.GLControl glControl1)
+        internal static void Resize(ref ModernGLControl glControl1)
         {

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/64e807b91e82cf14b4746c46262acaf012743c7a">missing comment</a>  -  64e807b</p><p>authored by Anthony Woodward, 3 weeks ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Editor/FrmEditor.Designer.cs b/Editor/FrmEditor.Designer.cs
index e1d86d8..7fe1870 100644
--- a/Editor/FrmEditor.Designer.cs
+++ b/Editor/FrmEditor.Designer.cs
@@ -30,3 +30,3 @@
         {
-            this.glControl1 = new ModernGLControl();
+            this.glControl1 = new ModernGLControl(); // modified a.woodward !
             this.button1 = new System.Windows.Forms.Button();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/0c132cb36670cc500e057d6b5845aa2beae86504">switched shaders to be version 330 compliant</a>  -  0c132cb</p><p>authored by Anthony Woodward, 26 hours ago</p></div><pre>
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 076dc19..ae3648f 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
 
diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
index c2bfc32..1fa5c1c 100644
--- a/KAOS/Data/Shaders/render-vs.glsl
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -1,2 +1,2 @@
-#version 410 core
+#version 330 core
 
diff --git a/KAOS/Data/Shaders/skybox-fs.glsl b/KAOS/Data/Shaders/skybox-fs.glsl
index f996bf4..7243b6f 100644
--- a/KAOS/Data/Shaders/skybox-fs.glsl
+++ b/KAOS/Data/Shaders/skybox-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
 
diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
index 0301135..d2dbe76 100644
--- a/KAOS/Data/Shaders/skybox-vs.glsl
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
  

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9808fbe0d81ff635a82fac23c6b8aec7cbc670dc">small tweaks here and there, added some new textures but yet to code them into the scene.</a>  -  9808fbe</p><p>authored by Anthony Woodward, 24 hours ago</p></div><pre>
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 9647f3e..d4dbf13 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -21,3 +21,3 @@ namespace Game
             SetupStates();
-            stateManager.ChangeState("SplashScreen");
+            SetState("SplashScreen");
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 7eaea93..27939fa 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -84,3 +84,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3d3b17397a70884c91d089057592f0c23a030bfe">Changed Graphics context to forward compatible in editor.</a>  -  3d3b173</p><p>authored by Anthony Woodward, 19 hours ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Editor/ModernGLControl.cs b/Editor/ModernGLControl.cs
index 9159fb9..36f2c58 100644
--- a/Editor/ModernGLControl.cs
+++ b/Editor/ModernGLControl.cs
@@ -15,3 +15,3 @@ namespace Editor
         public ModernGLControl()
-            : base(new GraphicsMode(32, 24, 8, 4), 3, 3, GraphicsContextFlags.Default)
+            : base(new GraphicsMode(32, 24, 8, 4), 3, 3, GraphicsContextFlags.ForwardCompatible)
         { }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/351bd6a1f33c65d5dbfd29a37a19191797f89ade">Abstracting states to help keep things maintainable.</a>  -  351bd6a</p><p>authored by Anthony Woodward, 19 hours ago</p></div><pre>
 3 files changed, 53 insertions(+), 10 deletions(-)

diff --git a/KAOS/States/AbstractState.cs b/KAOS/States/AbstractState.cs
new file mode 100644
index 0000000..0597db8
--- /dev/null
+++ b/KAOS/States/AbstractState.cs
@@ -0,0 +1,22 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.States
+{
+    public abstract class AbstractState : IDisposable
+    {
+        protected VertexBufferManager m_bufferManager;
+        protected StateManager m_stateManager;
+        protected TextureManager m_textureManager;
+
+        public void Dispose()
+        {
+            m_textureManager.Dispose();
+        }
+    }
+}
diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
new file mode 100644
index 0000000..c400254
--- /dev/null
+++ b/KAOS/States/ModelState.cs
@@ -0,0 +1,30 @@
+﻿using KAOS.Interfaces;
+using KAOS.Managers;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.States
+{
+    public class ModelState : AbstractState, IGameObject
+    {
+        public ModelState(StateManager stateManager)
+        {
+            m_bufferManager = new VertexBufferManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void Render()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
\ No newline at end of file
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 7eaea93..65b2327 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -11,8 +11,4 @@ namespace KAOS.States
 {
-    public class Skyboxstate : IDisposable, IGameObject
+    public class Skyboxstate : AbstractState, IGameObject
     {
-        private VertexBufferManager m_bufferManager;
-        private StateManager m_stateManager;
-        private TextureManager m_textureManager;
-
         static string defaultSkyboxPath = "Data/Textures/skybox/";
@@ -86,7 +82,2 @@ namespace KAOS.States
         }
-
-        public void Dispose()
-        {
-            m_textureManager.Dispose();
-        }
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/b296dcfb9160b4637442f7b6f1a440a80f50ae5b">switched shaders to be version 330 compliant</a>  -  b296dcf</p><p>authored by Anthony Woodward, 26 hours ago</p></div><pre>
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/KAOS/Data/Shaders/render-fs.glsl b/KAOS/Data/Shaders/render-fs.glsl
index 076dc19..ae3648f 100644
--- a/KAOS/Data/Shaders/render-fs.glsl
+++ b/KAOS/Data/Shaders/render-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
 
diff --git a/KAOS/Data/Shaders/render-vs.glsl b/KAOS/Data/Shaders/render-vs.glsl
index c2bfc32..1fa5c1c 100644
--- a/KAOS/Data/Shaders/render-vs.glsl
+++ b/KAOS/Data/Shaders/render-vs.glsl
@@ -1,2 +1,2 @@
-#version 410 core
+#version 330 core
 
diff --git a/KAOS/Data/Shaders/skybox-fs.glsl b/KAOS/Data/Shaders/skybox-fs.glsl
index f996bf4..7243b6f 100644
--- a/KAOS/Data/Shaders/skybox-fs.glsl
+++ b/KAOS/Data/Shaders/skybox-fs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
 
diff --git a/KAOS/Data/Shaders/skybox-vs.glsl b/KAOS/Data/Shaders/skybox-vs.glsl
index 0301135..d2dbe76 100644
--- a/KAOS/Data/Shaders/skybox-vs.glsl
+++ b/KAOS/Data/Shaders/skybox-vs.glsl
@@ -1,2 +1,2 @@
-﻿#version 410 core
+﻿#version 330 core
  

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/946d74a29e69be3cfadcb6ebeb9a9b1208f6f466">small tweaks here and there, added some new textures but yet to code them into the scene.</a>  -  946d74a</p><p>authored by Anthony Woodward, 24 hours ago</p></div><pre>
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index 9647f3e..d4dbf13 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -21,3 +21,3 @@ namespace Game
             SetupStates();
-            stateManager.ChangeState("SplashScreen");
+            SetState("SplashScreen");
         }
diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 65b2327..44dc4a2 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -80,3 +80,3 @@ namespace KAOS.States
             Renderer.DrawSkyBox(m_textureManager, m_bufferManager.GetBuffer("SkyCube"));
-            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("MengerSponge"));
+            Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/9168ba9f2ea63e0b2dba47f65e80d34dc458d4dd">merge confict</a>  -  9168ba9</p><p>authored by Anthony Woodward, 19 hours ago</p></div><pre>
<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/105fb6251ca40194061854df7d104e273c19c7e5">fixing bad merge</a>  -  105fb62</p><p>authored by Anthony Woodward, 19 hours ago</p></div><pre>
 1 file changed, 8 deletions(-)

diff --git a/KAOS/States/Skyboxstate.cs b/KAOS/States/Skyboxstate.cs
index 1b55a16..44dc4a2 100644
--- a/KAOS/States/Skyboxstate.cs
+++ b/KAOS/States/Skyboxstate.cs
@@ -81,10 +81,2 @@ namespace KAOS.States
             Renderer.DrawObject(m_textureManager, m_bufferManager.GetBuffer("Sphere"));
-<<<<<<< HEAD
-=======
-        }
-
-        public void Dispose()
-        {
-            m_textureManager.Dispose();
->>>>>>> 9808fbe0d81ff635a82fac23c6b8aec7cbc670dc
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/d8c705a15d515a6e1c9c11768e4fb24e9e1452f0">added assimp example code once again</a>  -  d8c705a</p><p>authored by Anthony Woodward, 19 hours ago</p></div><pre>
 1 file changed, 312 insertions(+), 3 deletions(-)

diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index c400254..e404032 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -1,6 +1,16 @@
-﻿using KAOS.Interfaces;
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Interfaces;
 using KAOS.Managers;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
 using System;
 using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Text;
@@ -12,2 +22,8 @@ namespace KAOS.States
     {
+        private Scene m_model;
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+
         public ModelState(StateManager stateManager)
@@ -17,2 +33,54 @@ namespace KAOS.States
             m_textureManager = new TextureManager();
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+
+            AssimpContext importer = new AssimpContext();
+            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
+            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
+            ComputeBoundingBox();
+        }
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
         }
@@ -21,3 +89,11 @@ namespace KAOS.States
         {
-            throw new NotImplementedException();
+            m_angle += 25f * (float)e.Time;
+            if (m_angle > 360)
+            {
+                m_angle = 0.0f;
+            }
+            //if (Keyboard[OpenTK.Input.Key.Escape])
+            //{
+            //    this.Exit();
+            //}
         }
@@ -26,3 +102,236 @@ namespace KAOS.States
         {
-            throw new NotImplementedException();
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/264aed4004786e41a4b7930af922669f892da0d2">syncing to lab workstation</a>  -  264aed4</p><p>authored by Anthony Woodward, 8 hours ago</p></div><pre>
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/Game/Game.cs b/Game/Game.cs
index d4dbf13..f9eee0a 100644
--- a/Game/Game.cs
+++ b/Game/Game.cs
@@ -27,3 +27,4 @@ namespace Game
             stateManager.AddState("SplashScreen", new SplashScreen(stateManager));
-            stateManager.AddState("TestScene", new Skyboxstate(stateManager));
+            stateManager.AddState("SkyboxScene", new Skyboxstate(stateManager));
+            stateManager.AddState("TestScene", new ModelState(stateManager));
         }
diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index e404032..c4b96cc 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -33,3 +33,3 @@ namespace KAOS.States
             m_textureManager = new TextureManager();
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "duck.dae");
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content\\Models\\Characters\\Duck\\duck.dae");
 
@@ -89,3 +89,3 @@ namespace KAOS.States
         {
-            m_angle += 25f * (float)e.Time;
+            m_angle += 25f * elapsedTime;
             if (m_angle > 360)

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/85c97bfe9f77ad80f7c72d8978670cf7588660cc">immeadiate mode model loading</a>  -  85c97bf</p><p>authored by Anthony Woodward, 7 hours ago</p></div><pre>
 4 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/Game/Program.cs b/Game/Program.cs
index e245025..8e33b1f 100644
--- a/Game/Program.cs
+++ b/Game/Program.cs
@@ -13,3 +13,3 @@ namespace Game
         {
-            using (Game game = new Game(1280, 720, 3, 3)) { game.Run(60, 0); }
+            using (Game game = new Game(1280, 720, 3, 3)) { game.Run(60, 30); }
         }
diff --git a/Game/States/SplashScreen.cs b/Game/States/SplashScreen.cs
index 86d194c..f088b4c 100644
--- a/Game/States/SplashScreen.cs
+++ b/Game/States/SplashScreen.cs
@@ -13,3 +13,3 @@ namespace Game.States
         double currentRotation = 0;
-        double delay = 300;
+        double delay = 100;
 
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index e3953d8..fec8c02 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -76,3 +76,5 @@ namespace KAOS
 
-            UpdateFrame(m_Timer.GetElapsedTime());
+            double time = e.Time;
+
+            UpdateFrame((float)time);
         }
@@ -109,2 +111,6 @@ namespace KAOS
             float aspect = ScreenWidth / (float)ScreenHeight;
+
+            Matrix4 perspective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect, 1, 64);
+            GL.MatrixMode(MatrixMode.Projection);
+            GL.LoadMatrix(ref perspective);
         }
diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index c4b96cc..6a89af7 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -33,3 +33,3 @@ namespace KAOS.States
             m_textureManager = new TextureManager();
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content\\Models\\Characters\\Duck\\duck.dae");
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content\\Models\\Characters\\bunny\\reconstruction\\bun_zipper.ply");
 
@@ -94,6 +94,2 @@ namespace KAOS.States
             }
-            //if (Keyboard[OpenTK.Input.Key.Escape])
-            //{
-            //    this.Exit();
-            //}
         }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/25ffa332b4c47434b17892207ad452bac16ef998">added shaders from lighthouse3d tutorial. this is work to extend the example code to be compatible with the 3.3+ core profile</a>  -  25ffa33</p><p>authored by Anthony Woodward, 7 hours ago</p></div><pre>
 4 files changed, 83 insertions(+), 2 deletions(-)

diff --git a/KAOS/Data/Shaders/assimp-fs.glsl b/KAOS/Data/Shaders/assimp-fs.glsl
new file mode 100644
index 0000000..24a0431
--- /dev/null
+++ b/KAOS/Data/Shaders/assimp-fs.glsl
@@ -0,0 +1,39 @@
+﻿#version 330
+ 
+layout (std140) uniform Material {
+    vec4 diffuse;
+    vec4 ambient;
+    vec4 specular;
+    vec4 emissive;
+    float shininess;
+    int texCount;
+};
+ 
+uniform sampler2D texUnit;
+ 
+in vec3 Normal;
+in vec2 TexCoord;
+out vec4 output;
+ 
+void main()
+{
+    vec4 color;
+    vec4 amb;
+    float intensity;
+    vec3 lightDir;
+    vec3 n;
+ 
+    lightDir = normalize(vec3(1.0,1.0,1.0));
+    n = normalize(Normal);
+    intensity = max(dot(lightDir,n),0.0);
+ 
+    if (texCount == 0) {
+        color = diffuse;
+        amb = ambient;
+    }
+    else {
+        color = texture2D(texUnit, TexCoord);
+        amb = color * 0.33;
+    }
+    output = (color * intensity) + amb;
+}
\ No newline at end of file
diff --git a/KAOS/Data/Shaders/assimp-vs.glsl b/KAOS/Data/Shaders/assimp-vs.glsl
new file mode 100644
index 0000000..d6b0efa
--- /dev/null
+++ b/KAOS/Data/Shaders/assimp-vs.glsl
@@ -0,0 +1,23 @@
+﻿#version 330
+ 
+layout (std140) uniform Matrices {
+ 
+    mat4 projMatrix;
+    mat4 viewMatrix;
+    mat4 modelMatrix;
+};
+ 
+in vec3 position;
+in vec3 normal;
+in vec2 texCoord;
+ 
+out vec4 vertexPos;
+out vec2 TexCoord;
+out vec3 Normal;
+ 
+void main()
+{
+    Normal = normalize(vec3(viewMatrix * modelMatrix * vec4(normal,0.0)));
+    TexCoord = vec2(texCoord);
+    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(position,1.0);
+}
\ No newline at end of file
diff --git a/KAOS/KAOSEngine.cs b/KAOS/KAOSEngine.cs
index fec8c02..40d5369 100644
--- a/KAOS/KAOSEngine.cs
+++ b/KAOS/KAOSEngine.cs
@@ -60,2 +60,3 @@ namespace KAOS
             ShaderManager.LoadDefaultRenderShader();
+            ShaderManager.LoadDefaultAssimpShader();
         }
diff --git a/KAOS/Managers/ShaderManager.cs b/KAOS/Managers/ShaderManager.cs
index 4c8182d..8a38bf6 100644
--- a/KAOS/Managers/ShaderManager.cs
+++ b/KAOS/Managers/ShaderManager.cs
@@ -39,2 +39,12 @@ namespace KAOS.Managers
             m_shaderStorage.Add("render", new Shader(m_programHandle));
+        }
+
+        internal static void LoadDefaultAssimpShader()
+        {
+            m_vertexShaderFile = "assimp-vs";
+            m_fragmentShaderFile = "assimp-fs";
+            if (m_shaderStorage == null)
+                m_shaderStorage = new Dictionary<string, Shader>();
+            m_programHandle = BuildProgram();
+            m_shaderStorage.Add("assimp", new Shader(m_programHandle));
         }
@@ -64,2 +74,10 @@ namespace KAOS.Managers
             }
+        }
+
+        public static Shader Assimp
+        {
+            get
+            {
+                return Get("assimp");
+            }
         }
@@ -137,4 +155,4 @@ namespace KAOS.Managers
         }
-        #endregion
-
+        #endregion
+
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/3cc9e7fe64a8d38e2026447f3455618f8a6d2b9a">fixed rotation issue for the time being</a>  -  3cc9e7f</p><p>authored by Anthony Woodward, 6 hours ago</p></div><pre>
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index 6a89af7..e379f88 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -3,3 +3,4 @@ using Assimp.Configs;
 using KAOS.Interfaces;
-using KAOS.Managers;
+using KAOS.Managers;
+using KAOS.Utilities;
 using OpenTK;
@@ -37,3 +38,9 @@ namespace KAOS.States
             importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
-            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
+            m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
+
+            if (m_model == null)
+            {
+                Logger.WriteLine("Import failed.");
+            }
+
             ComputeBoundingBox();

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/a3d43d3b4a3dd7b7c863aa8e2c906fc77490839d">line endings</a>  -  a3d43d3</p><p>authored by Anthony Woodward, 4 hours ago</p></div><pre>
 1 file changed, 335 insertions(+), 335 deletions(-)

diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index e379f88..b5b1caf 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -1,39 +1,39 @@
-﻿using Assimp;
-using Assimp.Configs;
-using KAOS.Interfaces;
+﻿using Assimp;
+using Assimp.Configs;
+using KAOS.Interfaces;
 using KAOS.Managers;
-using KAOS.Utilities;
-using OpenTK;
-using OpenTK.Graphics;
-using OpenTK.Graphics.OpenGL;
-using OpenTK.Input;
-using System;
-using System.Collections.Generic;
-using System.Drawing;
-using System.Drawing.Imaging;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace KAOS.States
-{
-    public class ModelState : AbstractState, IGameObject
-    {
-        private Scene m_model;
-        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
-        private float m_angle;
-        private int m_displayList;
-        private int m_texId;
-
-        public ModelState(StateManager stateManager)
-        {
-            m_bufferManager = new VertexBufferManager();
-            m_stateManager = stateManager;
-            m_textureManager = new TextureManager();
-            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content\\Models\\Characters\\bunny\\reconstruction\\bun_zipper.ply");
-
-            AssimpContext importer = new AssimpContext();
-            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
+using KAOS.Utilities;
+using OpenTK;
+using OpenTK.Graphics;
+using OpenTK.Graphics.OpenGL;
+using OpenTK.Input;
+using System;
+using System.Collections.Generic;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace KAOS.States
+{
+    public class ModelState : AbstractState, IGameObject
+    {
+        private Scene m_model;
+        private Vector3 m_sceneCenter, m_sceneMin, m_sceneMax;
+        private float m_angle;
+        private int m_displayList;
+        private int m_texId;
+
+        public ModelState(StateManager stateManager)
+        {
+            m_bufferManager = new VertexBufferManager();
+            m_stateManager = stateManager;
+            m_textureManager = new TextureManager();
+            String fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Content\\Models\\Characters\\bunny\\reconstruction\\bun_zipper.ply");
+
+            AssimpContext importer = new AssimpContext();
+            importer.SetConfig(new NormalSmoothingAngleConfig(66.0f));
             m_model = importer.ImportFile(fileName, PostProcessPreset.TargetRealTimeMaximumQuality);
@@ -43,300 +43,300 @@ namespace KAOS.States
                 Logger.WriteLine("Import failed.");
-            }
-
-            ComputeBoundingBox();
-        }
-
-        private void ComputeBoundingBox()
-        {
-            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
-            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
-            Matrix4 identity = Matrix4.Identity;
-
-            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
-
-            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
-            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
-            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
-        }
-
-        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
-        {
-            Matrix4 prev = trafo;
-            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = m_model.Meshes[index];
-                    for (int i = 0; i < mesh.VertexCount; i++)
-                    {
-                        Vector3 tmp = FromVector(mesh.Vertices[i]);
-                        Vector3.Transform(ref tmp, ref trafo, out tmp);
-
-                        min.X = Math.Min(min.X, tmp.X);
-                        min.Y = Math.Min(min.Y, tmp.Y);
-                        min.Z = Math.Min(min.Z, tmp.Z);
-
-                        max.X = Math.Max(max.X, tmp.X);
-                        max.Y = Math.Max(max.Y, tmp.Y);
-                        max.Z = Math.Max(max.Z, tmp.Z);
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
-            }
-            trafo = prev;
-        }
-
-        public void Update(float elapsedTime, float aspect)
-        {
-            m_angle += 25f * elapsedTime;
-            if (m_angle > 360)
-            {
-                m_angle = 0.0f;
-            }
-        }
-
-        public void Render()
-        {
-            GL.Enable(EnableCap.Texture2D);
-            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
-            GL.Enable(EnableCap.Lighting);
-            GL.Enable(EnableCap.Light0);
-            GL.Enable(EnableCap.DepthTest);
-            GL.Enable(EnableCap.Normalize);
-            GL.FrontFace(FrontFaceDirection.Ccw);
-
-            GL.MatrixMode(MatrixMode.Modelview);
-            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
-            GL.LoadMatrix(ref lookat);
-
-            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
-
-            float tmp = m_sceneMax.X - m_sceneMin.X;
-            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
-            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
-            tmp = 1.0f / tmp;
-            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
-
-            GL.Translate(-m_sceneCenter);
-
-            if (m_displayList == 0)
-            {
-                m_displayList = GL.GenLists(1);
-                GL.NewList(m_displayList, ListMode.Compile);
-                RecursiveRender(m_model, m_model.RootNode);
-                GL.EndList();
-            }
-
-            GL.CallList(m_displayList);
-        }
-
-        private void RecursiveRender(Scene scene, Node node)
-        {
-            Matrix4 m = FromMatrix(node.Transform);
-            m.Transpose();
-            GL.PushMatrix();
-            GL.MultMatrix(ref m);
-
-            if (node.HasMeshes)
-            {
-                foreach (int index in node.MeshIndices)
-                {
-                    Mesh mesh = scene.Meshes[index];
-                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
-
-                    if (mesh.HasNormals)
-                    {
-                        GL.Enable(EnableCap.Lighting);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.Lighting);
-                    }
-
-                    bool hasColors = mesh.HasVertexColors(0);
-                    if (hasColors)
-                    {
-                        GL.Enable(EnableCap.ColorMaterial);
-                    }
-                    else
-                    {
-                        GL.Disable(EnableCap.ColorMaterial);
-                    }
-
-                    bool hasTexCoords = mesh.HasTextureCoords(0);
-
-                    foreach (Face face in mesh.Faces)
-                    {
-                        BeginMode faceMode;
-                        switch (face.IndexCount)
-                        {
-                            case 1:
-                                faceMode = BeginMode.Points;
-                                break;
-                            case 2:
-                                faceMode = BeginMode.Lines;
-                                break;
-                            case 3:
-                                faceMode = BeginMode.Triangles;
-                                break;
-                            default:
-                                faceMode = BeginMode.Polygon;
-                                break;
-                        }
-
-                        GL.Begin(faceMode);
-                        for (int i = 0; i < face.IndexCount; i++)
-                        {
-                            int indice = face.Indices[i];
-                            if (hasColors)
-                            {
-                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
-                            }
-                            if (mesh.HasNormals)
-                            {
-                                Vector3 normal = FromVector(mesh.Normals[indice]);
-                                GL.Normal3(normal);
-                            }
-                            if (hasTexCoords)
-                            {
-                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
-                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
-                            }
-                            Vector3 pos = FromVector(mesh.Vertices[indice]);
-                            GL.Vertex3(pos);
-                        }
-                        GL.End();
-                    }
-                }
-            }
-
-            for (int i = 0; i < node.ChildCount; i++)
-            {
-                RecursiveRender(m_model, node.Children[i]);
-            }
-        }
-
-        private void LoadTexture(String fileName)
-        {
-            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
-            if (!File.Exists(fileName))
-            {
-                return;
-            }
-            Bitmap textureBitmap = new Bitmap(fileName);
-            BitmapData TextureData =
-                            textureBitmap.LockBits(
-                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
-                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
-                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
-                    );
-            m_texId = GL.GenTexture();
-            GL.BindTexture(TextureTarget.Texture2D, m_texId);
-
-            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
-                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
-            textureBitmap.UnlockBits(TextureData);
-
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
-            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
-        }
-
-        private void ApplyMaterial(Material mat)
-        {
-            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
-            {
-                TextureSlot tex;
-                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
-                    LoadTexture(tex.FilePath);
-            }
-
-            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
-            if (mat.HasColorDiffuse)
-            {
-                // color = FromColor(mat.ColorDiffuse);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorSpecular)
-            {
-                color = FromColor(mat.ColorSpecular);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
-
-            color = new Color4(.2f, .2f, .2f, 1.0f);
-            if (mat.HasColorAmbient)
-            {
-                color = FromColor(mat.ColorAmbient);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
-
-            color = new Color4(0, 0, 0, 1.0f);
-            if (mat.HasColorEmissive)
-            {
-                color = FromColor(mat.ColorEmissive);
-            }
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
-
-            float shininess = 1;
-            float strength = 1;
-            if (mat.HasShininess)
-            {
-                shininess = mat.Shininess;
-            }
-            if (mat.HasShininessStrength)
-            {
-                strength = mat.ShininessStrength;
-            }
-
-            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
-        }
-
-        private Matrix4 FromMatrix(Matrix4x4 mat)
-        {
-            Matrix4 m = new Matrix4();
-            m.M11 = mat.A1;
-            m.M12 = mat.A2;
-            m.M13 = mat.A3;
-            m.M14 = mat.A4;
-            m.M21 = mat.B1;
-            m.M22 = mat.B2;
-            m.M23 = mat.B3;
-            m.M24 = mat.B4;
-            m.M31 = mat.C1;
-            m.M32 = mat.C2;
-            m.M33 = mat.C3;
-            m.M34 = mat.C4;
-            m.M41 = mat.D1;
-            m.M42 = mat.D2;
-            m.M43 = mat.D3;
-            m.M44 = mat.D4;
-            return m;
-        }
-
-        private Vector3 FromVector(Vector3D vec)
-        {
-            Vector3 v;
-            v.X = vec.X;
-            v.Y = vec.Y;
-            v.Z = vec.Z;
-            return v;
-        }
-
-        private Color4 FromColor(Color4D color)
-        {
-            Color4 c;
-            c.R = color.R;
-            c.G = color.G;
-            c.B = color.B;
-            c.A = color.A;
-            return c;
-        }
-    }
+            }
+
+            ComputeBoundingBox();
+        }
+
+        private void ComputeBoundingBox()
+        {
+            m_sceneMin = new Vector3(1e10f, 1e10f, 1e10f);
+            m_sceneMax = new Vector3(-1e10f, -1e10f, -1e10f);
+            Matrix4 identity = Matrix4.Identity;
+
+            ComputeBoundingBox(m_model.RootNode, ref m_sceneMin, ref m_sceneMax, ref identity);
+
+            m_sceneCenter.X = (m_sceneMin.X + m_sceneMax.X) / 2.0f;
+            m_sceneCenter.Y = (m_sceneMin.Y + m_sceneMax.Y) / 2.0f;
+            m_sceneCenter.Z = (m_sceneMin.Z + m_sceneMax.Z) / 2.0f;
+        }
+
+        private void ComputeBoundingBox(Node node, ref Vector3 min, ref Vector3 max, ref Matrix4 trafo)
+        {
+            Matrix4 prev = trafo;
+            trafo = Matrix4.Mult(prev, FromMatrix(node.Transform));
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = m_model.Meshes[index];
+                    for (int i = 0; i < mesh.VertexCount; i++)
+                    {
+                        Vector3 tmp = FromVector(mesh.Vertices[i]);
+                        Vector3.Transform(ref tmp, ref trafo, out tmp);
+
+                        min.X = Math.Min(min.X, tmp.X);
+                        min.Y = Math.Min(min.Y, tmp.Y);
+                        min.Z = Math.Min(min.Z, tmp.Z);
+
+                        max.X = Math.Max(max.X, tmp.X);
+                        max.Y = Math.Max(max.Y, tmp.Y);
+                        max.Z = Math.Max(max.Z, tmp.Z);
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                ComputeBoundingBox(node.Children[i], ref min, ref max, ref trafo);
+            }
+            trafo = prev;
+        }
+
+        public void Update(float elapsedTime, float aspect)
+        {
+            m_angle += 25f * elapsedTime;
+            if (m_angle > 360)
+            {
+                m_angle = 0.0f;
+            }
+        }
+
+        public void Render()
+        {
+            GL.Enable(EnableCap.Texture2D);
+            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Nicest);
+            GL.Enable(EnableCap.Lighting);
+            GL.Enable(EnableCap.Light0);
+            GL.Enable(EnableCap.DepthTest);
+            GL.Enable(EnableCap.Normalize);
+            GL.FrontFace(FrontFaceDirection.Ccw);
+
+            GL.MatrixMode(MatrixMode.Modelview);
+            Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
+            GL.LoadMatrix(ref lookat);
+
+            GL.Rotate(m_angle, 0.0f, 1.0f, 0.0f);
+
+            float tmp = m_sceneMax.X - m_sceneMin.X;
+            tmp = Math.Max(m_sceneMax.Y - m_sceneMin.Y, tmp);
+            tmp = Math.Max(m_sceneMax.Z - m_sceneMin.Z, tmp);
+            tmp = 1.0f / tmp;
+            GL.Scale(tmp * 2, tmp * 2, tmp * 2);
+
+            GL.Translate(-m_sceneCenter);
+
+            if (m_displayList == 0)
+            {
+                m_displayList = GL.GenLists(1);
+                GL.NewList(m_displayList, ListMode.Compile);
+                RecursiveRender(m_model, m_model.RootNode);
+                GL.EndList();
+            }
+
+            GL.CallList(m_displayList);
+        }
+
+        private void RecursiveRender(Scene scene, Node node)
+        {
+            Matrix4 m = FromMatrix(node.Transform);
+            m.Transpose();
+            GL.PushMatrix();
+            GL.MultMatrix(ref m);
+
+            if (node.HasMeshes)
+            {
+                foreach (int index in node.MeshIndices)
+                {
+                    Mesh mesh = scene.Meshes[index];
+                    ApplyMaterial(scene.Materials[mesh.MaterialIndex]);
+
+                    if (mesh.HasNormals)
+                    {
+                        GL.Enable(EnableCap.Lighting);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.Lighting);
+                    }
+
+                    bool hasColors = mesh.HasVertexColors(0);
+                    if (hasColors)
+                    {
+                        GL.Enable(EnableCap.ColorMaterial);
+                    }
+                    else
+                    {
+                        GL.Disable(EnableCap.ColorMaterial);
+                    }
+
+                    bool hasTexCoords = mesh.HasTextureCoords(0);
+
+                    foreach (Face face in mesh.Faces)
+                    {
+                        BeginMode faceMode;
+                        switch (face.IndexCount)
+                        {
+                            case 1:
+                                faceMode = BeginMode.Points;
+                                break;
+                            case 2:
+                                faceMode = BeginMode.Lines;
+                                break;
+                            case 3:
+                                faceMode = BeginMode.Triangles;
+                                break;
+                            default:
+                                faceMode = BeginMode.Polygon;
+                                break;
+                        }
+
+                        GL.Begin(faceMode);
+                        for (int i = 0; i < face.IndexCount; i++)
+                        {
+                            int indice = face.Indices[i];
+                            if (hasColors)
+                            {
+                                Color4 vertColor = FromColor(mesh.VertexColorChannels[0][indice]);
+                            }
+                            if (mesh.HasNormals)
+                            {
+                                Vector3 normal = FromVector(mesh.Normals[indice]);
+                                GL.Normal3(normal);
+                            }
+                            if (hasTexCoords)
+                            {
+                                Vector3 uvw = FromVector(mesh.TextureCoordinateChannels[0][indice]);
+                                GL.TexCoord2(uvw.X, 1 - uvw.Y);
+                            }
+                            Vector3 pos = FromVector(mesh.Vertices[indice]);
+                            GL.Vertex3(pos);
+                        }
+                        GL.End();
+                    }
+                }
+            }
+
+            for (int i = 0; i < node.ChildCount; i++)
+            {
+                RecursiveRender(m_model, node.Children[i]);
+            }
+        }
+
+        private void LoadTexture(String fileName)
+        {
+            fileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), fileName);
+            if (!File.Exists(fileName))
+            {
+                return;
+            }
+            Bitmap textureBitmap = new Bitmap(fileName);
+            BitmapData TextureData =
+                            textureBitmap.LockBits(
+                            new System.Drawing.Rectangle(0, 0, textureBitmap.Width, textureBitmap.Height),
+                            System.Drawing.Imaging.ImageLockMode.ReadOnly,
+                            System.Drawing.Imaging.PixelFormat.Format24bppRgb
+                    );
+            m_texId = GL.GenTexture();
+            GL.BindTexture(TextureTarget.Texture2D, m_texId);
+
+            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, textureBitmap.Width, textureBitmap.Height, 0,
+                    OpenTK.Graphics.OpenGL.PixelFormat.Bgr, PixelType.UnsignedByte, TextureData.Scan0);
+            textureBitmap.UnlockBits(TextureData);
+
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
+            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
+        }
+
+        private void ApplyMaterial(Material mat)
+        {
+            if (mat.GetMaterialTextureCount(TextureType.Diffuse) > 0)
+            {
+                TextureSlot tex;
+                if (mat.GetMaterialTexture(TextureType.Diffuse, 0, out tex))
+                    LoadTexture(tex.FilePath);
+            }
+
+            Color4 color = new Color4(.8f, .8f, .8f, 1.0f);
+            if (mat.HasColorDiffuse)
+            {
+                // color = FromColor(mat.ColorDiffuse);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Diffuse, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorSpecular)
+            {
+                color = FromColor(mat.ColorSpecular);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Specular, color);
+
+            color = new Color4(.2f, .2f, .2f, 1.0f);
+            if (mat.HasColorAmbient)
+            {
+                color = FromColor(mat.ColorAmbient);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Ambient, color);
+
+            color = new Color4(0, 0, 0, 1.0f);
+            if (mat.HasColorEmissive)
+            {
+                color = FromColor(mat.ColorEmissive);
+            }
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Emission, color);
+
+            float shininess = 1;
+            float strength = 1;
+            if (mat.HasShininess)
+            {
+                shininess = mat.Shininess;
+            }
+            if (mat.HasShininessStrength)
+            {
+                strength = mat.ShininessStrength;
+            }
+
+            GL.Material(MaterialFace.FrontAndBack, MaterialParameter.Shininess, shininess * strength);
+        }
+
+        private Matrix4 FromMatrix(Matrix4x4 mat)
+        {
+            Matrix4 m = new Matrix4();
+            m.M11 = mat.A1;
+            m.M12 = mat.A2;
+            m.M13 = mat.A3;
+            m.M14 = mat.A4;
+            m.M21 = mat.B1;
+            m.M22 = mat.B2;
+            m.M23 = mat.B3;
+            m.M24 = mat.B4;
+            m.M31 = mat.C1;
+            m.M32 = mat.C2;
+            m.M33 = mat.C3;
+            m.M34 = mat.C4;
+            m.M41 = mat.D1;
+            m.M42 = mat.D2;
+            m.M43 = mat.D3;
+            m.M44 = mat.D4;
+            return m;
+        }
+
+        private Vector3 FromVector(Vector3D vec)
+        {
+            Vector3 v;
+            v.X = vec.X;
+            v.Y = vec.Y;
+            v.Z = vec.Z;
+            return v;
+        }
+
+        private Color4 FromColor(Color4D color)
+        {
+            Color4 c;
+            c.R = color.R;
+            c.G = color.G;
+            c.B = color.B;
+            c.A = color.A;
+            return c;
+        }
+    }
 }
\ No newline at end of file

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/cc81daf4ce57ba45ac52db01959664a510e8c20d">Part way through converting the assimp tutorial to be compatible with 3.3 core profile [untested]</a>  -  cc81daf</p><p>authored by Anthony Woodward, 2 hours ago</p></div><pre>
 1 file changed, 416 insertions(+)

diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index b5b1caf..1cb7590 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -29,2 +29,416 @@ namespace KAOS.States
 
+        #region Core 3.3 Update
+
+        // Information to render each assimp node
+        private struct MyMesh
+        {
+            uint vao;
+            uint texIndex;
+            uint uniformBlockIndex;
+            int numFaces;
+        }
+
+        //std::vector<struct MyMesh> myMeshes;
+
+        // This is for a shader uniform block
+        struct MyMaterial{
+
+            float[] diffuse;
+            float[] ambient;
+            float[] specular;
+            float[] emissive;
+	        float shininess;
+	        int texCount;
+        };
+
+        // Model Matrix (part of the OpenGL Model View Matrix)
+        float[] modelMatrix = new float[16];
+
+        // For push and pop matrix
+        //std::vector<float *> matrixStack;
+
+        // Vertex Attribute Locations
+        uint vertexLoc=0, normalLoc=1, texCoordLoc=2;
+
+        // Uniform Bindings Points
+        uint matricesUniLoc = 1, materialUniLoc = 2;
+
+        // The sampler uniform for textured models
+        // we are assuming a single texture so this will
+        //always be texture unit 0
+        uint texUnit = 0;
+
+        // Uniform Buffer for Matrices
+        // this buffer will contain 3 matrices: projection, view and model
+        // each matrix is a float array with 16 components
+        uint matricesUniBuffer;
+        int MatricesUniBufferSize = sizeof(float) * 16 * 3;
+        int ProjMatrixOffset = 0;
+        int ViewMatrixOffset = sizeof(float) * 16;
+        int ModelMatrixOffset = sizeof(float) * 16 * 2;
+        int MatrixSize = sizeof(float) * 16;
+
+        // Program and Shader Identifiers
+        uint program, vertexShader, fragmentShader;
+
+        // Shader Names
+        string vertexFileName = "Data\\Shaders\\assimp-vs.glsl";
+        string fragmentFileName = "Data\\Shaders\\assimp-fs.glsl";
+
+        // Create an instance of the Importer class
+        Assimp.AssimpContext importer;
+
+        // the global Assimp scene object
+        const Assimp.Scene scene = NULL;
+
+        // scale factor for the model to fit in the window
+        float scaleFactor;
+
+
+        // images / texture
+        // map image filenames to textureIds
+        // pointer to texture Array
+        //std::map<std::string, GLuint> textureIdMap;	
+
+        // Replace the model name by your model's filename
+        //static const std::string modelname = "bench.obj";
+
+
+        // Camera Position
+        float camX = 0, camY = 0, camZ = 5;
+
+        // Mouse Tracking Variables
+        int startX, startY, tracking = 0;
+
+        // Camera Spherical Coordinates
+        float alpha = 0.0f, beta = 0.0f;
+        float r = 5.0f;
+
+        //#define M_PI       3.14159265358979323846f
+
+        private static float DegToRad(float degrees) 
+        { 
+	        return (float)(degrees * (3.14159265358979323846f / 180.0f));
+        }
+
+        // Frame counting and FPS computation
+        //long time,timebase = 0,frame = 0;
+        //char s[32];
+
+        // ----------------------------------------------------
+        // VECTOR STUFF
+        //
+
+
+        // res = a cross b;
+        void crossProduct(float[] a, float[] b, float[] res)
+        {
+
+            res[0] = a[1] * b[2] - b[1] * a[2];
+            res[1] = a[2] * b[0] - b[2] * a[0];
+            res[2] = a[0] * b[1] - b[0] * a[1];
+        }
+
+
+        // Normalize a vec3
+        void normalize(float[] a)
+        {
+
+            float mag = (float) Math.Sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
+
+            a[0] /= mag;
+            a[1] /= mag;
+            a[2] /= mag;
+        }
+
+
+        // ----------------------------------------------------
+        // MATRIX STUFF
+        //
+
+        // Push and Pop for modelMatrix
+
+        void pushMatrix()
+        {
+
+            //float* aux = (float*)malloc(sizeof(float) * 16);
+            //memcpy(aux, modelMatrix, sizeof(float) * 16);
+            //matrixStack.push_back(aux);
+        }
+
+        void popMatrix()
+        {
+
+            //float* m = matrixStack[matrixStack.size() - 1];
+            //memcpy(modelMatrix, m, sizeof(float) * 16);
+            //matrixStack.pop_back();
+            //free(m);
+        }
+
+        // sets the square matrix mat to the identity matrix,
+        // size refers to the number of rows (or columns)
+        void setIdentityMatrix(float[] mat, int size)
+        {
+
+            // fill matrix with 0s
+            for (int i = 0; i < size * size; ++i)
+                mat[i] = 0.0f;
+
+            // fill diagonal with 1s
+            for (int i = 0; i < size; ++i)
+                mat[i + i * size] = 1.0f;
+        }
+
+
+        //
+        // a = a * b;
+        //
+        void multMatrix(float[] a, float[] b) {
+
+            float[] res = new float[16];
+
+            for (int i = 0; i < 4; ++i) {
+                for (int j = 0; j < 4; ++j) {
+                    res[j*4 + i] = 0.0f;
+                    for (int k = 0; k < 4; ++k) {
+                        res[j*4 + i] += a[k*4 + i] * b[j*4 + k]; 
+                    }
+                }
+            }
+            Array.Copy(a, res, 16 * sizeof(float));
+
+        }
+
+
+        // Defines a transformation matrix mat with a translation
+        void setTranslationMatrix(float[] mat, float x, float y, float z)
+        {
+
+            setIdentityMatrix(mat, 4);
+            mat[12] = x;
+            mat[13] = y;
+            mat[14] = z;
+        }
+
+        // Defines a transformation matrix mat with a scale
+        void setScaleMatrix(float[] mat, float sx, float sy, float sz)
+        {
+
+            setIdentityMatrix(mat, 4);
+            mat[0] = sx;
+            mat[5] = sy;
+            mat[10] = sz;
+        }
+
+        // Defines a transformation matrix mat with a rotation 
+        // angle alpha and a rotation axis (x,y,z)
+        void setRotationMatrix(float[] mat, float angle, float x, float y, float z)
+        {
+
+            float radAngle = DegToRad(angle);
+            float co = (float)Math.Cos(radAngle);
+            float si = (float)Math.Sin(radAngle);
+            float x2 = x * x;
+            float y2 = y * y;
+            float z2 = z * z;
+
+            mat[0] = x2 + (y2 + z2) * co;
+            mat[4] = x * y * (1 - co) - z * si;
+            mat[8] = x * z * (1 - co) + y * si;
+            mat[12] = 0.0f;
+
+            mat[1] = x * y * (1 - co) + z * si;
+            mat[5] = y2 + (x2 + z2) * co;
+            mat[9] = y * z * (1 - co) - x * si;
+            mat[13] = 0.0f;
+
+            mat[2] = x * z * (1 - co) - y * si;
+            mat[6] = y * z * (1 - co) + x * si;
+            mat[10] = z2 + (x2 + y2) * co;
+            mat[14] = 0.0f;
+
+            mat[3] = 0.0f;
+            mat[7] = 0.0f;
+            mat[11] = 0.0f;
+            mat[15] = 1.0f;
+
+        }
+
+        // ----------------------------------------------------
+        // Model Matrix 
+        //
+        // Copies the modelMatrix to the uniform buffer
+
+
+        void setModelMatrix()
+        {
+
+            GL.BindBuffer(BufferTarget.UniformBuffer, matricesUniBuffer);
+            GL.BufferSubData(BufferTarget.UniformBuffer, new IntPtr(ModelMatrixOffset), new IntPtr(MatrixSize), modelMatrix);
+            GL.BindBuffer(BufferTarget.UniformBuffer, 0);
+
+        }
+
+        // The equivalent to glTranslate applied to the model matrix
+        void translate(float x, float y, float z) {
+
+	        float[] aux = new float[16];
+
+	        setTranslationMatrix(aux,x,y,z);
+	        multMatrix(modelMatrix,aux);
+	        setModelMatrix();
+        }
+
+        // The equivalent to glRotate applied to the model matrix
+        void rotate(float angle, float x, float y, float z) {
+
+	        float[] aux = new float[16];
+
+	        setRotationMatrix(aux,angle,x,y,z);
+	        multMatrix(modelMatrix,aux);
+	        setModelMatrix();
+        }
+
+        // The equivalent to glScale applied to the model matrix
+        void scale(float x, float y, float z) {
+
+	        float[] aux = new float[16];
+
+	        setScaleMatrix(aux,x,y,z);
+	        multMatrix(modelMatrix,aux);
+	        setModelMatrix();
+        }
+
+        // ----------------------------------------------------
+        // Projection Matrix 
+        //
+        // Computes the projection Matrix and stores it in the uniform buffer
+
+        void buildProjectionMatrix(float fov, float ratio, float nearp, float farp) {
+
+	        float[] projMatrix = new float[16];
+
+            float f = 1.0f / (float)Math.Tan(fov * (3.14159265358979323846f / 360.0f));
+
+	        setIdentityMatrix(projMatrix,4);
+
+	        projMatrix[0] = f / ratio;
+	        projMatrix[1 * 4 + 1] = f;
+	        projMatrix[2 * 4 + 2] = (farp + nearp) / (nearp - farp);
+	        projMatrix[3 * 4 + 2] = (2.0f * farp * nearp) / (nearp - farp);
+	        projMatrix[2 * 4 + 3] = -1.0f;
+	        projMatrix[3 * 4 + 3] = 0.0f;
+
+	        GL.BindBuffer(BufferTarget.UniformBuffer,matricesUniBuffer);
+	        GL.BufferSubData(BufferTarget.UniformBuffer, new IntPtr(ProjMatrixOffset), new IntPtr(MatrixSize), projMatrix);
+	        GL.BindBuffer(BufferTarget.UniformBuffer,0);
+
+        }
+
+
+        // ----------------------------------------------------
+        // View Matrix
+        //
+        // Computes the viewMatrix and stores it in the uniform buffer
+        //
+        // note: it assumes the camera is not tilted, 
+        // i.e. a vertical up vector along the Y axis (remember gluLookAt?)
+        //
+
+        void setCamera(float posX, float posY, float posZ,
+                        float lookAtX, float lookAtY, float lookAtZ) {
+
+	        float[] dir = new float[3];
+            float[] right = new float[3];
+            float[] up = new float[3];
+
+	        up[0] = 0.0f;	up[1] = 1.0f;	up[2] = 0.0f;
+
+	        dir[0] =  (lookAtX - posX);
+	        dir[1] =  (lookAtY - posY);
+	        dir[2] =  (lookAtZ - posZ);
+	        normalize(dir);
+
+	        crossProduct(dir,up,right);
+	        normalize(right);
+
+	        crossProduct(right,dir,up);
+	        normalize(up);
+
+            float[] viewMatrix = new float[16];
+            float[] aux = new float[16];
+
+	        viewMatrix[0]  = right[0];
+	        viewMatrix[4]  = right[1];
+	        viewMatrix[8]  = right[2];
+	        viewMatrix[12] = 0.0f;
+
+	        viewMatrix[1]  = up[0];
+	        viewMatrix[5]  = up[1];
+	        viewMatrix[9]  = up[2];
+	        viewMatrix[13] = 0.0f;
+
+	        viewMatrix[2]  = -dir[0];
+	        viewMatrix[6]  = -dir[1];
+	        viewMatrix[10] = -dir[2];
+	        viewMatrix[14] =  0.0f;
+
+	        viewMatrix[3]  = 0.0f;
+	        viewMatrix[7]  = 0.0f;
+	        viewMatrix[11] = 0.0f;
+	        viewMatrix[15] = 1.0f;
+
+	        setTranslationMatrix(aux, -posX, -posY, -posZ);
+
+	        multMatrix(viewMatrix, aux);
+	
+	        GL.BindBuffer(BufferTarget.UniformBuffer, matricesUniBuffer);
+	        GL.BufferSubData(BufferTarget.UniformBuffer, new IntPtr(ViewMatrixOffset), new IntPtr(MatrixSize), viewMatrix);
+	        GL.BindBuffer(BufferTarget.UniformBuffer, 0);
+        }
+
+
+        // ----------------------------------------------------------------------------
+
+        private int aisgl_min(int x, int y) 
+        {
+            return x < y ? x : y;
+        }
+
+        private int aisgl_max(int x, int y)
+        {
+            return y > x ? y : x;
+        }
+
+        void get_bounding_box_for_node (Assimp.Node nd, Vector3 min, Vector3 max)
+	
+        {
+	        Matrix4x4 prev;
+	        uint n = 0, t;
+
+	        for (; n < nd.MeshCount; ++n) {
+                const Assimp.Mesh mesh = scene.Meshes[nd.Children[n]];  //mMeshes[nd->mMeshes[n]];    //////////////////////////////////////////////////////////////////////////
+		        for (t = 0; t < mesh->mNumVertices; ++t) {
+
+			        aiVector3D tmp = mesh->mVertices[t];
+
+			        min->x = aisgl_min(min->x,tmp.x);
+			        min->y = aisgl_min(min->y,tmp.y);
+			        min->z = aisgl_min(min->z,tmp.z);
+
+			        max->x = aisgl_max(max->x,tmp.x);
+			        max->y = aisgl_max(max->y,tmp.y);
+			        max->z = aisgl_max(max->z,tmp.z);
+		        }
+	        }
+
+	        for (n = 0; n < nd->mNumChildren; ++n) {
+		        get_bounding_box_for_node(nd->mChildren[n],min,max);
+	        }
+        }
+
+        #endregion
+
+        #region Pre Core 3.3 Update
+
         public ModelState(StateManager stateManager)
@@ -340,2 +754,4 @@ namespace KAOS.States
         }
+
+        #endregion
     }

<div><p><a href="http://github.com/stomppah/KAOS-Engine/commit/ae8472ec0b6a3dd93758ebc1067e014237ae7fad">[untested wip]</a>  -  ae8472e</p><p>authored by Anthony Woodward, 2 hours ago</p></div><pre>
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/KAOS/States/ModelState.cs b/KAOS/States/ModelState.cs
index 1cb7590..c821a8d 100644
--- a/KAOS/States/ModelState.cs
+++ b/KAOS/States/ModelState.cs
@@ -419,3 +419,3 @@ namespace KAOS.States
 	        for (; n < nd.MeshCount; ++n) {
-                const Assimp.Mesh mesh = scene.Meshes[nd.Children[n]];  //mMeshes[nd->mMeshes[n]];    //////////////////////////////////////////////////////////////////////////
+                Assimp.Mesh mesh = scene.Meshes[nd.Children.IndexOf(n)];  //mMeshes[nd->mMeshes[n]];    //////////////////////////////////////////////////////////////////////////
 		        for (t = 0; t < mesh->mNumVertices; ++t) {
